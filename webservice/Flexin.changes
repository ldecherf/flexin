'From Pharo5.0 of 16 April 2015 [Latest update: #50750] on 4 May 2016 at 2:43:21.824129 pm'!----QUIT----2016-05-04T14:43:21.828046+02:00 Pharo-50750.image priorSource: 0!----QUIT/NOSAVE----2016-05-04T14:44:40.111696+02:00 Pharo-50750.image priorSource: 93!----QUIT----2016-05-04T15:07:41.813729+02:00 Pharo-50750.image priorSource: 93!----QUIT----2016-05-06T09:32:23.845174+02:00 Pharo.image priorSource: 261!----QUIT----2016-05-06T09:32:27.065047+02:00 Pharo.image priorSource: 342!----QUIT----2016-05-06T09:32:32.006829+02:00 Pharo.image priorSource: 418!----QUIT----2016-05-08T10:49:37.375428+02:00 Pharo.image priorSource: 494!----QUIT----2016-05-08T10:49:40.17698+02:00 Pharo.image priorSource: 570!----QUIT----2016-05-08T10:49:45.070557+02:00 Pharo.image priorSource: 646!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 5/5/2016 23:02' prior: 57333776!commentForCurrentUpdate ^ '18167 NewValueHolder class>value: should use rawValue:	https://pharo.fogbugz.com/f/cases/18167'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 5/5/2016 23:02'!script50751	^ 'AST-Core-TheIntegrator.416.mczAST-FFI-Pharo50Compatibility-TheIntegrator.2.mczAST-Tests-Core-TheIntegrator.95.mczAlien-eem.32.mczAnnouncements-Core-TheIntegrator.68.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.31.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-NicolaiHess.123.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-EstebanLorenzano.63.mczAthens-Text-NicolaiHess.16.mczBalloon-TheIntegrator.132.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfFileTree-ThierryGoubier.15.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfQualityAssistant-YuriyTymchuk.46.mczBaselineOfRenraku-YuriyTymchuk.5.mczBlueInk-Core-TheIntegrator.24.mczBlueInk-Extras-TheIntegrator.10.mczBlueInk-Tests-TheIntegrator.12.mczChroma-CubeHelix-TheIntegrator.2.mczCodeExport-TheIntegrator.19.mczCodeImport-TheIntegrator.88.mczCodeImportCommandLineHandlers-TheIntegrator.7.mczCollections-Abstract-TheIntegrator.313.mczCollections-Arithmetic-TheIntegrator.20.mczCollections-Atomic-TheIntegrator.16.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.243.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.188.mczCollections-Strings-TheIntegrator.415.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.49.mczCollections-Unordered-TheIntegrator.232.mczCollections-Weak-TheIntegrator.102.mczCompiler-TheIntegrator.602.mczCompression-TheIntegrator.176.mczCompression-Tests-TheIntegrator.2.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.4.mczDebuggerActions-TheIntegrator.85.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.126.mczDeprecated50-TheIntegrator.59.mczEmbeddedFreeType-TheIntegrator.26.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczFFI-Kernel-JanVanDeSandt.40.mczFFI-Pools-eem.3.mczFileSystem-Core-TheIntegrator.200.mczFileSystem-Disk-TheIntegrator.97.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.95.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.417.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-TheIntegrator.17.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.14.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.742.mczFreeType-Tests-TheIntegrator.2.mczFuel-MaxLeske.825.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-TheIntegrator.62.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.411.mczFuelTools-Debugger-TheIntegrator.10.mczGT-BytecodeDebugger-TudorGirba.31.mczGT-Debugger-AndreiChis.350.mczGT-EventRecorder-TheIntegrator.68.mczGT-EventRecorder-Tests-JurajKubelka.37.mczGT-Inspector-AndreiChis.421.mczGT-InspectorExtensions-Core-TheIntegrator.214.mczGT-Playground-DenisKudryashov.124.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-TudorGirba.397.mczGT-Spotter-EventRecorder-GuillermoPolito.112.mczGT-SpotterExtensions-Core-VincentBlondeau.203.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-StefanReichhart.56.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AliakseiSyrel.17.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-TudorGirba.322.mczGlamour-Examples-TudorGirba.303.mczGlamour-FastTable-AndreiChis.59.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-GuillermoPolito.418.mczGlamour-Morphic-Brick-Tests-TheIntegrator.14.mczGlamour-Morphic-Pager-GuillermoPolito.110.mczGlamour-Morphic-Renderer-AndreiChis.349.mczGlamour-Morphic-Theme-HenrikNergaard.222.mczGlamour-Morphic-Widgets-AndreiChis.195.mczGlamour-Presentations-AndreiChis.186.mczGlamour-Rubric-Presentations-AndreiChis.52.mczGlamour-Tests-Core-AndreiChis.111.mczGlamour-Tests-Morphic-TudorGirba.137.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.35.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.6.mczGraphics-Display Objects-TheIntegrator.175.mczGraphics-Files-TheIntegrator.76.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.189.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.80.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.41.mczHelpSystem-Core-TheIntegrator.140.mczHelpSystem-Tests-TheIntegrator.32.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.90.mczImportingResource-Help-TheIntegrator.4.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.28.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2290.mczKernel-Rules-TheIntegrator.2.mczKernel-Tests-TheIntegrator.65.mczKeymapping-Core-TheIntegrator.198.mczKeymapping-KeyCombinations-TheIntegrator.62.mczKeymapping-Pragmas-TheIntegrator.54.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.105.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.166.mczManifest-Core-TheIntegrator.239.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.51.mczMenuRegistration-TheIntegrator.78.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.824.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-EstebanLorenzano.733.mczMetacello-PharoCommonPlatform-TheIntegrator.22.mczMetacello-Platform-EstebanLorenzano.3.mczMetacello-ProfStef-EstebanLorenzano.18.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.7.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform.squeakCommon-EstebanLorenzano.23.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-EstebanLorenzano.148.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1132.mczMonticello-OldDataStreamCompatibility-TheIntegrator.8.mczMonticello-Tests-TheIntegrator.35.mczMonticelloConfigurations-TheIntegrator.72.mczMonticelloFileServices-TheIntegrator.6.mczMonticelloFileTree-Core-TheIntegrator.141.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.30.mczMonticelloGUI-TheIntegrator.415.mczMonticelloMocks-TheIntegrator.4.mczMonticelloRemoteRepositories-TheIntegrator.15.mczMoose-Algos-Graph-vincentBlondeau.31.mczMorphic-Base-TheIntegrator.546.mczMorphic-Core-TheIntegrator.278.mczMorphic-Examples-TheIntegrator.50.mczMorphic-Tests-TheIntegrator.11.mczMorphic-Widgets-Basic-TheIntegrator.86.mczMorphic-Widgets-ColorPicker-TheIntegrator.19.mczMorphic-Widgets-Extra-TheIntegrator.27.mczMorphic-Widgets-FastTable-StephanEggermont.177.mczMorphic-Widgets-List-TheIntegrator.21.mczMorphic-Widgets-NewList-TheIntegrator.9.mczMorphic-Widgets-Pluggable-TheIntegrator.66.mczMorphic-Widgets-PolyTabs-TheIntegrator.2.mczMorphic-Widgets-Scrolling-TheIntegrator.32.mczMorphic-Widgets-Tabs-TheIntegrator.20.mczMorphic-Widgets-Taskbar-TheIntegrator.21.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.50.mczMorphic-Widgets-Windows-TheIntegrator.97.mczMultilingual-Encodings-TheIntegrator.61.mczMultilingual-Languages-TheIntegrator.55.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.81.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.244.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1251.mczNautilus-GroupManager-TheIntegrator.20.mczNautilus-GroupManagerUI-TheIntegrator.31.mczNautilus-Tests-TheIntegrator.37.mczNautilusCommon-TheIntegrator.305.mczNautilusGroupAutoBuilder-TheIntegrator.11.mczNautilusRefactoring-TheIntegrator.272.mczNetwork-Kernel-TheIntegrator.127.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-TheIntegrator.45.mczNetwork-Protocols-TheIntegrator.103.mczNetwork-Tests-TheIntegrator.10.mczNetwork-UUID-TheIntegrator.44.mczNetwork-Url-MarcusDenker.99.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.55.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-RonieSalgado.107.mczOSWindow-SDL2-RonieSalgado.96.mczOSWindow-SDL2-Examples-RonieSalgado.13.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOpalCompiler-Core-TheIntegrator.799.mczOpalCompiler-Tests-TheIntegrator.334.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.15.mczPolymorph-TaskbarIcons-TheIntegrator.46.mczPolymorph-Widgets-TheIntegrator.1338.mczPragmaCollector-TheIntegrator.12.mczProfStef-Core-TheIntegrator.73.mczProfStef-Help-TheIntegrator.16.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.101.mczQualityAssistantRecording-YuriyTymchuk.20.mczRPackage-Core-TheIntegrator.430.mczRPackage-Tests-TheIntegrator.181.mczRandom-Core-TheIntegrator.4.mczRandom-Tests-TheIntegrator.4.mczRecentSubmissions-TheIntegrator.238.mczRefactoring-Changes-TheIntegrator.67.mczRefactoring-Core-TheIntegrator.298.mczRefactoring-Critics-TheIntegrator.261.mczRefactoring-Environment-TheIntegrator.76.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.131.mczRefactoring-Tests-Critics-TheIntegrator.38.mczRefactoring-Tests-Environment-TheIntegrator.23.mczReflectivity-TheIntegrator.297.mczReflectivity-Examples-TheIntegrator.28.mczReflectivity-Tests-TheIntegrator.202.mczReflectivity-Tools-TheIntegrator.24.mczReflectivity-Tools-Tests-TheIntegrator.11.mczRegex-Core-TheIntegrator.38.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.31.mczRenraku-YuriyTymchuk.111.mczRenraku-Test-YuriyTymchuk.19.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.237.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.90.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-GuillermoPolito.363.mczRubric-Rules-YuriyTymchuk.3.mczSTON-Core-PavelKrivanek.73.mczSTON-Tests-SvenVanCaekenberghe.64.mczSUnit-Core-TheIntegrator.169.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.3.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-EstebanLorenzano.138.mczSUnit-UITesting-TheIntegrator.32.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.92.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TommasoDalSasso.3.mczShoreLine-Report-UI-TommasoDalSasso.17.mczShout-TheIntegrator.291.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.742.mczSlot-Tests-TheIntegrator.89.mczSmartSuggestions-TheIntegrator.234.mczSmartSuggestions-Tests-TheIntegrator.33.mczSpec-Core-TheIntegrator.465.mczSpec-Debugger-TheIntegrator.263.mczSpec-Examples-TheIntegrator.108.mczSpec-Help-TheIntegrator.10.mczSpec-Inspector-TheIntegrator.258.mczSpec-Layout-TheIntegrator.69.mczSpec-MorphicAdapters-TheIntegrator.262.mczSpec-PolyWidgets-TheIntegrator.66.mczSpec-Tests-TheIntegrator.63.mczSpec-Tools-TheIntegrator.324.mczStartupPreferences-TheIntegrator.149.mczSystem-Announcements-TheIntegrator.108.mczSystem-BasicCommandLineHandler-TheIntegrator.18.mczSystem-Caching-TheIntegrator.26.mczSystem-CachingTests-TheIntegrator.16.mczSystem-Changes-TheIntegrator.292.mczSystem-Changes-FileServices-TheIntegrator.2.mczSystem-Clipboard-TheIntegrator.40.mczSystem-CommandLine-TheIntegrator.181.mczSystem-CommandLine-TextSupport-TheIntegrator.4.mczSystem-CommandLineHandler-TheIntegrator.18.mczSystem-FileRegistry-TheIntegrator.50.mczSystem-Finalization-TheIntegrator.32.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.106.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.4.mczSystem-OSEnvironments-TheIntegrator.31.mczSystem-Object Events-TheIntegrator.25.mczSystem-Platforms-TheIntegrator.81.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.27.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.337.mczSystem-Settings-Tests-TheIntegrator.11.mczSystem-Sound-StephaneDucasse.18.mczSystem-Sources-TheIntegrator.50.mczSystem-Support-TheIntegrator.1215.mczSystem-SupportTests-TheIntegrator.2.mczSystem-VMEvents-TheIntegrator.17.mczTests-TheIntegrator.755.mczText-Core-TheIntegrator.50.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.114.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.140.mczTool-Catalog-GuillermoPolito.32.mczTool-CriticBrowser-TheIntegrator.21.mczTool-DependencyAnalyser-ChristopheDemarey.28.mczTool-DependencyAnalyser-Test-ChristopheDemarey.11.mczTool-DependencyAnalyser-UI-ChristopheDemarey.43.mczTool-Diff-TheIntegrator.31.mczTool-ExternalBrowser-TheIntegrator.49.mczTool-FileList-TheIntegrator.62.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.65.mczTool-ImageCleaner-TheIntegrator.15.mczTool-ProcessBrowser-TheIntegrator.20.mczTool-Profilers-TheIntegrator.22.mczTool-SystemReporter-TheIntegrator.15.mczTool-Transcript-TheIntegrator.25.mczTool-TxWorkspace-NicolaiHess.7.mczTool-Workspace-TheIntegrator.37.mczTools-TheIntegrator.1525.mczTools-Test-TheIntegrator.16.mczTraits-TheIntegrator.907.mczTranscript-TheIntegrator.50.mczTxText-Athens-GuillermoPolito.53.mczTxText-AthensTests-SeanDeNigris.10.mczTxText-Model-SeanDeNigris.61.mczTxText-Styler-MarcusDenker.17.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.187.mczUnicode-Initialization-TheIntegrator.15.mczUnifiedFFI-EstebanLorenzano.57.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.25.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-VincentBlondeau.32.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-StephaneDucasse.64.mczVersionner-Core-DependenciesModel-ChristopheDemarey.105.mczVersionner-Core-Model-ChristopheDemarey.52.mczVersionner-Spec-Browser-PabloTesone.189.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczZinc-Character-Encoding-Core-TheIntegrator.48.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.27.mczZinc-FileSystem-SvenVanCaekenberghe.12.mczZinc-HTTP-SvenVanCaekenberghe.448.mczZinc-Resource-Meta-Core-TheIntegrator.58.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.36.mczZinc-Tests-SvenVanCaekenberghe.236.mczZinc-Zodiac-TheIntegrator.37.mczZodiac-Core-SvenVanCaekenberghe.42.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.13.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 5/5/2016 23:02'!update50751	"self new update50751"	self withUpdateLog: '18167 NewValueHolder class>value: should use rawValue:	https://pharo.fogbugz.com/f/cases/18167'.	self loadTogether: self script50751 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update50750!ScriptLoader removeSelector: #script50750!"ScriptLoader50"!!NewValueHolder class methodsFor: 'instance creation' stamp: 'StephanEggermont 5/5/2016 11:14' prior: 50957654!value: contents	^ self new		rawValue: contents;		yourself! !"NewValueHolder"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo50/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader50-TheIntegrator.952.mcz') load.ScriptLoader new update50751.!----End fileIn----!----QUIT----2016-05-09T09:16:09.389032+02:00 Pharo.image priorSource: 721!----QUIT----2016-05-09T09:16:12.32598+02:00 Pharo.image priorSource: 18126!----QUIT----2016-05-09T09:16:17.504795+02:00 Pharo.image priorSource: 18202!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 5/9/2016 09:52' prior: 33555320!commentForCurrentUpdate ^ '18178 Some methods comments in FileReference	https://pharo.fogbugz.com/f/cases/1817818174 Delete the second " of the template method break the image	https://pharo.fogbugz.com/f/cases/1817418168 Add Tooltip to describe Rubric options	https://pharo.fogbugz.com/f/cases/18168'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 5/9/2016 09:53'!script50752	^ 'AST-Core-TheIntegrator.418.mczAST-FFI-Pharo50Compatibility-TheIntegrator.2.mczAST-Tests-Core-TheIntegrator.95.mczAlien-eem.32.mczAnnouncements-Core-TheIntegrator.68.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.31.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-NicolaiHess.123.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-EstebanLorenzano.63.mczAthens-Text-NicolaiHess.16.mczBalloon-TheIntegrator.132.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfFileTree-ThierryGoubier.15.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfQualityAssistant-YuriyTymchuk.46.mczBaselineOfRenraku-YuriyTymchuk.5.mczBlueInk-Core-TheIntegrator.24.mczBlueInk-Extras-TheIntegrator.10.mczBlueInk-Tests-TheIntegrator.12.mczChroma-CubeHelix-TheIntegrator.2.mczCodeExport-TheIntegrator.19.mczCodeImport-TheIntegrator.88.mczCodeImportCommandLineHandlers-TheIntegrator.7.mczCollections-Abstract-TheIntegrator.313.mczCollections-Arithmetic-TheIntegrator.20.mczCollections-Atomic-TheIntegrator.16.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.243.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.188.mczCollections-Strings-TheIntegrator.415.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.49.mczCollections-Unordered-TheIntegrator.232.mczCollections-Weak-TheIntegrator.102.mczCompiler-TheIntegrator.602.mczCompression-TheIntegrator.176.mczCompression-Tests-TheIntegrator.2.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.4.mczDebuggerActions-TheIntegrator.85.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.126.mczDeprecated50-TheIntegrator.59.mczEmbeddedFreeType-TheIntegrator.26.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczFFI-Kernel-JanVanDeSandt.40.mczFFI-Pools-eem.3.mczFileSystem-Core-TheIntegrator.202.mczFileSystem-Disk-TheIntegrator.97.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.95.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.417.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-TheIntegrator.17.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.14.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.742.mczFreeType-Tests-TheIntegrator.2.mczFuel-MaxLeske.825.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-TheIntegrator.62.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.411.mczFuelTools-Debugger-TheIntegrator.10.mczGT-BytecodeDebugger-TudorGirba.31.mczGT-Debugger-AndreiChis.350.mczGT-EventRecorder-TheIntegrator.68.mczGT-EventRecorder-Tests-JurajKubelka.37.mczGT-Inspector-AndreiChis.421.mczGT-InspectorExtensions-Core-TheIntegrator.214.mczGT-Playground-DenisKudryashov.124.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-TudorGirba.397.mczGT-Spotter-EventRecorder-GuillermoPolito.112.mczGT-SpotterExtensions-Core-VincentBlondeau.203.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-StefanReichhart.56.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AliakseiSyrel.17.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-TudorGirba.322.mczGlamour-Examples-TudorGirba.303.mczGlamour-FastTable-AndreiChis.59.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-GuillermoPolito.418.mczGlamour-Morphic-Brick-Tests-TheIntegrator.14.mczGlamour-Morphic-Pager-GuillermoPolito.110.mczGlamour-Morphic-Renderer-AndreiChis.349.mczGlamour-Morphic-Theme-HenrikNergaard.222.mczGlamour-Morphic-Widgets-AndreiChis.195.mczGlamour-Presentations-AndreiChis.186.mczGlamour-Rubric-Presentations-AndreiChis.52.mczGlamour-Tests-Core-AndreiChis.111.mczGlamour-Tests-Morphic-TudorGirba.137.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.35.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.6.mczGraphics-Display Objects-TheIntegrator.175.mczGraphics-Files-TheIntegrator.76.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.189.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.80.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.41.mczHelpSystem-Core-TheIntegrator.140.mczHelpSystem-Tests-TheIntegrator.32.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.90.mczImportingResource-Help-TheIntegrator.4.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.28.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2290.mczKernel-Rules-TheIntegrator.2.mczKernel-Tests-TheIntegrator.65.mczKeymapping-Core-TheIntegrator.198.mczKeymapping-KeyCombinations-TheIntegrator.62.mczKeymapping-Pragmas-TheIntegrator.54.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.105.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.166.mczManifest-Core-TheIntegrator.239.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.51.mczMenuRegistration-TheIntegrator.78.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.824.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-EstebanLorenzano.733.mczMetacello-PharoCommonPlatform-TheIntegrator.22.mczMetacello-Platform-EstebanLorenzano.3.mczMetacello-ProfStef-EstebanLorenzano.18.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.7.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform.squeakCommon-EstebanLorenzano.23.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-EstebanLorenzano.148.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1132.mczMonticello-OldDataStreamCompatibility-TheIntegrator.8.mczMonticello-Tests-TheIntegrator.35.mczMonticelloConfigurations-TheIntegrator.72.mczMonticelloFileServices-TheIntegrator.6.mczMonticelloFileTree-Core-TheIntegrator.141.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.30.mczMonticelloGUI-TheIntegrator.415.mczMonticelloMocks-TheIntegrator.4.mczMonticelloRemoteRepositories-TheIntegrator.15.mczMoose-Algos-Graph-vincentBlondeau.31.mczMorphic-Base-TheIntegrator.546.mczMorphic-Core-TheIntegrator.278.mczMorphic-Examples-TheIntegrator.50.mczMorphic-Tests-TheIntegrator.11.mczMorphic-Widgets-Basic-TheIntegrator.86.mczMorphic-Widgets-ColorPicker-TheIntegrator.19.mczMorphic-Widgets-Extra-TheIntegrator.27.mczMorphic-Widgets-FastTable-StephanEggermont.177.mczMorphic-Widgets-List-TheIntegrator.21.mczMorphic-Widgets-NewList-TheIntegrator.9.mczMorphic-Widgets-Pluggable-TheIntegrator.66.mczMorphic-Widgets-PolyTabs-TheIntegrator.2.mczMorphic-Widgets-Scrolling-TheIntegrator.32.mczMorphic-Widgets-Tabs-TheIntegrator.20.mczMorphic-Widgets-Taskbar-TheIntegrator.21.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.50.mczMorphic-Widgets-Windows-TheIntegrator.97.mczMultilingual-Encodings-TheIntegrator.61.mczMultilingual-Languages-TheIntegrator.55.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.81.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.244.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1253.mczNautilus-GroupManager-TheIntegrator.20.mczNautilus-GroupManagerUI-TheIntegrator.31.mczNautilus-Tests-TheIntegrator.37.mczNautilusCommon-TheIntegrator.305.mczNautilusGroupAutoBuilder-TheIntegrator.11.mczNautilusRefactoring-TheIntegrator.272.mczNetwork-Kernel-TheIntegrator.127.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-TheIntegrator.45.mczNetwork-Protocols-TheIntegrator.103.mczNetwork-Tests-TheIntegrator.10.mczNetwork-UUID-TheIntegrator.44.mczNetwork-Url-MarcusDenker.99.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.55.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-RonieSalgado.107.mczOSWindow-SDL2-RonieSalgado.96.mczOSWindow-SDL2-Examples-RonieSalgado.13.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOpalCompiler-Core-TheIntegrator.799.mczOpalCompiler-Tests-TheIntegrator.334.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.15.mczPolymorph-TaskbarIcons-TheIntegrator.46.mczPolymorph-Widgets-TheIntegrator.1338.mczPragmaCollector-TheIntegrator.12.mczProfStef-Core-TheIntegrator.73.mczProfStef-Help-TheIntegrator.16.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.101.mczQualityAssistantRecording-YuriyTymchuk.20.mczRPackage-Core-TheIntegrator.430.mczRPackage-Tests-TheIntegrator.181.mczRandom-Core-TheIntegrator.4.mczRandom-Tests-TheIntegrator.4.mczRecentSubmissions-TheIntegrator.238.mczRefactoring-Changes-TheIntegrator.67.mczRefactoring-Core-TheIntegrator.298.mczRefactoring-Critics-TheIntegrator.261.mczRefactoring-Environment-TheIntegrator.76.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.131.mczRefactoring-Tests-Critics-TheIntegrator.38.mczRefactoring-Tests-Environment-TheIntegrator.23.mczReflectivity-TheIntegrator.297.mczReflectivity-Examples-TheIntegrator.28.mczReflectivity-Tests-TheIntegrator.202.mczReflectivity-Tools-TheIntegrator.24.mczReflectivity-Tools-Tests-TheIntegrator.11.mczRegex-Core-TheIntegrator.38.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.31.mczRenraku-YuriyTymchuk.111.mczRenraku-Test-YuriyTymchuk.19.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.237.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.90.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-GuillermoPolito.363.mczRubric-Rules-YuriyTymchuk.3.mczSTON-Core-PavelKrivanek.73.mczSTON-Tests-SvenVanCaekenberghe.64.mczSUnit-Core-TheIntegrator.169.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.3.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-EstebanLorenzano.138.mczSUnit-UITesting-TheIntegrator.32.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.92.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TommasoDalSasso.3.mczShoreLine-Report-UI-TommasoDalSasso.17.mczShout-TheIntegrator.291.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.742.mczSlot-Tests-TheIntegrator.89.mczSmartSuggestions-TheIntegrator.234.mczSmartSuggestions-Tests-TheIntegrator.33.mczSpec-Core-TheIntegrator.465.mczSpec-Debugger-TheIntegrator.263.mczSpec-Examples-TheIntegrator.108.mczSpec-Help-TheIntegrator.10.mczSpec-Inspector-TheIntegrator.258.mczSpec-Layout-TheIntegrator.69.mczSpec-MorphicAdapters-TheIntegrator.262.mczSpec-PolyWidgets-TheIntegrator.66.mczSpec-Tests-TheIntegrator.63.mczSpec-Tools-TheIntegrator.324.mczStartupPreferences-TheIntegrator.149.mczSystem-Announcements-TheIntegrator.108.mczSystem-BasicCommandLineHandler-TheIntegrator.18.mczSystem-Caching-TheIntegrator.26.mczSystem-CachingTests-TheIntegrator.16.mczSystem-Changes-TheIntegrator.292.mczSystem-Changes-FileServices-TheIntegrator.2.mczSystem-Clipboard-TheIntegrator.40.mczSystem-CommandLine-TheIntegrator.181.mczSystem-CommandLine-TextSupport-TheIntegrator.4.mczSystem-CommandLineHandler-TheIntegrator.18.mczSystem-FileRegistry-TheIntegrator.50.mczSystem-Finalization-TheIntegrator.32.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.106.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.4.mczSystem-OSEnvironments-TheIntegrator.31.mczSystem-Object Events-TheIntegrator.25.mczSystem-Platforms-TheIntegrator.81.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.27.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.337.mczSystem-Settings-Tests-TheIntegrator.11.mczSystem-Sound-StephaneDucasse.18.mczSystem-Sources-TheIntegrator.50.mczSystem-Support-TheIntegrator.1215.mczSystem-SupportTests-TheIntegrator.2.mczSystem-VMEvents-TheIntegrator.17.mczTests-TheIntegrator.755.mczText-Core-TheIntegrator.50.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.114.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.140.mczTool-Catalog-GuillermoPolito.32.mczTool-CriticBrowser-TheIntegrator.21.mczTool-DependencyAnalyser-ChristopheDemarey.28.mczTool-DependencyAnalyser-Test-ChristopheDemarey.11.mczTool-DependencyAnalyser-UI-ChristopheDemarey.43.mczTool-Diff-TheIntegrator.31.mczTool-ExternalBrowser-TheIntegrator.49.mczTool-FileList-TheIntegrator.62.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.65.mczTool-ImageCleaner-TheIntegrator.15.mczTool-ProcessBrowser-TheIntegrator.20.mczTool-Profilers-TheIntegrator.22.mczTool-SystemReporter-TheIntegrator.15.mczTool-Transcript-TheIntegrator.25.mczTool-TxWorkspace-NicolaiHess.7.mczTool-Workspace-TheIntegrator.37.mczTools-TheIntegrator.1525.mczTools-Test-TheIntegrator.16.mczTraits-TheIntegrator.907.mczTranscript-TheIntegrator.50.mczTxText-Athens-GuillermoPolito.53.mczTxText-AthensTests-SeanDeNigris.10.mczTxText-Model-SeanDeNigris.61.mczTxText-Styler-MarcusDenker.17.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.187.mczUnicode-Initialization-TheIntegrator.15.mczUnifiedFFI-EstebanLorenzano.57.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.25.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-VincentBlondeau.32.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-StephaneDucasse.64.mczVersionner-Core-DependenciesModel-ChristopheDemarey.105.mczVersionner-Core-Model-ChristopheDemarey.52.mczVersionner-Spec-Browser-PabloTesone.189.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczZinc-Character-Encoding-Core-TheIntegrator.48.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.27.mczZinc-FileSystem-SvenVanCaekenberghe.12.mczZinc-HTTP-SvenVanCaekenberghe.448.mczZinc-Resource-Meta-Core-TheIntegrator.58.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.36.mczZinc-Tests-SvenVanCaekenberghe.236.mczZinc-Zodiac-TheIntegrator.37.mczZodiac-Core-SvenVanCaekenberghe.42.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.13.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 5/9/2016 09:53'!update50752	"self new update50752"	self withUpdateLog: '18178 Some methods comments in FileReference	https://pharo.fogbugz.com/f/cases/1817818174 Delete the second " of the template method break the image	https://pharo.fogbugz.com/f/cases/1817418168 Add Tooltip to describe Rubric options	https://pharo.fogbugz.com/f/cases/18168'.	self loadTogether: self script50752 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update50751!ScriptLoader removeSelector: #script50751!"ScriptLoader50"!!NautilusAnnotationDisplayer methodsFor: 'submorphs-accessing' stamp: 'CyrilFerlicot 5/6/2016 00:49' prior: 50667866!formatAsYouReadMorph	^ (CheckboxMorph on: self selected: #formatAsYouRead changeSelected: #toggleFormatAsYouRead)		getLabelSelector: #formatAsYouReadLabel;		labelClickable: true;		vResizing: #shrinkWrap;		hResizing: #shrinkWrap;		setBalloonText:			'Autoformat code without editing. Useful when reading some old/unformatted code. You can configure your own format in the settings browser.';		yourself! !!NautilusAnnotationDisplayer methodsFor: 'submorphs-accessing' stamp: 'CyrilFerlicot 5/6/2016 00:42' prior: 50668440!lineAnnotationMorph	^ (RubTextFieldArea new		withoutAnyDecorator;		backgroundColor: Color transparent;		font: self fontToUse;		beReadOnly;		textColor: self textColor)		setBalloonText: 'Current line number/Total line number [Current character number]';		yourself! !!NautilusAnnotationDisplayer methodsFor: 'submorphs-accessing' stamp: 'CyrilFerlicot 5/6/2016 00:46' prior: 50666530!lineNumbersDisplayLabelMorph	^ (StringMorph contents: self lineNumbersDisplayLabel font: self fontToUse)		setBalloonText: 'Let you decide if the code pane should show the line numbers at the left of the code pane or not. +L: Click to add the lines number/L: Click to hide them.';		yourself! !!NautilusAnnotationDisplayer methodsFor: 'submorphs-accessing' stamp: 'CyrilFerlicot 5/6/2016 00:44' prior: 50662265!wrappingPolicyLabelMorph	^ (StringMorph contents: self wrappingPolicyLabel font: self fontToUse)		setBalloonText:			'Let you decide if the code pane should automaticaly wrap lines if a line reach the end of the line. W: Wrap / NW: Add a scrollbar.';		yourself! !!AbstractFileReference methodsFor: 'delegated' stamp: 'AlexandreBergel 5/7/2016 18:41' prior: 16833596!exists	"Return true if the file reference exist (e.g., if there is a file on the hard disk pointed by the file reference)		E.g., (if you are on Unix or OSX)	'/tmp/' asFileReference exists => true	'/tmp/zorkbar' asFileReference exists => false	"	^ self resolve exists! !!RBParser class methodsFor: 'parsing' stamp: 'NicolaiHess 5/8/2016 16:36' prior: 54366838!parseMethod: aString onError: aBlock 	| parser |	parser := self new.	parser errorBlock: aBlock.	parser initializeParserWith: aString.	^ [ parser parseMethod: aString ]		on: ReparseAfterSourceEditing		do: [ :exception | self parseMethod: exception newSource onError: aBlock ]! !"AST-Core"!"FileSystem-Core"!"Nautilus"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo50/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader50-TheIntegrator.956.mcz') load.ScriptLoader new update50752.!----End fileIn----!----QUIT----2016-05-09T10:03:56.519402+02:00 Pharo.image priorSource: 18279!----QUIT----2016-05-09T10:03:59.448854+02:00 Pharo.image priorSource: 38380!----QUIT----2016-05-09T10:04:04.416367+02:00 Pharo.image priorSource: 38458!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 5/10/2016 09:13' prior: 33572880!commentForCurrentUpdate ^ '18188 localHostName is not guarded against uninitialized network	https://pharo.fogbugz.com/f/cases/18188'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 5/10/2016 09:13'!script50753	^ 'AST-Core-TheIntegrator.418.mczAST-FFI-Pharo50Compatibility-TheIntegrator.2.mczAST-Tests-Core-TheIntegrator.95.mczAlien-eem.32.mczAnnouncements-Core-TheIntegrator.68.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.31.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-NicolaiHess.123.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-EstebanLorenzano.63.mczAthens-Text-NicolaiHess.16.mczBalloon-TheIntegrator.132.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfFileTree-ThierryGoubier.15.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfQualityAssistant-YuriyTymchuk.46.mczBaselineOfRenraku-YuriyTymchuk.5.mczBlueInk-Core-TheIntegrator.24.mczBlueInk-Extras-TheIntegrator.10.mczBlueInk-Tests-TheIntegrator.12.mczChroma-CubeHelix-TheIntegrator.2.mczCodeExport-TheIntegrator.19.mczCodeImport-TheIntegrator.88.mczCodeImportCommandLineHandlers-TheIntegrator.7.mczCollections-Abstract-TheIntegrator.313.mczCollections-Arithmetic-TheIntegrator.20.mczCollections-Atomic-TheIntegrator.16.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.243.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.188.mczCollections-Strings-TheIntegrator.415.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.49.mczCollections-Unordered-TheIntegrator.232.mczCollections-Weak-TheIntegrator.102.mczCompiler-TheIntegrator.602.mczCompression-TheIntegrator.176.mczCompression-Tests-TheIntegrator.2.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.4.mczDebuggerActions-TheIntegrator.85.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.126.mczDeprecated50-TheIntegrator.59.mczEmbeddedFreeType-TheIntegrator.26.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczFFI-Kernel-JanVanDeSandt.40.mczFFI-Pools-eem.3.mczFileSystem-Core-TheIntegrator.202.mczFileSystem-Disk-TheIntegrator.97.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.95.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.417.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-TheIntegrator.17.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.14.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.742.mczFreeType-Tests-TheIntegrator.2.mczFuel-MaxLeske.825.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-TheIntegrator.62.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.411.mczFuelTools-Debugger-TheIntegrator.10.mczGT-BytecodeDebugger-TudorGirba.31.mczGT-Debugger-AndreiChis.350.mczGT-EventRecorder-TheIntegrator.68.mczGT-EventRecorder-Tests-JurajKubelka.37.mczGT-Inspector-AndreiChis.421.mczGT-InspectorExtensions-Core-TheIntegrator.214.mczGT-Playground-DenisKudryashov.124.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-TudorGirba.397.mczGT-Spotter-EventRecorder-GuillermoPolito.112.mczGT-SpotterExtensions-Core-VincentBlondeau.203.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-StefanReichhart.56.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AliakseiSyrel.17.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-TudorGirba.322.mczGlamour-Examples-TudorGirba.303.mczGlamour-FastTable-AndreiChis.59.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-GuillermoPolito.418.mczGlamour-Morphic-Brick-Tests-TheIntegrator.14.mczGlamour-Morphic-Pager-GuillermoPolito.110.mczGlamour-Morphic-Renderer-AndreiChis.349.mczGlamour-Morphic-Theme-HenrikNergaard.222.mczGlamour-Morphic-Widgets-AndreiChis.195.mczGlamour-Presentations-AndreiChis.186.mczGlamour-Rubric-Presentations-AndreiChis.52.mczGlamour-Tests-Core-AndreiChis.111.mczGlamour-Tests-Morphic-TudorGirba.137.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.35.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.6.mczGraphics-Display Objects-TheIntegrator.175.mczGraphics-Files-TheIntegrator.76.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.189.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.80.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.41.mczHelpSystem-Core-TheIntegrator.140.mczHelpSystem-Tests-TheIntegrator.32.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.90.mczImportingResource-Help-TheIntegrator.4.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.28.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2290.mczKernel-Rules-TheIntegrator.2.mczKernel-Tests-TheIntegrator.65.mczKeymapping-Core-TheIntegrator.198.mczKeymapping-KeyCombinations-TheIntegrator.62.mczKeymapping-Pragmas-TheIntegrator.54.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.105.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.166.mczManifest-Core-TheIntegrator.239.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.51.mczMenuRegistration-TheIntegrator.78.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.824.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-EstebanLorenzano.733.mczMetacello-PharoCommonPlatform-TheIntegrator.22.mczMetacello-Platform-EstebanLorenzano.3.mczMetacello-ProfStef-EstebanLorenzano.18.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.7.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform.squeakCommon-EstebanLorenzano.23.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-EstebanLorenzano.148.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1132.mczMonticello-OldDataStreamCompatibility-TheIntegrator.8.mczMonticello-Tests-TheIntegrator.35.mczMonticelloConfigurations-TheIntegrator.72.mczMonticelloFileServices-TheIntegrator.6.mczMonticelloFileTree-Core-TheIntegrator.141.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.30.mczMonticelloGUI-TheIntegrator.415.mczMonticelloMocks-TheIntegrator.4.mczMonticelloRemoteRepositories-TheIntegrator.15.mczMoose-Algos-Graph-vincentBlondeau.31.mczMorphic-Base-TheIntegrator.546.mczMorphic-Core-TheIntegrator.278.mczMorphic-Examples-TheIntegrator.50.mczMorphic-Tests-TheIntegrator.11.mczMorphic-Widgets-Basic-TheIntegrator.86.mczMorphic-Widgets-ColorPicker-TheIntegrator.19.mczMorphic-Widgets-Extra-TheIntegrator.27.mczMorphic-Widgets-FastTable-StephanEggermont.177.mczMorphic-Widgets-List-TheIntegrator.21.mczMorphic-Widgets-NewList-TheIntegrator.9.mczMorphic-Widgets-Pluggable-TheIntegrator.66.mczMorphic-Widgets-PolyTabs-TheIntegrator.2.mczMorphic-Widgets-Scrolling-TheIntegrator.32.mczMorphic-Widgets-Tabs-TheIntegrator.20.mczMorphic-Widgets-Taskbar-TheIntegrator.21.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.50.mczMorphic-Widgets-Windows-TheIntegrator.97.mczMultilingual-Encodings-TheIntegrator.61.mczMultilingual-Languages-TheIntegrator.55.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.81.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.244.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1253.mczNautilus-GroupManager-TheIntegrator.20.mczNautilus-GroupManagerUI-TheIntegrator.31.mczNautilus-Tests-TheIntegrator.37.mczNautilusCommon-TheIntegrator.305.mczNautilusGroupAutoBuilder-TheIntegrator.11.mczNautilusRefactoring-TheIntegrator.272.mczNetwork-Kernel-TheIntegrator.130.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-TheIntegrator.45.mczNetwork-Protocols-TheIntegrator.103.mczNetwork-Tests-TheIntegrator.10.mczNetwork-UUID-TheIntegrator.44.mczNetwork-Url-MarcusDenker.99.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.55.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-RonieSalgado.107.mczOSWindow-SDL2-RonieSalgado.96.mczOSWindow-SDL2-Examples-RonieSalgado.13.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOpalCompiler-Core-TheIntegrator.799.mczOpalCompiler-Tests-TheIntegrator.334.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.15.mczPolymorph-TaskbarIcons-TheIntegrator.46.mczPolymorph-Widgets-TheIntegrator.1338.mczPragmaCollector-TheIntegrator.12.mczProfStef-Core-TheIntegrator.73.mczProfStef-Help-TheIntegrator.16.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.101.mczQualityAssistantRecording-YuriyTymchuk.20.mczRPackage-Core-TheIntegrator.430.mczRPackage-Tests-TheIntegrator.181.mczRandom-Core-TheIntegrator.4.mczRandom-Tests-TheIntegrator.4.mczRecentSubmissions-TheIntegrator.238.mczRefactoring-Changes-TheIntegrator.67.mczRefactoring-Core-TheIntegrator.298.mczRefactoring-Critics-TheIntegrator.261.mczRefactoring-Environment-TheIntegrator.76.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.131.mczRefactoring-Tests-Critics-TheIntegrator.38.mczRefactoring-Tests-Environment-TheIntegrator.23.mczReflectivity-TheIntegrator.297.mczReflectivity-Examples-TheIntegrator.28.mczReflectivity-Tests-TheIntegrator.202.mczReflectivity-Tools-TheIntegrator.24.mczReflectivity-Tools-Tests-TheIntegrator.11.mczRegex-Core-TheIntegrator.38.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.31.mczRenraku-YuriyTymchuk.111.mczRenraku-Test-YuriyTymchuk.19.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.237.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.90.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-GuillermoPolito.363.mczRubric-Rules-YuriyTymchuk.3.mczSTON-Core-PavelKrivanek.73.mczSTON-Tests-SvenVanCaekenberghe.64.mczSUnit-Core-TheIntegrator.169.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.3.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-EstebanLorenzano.138.mczSUnit-UITesting-TheIntegrator.32.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.92.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TommasoDalSasso.3.mczShoreLine-Report-UI-TommasoDalSasso.17.mczShout-TheIntegrator.291.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.742.mczSlot-Tests-TheIntegrator.89.mczSmartSuggestions-TheIntegrator.234.mczSmartSuggestions-Tests-TheIntegrator.33.mczSpec-Core-TheIntegrator.465.mczSpec-Debugger-TheIntegrator.263.mczSpec-Examples-TheIntegrator.108.mczSpec-Help-TheIntegrator.10.mczSpec-Inspector-TheIntegrator.258.mczSpec-Layout-TheIntegrator.69.mczSpec-MorphicAdapters-TheIntegrator.262.mczSpec-PolyWidgets-TheIntegrator.66.mczSpec-Tests-TheIntegrator.63.mczSpec-Tools-TheIntegrator.324.mczStartupPreferences-TheIntegrator.149.mczSystem-Announcements-TheIntegrator.108.mczSystem-BasicCommandLineHandler-TheIntegrator.18.mczSystem-Caching-TheIntegrator.26.mczSystem-CachingTests-TheIntegrator.16.mczSystem-Changes-TheIntegrator.292.mczSystem-Changes-FileServices-TheIntegrator.2.mczSystem-Clipboard-TheIntegrator.40.mczSystem-CommandLine-TheIntegrator.181.mczSystem-CommandLine-TextSupport-TheIntegrator.4.mczSystem-CommandLineHandler-TheIntegrator.18.mczSystem-FileRegistry-TheIntegrator.50.mczSystem-Finalization-TheIntegrator.32.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.106.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.4.mczSystem-OSEnvironments-TheIntegrator.31.mczSystem-Object Events-TheIntegrator.25.mczSystem-Platforms-TheIntegrator.81.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.27.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.337.mczSystem-Settings-Tests-TheIntegrator.11.mczSystem-Sound-StephaneDucasse.18.mczSystem-Sources-TheIntegrator.50.mczSystem-Support-TheIntegrator.1215.mczSystem-SupportTests-TheIntegrator.2.mczSystem-VMEvents-TheIntegrator.17.mczTests-TheIntegrator.755.mczText-Core-TheIntegrator.50.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.114.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.140.mczTool-Catalog-GuillermoPolito.32.mczTool-CriticBrowser-TheIntegrator.21.mczTool-DependencyAnalyser-ChristopheDemarey.28.mczTool-DependencyAnalyser-Test-ChristopheDemarey.11.mczTool-DependencyAnalyser-UI-ChristopheDemarey.43.mczTool-Diff-TheIntegrator.31.mczTool-ExternalBrowser-TheIntegrator.49.mczTool-FileList-TheIntegrator.62.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.65.mczTool-ImageCleaner-TheIntegrator.15.mczTool-ProcessBrowser-TheIntegrator.20.mczTool-Profilers-TheIntegrator.22.mczTool-SystemReporter-TheIntegrator.15.mczTool-Transcript-TheIntegrator.25.mczTool-TxWorkspace-NicolaiHess.7.mczTool-Workspace-TheIntegrator.37.mczTools-TheIntegrator.1525.mczTools-Test-TheIntegrator.16.mczTraits-TheIntegrator.907.mczTranscript-TheIntegrator.50.mczTxText-Athens-GuillermoPolito.53.mczTxText-AthensTests-SeanDeNigris.10.mczTxText-Model-SeanDeNigris.61.mczTxText-Styler-MarcusDenker.17.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.187.mczUnicode-Initialization-TheIntegrator.15.mczUnifiedFFI-EstebanLorenzano.57.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.25.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-VincentBlondeau.32.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-StephaneDucasse.64.mczVersionner-Core-DependenciesModel-ChristopheDemarey.105.mczVersionner-Core-Model-ChristopheDemarey.52.mczVersionner-Spec-Browser-PabloTesone.189.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczZinc-Character-Encoding-Core-TheIntegrator.48.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.27.mczZinc-FileSystem-SvenVanCaekenberghe.12.mczZinc-HTTP-SvenVanCaekenberghe.448.mczZinc-Resource-Meta-Core-TheIntegrator.58.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.36.mczZinc-Tests-SvenVanCaekenberghe.236.mczZinc-Zodiac-TheIntegrator.37.mczZodiac-Core-SvenVanCaekenberghe.42.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.13.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 5/10/2016 09:14'!update50753	"self new update50753"	self withUpdateLog: '18188 localHostName is not guarded against uninitialized network	https://pharo.fogbugz.com/f/cases/18188'.	self loadTogether: self script50753 merge: false.	self flushCaches.self cleanRepositories.! !ScriptLoader removeSelector: #update50752!ScriptLoader removeSelector: #script50752!"ScriptLoader50"!!NetNameResolver class methodsFor: 'lookups' stamp: 'HenrikSperreJohansen 5/9/2016 11:06' prior: 50837885!localHostName	"Return the local name of this host."	"NetNameResolver localHostName"	^ [ | hostName |	self initializeNetwork.	hostName := String new: self primHostNameSize.	self primHostNameResult: hostName.	hostName ]		on: PrimitiveFailed		do: [ self loopBackName ]! !!Socket methodsFor: 'initialize-destroy' stamp: 'HenrikSperreJohansen 5/9/2016 11:08'!bindTo: anAddress port: aPort	^self primSocket: socketHandle bindTo: anAddress port: aPort ! !!Socket methodsFor: 'primitives' stamp: 'HenrikSperreJohansen 5/9/2016 11:11'!primSocket: socketID bindTo: anAddress port: aPort 	"Bind socket to provided IPv4 address and port"	<primitive: 'primitiveSocketBindToPort' module: 'SocketPlugin'>	^self primitiveFailed! !"Network-Kernel"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo50/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader50-TheIntegrator.957.mcz') load.ScriptLoader new update50753.!----End fileIn----!----QUIT----2016-05-10T09:16:10.918677+02:00 Pharo.image priorSource: 38536!----QUIT----2016-05-10T09:16:13.831462+02:00 Pharo.image priorSource: 56658!----QUIT----2016-05-10T09:16:18.655617+02:00 Pharo.image priorSource: 56736!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 5/10/2016 17:11' prior: 33593138!commentForCurrentUpdate ^ '18153 Failing on CI on Windows: SocketTest.testUDPBroadcastError (from Network-Tests)	https://pharo.fogbugz.com/f/cases/18153'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 5/10/2016 17:11'!script50754	^ 'AST-Core-TheIntegrator.418.mczAST-FFI-Pharo50Compatibility-TheIntegrator.2.mczAST-Tests-Core-TheIntegrator.95.mczAlien-eem.32.mczAnnouncements-Core-TheIntegrator.68.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.31.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-NicolaiHess.123.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-EstebanLorenzano.63.mczAthens-Text-NicolaiHess.16.mczBalloon-TheIntegrator.132.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfFileTree-ThierryGoubier.15.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfQualityAssistant-YuriyTymchuk.46.mczBaselineOfRenraku-YuriyTymchuk.5.mczBlueInk-Core-TheIntegrator.24.mczBlueInk-Extras-TheIntegrator.10.mczBlueInk-Tests-TheIntegrator.12.mczChroma-CubeHelix-TheIntegrator.2.mczCodeExport-TheIntegrator.19.mczCodeImport-TheIntegrator.88.mczCodeImportCommandLineHandlers-TheIntegrator.7.mczCollections-Abstract-TheIntegrator.313.mczCollections-Arithmetic-TheIntegrator.20.mczCollections-Atomic-TheIntegrator.16.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.243.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.188.mczCollections-Strings-TheIntegrator.415.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.49.mczCollections-Unordered-TheIntegrator.232.mczCollections-Weak-TheIntegrator.102.mczCompiler-TheIntegrator.602.mczCompression-TheIntegrator.176.mczCompression-Tests-TheIntegrator.2.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.4.mczDebuggerActions-TheIntegrator.85.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.126.mczDeprecated50-TheIntegrator.59.mczEmbeddedFreeType-TheIntegrator.26.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczFFI-Kernel-JanVanDeSandt.40.mczFFI-Pools-eem.3.mczFileSystem-Core-TheIntegrator.202.mczFileSystem-Disk-TheIntegrator.97.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.95.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.417.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-TheIntegrator.17.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.14.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.742.mczFreeType-Tests-TheIntegrator.2.mczFuel-MaxLeske.825.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-TheIntegrator.62.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.411.mczFuelTools-Debugger-TheIntegrator.10.mczGT-BytecodeDebugger-TudorGirba.31.mczGT-Debugger-AndreiChis.350.mczGT-EventRecorder-TheIntegrator.68.mczGT-EventRecorder-Tests-JurajKubelka.37.mczGT-Inspector-AndreiChis.421.mczGT-InspectorExtensions-Core-TheIntegrator.214.mczGT-Playground-DenisKudryashov.124.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-TudorGirba.397.mczGT-Spotter-EventRecorder-GuillermoPolito.112.mczGT-SpotterExtensions-Core-VincentBlondeau.203.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-StefanReichhart.56.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AliakseiSyrel.17.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-TudorGirba.322.mczGlamour-Examples-TudorGirba.303.mczGlamour-FastTable-AndreiChis.59.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-GuillermoPolito.418.mczGlamour-Morphic-Brick-Tests-TheIntegrator.14.mczGlamour-Morphic-Pager-GuillermoPolito.110.mczGlamour-Morphic-Renderer-AndreiChis.349.mczGlamour-Morphic-Theme-HenrikNergaard.222.mczGlamour-Morphic-Widgets-AndreiChis.195.mczGlamour-Presentations-AndreiChis.186.mczGlamour-Rubric-Presentations-AndreiChis.52.mczGlamour-Tests-Core-AndreiChis.111.mczGlamour-Tests-Morphic-TudorGirba.137.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.35.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.6.mczGraphics-Display Objects-TheIntegrator.175.mczGraphics-Files-TheIntegrator.76.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.189.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.80.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.41.mczHelpSystem-Core-TheIntegrator.140.mczHelpSystem-Tests-TheIntegrator.32.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.90.mczImportingResource-Help-TheIntegrator.4.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.28.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2290.mczKernel-Rules-TheIntegrator.2.mczKernel-Tests-TheIntegrator.65.mczKeymapping-Core-TheIntegrator.198.mczKeymapping-KeyCombinations-TheIntegrator.62.mczKeymapping-Pragmas-TheIntegrator.54.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.105.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.166.mczManifest-Core-TheIntegrator.239.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.51.mczMenuRegistration-TheIntegrator.78.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.824.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-EstebanLorenzano.733.mczMetacello-PharoCommonPlatform-TheIntegrator.22.mczMetacello-Platform-EstebanLorenzano.3.mczMetacello-ProfStef-EstebanLorenzano.18.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.7.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform.squeakCommon-EstebanLorenzano.23.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-EstebanLorenzano.148.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1132.mczMonticello-OldDataStreamCompatibility-TheIntegrator.8.mczMonticello-Tests-TheIntegrator.35.mczMonticelloConfigurations-TheIntegrator.72.mczMonticelloFileServices-TheIntegrator.6.mczMonticelloFileTree-Core-TheIntegrator.141.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.30.mczMonticelloGUI-TheIntegrator.415.mczMonticelloMocks-TheIntegrator.4.mczMonticelloRemoteRepositories-TheIntegrator.15.mczMoose-Algos-Graph-vincentBlondeau.31.mczMorphic-Base-TheIntegrator.546.mczMorphic-Core-TheIntegrator.278.mczMorphic-Examples-TheIntegrator.50.mczMorphic-Tests-TheIntegrator.11.mczMorphic-Widgets-Basic-TheIntegrator.86.mczMorphic-Widgets-ColorPicker-TheIntegrator.19.mczMorphic-Widgets-Extra-TheIntegrator.27.mczMorphic-Widgets-FastTable-StephanEggermont.177.mczMorphic-Widgets-List-TheIntegrator.21.mczMorphic-Widgets-NewList-TheIntegrator.9.mczMorphic-Widgets-Pluggable-TheIntegrator.66.mczMorphic-Widgets-PolyTabs-TheIntegrator.2.mczMorphic-Widgets-Scrolling-TheIntegrator.32.mczMorphic-Widgets-Tabs-TheIntegrator.20.mczMorphic-Widgets-Taskbar-TheIntegrator.21.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.50.mczMorphic-Widgets-Windows-TheIntegrator.97.mczMultilingual-Encodings-TheIntegrator.61.mczMultilingual-Languages-TheIntegrator.55.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.81.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.244.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1253.mczNautilus-GroupManager-TheIntegrator.20.mczNautilus-GroupManagerUI-TheIntegrator.31.mczNautilus-Tests-TheIntegrator.37.mczNautilusCommon-TheIntegrator.305.mczNautilusGroupAutoBuilder-TheIntegrator.11.mczNautilusRefactoring-TheIntegrator.272.mczNetwork-Kernel-TheIntegrator.133.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-TheIntegrator.45.mczNetwork-Protocols-TheIntegrator.103.mczNetwork-Tests-TheIntegrator.13.mczNetwork-UUID-TheIntegrator.44.mczNetwork-Url-MarcusDenker.99.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.55.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-RonieSalgado.107.mczOSWindow-SDL2-RonieSalgado.96.mczOSWindow-SDL2-Examples-RonieSalgado.13.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOpalCompiler-Core-TheIntegrator.799.mczOpalCompiler-Tests-TheIntegrator.334.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.15.mczPolymorph-TaskbarIcons-TheIntegrator.46.mczPolymorph-Widgets-TheIntegrator.1338.mczPragmaCollector-TheIntegrator.12.mczProfStef-Core-TheIntegrator.73.mczProfStef-Help-TheIntegrator.16.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.101.mczQualityAssistantRecording-YuriyTymchuk.20.mczRPackage-Core-TheIntegrator.430.mczRPackage-Tests-TheIntegrator.181.mczRandom-Core-TheIntegrator.4.mczRandom-Tests-TheIntegrator.4.mczRecentSubmissions-TheIntegrator.238.mczRefactoring-Changes-TheIntegrator.67.mczRefactoring-Core-TheIntegrator.298.mczRefactoring-Critics-TheIntegrator.261.mczRefactoring-Environment-TheIntegrator.76.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.131.mczRefactoring-Tests-Critics-TheIntegrator.38.mczRefactoring-Tests-Environment-TheIntegrator.23.mczReflectivity-TheIntegrator.297.mczReflectivity-Examples-TheIntegrator.28.mczReflectivity-Tests-TheIntegrator.202.mczReflectivity-Tools-TheIntegrator.24.mczReflectivity-Tools-Tests-TheIntegrator.11.mczRegex-Core-TheIntegrator.38.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.31.mczRenraku-YuriyTymchuk.111.mczRenraku-Test-YuriyTymchuk.19.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.237.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.90.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-GuillermoPolito.363.mczRubric-Rules-YuriyTymchuk.3.mczSTON-Core-PavelKrivanek.73.mczSTON-Tests-SvenVanCaekenberghe.64.mczSUnit-Core-TheIntegrator.169.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.3.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-EstebanLorenzano.138.mczSUnit-UITesting-TheIntegrator.32.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.92.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TommasoDalSasso.3.mczShoreLine-Report-UI-TommasoDalSasso.17.mczShout-TheIntegrator.291.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.742.mczSlot-Tests-TheIntegrator.89.mczSmartSuggestions-TheIntegrator.234.mczSmartSuggestions-Tests-TheIntegrator.33.mczSpec-Core-TheIntegrator.465.mczSpec-Debugger-TheIntegrator.263.mczSpec-Examples-TheIntegrator.108.mczSpec-Help-TheIntegrator.10.mczSpec-Inspector-TheIntegrator.258.mczSpec-Layout-TheIntegrator.69.mczSpec-MorphicAdapters-TheIntegrator.262.mczSpec-PolyWidgets-TheIntegrator.66.mczSpec-Tests-TheIntegrator.63.mczSpec-Tools-TheIntegrator.324.mczStartupPreferences-TheIntegrator.149.mczSystem-Announcements-TheIntegrator.108.mczSystem-BasicCommandLineHandler-TheIntegrator.18.mczSystem-Caching-TheIntegrator.26.mczSystem-CachingTests-TheIntegrator.16.mczSystem-Changes-TheIntegrator.292.mczSystem-Changes-FileServices-TheIntegrator.2.mczSystem-Clipboard-TheIntegrator.40.mczSystem-CommandLine-TheIntegrator.181.mczSystem-CommandLine-TextSupport-TheIntegrator.4.mczSystem-CommandLineHandler-TheIntegrator.18.mczSystem-FileRegistry-TheIntegrator.50.mczSystem-Finalization-TheIntegrator.32.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.106.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.4.mczSystem-OSEnvironments-TheIntegrator.31.mczSystem-Object Events-TheIntegrator.25.mczSystem-Platforms-TheIntegrator.81.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.27.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.337.mczSystem-Settings-Tests-TheIntegrator.11.mczSystem-Sound-StephaneDucasse.18.mczSystem-Sources-TheIntegrator.50.mczSystem-Support-TheIntegrator.1215.mczSystem-SupportTests-TheIntegrator.2.mczSystem-VMEvents-TheIntegrator.17.mczTests-TheIntegrator.755.mczText-Core-TheIntegrator.50.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.114.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.140.mczTool-Catalog-GuillermoPolito.32.mczTool-CriticBrowser-TheIntegrator.21.mczTool-DependencyAnalyser-ChristopheDemarey.28.mczTool-DependencyAnalyser-Test-ChristopheDemarey.11.mczTool-DependencyAnalyser-UI-ChristopheDemarey.43.mczTool-Diff-TheIntegrator.31.mczTool-ExternalBrowser-TheIntegrator.49.mczTool-FileList-TheIntegrator.62.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.65.mczTool-ImageCleaner-TheIntegrator.15.mczTool-ProcessBrowser-TheIntegrator.20.mczTool-Profilers-TheIntegrator.22.mczTool-SystemReporter-TheIntegrator.15.mczTool-Transcript-TheIntegrator.25.mczTool-TxWorkspace-NicolaiHess.7.mczTool-Workspace-TheIntegrator.37.mczTools-TheIntegrator.1525.mczTools-Test-TheIntegrator.16.mczTraits-TheIntegrator.907.mczTranscript-TheIntegrator.50.mczTxText-Athens-GuillermoPolito.53.mczTxText-AthensTests-SeanDeNigris.10.mczTxText-Model-SeanDeNigris.61.mczTxText-Styler-MarcusDenker.17.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.187.mczUnicode-Initialization-TheIntegrator.15.mczUnifiedFFI-EstebanLorenzano.57.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.25.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-VincentBlondeau.32.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-StephaneDucasse.64.mczVersionner-Core-DependenciesModel-ChristopheDemarey.105.mczVersionner-Core-Model-ChristopheDemarey.52.mczVersionner-Spec-Browser-PabloTesone.189.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczZinc-Character-Encoding-Core-TheIntegrator.48.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.27.mczZinc-FileSystem-SvenVanCaekenberghe.12.mczZinc-HTTP-SvenVanCaekenberghe.448.mczZinc-Resource-Meta-Core-TheIntegrator.58.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.36.mczZinc-Tests-SvenVanCaekenberghe.236.mczZinc-Zodiac-TheIntegrator.37.mczZodiac-Core-SvenVanCaekenberghe.42.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.13.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 5/10/2016 17:11'!update50754	"self new update50754"	self withUpdateLog: '18153 Failing on CI on Windows: SocketTest.testUDPBroadcastError (from Network-Tests)	https://pharo.fogbugz.com/f/cases/18153'.	self loadTogether: self script50754 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update50753!ScriptLoader removeSelector: #script50753!"ScriptLoader50"!!SocketTest methodsFor: 'mocks' stamp: 'HenrikNergaard 5/10/2016 11:33'!faultyUDPSocket	| cls |		cls := Socket newAnonymousSubclass .		"the mock socket is not sending anything, so there is nothing to wait for"	cls compile: 'waitForSendDoneFor: aNumber ^ true'.		"compile the primitive to not send, but return a 0 count for any send"	cls compile: 'primSocket: socketID sendUDPData: aStringOrByteArray toHost: hostAddress port: portNumber startIndex: startIndex count: count ^ 0'.		^ cls newUDP! !!SocketTest methodsFor: 'tests' stamp: 'HenrikSperreJohansen 5/9/2016 09:49' prior: 58415898!testUDPBroadcastError	"Test that we get a specific error when failure is due to sending to a broadcast address without SO_BROADCAST set"	"Use 255.255.255.255 for testing, which in RFC 919 is defined as 'denoting a broadcast on a local hardware network, which must not be forwarded. 	This address may be used, for example, by hosts that do not know their network number and are asking some server for it.'"	self		should: [ 			Socket newUDP				setOption: 'SO_BROADCAST' value: false;				sendUDPData: #[] toHost: #[255 255 255 255] port: 1950 ]		raise: NoBroadcastAllowed.	self		shouldnt: [ 			Socket newUDP				setOption: 'SO_BROADCAST' value: true;				sendUDPData: #[] toHost: #[255 255 255 255] port: 1 ]		raise: NoBroadcastAllowed! !!SocketTest methodsFor: 'tests' stamp: 'HenrikNergaard 5/10/2016 11:35'!testUDPFaultySend	| socket host |		socket := self faultyUDPSocket.		host := #[1 2 3 4].		"Check that sending is not caught in a infinite loop"	self should: [ 				self 			deny: (socket isBroadcastAddress: host);			should: [socket sendUDPData: #[123] toHost: host port: 1 ] raise: NetworkError.					host := #[ 255 255 255 255].				self 			assert: (socket isBroadcastAddress: host);			should: [ socket sendUDPData: #[123] toHost: host port: 1 ] raise: NoBroadcastAllowed.					socket setOption: 'SO_BROADCAST' value: true.				self should: [ socket sendUDPData: #[123] toHost: host port: 1 ] raise: NetworkError.			] notTakeMoreThanMilliseconds: 20 .	socket destroy.! !!Socket methodsFor: 'private - errors' stamp: 'HenrikSperreJohansen 5/9/2016 08:53'!broadcastError: hostAddress	^ (NoBroadcastAllowed new		messageText: 'Sending to ' , hostAddress printString , ' without SO_BROADCAST set')		signal! !!Socket methodsFor: 'private - errors' stamp: 'HenrikSperreJohansen 5/10/2016 16:05'!broadcastMisconfiguredForSendingTo: hostAddress	^ (self isBroadcastAddress: hostAddress)		and: [ ((self getOption: 'SO_BROADCAST') last = 0) ]! !!Socket methodsFor: 'private - errors' stamp: 'HenrikSperreJohansen 5/9/2016 09:23' prior: 58337998!errorSending: data startingAt: startIndex count: aCount toHost: hostAddress port: portNumber	"If there are known primitive failure reasons when sending that can be specified using more exact errors, discern them here""Only applicable to UDP sockets, TCP does not have broadcast"	(self broadcastMisconfiguredForSendingTo: hostAddress)		ifTrue: [ ^ self broadcastError: hostAddress ].		^ self primitiveFailed: thisContext sender selector! !!Socket methodsFor: 'datagrams' stamp: 'HenrikSperreJohansen 5/9/2016 09:51' prior: 58351092!sendUDPData: aStringOrByteArray toHost: hostAddress port: portNumber	"Send a UDP packet containing the given data to the specified host/port."	| bytesToSend bytesSent count |	bytesToSend := aStringOrByteArray size.	bytesSent := 0.	[		(self waitForSendDoneFor: 20)			ifFalse: [ConnectionTimedOut signal: 'send data timeout; data not sent'].		count := self primSocket: socketHandle			sendUDPData: aStringOrByteArray			toHost: hostAddress			port: portNumber			startIndex: bytesSent + 1			count: bytesToSend - bytesSent.		count = 0 ifTrue: 			["Usually broadcast fails in primitive without the proper option set, 			but some platforms simply return count=0"			(self broadcastMisconfiguredForSendingTo: hostAddress)				ifTrue: [ ^ self broadcastError: hostAddress ].			bytesToSend ~= count 				ifTrue: [ ^NetworkError signal: 'failed to send data']].		bytesSent := bytesSent + count.		bytesSent < bytesToSend] whileTrue.	^ bytesSent! !"Network-Kernel"!"Network-Tests"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo50/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader50-TheIntegrator.958.mcz') load.ScriptLoader new update50754.!----End fileIn----!----QUIT----2016-05-10T17:12:58.119405+02:00 Pharo.image priorSource: 56814!----QUIT----2016-05-10T17:13:01.033114+02:00 Pharo.image priorSource: 78312!----QUIT----2016-05-10T17:13:06.252828+02:00 Pharo.image priorSource: 78390!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 5/11/2016 16:47' prior: 33611416!commentForCurrentUpdate ^ '18023 add a WelcomeHelp page to open a Help Browser on it when starting	https://pharo.fogbugz.com/f/cases/18023'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 5/11/2016 16:47'!script50755	^ 'AST-Core-TheIntegrator.418.mczAST-FFI-Pharo50Compatibility-TheIntegrator.2.mczAST-Tests-Core-TheIntegrator.95.mczAlien-eem.32.mczAnnouncements-Core-TheIntegrator.68.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.31.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-NicolaiHess.123.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-EstebanLorenzano.63.mczAthens-Text-NicolaiHess.16.mczBalloon-TheIntegrator.132.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfFileTree-ThierryGoubier.15.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfQualityAssistant-YuriyTymchuk.46.mczBaselineOfRenraku-YuriyTymchuk.5.mczBlueInk-Core-TheIntegrator.24.mczBlueInk-Extras-TheIntegrator.10.mczBlueInk-Tests-TheIntegrator.12.mczChroma-CubeHelix-TheIntegrator.2.mczCodeExport-TheIntegrator.19.mczCodeImport-TheIntegrator.88.mczCodeImportCommandLineHandlers-TheIntegrator.7.mczCollections-Abstract-TheIntegrator.313.mczCollections-Arithmetic-TheIntegrator.20.mczCollections-Atomic-TheIntegrator.16.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.243.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.188.mczCollections-Strings-TheIntegrator.415.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.49.mczCollections-Unordered-TheIntegrator.232.mczCollections-Weak-TheIntegrator.102.mczCompiler-TheIntegrator.602.mczCompression-TheIntegrator.176.mczCompression-Tests-TheIntegrator.2.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.4.mczDebuggerActions-TheIntegrator.85.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.126.mczDeprecated50-TheIntegrator.59.mczEmbeddedFreeType-TheIntegrator.26.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczFFI-Kernel-JanVanDeSandt.40.mczFFI-Pools-eem.3.mczFileSystem-Core-TheIntegrator.202.mczFileSystem-Disk-TheIntegrator.97.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.95.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.417.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-TheIntegrator.17.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.14.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.742.mczFreeType-Tests-TheIntegrator.2.mczFuel-MaxLeske.825.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-TheIntegrator.62.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.411.mczFuelTools-Debugger-TheIntegrator.10.mczGT-BytecodeDebugger-TudorGirba.31.mczGT-Debugger-AndreiChis.350.mczGT-EventRecorder-TheIntegrator.68.mczGT-EventRecorder-Tests-JurajKubelka.37.mczGT-Inspector-AndreiChis.421.mczGT-InspectorExtensions-Core-TheIntegrator.214.mczGT-Playground-DenisKudryashov.124.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-TudorGirba.397.mczGT-Spotter-EventRecorder-GuillermoPolito.112.mczGT-SpotterExtensions-Core-VincentBlondeau.203.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-StefanReichhart.56.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AliakseiSyrel.17.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-TudorGirba.322.mczGlamour-Examples-TudorGirba.303.mczGlamour-FastTable-AndreiChis.59.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-GuillermoPolito.418.mczGlamour-Morphic-Brick-Tests-TheIntegrator.14.mczGlamour-Morphic-Pager-GuillermoPolito.110.mczGlamour-Morphic-Renderer-AndreiChis.349.mczGlamour-Morphic-Theme-HenrikNergaard.222.mczGlamour-Morphic-Widgets-AndreiChis.195.mczGlamour-Presentations-AndreiChis.186.mczGlamour-Rubric-Presentations-AndreiChis.52.mczGlamour-Tests-Core-AndreiChis.111.mczGlamour-Tests-Morphic-TudorGirba.137.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.35.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.6.mczGraphics-Display Objects-TheIntegrator.175.mczGraphics-Files-TheIntegrator.76.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.189.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.80.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.41.mczHelpSystem-Core-TheIntegrator.144.mczHelpSystem-Tests-TheIntegrator.32.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.90.mczImportingResource-Help-TheIntegrator.4.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.28.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2290.mczKernel-Rules-TheIntegrator.2.mczKernel-Tests-TheIntegrator.65.mczKeymapping-Core-TheIntegrator.198.mczKeymapping-KeyCombinations-TheIntegrator.62.mczKeymapping-Pragmas-TheIntegrator.54.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.105.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.166.mczManifest-Core-TheIntegrator.239.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.51.mczMenuRegistration-TheIntegrator.78.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.824.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-EstebanLorenzano.733.mczMetacello-PharoCommonPlatform-TheIntegrator.22.mczMetacello-Platform-EstebanLorenzano.3.mczMetacello-ProfStef-EstebanLorenzano.18.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.7.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform.squeakCommon-EstebanLorenzano.23.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-EstebanLorenzano.148.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1132.mczMonticello-OldDataStreamCompatibility-TheIntegrator.8.mczMonticello-Tests-TheIntegrator.35.mczMonticelloConfigurations-TheIntegrator.72.mczMonticelloFileServices-TheIntegrator.6.mczMonticelloFileTree-Core-TheIntegrator.141.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.30.mczMonticelloGUI-TheIntegrator.415.mczMonticelloMocks-TheIntegrator.4.mczMonticelloRemoteRepositories-TheIntegrator.15.mczMoose-Algos-Graph-vincentBlondeau.31.mczMorphic-Base-TheIntegrator.546.mczMorphic-Core-TheIntegrator.278.mczMorphic-Examples-TheIntegrator.50.mczMorphic-Tests-TheIntegrator.11.mczMorphic-Widgets-Basic-TheIntegrator.86.mczMorphic-Widgets-ColorPicker-TheIntegrator.19.mczMorphic-Widgets-Extra-TheIntegrator.27.mczMorphic-Widgets-FastTable-StephanEggermont.177.mczMorphic-Widgets-List-TheIntegrator.21.mczMorphic-Widgets-NewList-TheIntegrator.9.mczMorphic-Widgets-Pluggable-TheIntegrator.66.mczMorphic-Widgets-PolyTabs-TheIntegrator.2.mczMorphic-Widgets-Scrolling-TheIntegrator.32.mczMorphic-Widgets-Tabs-TheIntegrator.20.mczMorphic-Widgets-Taskbar-TheIntegrator.21.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.50.mczMorphic-Widgets-Windows-TheIntegrator.97.mczMultilingual-Encodings-TheIntegrator.61.mczMultilingual-Languages-TheIntegrator.55.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.81.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.244.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1253.mczNautilus-GroupManager-TheIntegrator.20.mczNautilus-GroupManagerUI-TheIntegrator.31.mczNautilus-Tests-TheIntegrator.37.mczNautilusCommon-TheIntegrator.305.mczNautilusGroupAutoBuilder-TheIntegrator.11.mczNautilusRefactoring-TheIntegrator.272.mczNetwork-Kernel-TheIntegrator.133.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-TheIntegrator.45.mczNetwork-Protocols-TheIntegrator.103.mczNetwork-Tests-TheIntegrator.13.mczNetwork-UUID-TheIntegrator.44.mczNetwork-Url-MarcusDenker.99.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.55.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-RonieSalgado.107.mczOSWindow-SDL2-RonieSalgado.96.mczOSWindow-SDL2-Examples-RonieSalgado.13.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOpalCompiler-Core-TheIntegrator.799.mczOpalCompiler-Tests-TheIntegrator.334.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.20.mczPolymorph-TaskbarIcons-TheIntegrator.46.mczPolymorph-Widgets-TheIntegrator.1338.mczPragmaCollector-TheIntegrator.12.mczProfStef-Core-TheIntegrator.77.mczProfStef-Help-TheIntegrator.16.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.101.mczQualityAssistantRecording-YuriyTymchuk.20.mczRPackage-Core-TheIntegrator.430.mczRPackage-Tests-TheIntegrator.181.mczRandom-Core-TheIntegrator.4.mczRandom-Tests-TheIntegrator.4.mczRecentSubmissions-TheIntegrator.238.mczRefactoring-Changes-TheIntegrator.67.mczRefactoring-Core-TheIntegrator.298.mczRefactoring-Critics-TheIntegrator.261.mczRefactoring-Environment-TheIntegrator.76.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.131.mczRefactoring-Tests-Critics-TheIntegrator.38.mczRefactoring-Tests-Environment-TheIntegrator.23.mczReflectivity-TheIntegrator.297.mczReflectivity-Examples-TheIntegrator.28.mczReflectivity-Tests-TheIntegrator.202.mczReflectivity-Tools-TheIntegrator.24.mczReflectivity-Tools-Tests-TheIntegrator.11.mczRegex-Core-TheIntegrator.38.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.31.mczRenraku-YuriyTymchuk.111.mczRenraku-Test-YuriyTymchuk.19.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.237.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.90.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.364.mczRubric-Rules-YuriyTymchuk.3.mczSTON-Core-PavelKrivanek.73.mczSTON-Tests-SvenVanCaekenberghe.64.mczSUnit-Core-TheIntegrator.169.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.3.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-EstebanLorenzano.138.mczSUnit-UITesting-TheIntegrator.32.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.92.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TommasoDalSasso.3.mczShoreLine-Report-UI-TommasoDalSasso.17.mczShout-TheIntegrator.291.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.742.mczSlot-Tests-TheIntegrator.89.mczSmartSuggestions-TheIntegrator.234.mczSmartSuggestions-Tests-TheIntegrator.33.mczSpec-Core-TheIntegrator.465.mczSpec-Debugger-TheIntegrator.263.mczSpec-Examples-TheIntegrator.108.mczSpec-Help-TheIntegrator.10.mczSpec-Inspector-TheIntegrator.258.mczSpec-Layout-TheIntegrator.69.mczSpec-MorphicAdapters-TheIntegrator.262.mczSpec-PolyWidgets-TheIntegrator.66.mczSpec-Tests-TheIntegrator.63.mczSpec-Tools-TheIntegrator.324.mczStartupPreferences-TheIntegrator.149.mczSystem-Announcements-TheIntegrator.108.mczSystem-BasicCommandLineHandler-TheIntegrator.18.mczSystem-Caching-TheIntegrator.26.mczSystem-CachingTests-TheIntegrator.16.mczSystem-Changes-TheIntegrator.292.mczSystem-Changes-FileServices-TheIntegrator.2.mczSystem-Clipboard-TheIntegrator.40.mczSystem-CommandLine-TheIntegrator.181.mczSystem-CommandLine-TextSupport-TheIntegrator.4.mczSystem-CommandLineHandler-TheIntegrator.18.mczSystem-FileRegistry-TheIntegrator.50.mczSystem-Finalization-TheIntegrator.32.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.106.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.4.mczSystem-OSEnvironments-TheIntegrator.31.mczSystem-Object Events-TheIntegrator.25.mczSystem-Platforms-TheIntegrator.81.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.27.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.337.mczSystem-Settings-Tests-TheIntegrator.11.mczSystem-Sound-StephaneDucasse.18.mczSystem-Sources-TheIntegrator.50.mczSystem-Support-TheIntegrator.1215.mczSystem-SupportTests-TheIntegrator.2.mczSystem-VMEvents-TheIntegrator.17.mczTests-TheIntegrator.755.mczText-Core-TheIntegrator.50.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.114.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.140.mczTool-Catalog-GuillermoPolito.32.mczTool-CriticBrowser-TheIntegrator.21.mczTool-DependencyAnalyser-ChristopheDemarey.28.mczTool-DependencyAnalyser-Test-ChristopheDemarey.11.mczTool-DependencyAnalyser-UI-ChristopheDemarey.43.mczTool-Diff-TheIntegrator.31.mczTool-ExternalBrowser-TheIntegrator.49.mczTool-FileList-TheIntegrator.62.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.65.mczTool-ImageCleaner-TheIntegrator.15.mczTool-ProcessBrowser-TheIntegrator.20.mczTool-Profilers-TheIntegrator.22.mczTool-SystemReporter-TheIntegrator.15.mczTool-Transcript-TheIntegrator.25.mczTool-TxWorkspace-NicolaiHess.7.mczTool-Workspace-TheIntegrator.37.mczTools-TheIntegrator.1525.mczTools-Test-TheIntegrator.16.mczTraits-TheIntegrator.907.mczTranscript-TheIntegrator.50.mczTxText-Athens-GuillermoPolito.53.mczTxText-AthensTests-SeanDeNigris.10.mczTxText-Model-SeanDeNigris.61.mczTxText-Styler-MarcusDenker.17.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.187.mczUnicode-Initialization-TheIntegrator.15.mczUnifiedFFI-EstebanLorenzano.57.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.25.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-VincentBlondeau.32.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-StephaneDucasse.64.mczVersionner-Core-DependenciesModel-ChristopheDemarey.105.mczVersionner-Core-Model-ChristopheDemarey.52.mczVersionner-Spec-Browser-PabloTesone.189.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczZinc-Character-Encoding-Core-TheIntegrator.48.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.27.mczZinc-FileSystem-SvenVanCaekenberghe.12.mczZinc-HTTP-SvenVanCaekenberghe.448.mczZinc-Resource-Meta-Core-TheIntegrator.58.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.36.mczZinc-Tests-SvenVanCaekenberghe.236.mczZinc-Zodiac-TheIntegrator.37.mczZodiac-Core-SvenVanCaekenberghe.42.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.13.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 5/11/2016 16:47'!update50755	"self new update50755"	self withUpdateLog: '18023 add a WelcomeHelp page to open a Help Browser on it when starting	https://pharo.fogbugz.com/f/cases/18023'.	self loadTogether: self script50755 merge: false.	PharoWelcomePage openForRelease.	self flushCaches.! !ScriptLoader removeSelector: #update50754!ScriptLoader removeSelector: #script50754!"ScriptLoader50"!!PharoWelcomePage commentStamp: 'PavelKrivanek 4/22/2016 17:18' prior: 0!Pharo 5.0=========Welcome to Pharo, an immersive live programming environment."Pharo 5.0 already comes pre-loaded with a rich set of packages that you can use to explore the system and develop your own applications. However there is also a huge library of user contributed projects that you can also load using the 'Configurations Browser' by executing:"MetacelloConfigurationBrowser open."This browser is also accessible from the World | Tools menu (just click the desktop, select Tools, and then Configuration Browser).You can find information about Pharo on http://www.pharo.org. Some useful starting points are:- Joining us and getting help http://www.pharo.org/get-help- Getting the Pharo By Example book (available as a free PDF): http://www.pharobyexample.org- Browser the documentation http://www.pharo.org/documentation- Reporting problems http://www.pharo.org/get-involvedAbout this release---------------------------There are more than 1600 issues treated in this release. Sumarized issues for 4.0:=========================New stuff---------- GTools (Playground, Inspector, Spotter)- Slots model instance variables as first class enities and enable meta-programming on this level.- ShoreLine reporter: submit information automatically when errors happen- TxModel, a modern text model who works with Athens (Preview)- OSWindow, a new way to handle windows and input events (Preview)- Glamour, a mature declarative browser builder- Dark themeUpdated stuff-------------- Zinc/Zodiac- Fuel- VersionnerAnd a lot more!!You can check a more detailed explanation here: https://github.com/pharo-project/pharo-changelogs/blob/master/Pharo40ChangeLogs.md"!!WelcomeHelp commentStamp: '<historical>' prior: 0!I'm the help page for welcoming new users. I pass through basic concepts to getting started with Pharo.!!RubFindReplaceService commentStamp: 'StephaneDucasse 6/13/2015 14:25' prior: 56085045!RubFindReplaceService default newDialog openInWorldRubFindReplaceService !!PharoWelcomePage class methodsFor: 'opening' stamp: 'EstebanLorenzano 5/10/2016 11:58'!open	| group welcome help zen about window |	welcome := WelcomeHelp open.	help := HelpBrowser open.	zen := TextModel new			text: ProfStef pharoZenValuesContents;			title: 'Pharo Zen';			aboutText: ProfStef aboutPharoZen;			beForText;			openWithSpec.				about := TextModel new			text: Smalltalk systemInformationString withCRs;			title: 'About Pharo';			beForText;			openWithSpec.	group := GroupWindowMorph new.	group addWindow: welcome window.	group addWindow: help window.	group addWindow: SettingBrowser open.	group addWindow: KeymapBrowser new openWithSpec window.	group addWindow: zen window.	group addWindow: about window.	window := (group openInWindowLabeled: self title translated)		extent: welcome window extent;		yourself.			group tabGroup selectedPageIndex: 1.	^ window! !!PharoWelcomePage class methodsFor: 'opening' stamp: 'EstebanLorenzano 4/22/2016 17:48'!openForRelease	| window |		World submorphs 		detect: [ :each | (each isKindOf: SystemWindow) and: [ each label = self title ] ] 		ifFound: [ :oldWindow | oldWindow delete ].	window := self open.	window extent: 750@400.	window center: Display extent / 2! !!PharoWelcomePage class methodsFor: 'accessing' stamp: 'EstebanLorenzano 4/22/2016 17:44'!title	^ 'Welcome to Pharo 5.0'! !!PharoEnvironmentHelp class methodsFor: 'help-text' stamp: 'EstebanLorenzano 5/10/2016 12:02' prior: 52713451!wikiStyleHelp	<wikiStyleHelp: #' Pharo Environment Help'>		^ self comment! !!RubScrolledTextMorph methodsFor: 'initialize-release' stamp: 'EstebanLorenzano 4/19/2016 16:29'!beForSmalltalkCodeWithDefaultFont	self textArea beForSmalltalkCodeWithDefaultFont.	self withTextSegmentIcons! !!RubScrolledTextMorph methodsFor: 'accessing' stamp: 'EstebanLorenzano 4/19/2016 16:31'!beForSmalltalkScriptingWithDefaultFont    self textArea beForSmalltalkScriptingWithDefaultFont! !!RubEditingArea methodsFor: 'initialize-release' stamp: 'EstebanLorenzano 4/19/2016 14:35'!beForSmalltalkCodeWithDefaultFont	self editingMode: RubSmalltalkCodeMode new.	self font: StandardFonts defaultFont! !!RubEditingArea methodsFor: 'public accessing' stamp: 'EstebanLorenzano 4/19/2016 16:29'!beForSmalltalkScriptingWithDefaultFont	self editingMode: RubSmalltalkScriptingMode new.	self font: StandardFonts defaultFont! !!ProfStef class methodsFor: 'cleanup' stamp: 'EstebanLorenzano 4/19/2016 15:01'!cleanUp	self reset! !!ProfStef class methodsFor: 'navigating' stamp: 'StephaneDucasse 7/28/2015 17:17' prior: 53487663!goToNextLesson  self next! !!HelpBrowser class methodsFor: 'ui' stamp: 'EstebanLorenzano 4/21/2016 15:51'!menuOn: aBuilder	<HelpBrowserContextMenu>		(aBuilder item: #'Do it' translated)		keyText: 'd';		selector: #doIt;		help: nil;		icon: (Smalltalk ui icons iconNamed: #smallDoIt).	(aBuilder item: #'Print it' translated)		keyText: 'p';		selector: #printIt;		help: nil;		icon: (Smalltalk ui icons iconNamed: #smallPrintIt).	(aBuilder item: #'Inspect it' translated)		keyText: 'i';		selector: #inspectIt;		help: nil;		icon: (Smalltalk ui icons iconNamed: #smallInspectIt).! !!HelpBrowser methodsFor: 'ui' stamp: 'EstebanLorenzano 4/19/2016 16:30' prior: 27864611!initWindow	| toolbar dock contentMorph |	window := (Smalltalk at: #StandardWindow) new.	window model: self.	window title: 'Help Browser'.	toolbar := window		newToolbar:			{window				newButtonFor: self				getState: nil				action: #refresh				arguments: nil				getEnabled: nil				labelForm: (Smalltalk ui icons refreshIcon)				help: 'Refresh' translated}.	dock := window newToolDockingBar.	dock addMorphBack: toolbar.	window addMorph: dock fullFrame: ((0 @ 0 corner: 1 @ 0) asLayoutFrame bottomOffset: dock minExtent y).	"Tree"	treeMorph := PluggableTreeMorph new.	treeMorph		model: self;		setSelectedSelector: #onItemClicked:.	window addMorph: treeMorph fullFrame: ((0 @ 0 corner: 0.3 @ 1) asLayoutFrame topOffset: dock minExtent y).	"Text"	contentMorph := self sourceTextModel newScrolledText		beForSmalltalkScriptingWithDefaultFont;		beWrapped;		yourself.	contentMorph menuProvider: self selector: #shoutMorphFillMenu:.	window addMorph: contentMorph fullFrame: ((0.3 @ 0 corner: 1 @ 1) asLayoutFrame topOffset: dock minExtent y)! !!HelpBrowser methodsFor: 'ui' stamp: 'EstebanLorenzano 4/21/2016 15:50' prior: 27867071!menu	^ (PragmaMenuBuilder pragmaKeyword: #HelpBrowserContextMenu model: self) menu.! !!HelpBrowser methodsFor: 'accessing' stamp: 'EstebanLorenzano 4/19/2016 17:06'!selectedClassOrMetaClass	^ nil! !!HelpBrowser methodsFor: 'accessing' stamp: 'PavelKrivanek 4/22/2016 16:25'!window	^ window! !!LessonView class methodsFor: 'gui' stamp: 'EstebanLorenzano 4/21/2016 15:52'!menuOn: aBuilder	<LessonViewContextMenu>		(aBuilder item: #'Do it' translated)		keyText: 'd';		selector: #doIt;		help: nil;		icon: (Smalltalk ui icons iconNamed: #smallDoIt).	(aBuilder item: #'Print it' translated)		keyText: 'p';		selector: #printIt;		help: nil;		icon: (Smalltalk ui icons iconNamed: #smallPrintIt).	(aBuilder item: #'Inspect it' translated)		keyText: 'i';		selector: #inspectIt;		help: nil;		icon: (Smalltalk ui icons iconNamed: #smallInspectIt).! !!LessonView methodsFor: 'gui' stamp: 'EstebanLorenzano 4/19/2016 14:51' prior: 29392129!buildText	| scrolledText |	scrolledText := self sourceTextModel newScrolledText		beForSmalltalkScripting;		beWrapped;		yourself.	scrolledText textArea font: StandardFonts codeFont.	^ scrolledText! !!LessonView methodsFor: 'gui' stamp: 'EstebanLorenzano 4/21/2016 15:52' prior: 29391757!menu	^ (PragmaMenuBuilder pragmaKeyword: #LessonViewContextMenu model: self) menu.! !!LessonView methodsFor: 'accessing' stamp: 'StephaneDucasse 7/10/2015 16:46' prior: 29391189!sourceTextModel	^ sourceTextModel ifNil: [ sourceTextModel := RubScrolledTextModel new interactionModel: self ].! !!WelcomeHelp class methodsFor: 'accessing' stamp: 'EstebanLorenzano 5/10/2016 12:05'!bookName	"the character zero is a hack to display it always first"	^ (Character value: 0) asString, 'Welcome'! !!WelcomeHelp class methodsFor: 'pages' stamp: 'EstebanLorenzano 4/19/2016 14:40'!changeLog	^ HelpTopic 		title: 'ChangeLog'		contents: 'TODO'! !!WelcomeHelp class methodsFor: 'pages' stamp: 'EstebanLorenzano 5/10/2016 11:38'!documentation	^ HelpTopic 		title: 'More documentation'		contents: 'The most important documentation is the one you can get by exploring the system, reading class comments and looking for examples. You can find "in image" help by highlighting the next line and selecting [Do it] from the context menu:HelpBrowser open.This browser is also accessible from the World>Help>Help Browser menu (just click the desktop, select Help, and then Help Browser).A compendium of Pharo documentation can be found at: http://pharo.org/documentationThere you can find:- Pharo books: http://books.pharo.org- Screencasts: https://www.youtube.com/channel/UCp3mNigANqkesFzdm058bvw- Presentations: http://www.slideshare.net/pharoproject/'! !!WelcomeHelp class methodsFor: 'pages' stamp: 'EstebanLorenzano 5/10/2016 11:32'!exploreEnvironment	^ HelpTopic 		title: 'Explore Pharo Environment'		contents: 'The best way to learn Pharo is to explore it by your self. This is live objects all the way down: they can be inspected, browsed, changed... everything in the environment you have in your hands.But sometimes it can be hard to getting you started with the tools and capabilities the environment gives you.The most complete and updated guide for the Pharo environment can be found at "Updated Pharo by Example" free book. It is still a work in progress, but most of it is already done. You can find the book here: https://github.com/SquareBracketAssociates/UpdatedPharoByExampleOne particular chapter that is interesting is the one that gisves you a quick tour for all the environment: https://ci.inria.fr/pharo-contribution/job/UpdatedPharoByExample/lastSuccessfulBuild/artifact/book-result/PharoTour/PharoTour.pdf '! !!WelcomeHelp class methodsFor: 'pages' stamp: 'EstebanLorenzano 5/10/2016 11:38'!gettingHelp	^ HelpTopic 		title: 'Getting help'		contents: 'Pharo has a vibrant community that shares knowledge in different ways: - The "Pharo Users" mailing list: http://lists.pharo.org/mailman/listinfo/pharo-users_lists.pharo.org- The "Pharo Slack Team": http://slack4pharo.trentosur.com/- The "Pharo IRC Channel": irc.freenode.net, #pharo channel You can find more information, lists to browse/suscribe and places to share code at: http://pharo.org/community'! !!WelcomeHelp class methodsFor: 'pages' stamp: 'EstebanLorenzano 5/10/2016 11:31'!learn	^ HelpTopic 		title: 'Learn Pharo Smalltalk'		contents: 'You can learn Pharo by highlighting the next line and selecting [Do it] from the context menu:ProfStef go.Pharo has also an excellent MOOC (Massive Open Online Course). You can find more indormation here: http://mooc.pharo.orgThere are also several free Pharo books that can be download here: http://books.pharo.orgA very interesting starting point would be looking into the "Updated Pharo by Example" free book. It is still a work in progress, but most of it is already done. You can find the book here: https://github.com/SquareBracketAssociates/UpdatedPharoByExample'! !!WelcomeHelp class methodsFor: 'showing' stamp: 'EstebanLorenzano 4/19/2016 16:00'!open	^ (HelpBrowser openOn: self) next! !!WelcomeHelp class methodsFor: 'showing' stamp: 'EstebanLorenzano 4/19/2016 16:10'!openForRelease	| browser window findBlock |		findBlock := [ :each | (each isKindOf: SystemWindow) and: [ each label = self bookName ] ]. 	World submorphs 		detect: findBlock 		ifFound: [ :oldWindow | oldWindow delete ].	browser := self open.	window := browser dependents detect: findBlock.	window extent: 700@400.	window center: Display extent / 2! !!WelcomeHelp class methodsFor: 'accessing' stamp: 'EstebanLorenzano 4/19/2016 14:39'!pages	^ #(welcome changeLog learn exploreEnvironment useExternalPackages documentation gettingHelp)! !!WelcomeHelp class methodsFor: 'pages' stamp: 'EstebanLorenzano 5/10/2016 11:39'!useExternalPackages	^ HelpTopic 		title: 'Use external packages'		contents: 'Pharo 5.0 already comes pre-loaded with a rich set of packages that you can use to explore the system and develop your own applications. However there is also a huge library of user contributed projects that you can also load using the "Catalog Browser" by highlighting the next line and selecting [Do it] from the context menu:CatalogBrowser open.This browser is also accessible from the World>Tools>Catalog Browser menu (just click the desktop, select Tools, and then Catalog Browser).Catalog projects can also be browsed online: http://catalog.pharo.orgYou can also have a rough list (not very friendly) of many packages available stored in smalltalkhub repository:http://smalltalkhub.com/list(this list is not a compendium of packages for Pharo but is a good place to start if looking for something in particular and is not in the catalog)'! !!WelcomeHelp class methodsFor: 'pages' stamp: 'EstebanLorenzano 5/10/2016 11:29'!welcome	^ HelpTopic 		title: 'Welcome to Pharo 5.0'		contents: 'Pharo 5.0=========Welcome to Pharo, an immersive live programming environment.Pharo is a pure object-oriented programming language and a powerful environment, focused on simplicity and immediate feedback (think IDE and OS rolled into one).For more information, please visite here: http://pharo.org'! !!RubTextAreaExamples class methodsFor: 'examples' stamp: 'EstebanLorenzano 4/19/2016 14:33' prior: 56341649!smalltalkCodeWrappedTo400	"self smalltalkCodeWrappedTo400"	| area |	ModelForShout := self.	area := RubEditingArea new		beWrapped;		model: self;		width: 400;		beForSmalltalkCodeWithDefaultFont;		updateTextWith: self someSmalltalkCode.	area openInWorld.	^ area! !"HelpSystem-Core"!"Pharo-Help"!"ProfStef-Core"!"Rubric"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo50/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader50-TheIntegrator.959.mcz') load.ScriptLoader new update50755.!----End fileIn----!----QUIT----2016-05-11T16:50:04.778482+02:00 Pharo.image priorSource: 78468!----QUIT----2016-05-11T16:50:08.074507+02:00 Pharo.image priorSource: 110002!----QUIT----2016-05-11T16:50:13.413083+02:00 Pharo.image priorSource: 110080!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 5/12/2016 11:59' prior: 33633070!commentForCurrentUpdate ^ '18203 Welcome window does not show content at startup	https://pharo.fogbugz.com/f/cases/1820318204 typo in Explore Pharo Environment chapter	https://pharo.fogbugz.com/f/cases/1820418205 typo in chapter "Learn Pharo Smalltalk"	https://pharo.fogbugz.com/f/cases/18205'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 5/12/2016 11:59'!script50756	^ 'AST-Core-TheIntegrator.418.mczAST-FFI-Pharo50Compatibility-TheIntegrator.2.mczAST-Tests-Core-TheIntegrator.95.mczAlien-eem.32.mczAnnouncements-Core-TheIntegrator.68.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.31.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-NicolaiHess.123.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-EstebanLorenzano.63.mczAthens-Text-NicolaiHess.16.mczBalloon-TheIntegrator.132.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfFileTree-ThierryGoubier.15.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfQualityAssistant-YuriyTymchuk.46.mczBaselineOfRenraku-YuriyTymchuk.5.mczBlueInk-Core-TheIntegrator.24.mczBlueInk-Extras-TheIntegrator.10.mczBlueInk-Tests-TheIntegrator.12.mczChroma-CubeHelix-TheIntegrator.2.mczCodeExport-TheIntegrator.19.mczCodeImport-TheIntegrator.88.mczCodeImportCommandLineHandlers-TheIntegrator.7.mczCollections-Abstract-TheIntegrator.313.mczCollections-Arithmetic-TheIntegrator.20.mczCollections-Atomic-TheIntegrator.16.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.243.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.188.mczCollections-Strings-TheIntegrator.415.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.49.mczCollections-Unordered-TheIntegrator.232.mczCollections-Weak-TheIntegrator.102.mczCompiler-TheIntegrator.602.mczCompression-TheIntegrator.176.mczCompression-Tests-TheIntegrator.2.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.4.mczDebuggerActions-TheIntegrator.85.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.126.mczDeprecated50-TheIntegrator.59.mczEmbeddedFreeType-TheIntegrator.26.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczFFI-Kernel-JanVanDeSandt.40.mczFFI-Pools-eem.3.mczFileSystem-Core-TheIntegrator.202.mczFileSystem-Disk-TheIntegrator.97.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.95.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.417.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-TheIntegrator.17.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.14.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.742.mczFreeType-Tests-TheIntegrator.2.mczFuel-MaxLeske.825.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-TheIntegrator.62.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.411.mczFuelTools-Debugger-TheIntegrator.10.mczGT-BytecodeDebugger-TudorGirba.31.mczGT-Debugger-AndreiChis.350.mczGT-EventRecorder-TheIntegrator.68.mczGT-EventRecorder-Tests-JurajKubelka.37.mczGT-Inspector-AndreiChis.421.mczGT-InspectorExtensions-Core-TheIntegrator.214.mczGT-Playground-DenisKudryashov.124.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-TudorGirba.397.mczGT-Spotter-EventRecorder-GuillermoPolito.112.mczGT-SpotterExtensions-Core-VincentBlondeau.203.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-StefanReichhart.56.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AliakseiSyrel.17.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-TudorGirba.322.mczGlamour-Examples-TudorGirba.303.mczGlamour-FastTable-AndreiChis.59.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-GuillermoPolito.418.mczGlamour-Morphic-Brick-Tests-TheIntegrator.14.mczGlamour-Morphic-Pager-GuillermoPolito.110.mczGlamour-Morphic-Renderer-AndreiChis.349.mczGlamour-Morphic-Theme-HenrikNergaard.222.mczGlamour-Morphic-Widgets-AndreiChis.195.mczGlamour-Presentations-AndreiChis.186.mczGlamour-Rubric-Presentations-AndreiChis.52.mczGlamour-Tests-Core-AndreiChis.111.mczGlamour-Tests-Morphic-TudorGirba.137.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.35.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.6.mczGraphics-Display Objects-TheIntegrator.175.mczGraphics-Files-TheIntegrator.76.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.189.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.80.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.41.mczHelpSystem-Core-TheIntegrator.144.mczHelpSystem-Tests-TheIntegrator.32.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.90.mczImportingResource-Help-TheIntegrator.4.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.28.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2290.mczKernel-Rules-TheIntegrator.2.mczKernel-Tests-TheIntegrator.65.mczKeymapping-Core-TheIntegrator.198.mczKeymapping-KeyCombinations-TheIntegrator.62.mczKeymapping-Pragmas-TheIntegrator.54.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.105.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.166.mczManifest-Core-TheIntegrator.239.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.51.mczMenuRegistration-TheIntegrator.78.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.824.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-EstebanLorenzano.733.mczMetacello-PharoCommonPlatform-TheIntegrator.22.mczMetacello-Platform-EstebanLorenzano.3.mczMetacello-ProfStef-EstebanLorenzano.18.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.7.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform.squeakCommon-EstebanLorenzano.23.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-EstebanLorenzano.148.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1132.mczMonticello-OldDataStreamCompatibility-TheIntegrator.8.mczMonticello-Tests-TheIntegrator.35.mczMonticelloConfigurations-TheIntegrator.72.mczMonticelloFileServices-TheIntegrator.6.mczMonticelloFileTree-Core-TheIntegrator.141.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.30.mczMonticelloGUI-TheIntegrator.415.mczMonticelloMocks-TheIntegrator.4.mczMonticelloRemoteRepositories-TheIntegrator.15.mczMoose-Algos-Graph-vincentBlondeau.31.mczMorphic-Base-TheIntegrator.546.mczMorphic-Core-TheIntegrator.278.mczMorphic-Examples-TheIntegrator.50.mczMorphic-Tests-TheIntegrator.11.mczMorphic-Widgets-Basic-TheIntegrator.86.mczMorphic-Widgets-ColorPicker-TheIntegrator.19.mczMorphic-Widgets-Extra-TheIntegrator.27.mczMorphic-Widgets-FastTable-StephanEggermont.177.mczMorphic-Widgets-List-TheIntegrator.21.mczMorphic-Widgets-NewList-TheIntegrator.9.mczMorphic-Widgets-Pluggable-TheIntegrator.66.mczMorphic-Widgets-PolyTabs-TheIntegrator.2.mczMorphic-Widgets-Scrolling-TheIntegrator.32.mczMorphic-Widgets-Tabs-TheIntegrator.20.mczMorphic-Widgets-Taskbar-TheIntegrator.21.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.50.mczMorphic-Widgets-Windows-TheIntegrator.97.mczMultilingual-Encodings-TheIntegrator.61.mczMultilingual-Languages-TheIntegrator.55.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.81.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.244.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1253.mczNautilus-GroupManager-TheIntegrator.20.mczNautilus-GroupManagerUI-TheIntegrator.31.mczNautilus-Tests-TheIntegrator.37.mczNautilusCommon-TheIntegrator.305.mczNautilusGroupAutoBuilder-TheIntegrator.11.mczNautilusRefactoring-TheIntegrator.272.mczNetwork-Kernel-TheIntegrator.133.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-TheIntegrator.45.mczNetwork-Protocols-TheIntegrator.103.mczNetwork-Tests-TheIntegrator.13.mczNetwork-UUID-TheIntegrator.44.mczNetwork-Url-MarcusDenker.99.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.55.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-RonieSalgado.107.mczOSWindow-SDL2-RonieSalgado.96.mczOSWindow-SDL2-Examples-RonieSalgado.13.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOpalCompiler-Core-TheIntegrator.799.mczOpalCompiler-Tests-TheIntegrator.334.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.23.mczPolymorph-TaskbarIcons-TheIntegrator.46.mczPolymorph-Widgets-TheIntegrator.1338.mczPragmaCollector-TheIntegrator.12.mczProfStef-Core-TheIntegrator.77.mczProfStef-Help-TheIntegrator.16.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.101.mczQualityAssistantRecording-YuriyTymchuk.20.mczRPackage-Core-TheIntegrator.430.mczRPackage-Tests-TheIntegrator.181.mczRandom-Core-TheIntegrator.4.mczRandom-Tests-TheIntegrator.4.mczRecentSubmissions-TheIntegrator.238.mczRefactoring-Changes-TheIntegrator.67.mczRefactoring-Core-TheIntegrator.298.mczRefactoring-Critics-TheIntegrator.261.mczRefactoring-Environment-TheIntegrator.76.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.131.mczRefactoring-Tests-Critics-TheIntegrator.38.mczRefactoring-Tests-Environment-TheIntegrator.23.mczReflectivity-TheIntegrator.297.mczReflectivity-Examples-TheIntegrator.28.mczReflectivity-Tests-TheIntegrator.202.mczReflectivity-Tools-TheIntegrator.24.mczReflectivity-Tools-Tests-TheIntegrator.11.mczRegex-Core-TheIntegrator.38.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.31.mczRenraku-YuriyTymchuk.111.mczRenraku-Test-YuriyTymchuk.19.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.237.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.90.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.364.mczRubric-Rules-YuriyTymchuk.3.mczSTON-Core-PavelKrivanek.73.mczSTON-Tests-SvenVanCaekenberghe.64.mczSUnit-Core-TheIntegrator.169.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.3.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-EstebanLorenzano.138.mczSUnit-UITesting-TheIntegrator.32.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.92.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TommasoDalSasso.3.mczShoreLine-Report-UI-TommasoDalSasso.17.mczShout-TheIntegrator.291.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.742.mczSlot-Tests-TheIntegrator.89.mczSmartSuggestions-TheIntegrator.234.mczSmartSuggestions-Tests-TheIntegrator.33.mczSpec-Core-TheIntegrator.465.mczSpec-Debugger-TheIntegrator.263.mczSpec-Examples-TheIntegrator.108.mczSpec-Help-TheIntegrator.10.mczSpec-Inspector-TheIntegrator.258.mczSpec-Layout-TheIntegrator.69.mczSpec-MorphicAdapters-TheIntegrator.262.mczSpec-PolyWidgets-TheIntegrator.66.mczSpec-Tests-TheIntegrator.63.mczSpec-Tools-TheIntegrator.324.mczStartupPreferences-TheIntegrator.149.mczSystem-Announcements-TheIntegrator.108.mczSystem-BasicCommandLineHandler-TheIntegrator.18.mczSystem-Caching-TheIntegrator.26.mczSystem-CachingTests-TheIntegrator.16.mczSystem-Changes-TheIntegrator.292.mczSystem-Changes-FileServices-TheIntegrator.2.mczSystem-Clipboard-TheIntegrator.40.mczSystem-CommandLine-TheIntegrator.181.mczSystem-CommandLine-TextSupport-TheIntegrator.4.mczSystem-CommandLineHandler-TheIntegrator.18.mczSystem-FileRegistry-TheIntegrator.50.mczSystem-Finalization-TheIntegrator.32.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.106.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.4.mczSystem-OSEnvironments-TheIntegrator.31.mczSystem-Object Events-TheIntegrator.25.mczSystem-Platforms-TheIntegrator.81.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.27.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.337.mczSystem-Settings-Tests-TheIntegrator.11.mczSystem-Sound-StephaneDucasse.18.mczSystem-Sources-TheIntegrator.50.mczSystem-Support-TheIntegrator.1215.mczSystem-SupportTests-TheIntegrator.2.mczSystem-VMEvents-TheIntegrator.17.mczTests-TheIntegrator.755.mczText-Core-TheIntegrator.50.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.114.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.140.mczTool-Catalog-GuillermoPolito.32.mczTool-CriticBrowser-TheIntegrator.21.mczTool-DependencyAnalyser-ChristopheDemarey.28.mczTool-DependencyAnalyser-Test-ChristopheDemarey.11.mczTool-DependencyAnalyser-UI-ChristopheDemarey.43.mczTool-Diff-TheIntegrator.31.mczTool-ExternalBrowser-TheIntegrator.49.mczTool-FileList-TheIntegrator.62.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.65.mczTool-ImageCleaner-TheIntegrator.15.mczTool-ProcessBrowser-TheIntegrator.20.mczTool-Profilers-TheIntegrator.22.mczTool-SystemReporter-TheIntegrator.15.mczTool-Transcript-TheIntegrator.25.mczTool-TxWorkspace-NicolaiHess.7.mczTool-Workspace-TheIntegrator.37.mczTools-TheIntegrator.1525.mczTools-Test-TheIntegrator.16.mczTraits-TheIntegrator.907.mczTranscript-TheIntegrator.50.mczTxText-Athens-GuillermoPolito.53.mczTxText-AthensTests-SeanDeNigris.10.mczTxText-Model-SeanDeNigris.61.mczTxText-Styler-MarcusDenker.17.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.187.mczUnicode-Initialization-TheIntegrator.15.mczUnifiedFFI-EstebanLorenzano.57.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.25.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-VincentBlondeau.32.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-StephaneDucasse.64.mczVersionner-Core-DependenciesModel-ChristopheDemarey.105.mczVersionner-Core-Model-ChristopheDemarey.52.mczVersionner-Spec-Browser-PabloTesone.189.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczZinc-Character-Encoding-Core-TheIntegrator.48.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.27.mczZinc-FileSystem-SvenVanCaekenberghe.12.mczZinc-HTTP-SvenVanCaekenberghe.448.mczZinc-Resource-Meta-Core-TheIntegrator.58.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.36.mczZinc-Tests-SvenVanCaekenberghe.236.mczZinc-Zodiac-TheIntegrator.37.mczZodiac-Core-SvenVanCaekenberghe.42.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.13.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 5/12/2016 11:59'!update50756	"self new update50756"	self withUpdateLog: '18203 Welcome window does not show content at startup	https://pharo.fogbugz.com/f/cases/1820318204 typo in Explore Pharo Environment chapter	https://pharo.fogbugz.com/f/cases/1820418205 typo in chapter "Learn Pharo Smalltalk"	https://pharo.fogbugz.com/f/cases/18205'.	self loadTogether: self script50756 merge: false.	PharoWelcomePage openForRelease.100 timesRepeat: [10 milliSecond wait. World doOneCycle. Processor yield. ].3 timesRepeat: [Smalltalk garbageCollect].	self flushCaches.! !ScriptLoader removeSelector: #update50755!ScriptLoader removeSelector: #script50755!"ScriptLoader50"!!WelcomeHelp class methodsFor: 'pages' stamp: 'PavelKrivanek 5/12/2016 09:39' prior: 33658941!exploreEnvironment	^ HelpTopic 		title: 'Explore Pharo Environment'		contents: 'The best way to learn Pharo is to explore it by your self. This is live objects all the way down: they can be inspected, browsed, changed... everything in the environment you have in your hands.But sometimes it can be hard to getting you started with the tools and capabilities the environment gives you.The most complete and updated guide for the Pharo environment can be found at "Updated Pharo by Example" free book. It is still a work in progress, but most of it is already done. You can find the book here: https://github.com/SquareBracketAssociates/UpdatedPharoByExampleOne particular chapter that is interesting is the one that gives you a quick tour for all the environment: https://ci.inria.fr/pharo-contribution/job/UpdatedPharoByExample/lastSuccessfulBuild/artifact/book-result/PharoTour/PharoTour.pdf '! !!WelcomeHelp class methodsFor: 'pages' stamp: 'PavelKrivanek 5/12/2016 09:44' prior: 33660496!learn	^ HelpTopic 		title: 'Learn Pharo Smalltalk'		contents: 'You can learn Pharo by highlighting the next line and selecting [Do it] from the context menu:ProfStef go.Pharo has also an excellent MOOC (Massive Open Online Course). You can find more information here: http://mooc.pharo.orgThere are also several free Pharo books that can be download here: http://books.pharo.orgA very interesting starting point would be looking into the "Updated Pharo by Example" free book. It is still a work in progress, but most of it is already done. You can find the book here: https://github.com/SquareBracketAssociates/UpdatedPharoByExample'! !"Pharo-Help"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo50/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader50-TheIntegrator.960.mcz') load.ScriptLoader new update50756.!----End fileIn----!----QUIT----2016-05-12T12:01:28.25231+02:00 Pharo.image priorSource: 110159!----QUIT----2016-05-12T12:01:31.348977+02:00 Pharo.image priorSource: 129652!----QUIT----2016-05-12T12:01:36.707369+02:00 Pharo.image priorSource: 129730!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 5/12/2016 15:02' prior: 33664762!commentForCurrentUpdate ^ '18203 Welcome window does not show content at startup	https://pharo.fogbugz.com/f/cases/1820318208 Add changelog to welcome browser	https://pharo.fogbugz.com/f/cases/18208'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 5/12/2016 15:02'!script50757	^ 'AST-Core-TheIntegrator.418.mczAST-FFI-Pharo50Compatibility-TheIntegrator.2.mczAST-Tests-Core-TheIntegrator.95.mczAlien-eem.32.mczAnnouncements-Core-TheIntegrator.68.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.31.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-NicolaiHess.123.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-EstebanLorenzano.63.mczAthens-Text-NicolaiHess.16.mczBalloon-TheIntegrator.132.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfFileTree-ThierryGoubier.15.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfQualityAssistant-YuriyTymchuk.46.mczBaselineOfRenraku-YuriyTymchuk.5.mczBlueInk-Core-TheIntegrator.24.mczBlueInk-Extras-TheIntegrator.10.mczBlueInk-Tests-TheIntegrator.12.mczChroma-CubeHelix-TheIntegrator.2.mczCodeExport-TheIntegrator.19.mczCodeImport-TheIntegrator.88.mczCodeImportCommandLineHandlers-TheIntegrator.7.mczCollections-Abstract-TheIntegrator.313.mczCollections-Arithmetic-TheIntegrator.20.mczCollections-Atomic-TheIntegrator.16.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.243.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.188.mczCollections-Strings-TheIntegrator.415.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.49.mczCollections-Unordered-TheIntegrator.232.mczCollections-Weak-TheIntegrator.102.mczCompiler-TheIntegrator.602.mczCompression-TheIntegrator.176.mczCompression-Tests-TheIntegrator.2.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.4.mczDebuggerActions-TheIntegrator.85.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.126.mczDeprecated50-TheIntegrator.59.mczEmbeddedFreeType-TheIntegrator.26.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczFFI-Kernel-JanVanDeSandt.40.mczFFI-Pools-eem.3.mczFileSystem-Core-TheIntegrator.202.mczFileSystem-Disk-TheIntegrator.97.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.95.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.417.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-TheIntegrator.17.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.14.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.742.mczFreeType-Tests-TheIntegrator.2.mczFuel-MaxLeske.825.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-TheIntegrator.62.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.411.mczFuelTools-Debugger-TheIntegrator.10.mczGT-BytecodeDebugger-TudorGirba.31.mczGT-Debugger-AndreiChis.350.mczGT-EventRecorder-TheIntegrator.68.mczGT-EventRecorder-Tests-JurajKubelka.37.mczGT-Inspector-AndreiChis.421.mczGT-InspectorExtensions-Core-TheIntegrator.214.mczGT-Playground-DenisKudryashov.124.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-TudorGirba.397.mczGT-Spotter-EventRecorder-GuillermoPolito.112.mczGT-SpotterExtensions-Core-VincentBlondeau.203.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-StefanReichhart.56.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AliakseiSyrel.17.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-TudorGirba.322.mczGlamour-Examples-TudorGirba.303.mczGlamour-FastTable-AndreiChis.59.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-GuillermoPolito.418.mczGlamour-Morphic-Brick-Tests-TheIntegrator.14.mczGlamour-Morphic-Pager-GuillermoPolito.110.mczGlamour-Morphic-Renderer-AndreiChis.349.mczGlamour-Morphic-Theme-HenrikNergaard.222.mczGlamour-Morphic-Widgets-AndreiChis.195.mczGlamour-Presentations-AndreiChis.186.mczGlamour-Rubric-Presentations-AndreiChis.52.mczGlamour-Tests-Core-AndreiChis.111.mczGlamour-Tests-Morphic-TudorGirba.137.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.35.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.6.mczGraphics-Display Objects-TheIntegrator.175.mczGraphics-Files-TheIntegrator.76.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.189.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.80.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.41.mczHelpSystem-Core-TheIntegrator.144.mczHelpSystem-Tests-TheIntegrator.32.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.90.mczImportingResource-Help-TheIntegrator.4.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.28.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2290.mczKernel-Rules-TheIntegrator.2.mczKernel-Tests-TheIntegrator.65.mczKeymapping-Core-TheIntegrator.198.mczKeymapping-KeyCombinations-TheIntegrator.62.mczKeymapping-Pragmas-TheIntegrator.54.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.105.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.166.mczManifest-Core-TheIntegrator.239.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.51.mczMenuRegistration-TheIntegrator.78.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.824.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-EstebanLorenzano.733.mczMetacello-PharoCommonPlatform-TheIntegrator.22.mczMetacello-Platform-EstebanLorenzano.3.mczMetacello-ProfStef-EstebanLorenzano.18.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.7.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform.squeakCommon-EstebanLorenzano.23.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-EstebanLorenzano.148.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1132.mczMonticello-OldDataStreamCompatibility-TheIntegrator.8.mczMonticello-Tests-TheIntegrator.35.mczMonticelloConfigurations-TheIntegrator.72.mczMonticelloFileServices-TheIntegrator.6.mczMonticelloFileTree-Core-TheIntegrator.141.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.30.mczMonticelloGUI-TheIntegrator.415.mczMonticelloMocks-TheIntegrator.4.mczMonticelloRemoteRepositories-TheIntegrator.15.mczMoose-Algos-Graph-vincentBlondeau.31.mczMorphic-Base-TheIntegrator.546.mczMorphic-Core-TheIntegrator.278.mczMorphic-Examples-TheIntegrator.50.mczMorphic-Tests-TheIntegrator.11.mczMorphic-Widgets-Basic-TheIntegrator.86.mczMorphic-Widgets-ColorPicker-TheIntegrator.19.mczMorphic-Widgets-Extra-TheIntegrator.27.mczMorphic-Widgets-FastTable-StephanEggermont.177.mczMorphic-Widgets-List-TheIntegrator.21.mczMorphic-Widgets-NewList-TheIntegrator.9.mczMorphic-Widgets-Pluggable-TheIntegrator.66.mczMorphic-Widgets-PolyTabs-TheIntegrator.2.mczMorphic-Widgets-Scrolling-TheIntegrator.32.mczMorphic-Widgets-Tabs-TheIntegrator.20.mczMorphic-Widgets-Taskbar-TheIntegrator.21.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.50.mczMorphic-Widgets-Windows-TheIntegrator.97.mczMultilingual-Encodings-TheIntegrator.61.mczMultilingual-Languages-TheIntegrator.55.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.81.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.244.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1253.mczNautilus-GroupManager-TheIntegrator.20.mczNautilus-GroupManagerUI-TheIntegrator.31.mczNautilus-Tests-TheIntegrator.37.mczNautilusCommon-TheIntegrator.305.mczNautilusGroupAutoBuilder-TheIntegrator.11.mczNautilusRefactoring-TheIntegrator.272.mczNetwork-Kernel-TheIntegrator.133.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-TheIntegrator.45.mczNetwork-Protocols-TheIntegrator.103.mczNetwork-Tests-TheIntegrator.13.mczNetwork-UUID-TheIntegrator.44.mczNetwork-Url-MarcusDenker.99.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.55.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-RonieSalgado.107.mczOSWindow-SDL2-RonieSalgado.96.mczOSWindow-SDL2-Examples-RonieSalgado.13.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOpalCompiler-Core-TheIntegrator.799.mczOpalCompiler-Tests-TheIntegrator.334.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.25.mczPolymorph-TaskbarIcons-TheIntegrator.46.mczPolymorph-Widgets-TheIntegrator.1338.mczPragmaCollector-TheIntegrator.12.mczProfStef-Core-TheIntegrator.77.mczProfStef-Help-TheIntegrator.16.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.101.mczQualityAssistantRecording-YuriyTymchuk.20.mczRPackage-Core-TheIntegrator.430.mczRPackage-Tests-TheIntegrator.181.mczRandom-Core-TheIntegrator.4.mczRandom-Tests-TheIntegrator.4.mczRecentSubmissions-TheIntegrator.238.mczRefactoring-Changes-TheIntegrator.67.mczRefactoring-Core-TheIntegrator.298.mczRefactoring-Critics-TheIntegrator.261.mczRefactoring-Environment-TheIntegrator.76.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.131.mczRefactoring-Tests-Critics-TheIntegrator.38.mczRefactoring-Tests-Environment-TheIntegrator.23.mczReflectivity-TheIntegrator.297.mczReflectivity-Examples-TheIntegrator.28.mczReflectivity-Tests-TheIntegrator.202.mczReflectivity-Tools-TheIntegrator.24.mczReflectivity-Tools-Tests-TheIntegrator.11.mczRegex-Core-TheIntegrator.38.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.31.mczRenraku-YuriyTymchuk.111.mczRenraku-Test-YuriyTymchuk.19.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.237.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.90.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.364.mczRubric-Rules-YuriyTymchuk.3.mczSTON-Core-PavelKrivanek.73.mczSTON-Tests-SvenVanCaekenberghe.64.mczSUnit-Core-TheIntegrator.169.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.3.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-EstebanLorenzano.138.mczSUnit-UITesting-TheIntegrator.32.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.92.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TommasoDalSasso.3.mczShoreLine-Report-UI-TommasoDalSasso.17.mczShout-TheIntegrator.291.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.742.mczSlot-Tests-TheIntegrator.89.mczSmartSuggestions-TheIntegrator.234.mczSmartSuggestions-Tests-TheIntegrator.33.mczSpec-Core-TheIntegrator.465.mczSpec-Debugger-TheIntegrator.263.mczSpec-Examples-TheIntegrator.108.mczSpec-Help-TheIntegrator.10.mczSpec-Inspector-TheIntegrator.258.mczSpec-Layout-TheIntegrator.69.mczSpec-MorphicAdapters-TheIntegrator.262.mczSpec-PolyWidgets-TheIntegrator.66.mczSpec-Tests-TheIntegrator.63.mczSpec-Tools-TheIntegrator.324.mczStartupPreferences-TheIntegrator.149.mczSystem-Announcements-TheIntegrator.108.mczSystem-BasicCommandLineHandler-TheIntegrator.18.mczSystem-Caching-TheIntegrator.26.mczSystem-CachingTests-TheIntegrator.16.mczSystem-Changes-TheIntegrator.292.mczSystem-Changes-FileServices-TheIntegrator.2.mczSystem-Clipboard-TheIntegrator.40.mczSystem-CommandLine-TheIntegrator.181.mczSystem-CommandLine-TextSupport-TheIntegrator.4.mczSystem-CommandLineHandler-TheIntegrator.18.mczSystem-FileRegistry-TheIntegrator.50.mczSystem-Finalization-TheIntegrator.32.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.106.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.4.mczSystem-OSEnvironments-TheIntegrator.31.mczSystem-Object Events-TheIntegrator.25.mczSystem-Platforms-TheIntegrator.81.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.27.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.337.mczSystem-Settings-Tests-TheIntegrator.11.mczSystem-Sound-StephaneDucasse.18.mczSystem-Sources-TheIntegrator.50.mczSystem-Support-TheIntegrator.1215.mczSystem-SupportTests-TheIntegrator.2.mczSystem-VMEvents-TheIntegrator.17.mczTests-TheIntegrator.755.mczText-Core-TheIntegrator.50.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.114.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.140.mczTool-Catalog-GuillermoPolito.32.mczTool-CriticBrowser-TheIntegrator.21.mczTool-DependencyAnalyser-ChristopheDemarey.28.mczTool-DependencyAnalyser-Test-ChristopheDemarey.11.mczTool-DependencyAnalyser-UI-ChristopheDemarey.43.mczTool-Diff-TheIntegrator.31.mczTool-ExternalBrowser-TheIntegrator.49.mczTool-FileList-TheIntegrator.62.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.65.mczTool-ImageCleaner-TheIntegrator.17.mczTool-ProcessBrowser-TheIntegrator.20.mczTool-Profilers-TheIntegrator.22.mczTool-SystemReporter-TheIntegrator.15.mczTool-Transcript-TheIntegrator.25.mczTool-TxWorkspace-NicolaiHess.7.mczTool-Workspace-TheIntegrator.37.mczTools-TheIntegrator.1525.mczTools-Test-TheIntegrator.16.mczTraits-TheIntegrator.907.mczTranscript-TheIntegrator.50.mczTxText-Athens-GuillermoPolito.53.mczTxText-AthensTests-SeanDeNigris.10.mczTxText-Model-SeanDeNigris.61.mczTxText-Styler-MarcusDenker.17.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.187.mczUnicode-Initialization-TheIntegrator.15.mczUnifiedFFI-EstebanLorenzano.57.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.25.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-VincentBlondeau.32.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-StephaneDucasse.64.mczVersionner-Core-DependenciesModel-ChristopheDemarey.105.mczVersionner-Core-Model-ChristopheDemarey.52.mczVersionner-Spec-Browser-PabloTesone.189.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczZinc-Character-Encoding-Core-TheIntegrator.48.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.27.mczZinc-FileSystem-SvenVanCaekenberghe.12.mczZinc-HTTP-SvenVanCaekenberghe.448.mczZinc-Resource-Meta-Core-TheIntegrator.58.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.36.mczZinc-Tests-SvenVanCaekenberghe.236.mczZinc-Zodiac-TheIntegrator.37.mczZodiac-Core-SvenVanCaekenberghe.42.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.13.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 5/12/2016 15:02'!update50757	"self new update50757"	self withUpdateLog: '18203 Welcome window does not show content at startup	https://pharo.fogbugz.com/f/cases/1820318208 Add changelog to welcome browser	https://pharo.fogbugz.com/f/cases/18208'.	self loadTogether: self script50757 merge: false.	PharoWelcomePage openForRelease..	self flushCaches.! !ScriptLoader removeSelector: #update50756!ScriptLoader removeSelector: #script50756!"ScriptLoader50"!!WelcomeHelp class methodsFor: 'pages' stamp: 'EstebanLorenzano 5/12/2016 14:42' prior: 33657971!changeLog	^ HelpTopic 		title: 'ChangeLog'		contents: 'New Stuff in Pharo 5.0----------------------- The PharoVM is now based on Spur, the new memory management, and it brings with it a 35% speedup!!- A new unified foreign function interface (UFFI) replaced NativeBoost to provide a strong Spur-compatible framework for interfacing with the outside world.- The Glamorous Toolkit now includes the GTDebugger to offer a moldable infrastructure that allows the developer to customize the debugger deeply.- The underlying Reflectivity mechanism has reached maturity with multiple pieces coming together to empower developers to instrument their own systems. For example, we now have breakpoints implemented as just a simple extension of this mechanism.- QualityAssistant is now part of the image to provide live feedback during development.All Issues----------Many changes have been made to support the generation of a more modular system. This release integrates  a quite large number of fixes and enhancements: more than 2450!! List is so big that we cannot put it here  (it would have any sense), but you can review all issues at FogBugz issue tracker (https://pharo.fogbugz.com) (you will need an account there, sorry).You can see the Pharo 5.0 changelog at: https://github.com/pharo-project/pharo-changelogs/blob/master/Pharo50ChangeLogs.md'! !!ImageCleaner methodsFor: 'api' stamp: 'EstebanLorenzano 5/12/2016 14:19' prior: 28189911!cleanUpForRelease	"self new cleanUpForRelease"	Author fullName: 'Mr.Cleaner'.	self cleanUpMethods.		FreeTypeFontProvider current initialize.	EmbeddedFreeTypeFontInstaller initialize.	#MetacelloProjectRegistration asClassIfPresent: [ :class | class resetRegistry ].	SystemNavigation new		allObjectsDo: [ :each | 			((each respondsTo: #releaseCachedState) and: [ (each isKindOf: RubAbstractTextArea) not ])				ifTrue: [ each releaseCachedState ] ].		self removeEmptyCategories.	self removeEmptyPackages.	Smalltalk organization sortCategories.	Smalltalk garbageCollect.	Smalltalk cleanOutUndeclared. 	Smalltalk fixObsoleteReferences.	Smalltalk cleanUp: true except: #() confirming: false.		Author reset! !"Pharo-Help"!"Tool-ImageCleaner"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo50/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader50-TheIntegrator.961.mcz') load.ScriptLoader new update50757.!----End fileIn----!----QUIT----2016-05-12T15:04:01.115517+02:00 Pharo.image priorSource: 129809!----QUIT----2016-05-12T15:04:04.55159+02:00 Pharo.image priorSource: 149536!----QUIT----2016-05-12T15:04:09.715449+02:00 Pharo.image priorSource: 149615!----QUIT----2016-05-14T14:56:45.122151+02:00 Pharo.image priorSource: 149693!----QUIT----2016-05-14T14:56:47.970827+02:00 Pharo.image priorSource: 149772!----QUIT----2016-05-14T14:56:52.955784+02:00 Pharo.image priorSource: 149851!----QUIT----2016-05-25T13:37:54.884983+02:00 Pharo.image priorSource: 149930!----QUIT----2016-05-25T13:37:57.748359+02:00 Pharo.image priorSource: 150009!----QUIT----2016-05-25T13:38:03.199623+02:00 Pharo.image priorSource: 150088!!ScriptLoader methodsFor: 'public' stamp: 'EstebanLorenzano 5/25/2016 14:07' prior: 33684412!commentForCurrentUpdate ^ '18284 SmallFloat64 identityHash is answering bad value	https://pharo.fogbugz.com/f/cases/18284'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'EstebanLorenzano 5/25/2016 14:07'!script50758	^ 'AST-Core-TheIntegrator.418.mczAST-FFI-Pharo50Compatibility-TheIntegrator.2.mczAST-Tests-Core-TheIntegrator.95.mczAlien-eem.32.mczAnnouncements-Core-TheIntegrator.68.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.31.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-NicolaiHess.123.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-EstebanLorenzano.63.mczAthens-Text-NicolaiHess.16.mczBalloon-TheIntegrator.132.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfFileTree-ThierryGoubier.15.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfQualityAssistant-YuriyTymchuk.46.mczBaselineOfRenraku-YuriyTymchuk.5.mczBlueInk-Core-TheIntegrator.24.mczBlueInk-Extras-TheIntegrator.10.mczBlueInk-Tests-TheIntegrator.12.mczChroma-CubeHelix-TheIntegrator.2.mczCodeExport-TheIntegrator.19.mczCodeImport-TheIntegrator.88.mczCodeImportCommandLineHandlers-TheIntegrator.7.mczCollections-Abstract-TheIntegrator.313.mczCollections-Arithmetic-TheIntegrator.20.mczCollections-Atomic-TheIntegrator.16.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.243.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.188.mczCollections-Strings-TheIntegrator.415.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.49.mczCollections-Unordered-TheIntegrator.232.mczCollections-Weak-TheIntegrator.102.mczCompiler-TheIntegrator.602.mczCompression-TheIntegrator.176.mczCompression-Tests-TheIntegrator.2.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.4.mczDebuggerActions-TheIntegrator.85.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.126.mczDeprecated50-TheIntegrator.59.mczEmbeddedFreeType-TheIntegrator.26.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczFFI-Kernel-JanVanDeSandt.40.mczFFI-Pools-eem.3.mczFileSystem-Core-TheIntegrator.202.mczFileSystem-Disk-TheIntegrator.97.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.95.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.417.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-TheIntegrator.17.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.14.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.742.mczFreeType-Tests-TheIntegrator.2.mczFuel-MaxLeske.825.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-TheIntegrator.62.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.411.mczFuelTools-Debugger-TheIntegrator.10.mczGT-BytecodeDebugger-TudorGirba.31.mczGT-Debugger-AndreiChis.350.mczGT-EventRecorder-TheIntegrator.68.mczGT-EventRecorder-Tests-JurajKubelka.37.mczGT-Inspector-AndreiChis.421.mczGT-InspectorExtensions-Core-TheIntegrator.214.mczGT-Playground-DenisKudryashov.124.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-TudorGirba.397.mczGT-Spotter-EventRecorder-GuillermoPolito.112.mczGT-SpotterExtensions-Core-VincentBlondeau.203.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-StefanReichhart.56.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AliakseiSyrel.17.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-TudorGirba.322.mczGlamour-Examples-TudorGirba.303.mczGlamour-FastTable-AndreiChis.59.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-GuillermoPolito.418.mczGlamour-Morphic-Brick-Tests-TheIntegrator.14.mczGlamour-Morphic-Pager-GuillermoPolito.110.mczGlamour-Morphic-Renderer-AndreiChis.349.mczGlamour-Morphic-Theme-HenrikNergaard.222.mczGlamour-Morphic-Widgets-AndreiChis.195.mczGlamour-Presentations-AndreiChis.186.mczGlamour-Rubric-Presentations-AndreiChis.52.mczGlamour-Tests-Core-AndreiChis.111.mczGlamour-Tests-Morphic-TudorGirba.137.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.35.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.6.mczGraphics-Display Objects-TheIntegrator.175.mczGraphics-Files-TheIntegrator.76.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.189.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.80.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.41.mczHelpSystem-Core-TheIntegrator.144.mczHelpSystem-Tests-TheIntegrator.32.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.90.mczImportingResource-Help-TheIntegrator.4.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.28.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2290.mczKernel-Rules-TheIntegrator.2.mczKernel-Tests-TheIntegrator.65.mczKeymapping-Core-TheIntegrator.198.mczKeymapping-KeyCombinations-TheIntegrator.62.mczKeymapping-Pragmas-TheIntegrator.54.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.105.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.166.mczManifest-Core-TheIntegrator.239.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.51.mczMenuRegistration-TheIntegrator.78.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.824.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-EstebanLorenzano.733.mczMetacello-PharoCommonPlatform-TheIntegrator.22.mczMetacello-Platform-EstebanLorenzano.3.mczMetacello-ProfStef-EstebanLorenzano.18.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.7.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform.squeakCommon-EstebanLorenzano.23.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-EstebanLorenzano.148.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1132.mczMonticello-OldDataStreamCompatibility-TheIntegrator.8.mczMonticello-Tests-TheIntegrator.35.mczMonticelloConfigurations-TheIntegrator.72.mczMonticelloFileServices-TheIntegrator.6.mczMonticelloFileTree-Core-TheIntegrator.141.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.30.mczMonticelloGUI-TheIntegrator.415.mczMonticelloMocks-TheIntegrator.4.mczMonticelloRemoteRepositories-TheIntegrator.15.mczMoose-Algos-Graph-vincentBlondeau.31.mczMorphic-Base-TheIntegrator.546.mczMorphic-Core-TheIntegrator.278.mczMorphic-Examples-TheIntegrator.50.mczMorphic-Tests-TheIntegrator.11.mczMorphic-Widgets-Basic-TheIntegrator.86.mczMorphic-Widgets-ColorPicker-TheIntegrator.19.mczMorphic-Widgets-Extra-TheIntegrator.27.mczMorphic-Widgets-FastTable-StephanEggermont.177.mczMorphic-Widgets-List-TheIntegrator.21.mczMorphic-Widgets-NewList-TheIntegrator.9.mczMorphic-Widgets-Pluggable-TheIntegrator.66.mczMorphic-Widgets-PolyTabs-TheIntegrator.2.mczMorphic-Widgets-Scrolling-TheIntegrator.32.mczMorphic-Widgets-Tabs-TheIntegrator.20.mczMorphic-Widgets-Taskbar-TheIntegrator.21.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.50.mczMorphic-Widgets-Windows-TheIntegrator.97.mczMultilingual-Encodings-TheIntegrator.61.mczMultilingual-Languages-TheIntegrator.55.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.81.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.244.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1253.mczNautilus-GroupManager-TheIntegrator.20.mczNautilus-GroupManagerUI-TheIntegrator.31.mczNautilus-Tests-TheIntegrator.37.mczNautilusCommon-TheIntegrator.305.mczNautilusGroupAutoBuilder-TheIntegrator.11.mczNautilusRefactoring-TheIntegrator.272.mczNetwork-Kernel-TheIntegrator.133.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-TheIntegrator.45.mczNetwork-Protocols-TheIntegrator.103.mczNetwork-Tests-TheIntegrator.13.mczNetwork-UUID-TheIntegrator.44.mczNetwork-Url-MarcusDenker.99.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.55.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-RonieSalgado.107.mczOSWindow-SDL2-RonieSalgado.96.mczOSWindow-SDL2-Examples-RonieSalgado.13.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOpalCompiler-Core-TheIntegrator.799.mczOpalCompiler-Tests-TheIntegrator.334.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.25.mczPolymorph-TaskbarIcons-TheIntegrator.46.mczPolymorph-Widgets-TheIntegrator.1338.mczPragmaCollector-TheIntegrator.12.mczProfStef-Core-TheIntegrator.77.mczProfStef-Help-TheIntegrator.16.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.101.mczQualityAssistantRecording-YuriyTymchuk.20.mczRPackage-Core-TheIntegrator.430.mczRPackage-Tests-TheIntegrator.181.mczRandom-Core-TheIntegrator.4.mczRandom-Tests-TheIntegrator.4.mczRecentSubmissions-TheIntegrator.238.mczRefactoring-Changes-TheIntegrator.67.mczRefactoring-Core-TheIntegrator.298.mczRefactoring-Critics-TheIntegrator.261.mczRefactoring-Environment-TheIntegrator.76.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.131.mczRefactoring-Tests-Critics-TheIntegrator.38.mczRefactoring-Tests-Environment-TheIntegrator.23.mczReflectivity-TheIntegrator.297.mczReflectivity-Examples-TheIntegrator.28.mczReflectivity-Tests-TheIntegrator.202.mczReflectivity-Tools-TheIntegrator.24.mczReflectivity-Tools-Tests-TheIntegrator.11.mczRegex-Core-TheIntegrator.38.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.31.mczRenraku-YuriyTymchuk.111.mczRenraku-Test-YuriyTymchuk.19.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.237.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.90.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.364.mczRubric-Rules-YuriyTymchuk.3.mczSTON-Core-PavelKrivanek.73.mczSTON-Tests-SvenVanCaekenberghe.64.mczSUnit-Core-TheIntegrator.169.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.3.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-EstebanLorenzano.138.mczSUnit-UITesting-TheIntegrator.32.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.92.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TommasoDalSasso.3.mczShoreLine-Report-UI-TommasoDalSasso.17.mczShout-TheIntegrator.291.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.742.mczSlot-Tests-TheIntegrator.89.mczSmartSuggestions-TheIntegrator.234.mczSmartSuggestions-Tests-TheIntegrator.33.mczSpec-Core-TheIntegrator.465.mczSpec-Debugger-TheIntegrator.263.mczSpec-Examples-TheIntegrator.108.mczSpec-Help-TheIntegrator.10.mczSpec-Inspector-TheIntegrator.258.mczSpec-Layout-TheIntegrator.69.mczSpec-MorphicAdapters-TheIntegrator.262.mczSpec-PolyWidgets-TheIntegrator.66.mczSpec-Tests-TheIntegrator.63.mczSpec-Tools-TheIntegrator.324.mczStartupPreferences-TheIntegrator.149.mczSystem-Announcements-TheIntegrator.108.mczSystem-BasicCommandLineHandler-TheIntegrator.18.mczSystem-Caching-TheIntegrator.26.mczSystem-CachingTests-TheIntegrator.16.mczSystem-Changes-TheIntegrator.292.mczSystem-Changes-FileServices-TheIntegrator.2.mczSystem-Clipboard-TheIntegrator.40.mczSystem-CommandLine-TheIntegrator.181.mczSystem-CommandLine-TextSupport-TheIntegrator.4.mczSystem-CommandLineHandler-TheIntegrator.18.mczSystem-FileRegistry-TheIntegrator.50.mczSystem-Finalization-TheIntegrator.32.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.106.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.4.mczSystem-OSEnvironments-TheIntegrator.31.mczSystem-Object Events-TheIntegrator.25.mczSystem-Platforms-TheIntegrator.81.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.27.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.337.mczSystem-Settings-Tests-TheIntegrator.11.mczSystem-Sound-StephaneDucasse.18.mczSystem-Sources-TheIntegrator.50.mczSystem-Support-TheIntegrator.1215.mczSystem-SupportTests-TheIntegrator.2.mczSystem-VMEvents-TheIntegrator.17.mczTests-TheIntegrator.755.mczText-Core-TheIntegrator.50.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.114.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.140.mczTool-Catalog-GuillermoPolito.32.mczTool-CriticBrowser-TheIntegrator.21.mczTool-DependencyAnalyser-ChristopheDemarey.28.mczTool-DependencyAnalyser-Test-ChristopheDemarey.11.mczTool-DependencyAnalyser-UI-ChristopheDemarey.43.mczTool-Diff-TheIntegrator.31.mczTool-ExternalBrowser-TheIntegrator.49.mczTool-FileList-TheIntegrator.62.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.65.mczTool-ImageCleaner-TheIntegrator.17.mczTool-ProcessBrowser-TheIntegrator.20.mczTool-Profilers-TheIntegrator.22.mczTool-SystemReporter-TheIntegrator.15.mczTool-Transcript-TheIntegrator.25.mczTool-TxWorkspace-NicolaiHess.7.mczTool-Workspace-TheIntegrator.37.mczTools-TheIntegrator.1525.mczTools-Test-TheIntegrator.16.mczTraits-TheIntegrator.907.mczTranscript-TheIntegrator.50.mczTxText-Athens-GuillermoPolito.53.mczTxText-AthensTests-SeanDeNigris.10.mczTxText-Model-SeanDeNigris.61.mczTxText-Styler-MarcusDenker.17.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.187.mczUnicode-Initialization-TheIntegrator.15.mczUnifiedFFI-EstebanLorenzano.57.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.25.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-VincentBlondeau.32.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-StephaneDucasse.64.mczVersionner-Core-DependenciesModel-ChristopheDemarey.105.mczVersionner-Core-Model-ChristopheDemarey.52.mczVersionner-Spec-Browser-PabloTesone.189.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczZinc-Character-Encoding-Core-TheIntegrator.48.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.27.mczZinc-FileSystem-SvenVanCaekenberghe.12.mczZinc-HTTP-SvenVanCaekenberghe.448.mczZinc-Resource-Meta-Core-TheIntegrator.58.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.36.mczZinc-Tests-SvenVanCaekenberghe.236.mczZinc-Zodiac-TheIntegrator.37.mczZodiac-Core-SvenVanCaekenberghe.42.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.13.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'EstebanLorenzano 5/25/2016 14:07'!update50758	"self new update50758"	self withUpdateLog: '18284 SmallFloat64 identityHash is answering bad value	https://pharo.fogbugz.com/f/cases/18284'.	self loadTogether: self script50758 merge: false.	SmallFloat64 tryPrimitive: 161 withArgs: #(4 true).HashedCollection rehashAll.	self flushCaches.self cleanRepositories.! !ScriptLoader removeSelector: #update50757!ScriptLoader removeSelector: #script50757!"ScriptLoader50"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo50/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader50-EstebanLorenzano.964.mcz') load.ScriptLoader new update50758.!----End fileIn----!----QUIT----2016-05-25T14:11:52.008264+02:00 Pharo.image priorSource: 150167!----QUIT----2016-05-25T14:11:54.948107+02:00 Pharo.image priorSource: 167499!----QUIT----2016-05-25T14:11:59.831777+02:00 Pharo.image priorSource: 167578!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 5/25/2016 15:02' prior: 33704773!commentForCurrentUpdate ^ '18212 PharoTutorial class missing	https://pharo.fogbugz.com/f/cases/1821218259 Error in Spec MorphicTextAdapter	https://pharo.fogbugz.com/f/cases/18259'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 5/25/2016 15:02'!script50759	^ 'AST-Core-TheIntegrator.418.mczAST-FFI-Pharo50Compatibility-TheIntegrator.2.mczAST-Tests-Core-TheIntegrator.95.mczAlien-eem.32.mczAnnouncements-Core-TheIntegrator.68.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.31.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-NicolaiHess.123.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-EstebanLorenzano.63.mczAthens-Text-NicolaiHess.16.mczBalloon-TheIntegrator.132.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfFileTree-ThierryGoubier.15.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfQualityAssistant-YuriyTymchuk.46.mczBaselineOfRenraku-YuriyTymchuk.5.mczBlueInk-Core-TheIntegrator.24.mczBlueInk-Extras-TheIntegrator.10.mczBlueInk-Tests-TheIntegrator.12.mczChroma-CubeHelix-TheIntegrator.2.mczCodeExport-TheIntegrator.19.mczCodeImport-TheIntegrator.88.mczCodeImportCommandLineHandlers-TheIntegrator.7.mczCollections-Abstract-TheIntegrator.313.mczCollections-Arithmetic-TheIntegrator.20.mczCollections-Atomic-TheIntegrator.16.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.243.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.188.mczCollections-Strings-TheIntegrator.415.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.49.mczCollections-Unordered-TheIntegrator.232.mczCollections-Weak-TheIntegrator.102.mczCompiler-TheIntegrator.602.mczCompression-TheIntegrator.176.mczCompression-Tests-TheIntegrator.2.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.4.mczDebuggerActions-TheIntegrator.85.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.126.mczDeprecated50-TheIntegrator.59.mczEmbeddedFreeType-TheIntegrator.26.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczFFI-Kernel-JanVanDeSandt.40.mczFFI-Pools-eem.3.mczFileSystem-Core-TheIntegrator.202.mczFileSystem-Disk-TheIntegrator.97.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.95.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.417.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-TheIntegrator.17.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.14.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.742.mczFreeType-Tests-TheIntegrator.2.mczFuel-MaxLeske.825.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-TheIntegrator.62.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.411.mczFuelTools-Debugger-TheIntegrator.10.mczGT-BytecodeDebugger-TudorGirba.31.mczGT-Debugger-AndreiChis.350.mczGT-EventRecorder-TheIntegrator.68.mczGT-EventRecorder-Tests-JurajKubelka.37.mczGT-Inspector-AndreiChis.421.mczGT-InspectorExtensions-Core-TheIntegrator.214.mczGT-Playground-DenisKudryashov.124.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-TudorGirba.397.mczGT-Spotter-EventRecorder-GuillermoPolito.112.mczGT-SpotterExtensions-Core-VincentBlondeau.203.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-StefanReichhart.56.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AliakseiSyrel.17.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-TudorGirba.322.mczGlamour-Examples-TudorGirba.303.mczGlamour-FastTable-AndreiChis.59.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-GuillermoPolito.418.mczGlamour-Morphic-Brick-Tests-TheIntegrator.14.mczGlamour-Morphic-Pager-GuillermoPolito.110.mczGlamour-Morphic-Renderer-AndreiChis.349.mczGlamour-Morphic-Theme-HenrikNergaard.222.mczGlamour-Morphic-Widgets-AndreiChis.195.mczGlamour-Presentations-AndreiChis.186.mczGlamour-Rubric-Presentations-AndreiChis.52.mczGlamour-Tests-Core-AndreiChis.111.mczGlamour-Tests-Morphic-TudorGirba.137.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.35.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.6.mczGraphics-Display Objects-TheIntegrator.175.mczGraphics-Files-TheIntegrator.76.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.189.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.80.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.41.mczHelpSystem-Core-TheIntegrator.144.mczHelpSystem-Tests-TheIntegrator.32.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.90.mczImportingResource-Help-TheIntegrator.4.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.28.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2290.mczKernel-Rules-TheIntegrator.2.mczKernel-Tests-TheIntegrator.65.mczKeymapping-Core-TheIntegrator.198.mczKeymapping-KeyCombinations-TheIntegrator.62.mczKeymapping-Pragmas-TheIntegrator.54.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.105.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.166.mczManifest-Core-TheIntegrator.239.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.51.mczMenuRegistration-TheIntegrator.78.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.824.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-EstebanLorenzano.733.mczMetacello-PharoCommonPlatform-TheIntegrator.22.mczMetacello-Platform-EstebanLorenzano.3.mczMetacello-ProfStef-EstebanLorenzano.18.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.7.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform.squeakCommon-EstebanLorenzano.23.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-EstebanLorenzano.148.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1132.mczMonticello-OldDataStreamCompatibility-TheIntegrator.8.mczMonticello-Tests-TheIntegrator.35.mczMonticelloConfigurations-TheIntegrator.72.mczMonticelloFileServices-TheIntegrator.6.mczMonticelloFileTree-Core-TheIntegrator.141.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.30.mczMonticelloGUI-TheIntegrator.415.mczMonticelloMocks-TheIntegrator.4.mczMonticelloRemoteRepositories-TheIntegrator.15.mczMoose-Algos-Graph-vincentBlondeau.31.mczMorphic-Base-TheIntegrator.546.mczMorphic-Core-TheIntegrator.278.mczMorphic-Examples-TheIntegrator.50.mczMorphic-Tests-TheIntegrator.11.mczMorphic-Widgets-Basic-TheIntegrator.86.mczMorphic-Widgets-ColorPicker-TheIntegrator.19.mczMorphic-Widgets-Extra-TheIntegrator.27.mczMorphic-Widgets-FastTable-StephanEggermont.177.mczMorphic-Widgets-List-TheIntegrator.21.mczMorphic-Widgets-NewList-TheIntegrator.9.mczMorphic-Widgets-Pluggable-TheIntegrator.66.mczMorphic-Widgets-PolyTabs-TheIntegrator.2.mczMorphic-Widgets-Scrolling-TheIntegrator.32.mczMorphic-Widgets-Tabs-TheIntegrator.20.mczMorphic-Widgets-Taskbar-TheIntegrator.21.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.50.mczMorphic-Widgets-Windows-TheIntegrator.97.mczMultilingual-Encodings-TheIntegrator.61.mczMultilingual-Languages-TheIntegrator.55.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.81.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.244.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1253.mczNautilus-GroupManager-TheIntegrator.20.mczNautilus-GroupManagerUI-TheIntegrator.31.mczNautilus-Tests-TheIntegrator.37.mczNautilusCommon-TheIntegrator.305.mczNautilusGroupAutoBuilder-TheIntegrator.11.mczNautilusRefactoring-TheIntegrator.272.mczNetwork-Kernel-TheIntegrator.133.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-TheIntegrator.45.mczNetwork-Protocols-TheIntegrator.103.mczNetwork-Tests-TheIntegrator.13.mczNetwork-UUID-TheIntegrator.44.mczNetwork-Url-MarcusDenker.99.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.55.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-RonieSalgado.107.mczOSWindow-SDL2-RonieSalgado.96.mczOSWindow-SDL2-Examples-RonieSalgado.13.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOpalCompiler-Core-TheIntegrator.799.mczOpalCompiler-Tests-TheIntegrator.334.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.28.mczPolymorph-TaskbarIcons-TheIntegrator.46.mczPolymorph-Widgets-TheIntegrator.1338.mczPragmaCollector-TheIntegrator.12.mczProfStef-Core-TheIntegrator.77.mczProfStef-Help-TheIntegrator.16.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.101.mczQualityAssistantRecording-YuriyTymchuk.20.mczRPackage-Core-TheIntegrator.430.mczRPackage-Tests-TheIntegrator.181.mczRandom-Core-TheIntegrator.4.mczRandom-Tests-TheIntegrator.4.mczRecentSubmissions-TheIntegrator.238.mczRefactoring-Changes-TheIntegrator.67.mczRefactoring-Core-TheIntegrator.298.mczRefactoring-Critics-TheIntegrator.261.mczRefactoring-Environment-TheIntegrator.76.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.131.mczRefactoring-Tests-Critics-TheIntegrator.38.mczRefactoring-Tests-Environment-TheIntegrator.23.mczReflectivity-TheIntegrator.297.mczReflectivity-Examples-TheIntegrator.28.mczReflectivity-Tests-TheIntegrator.202.mczReflectivity-Tools-TheIntegrator.24.mczReflectivity-Tools-Tests-TheIntegrator.11.mczRegex-Core-TheIntegrator.38.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.31.mczRenraku-YuriyTymchuk.111.mczRenraku-Test-YuriyTymchuk.19.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.237.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.90.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.364.mczRubric-Rules-YuriyTymchuk.3.mczSTON-Core-PavelKrivanek.73.mczSTON-Tests-SvenVanCaekenberghe.64.mczSUnit-Core-TheIntegrator.169.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.3.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-EstebanLorenzano.138.mczSUnit-UITesting-TheIntegrator.32.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.92.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TommasoDalSasso.3.mczShoreLine-Report-UI-TommasoDalSasso.17.mczShout-TheIntegrator.291.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.742.mczSlot-Tests-TheIntegrator.89.mczSmartSuggestions-TheIntegrator.234.mczSmartSuggestions-Tests-TheIntegrator.33.mczSpec-Core-TheIntegrator.465.mczSpec-Debugger-TheIntegrator.263.mczSpec-Examples-TheIntegrator.108.mczSpec-Help-TheIntegrator.10.mczSpec-Inspector-TheIntegrator.258.mczSpec-Layout-TheIntegrator.69.mczSpec-MorphicAdapters-TheIntegrator.266.mczSpec-PolyWidgets-TheIntegrator.66.mczSpec-Tests-TheIntegrator.63.mczSpec-Tools-TheIntegrator.324.mczStartupPreferences-TheIntegrator.149.mczSystem-Announcements-TheIntegrator.108.mczSystem-BasicCommandLineHandler-TheIntegrator.18.mczSystem-Caching-TheIntegrator.26.mczSystem-CachingTests-TheIntegrator.16.mczSystem-Changes-TheIntegrator.292.mczSystem-Changes-FileServices-TheIntegrator.2.mczSystem-Clipboard-TheIntegrator.40.mczSystem-CommandLine-TheIntegrator.181.mczSystem-CommandLine-TextSupport-TheIntegrator.4.mczSystem-CommandLineHandler-TheIntegrator.18.mczSystem-FileRegistry-TheIntegrator.50.mczSystem-Finalization-TheIntegrator.32.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.106.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.4.mczSystem-OSEnvironments-TheIntegrator.31.mczSystem-Object Events-TheIntegrator.25.mczSystem-Platforms-TheIntegrator.81.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.27.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.337.mczSystem-Settings-Tests-TheIntegrator.11.mczSystem-Sound-StephaneDucasse.18.mczSystem-Sources-TheIntegrator.50.mczSystem-Support-TheIntegrator.1215.mczSystem-SupportTests-TheIntegrator.2.mczSystem-VMEvents-TheIntegrator.17.mczTests-TheIntegrator.755.mczText-Core-TheIntegrator.50.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.114.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.140.mczTool-Catalog-GuillermoPolito.32.mczTool-CriticBrowser-TheIntegrator.21.mczTool-DependencyAnalyser-ChristopheDemarey.28.mczTool-DependencyAnalyser-Test-ChristopheDemarey.11.mczTool-DependencyAnalyser-UI-ChristopheDemarey.43.mczTool-Diff-TheIntegrator.31.mczTool-ExternalBrowser-TheIntegrator.49.mczTool-FileList-TheIntegrator.62.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.65.mczTool-ImageCleaner-TheIntegrator.17.mczTool-ProcessBrowser-TheIntegrator.20.mczTool-Profilers-TheIntegrator.22.mczTool-SystemReporter-TheIntegrator.15.mczTool-Transcript-TheIntegrator.25.mczTool-TxWorkspace-NicolaiHess.7.mczTool-Workspace-TheIntegrator.37.mczTools-TheIntegrator.1525.mczTools-Test-TheIntegrator.16.mczTraits-TheIntegrator.907.mczTranscript-TheIntegrator.50.mczTxText-Athens-GuillermoPolito.53.mczTxText-AthensTests-SeanDeNigris.10.mczTxText-Model-SeanDeNigris.61.mczTxText-Styler-MarcusDenker.17.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.187.mczUnicode-Initialization-TheIntegrator.15.mczUnifiedFFI-EstebanLorenzano.57.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.25.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-VincentBlondeau.32.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-StephaneDucasse.64.mczVersionner-Core-DependenciesModel-ChristopheDemarey.105.mczVersionner-Core-Model-ChristopheDemarey.52.mczVersionner-Spec-Browser-PabloTesone.189.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczZinc-Character-Encoding-Core-TheIntegrator.48.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.27.mczZinc-FileSystem-SvenVanCaekenberghe.12.mczZinc-HTTP-SvenVanCaekenberghe.448.mczZinc-Resource-Meta-Core-TheIntegrator.58.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.36.mczZinc-Tests-SvenVanCaekenberghe.236.mczZinc-Zodiac-TheIntegrator.37.mczZodiac-Core-SvenVanCaekenberghe.42.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.13.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 5/25/2016 15:02'!update50759	"self new update50759"	self withUpdateLog: '18212 PharoTutorial class missing	https://pharo.fogbugz.com/f/cases/1821218259 Error in Spec MorphicTextAdapter	https://pharo.fogbugz.com/f/cases/18259'.	self loadTogether: self script50759 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update50758!ScriptLoader removeSelector: #script50758!"ScriptLoader50"!!PharoEnvironmentHelp commentStamp: 'CyrilFerlicot 5/24/2016 20:50' prior: 52705640!This is introductory help for the Pharo environment and tools. !! Keyboard ShortcutsPharo has a variety of useful keyboard shortcuts that help you navigate its environment without always using a mouse.!!!! Browser ShortcutsThere are many keyboard shortcuts available in Pharo:- A full list is available in the System Browser by clicking the window menu button (the triangle) at the top right of the browser title, and selecting the 'Shortcuts Description' menu item.  Alternatively you can evaluate (cmd-d) the following code now:KMDescription new categories: #(NautilusGlobalShortcuts); openWithSpec.- Shortcuts are typically multi-key combinations, where you hold a modifier key and press the listed secondary key. For example if something is listed as CMD-F, CMD-C you would press and hold the CMD key while typing  F and then C- The modifier key varies between platforms: - Windows = ALT - Mac/OSX = CMD - Linux = CTRL!!!! Spotter/Global searchSimilar to the Spotlight search on OSX, or the Windows Search charm - Pharo has a global code search tool that is activated using:  Shift+EnterThis search tool shows a popup window on the center of the screen where you can incrementally search for classes, packages, symbols,  pragmas, files, folders and many other types of data.  As you type a search query  all available searches are performed at the same time and results are displayed as they are discovered and grouped based on the type of the search.You can cursor/keyboard navigate through the results, or press enter to spawn a new tool to examine the selected result.The following shortcuts are available:	Ctrl+Arrow_right dives in and restricts the available types of searches only to the selected element.	Ctrl+Shift+Arrow_right dives in and shows all the rearch results from a category.	Ctrl+Arrow_left dives out to the previous search	Ctrl+p toggles the preview pane	Enter  spawns a new tool to examine the selected result	Ctrl+Shift+Arrow_down/Ctrl+Shift+Arrow_down navigatew through different types of searches	Shift highlights all butons from the UI (only works with newer VMs)!!!! Visual ExplorationA useful way of discovering how things work in Pharo, is to point your mouse cursor at something on the screen (e.g. a browser button) and invoke a visual Halo selection by pressing:   Alt+Shift + left mouse clickIf you continue clicking the left mouse button (while holding Alt+Shift), the halo will expand it's selection to the current item's parent. This is useful for traversing the lineage of graphical Morph's to see what contains what.The halo has a series of icons, which if you hover over them will give you some balloon help about their operation. For exploring, the spanner icon is useful for letting you inspect or browse the current item to locate where the actual code is implemented.To remove the halo,  simply click anywhere outside of the current halo.It is possible to directly explore a visual object and bypass using the halo mechanism by pressing:  Ctrl+Shift + left mouse clickThis will give you a menu for the current item with options to inspect, debug etc.!! Browsing and Navigating CodeFinding and navigating through code in Pharo is an important part of developing programs in Smalltalk.!!!! System Browser (Nautilus)The System Browser (available in the desktop World menu), is the primary way of viewing your source code. This browser framework has been rewritten in Pharo and is often referred to as Nautilus (see the other top level help item for more technical details)!!!!!! Showing HierarchiesNautilus defaults to a simple 'Flat' display of the list of classes that are in the currently selected package (far left). If you want to see the hierarchy of a particular class, first select it and then press (toggle) the 'Flat' button, to show show its 'Hierarchy'. Pressing this button again will toggle back to the 'Flat' model.!!!!!! Browser HistoryThe browser records the history of methods and classes you have visited similar to a Web Browser. The dropdown list in the middle right of the panes (above the lower text pane) shows this history, and clicking on one of its items will navigate to that item. This is convenient if you have clicked on a different package, or navigated to superclass and want to return back to where you were. !!!!!! CustomisingThe system browser can also be configured with a different title as well as optional plugins. These are all available in the window dropdown menu in the top right of the title bar (normally a small triangle).!!!! SpotterUse the Shift+Enter global keystroke to activate a popup window that lets you incrementally search for methods, classes, packages, pragmas, files, folders and many other types of data.!!!! Finder The code Finder browswer is available from the World | Tools menu. The Finder lets you enter some general text in top edit field and then categorize it as either text, or language construct in the dropdown list to refine your search. There are more detailed instructions in the bottom pane of the browser detailing the different options.!!!! WorkspaceIn any workspace you can type or select any text and then perform an 'code search' (context menu item) that will look for matching senders, implementors, references or method source.!! IconsThere are many icons that are visible in the envionment, each with different meanings.!!!! GeneralAn orange smudge in the top right of any editable text field indicatest that the field has been modified and should be saved with CMD+S.!!!! Class PaneIn the System Browser class pane, you will see the following icons appear next to specific types of class objects:- Red exclamation mark: a missing class comment. The pharo team reccommend that all classes should describe their intent with a comment. - Gray dot: a TestCase - Yellow Lightening bolt: an Exception - 3 Coloured Balls: a Collection - Blue Speech bubble: an Announcement - Blue Paragraph symbol: a String - Gray Epsilon symbol: a Magniture - Blue Matrix box: a graphcial Morph - Purple Ball with T: a Trait!!!! Protocol PaneIn the System Browser protocol pane, you will see the following icons appear next to specific types of protocol objects:- Yellow diamond: initialisation methods- Red Square: private methods!!!! Method PaneIn the System Browser methods pane, you will see the following icons appear next to specific types of method objects:- Green Up Arrow: indicates this method overrides a method in a super class- Green Down Arrow: indicates this method is overriden in a subclass!!!! Source PaneIn the System Browser lower code source pane, you will see the following icons appear which have the following meaning:- Orange Smudge top right: the source has changed and should be saved- Yellow Stripe right margin: a long or complicated method that needs refactoring- Yellow Padlock top right: when locked, indicates the current method source will be displayed stacked with other locked methods in the source pane!! Getting More HelpIf you need more detailed help, here are some additional places to look.!!!! Pharo TutorialTry using the Pharo Smalltalk tutorial by evaluating (CMD+D) the code below: 	ProfStef go.!!!! Online ResourcesYou can find more information about Pharo by visiting: 	http://www.pharo.orgIn particular, you may also be interested in:- Joining discussions and getting help at: http://pharo.org/community - The Pharo By Example book (available as a free PDF): http://www.pharobyexample.org- Browsing the online documentation: http://www.pharo.org/documentation- Reporting problems: http://pharo.org/contribute!!MorphicTextAdapter methodsFor: 'widget API' stamp: 'EricVeltenDeMelo 5/19/2016 20:24' prior: 33483241!setScrollValue: aValue	self		widgetDo: [ :w | 			w scrollPane				hScrollbarValue: aValue x;				vScrollbarValue: aValue y ]! !"Pharo-Help"!"Spec-MorphicAdapters"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo50/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader50-TheIntegrator.965.mcz') load.ScriptLoader new update50759.!----End fileIn----!----QUIT----2016-05-25T15:04:08.153741+02:00 Pharo.image priorSource: 167657!----QUIT----2016-05-25T15:04:11.38136+02:00 Pharo.image priorSource: 193066!----QUIT----2016-05-25T15:04:16.506542+02:00 Pharo.image priorSource: 193145!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 6/3/2016 15:36' prior: 33722260!commentForCurrentUpdate ^ '18324 Spelling mistakes in Pharo	https://pharo.fogbugz.com/f/cases/18324'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 6/3/2016 15:37'!script50760	^ 'AST-Core-TheIntegrator.418.mczAST-FFI-Pharo50Compatibility-TheIntegrator.2.mczAST-Tests-Core-TheIntegrator.95.mczAlien-eem.32.mczAnnouncements-Core-TheIntegrator.68.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.31.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-NicolaiHess.123.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-EstebanLorenzano.63.mczAthens-Text-NicolaiHess.16.mczBalloon-TheIntegrator.132.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfFileTree-ThierryGoubier.15.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfQualityAssistant-YuriyTymchuk.46.mczBaselineOfRenraku-YuriyTymchuk.5.mczBlueInk-Core-TheIntegrator.24.mczBlueInk-Extras-TheIntegrator.10.mczBlueInk-Tests-TheIntegrator.12.mczChroma-CubeHelix-TheIntegrator.2.mczCodeExport-TheIntegrator.19.mczCodeImport-TheIntegrator.88.mczCodeImportCommandLineHandlers-TheIntegrator.7.mczCollections-Abstract-TheIntegrator.313.mczCollections-Arithmetic-TheIntegrator.20.mczCollections-Atomic-TheIntegrator.16.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.246.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.188.mczCollections-Strings-TheIntegrator.415.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.49.mczCollections-Unordered-TheIntegrator.232.mczCollections-Weak-TheIntegrator.102.mczCompiler-TheIntegrator.602.mczCompression-TheIntegrator.176.mczCompression-Tests-TheIntegrator.2.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.4.mczDebuggerActions-TheIntegrator.85.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.126.mczDeprecated50-TheIntegrator.59.mczEmbeddedFreeType-TheIntegrator.26.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczFFI-Kernel-JanVanDeSandt.40.mczFFI-Pools-eem.3.mczFileSystem-Core-TheIntegrator.202.mczFileSystem-Disk-TheIntegrator.97.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.95.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.417.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-TheIntegrator.17.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.14.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.742.mczFreeType-Tests-TheIntegrator.2.mczFuel-MaxLeske.825.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-TheIntegrator.62.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.411.mczFuelTools-Debugger-TheIntegrator.10.mczGT-BytecodeDebugger-TudorGirba.31.mczGT-Debugger-AndreiChis.350.mczGT-EventRecorder-TheIntegrator.68.mczGT-EventRecorder-Tests-JurajKubelka.37.mczGT-Inspector-AndreiChis.421.mczGT-InspectorExtensions-Core-TheIntegrator.214.mczGT-Playground-DenisKudryashov.124.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-TudorGirba.397.mczGT-Spotter-EventRecorder-GuillermoPolito.112.mczGT-SpotterExtensions-Core-VincentBlondeau.203.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-StefanReichhart.56.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AliakseiSyrel.17.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-TudorGirba.322.mczGlamour-Examples-TudorGirba.303.mczGlamour-FastTable-AndreiChis.59.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-GuillermoPolito.418.mczGlamour-Morphic-Brick-Tests-TheIntegrator.14.mczGlamour-Morphic-Pager-GuillermoPolito.110.mczGlamour-Morphic-Renderer-AndreiChis.349.mczGlamour-Morphic-Theme-HenrikNergaard.222.mczGlamour-Morphic-Widgets-AndreiChis.195.mczGlamour-Presentations-AndreiChis.186.mczGlamour-Rubric-Presentations-AndreiChis.52.mczGlamour-Tests-Core-AndreiChis.111.mczGlamour-Tests-Morphic-TudorGirba.137.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.35.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.6.mczGraphics-Display Objects-TheIntegrator.175.mczGraphics-Files-TheIntegrator.76.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.189.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.80.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.41.mczHelpSystem-Core-TheIntegrator.144.mczHelpSystem-Tests-TheIntegrator.32.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.90.mczImportingResource-Help-TheIntegrator.4.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.28.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2293.mczKernel-Rules-TheIntegrator.2.mczKernel-Tests-TheIntegrator.65.mczKeymapping-Core-TheIntegrator.198.mczKeymapping-KeyCombinations-TheIntegrator.62.mczKeymapping-Pragmas-TheIntegrator.54.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.105.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.166.mczManifest-Core-TheIntegrator.239.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.51.mczMenuRegistration-TheIntegrator.78.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.824.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-EstebanLorenzano.733.mczMetacello-PharoCommonPlatform-TheIntegrator.22.mczMetacello-Platform-EstebanLorenzano.3.mczMetacello-ProfStef-EstebanLorenzano.18.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.7.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform.squeakCommon-EstebanLorenzano.23.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-EstebanLorenzano.148.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1132.mczMonticello-OldDataStreamCompatibility-TheIntegrator.8.mczMonticello-Tests-TheIntegrator.35.mczMonticelloConfigurations-TheIntegrator.72.mczMonticelloFileServices-TheIntegrator.6.mczMonticelloFileTree-Core-TheIntegrator.141.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.30.mczMonticelloGUI-TheIntegrator.415.mczMonticelloMocks-TheIntegrator.4.mczMonticelloRemoteRepositories-TheIntegrator.15.mczMoose-Algos-Graph-vincentBlondeau.31.mczMorphic-Base-TheIntegrator.546.mczMorphic-Core-TheIntegrator.278.mczMorphic-Examples-TheIntegrator.50.mczMorphic-Tests-TheIntegrator.11.mczMorphic-Widgets-Basic-TheIntegrator.86.mczMorphic-Widgets-ColorPicker-TheIntegrator.19.mczMorphic-Widgets-Extra-TheIntegrator.27.mczMorphic-Widgets-FastTable-StephanEggermont.177.mczMorphic-Widgets-List-TheIntegrator.21.mczMorphic-Widgets-NewList-TheIntegrator.9.mczMorphic-Widgets-Pluggable-TheIntegrator.66.mczMorphic-Widgets-PolyTabs-TheIntegrator.2.mczMorphic-Widgets-Scrolling-TheIntegrator.32.mczMorphic-Widgets-Tabs-TheIntegrator.20.mczMorphic-Widgets-Taskbar-TheIntegrator.21.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.50.mczMorphic-Widgets-Windows-TheIntegrator.97.mczMultilingual-Encodings-TheIntegrator.61.mczMultilingual-Languages-TheIntegrator.55.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.81.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.244.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1253.mczNautilus-GroupManager-TheIntegrator.20.mczNautilus-GroupManagerUI-TheIntegrator.31.mczNautilus-Tests-TheIntegrator.37.mczNautilusCommon-TheIntegrator.305.mczNautilusGroupAutoBuilder-TheIntegrator.11.mczNautilusRefactoring-TheIntegrator.272.mczNetwork-Kernel-TheIntegrator.133.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-TheIntegrator.45.mczNetwork-Protocols-TheIntegrator.103.mczNetwork-Tests-TheIntegrator.13.mczNetwork-UUID-TheIntegrator.44.mczNetwork-Url-MarcusDenker.99.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.55.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-RonieSalgado.107.mczOSWindow-SDL2-RonieSalgado.96.mczOSWindow-SDL2-Examples-RonieSalgado.13.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOpalCompiler-Core-TheIntegrator.799.mczOpalCompiler-Tests-TheIntegrator.334.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.31.mczPolymorph-TaskbarIcons-TheIntegrator.46.mczPolymorph-Widgets-TheIntegrator.1338.mczPragmaCollector-TheIntegrator.12.mczProfStef-Core-TheIntegrator.77.mczProfStef-Help-TheIntegrator.16.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.101.mczQualityAssistantRecording-YuriyTymchuk.20.mczRPackage-Core-TheIntegrator.430.mczRPackage-Tests-TheIntegrator.181.mczRandom-Core-TheIntegrator.4.mczRandom-Tests-TheIntegrator.4.mczRecentSubmissions-TheIntegrator.238.mczRefactoring-Changes-TheIntegrator.67.mczRefactoring-Core-TheIntegrator.298.mczRefactoring-Critics-TheIntegrator.261.mczRefactoring-Environment-TheIntegrator.76.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.131.mczRefactoring-Tests-Critics-TheIntegrator.38.mczRefactoring-Tests-Environment-TheIntegrator.23.mczReflectivity-TheIntegrator.297.mczReflectivity-Examples-TheIntegrator.28.mczReflectivity-Tests-TheIntegrator.202.mczReflectivity-Tools-TheIntegrator.24.mczReflectivity-Tools-Tests-TheIntegrator.11.mczRegex-Core-TheIntegrator.38.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.31.mczRenraku-YuriyTymchuk.111.mczRenraku-Test-YuriyTymchuk.19.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.237.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.90.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.364.mczRubric-Rules-YuriyTymchuk.3.mczSTON-Core-PavelKrivanek.73.mczSTON-Tests-SvenVanCaekenberghe.64.mczSUnit-Core-TheIntegrator.169.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.3.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-EstebanLorenzano.138.mczSUnit-UITesting-TheIntegrator.32.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.92.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TommasoDalSasso.3.mczShoreLine-Report-UI-TommasoDalSasso.17.mczShout-TheIntegrator.291.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.742.mczSlot-Tests-TheIntegrator.89.mczSmartSuggestions-TheIntegrator.234.mczSmartSuggestions-Tests-TheIntegrator.33.mczSpec-Core-TheIntegrator.465.mczSpec-Debugger-TheIntegrator.263.mczSpec-Examples-TheIntegrator.108.mczSpec-Help-TheIntegrator.10.mczSpec-Inspector-TheIntegrator.258.mczSpec-Layout-TheIntegrator.69.mczSpec-MorphicAdapters-TheIntegrator.269.mczSpec-PolyWidgets-TheIntegrator.66.mczSpec-Tests-TheIntegrator.63.mczSpec-Tools-TheIntegrator.324.mczStartupPreferences-TheIntegrator.149.mczSystem-Announcements-TheIntegrator.108.mczSystem-BasicCommandLineHandler-TheIntegrator.18.mczSystem-Caching-TheIntegrator.26.mczSystem-CachingTests-TheIntegrator.16.mczSystem-Changes-TheIntegrator.292.mczSystem-Changes-FileServices-TheIntegrator.2.mczSystem-Clipboard-TheIntegrator.40.mczSystem-CommandLine-TheIntegrator.181.mczSystem-CommandLine-TextSupport-TheIntegrator.4.mczSystem-CommandLineHandler-TheIntegrator.18.mczSystem-FileRegistry-TheIntegrator.50.mczSystem-Finalization-TheIntegrator.32.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.106.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.4.mczSystem-OSEnvironments-TheIntegrator.31.mczSystem-Object Events-TheIntegrator.25.mczSystem-Platforms-TheIntegrator.81.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.27.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.337.mczSystem-Settings-Tests-TheIntegrator.11.mczSystem-Sound-StephaneDucasse.18.mczSystem-Sources-TheIntegrator.50.mczSystem-Support-TheIntegrator.1215.mczSystem-SupportTests-TheIntegrator.2.mczSystem-VMEvents-TheIntegrator.17.mczTests-TheIntegrator.755.mczText-Core-TheIntegrator.50.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.114.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.140.mczTool-Catalog-GuillermoPolito.32.mczTool-CriticBrowser-TheIntegrator.21.mczTool-DependencyAnalyser-ChristopheDemarey.28.mczTool-DependencyAnalyser-Test-ChristopheDemarey.11.mczTool-DependencyAnalyser-UI-ChristopheDemarey.43.mczTool-Diff-TheIntegrator.31.mczTool-ExternalBrowser-TheIntegrator.49.mczTool-FileList-TheIntegrator.62.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.65.mczTool-ImageCleaner-TheIntegrator.17.mczTool-ProcessBrowser-TheIntegrator.20.mczTool-Profilers-TheIntegrator.22.mczTool-SystemReporter-TheIntegrator.15.mczTool-Transcript-TheIntegrator.25.mczTool-TxWorkspace-NicolaiHess.7.mczTool-Workspace-TheIntegrator.37.mczTools-TheIntegrator.1525.mczTools-Test-TheIntegrator.16.mczTraits-TheIntegrator.907.mczTranscript-TheIntegrator.50.mczTxText-Athens-GuillermoPolito.53.mczTxText-AthensTests-SeanDeNigris.10.mczTxText-Model-SeanDeNigris.61.mczTxText-Styler-MarcusDenker.17.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.187.mczUnicode-Initialization-TheIntegrator.15.mczUnifiedFFI-EstebanLorenzano.57.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.25.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-VincentBlondeau.32.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-StephaneDucasse.64.mczVersionner-Core-DependenciesModel-ChristopheDemarey.105.mczVersionner-Core-Model-ChristopheDemarey.52.mczVersionner-Spec-Browser-PabloTesone.189.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczZinc-Character-Encoding-Core-TheIntegrator.48.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.27.mczZinc-FileSystem-SvenVanCaekenberghe.12.mczZinc-HTTP-SvenVanCaekenberghe.448.mczZinc-Resource-Meta-Core-TheIntegrator.58.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.36.mczZinc-Tests-SvenVanCaekenberghe.236.mczZinc-Zodiac-TheIntegrator.37.mczZodiac-Core-SvenVanCaekenberghe.42.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.13.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 6/3/2016 15:37'!update50760	"self new update50760"	self withUpdateLog: '18324 Spelling mistakes in Pharo	https://pharo.fogbugz.com/f/cases/18324'.	self loadTogether: self script50760 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update50759!ScriptLoader removeSelector: #script50759!"ScriptLoader50"!!WorldModel commentStamp: 'NicolaiHess 5/25/2016 21:39' prior: 64018446!I am a model representing Pharo World.This way, every spec application can be opened as the Pharo system window as window, to simulate native a application.!!OrderedCollection commentStamp: 'NicolaiHess 5/25/2016 21:36' prior: 52002587!I am one of the most common collection. I can grow, and elements can be added sequentially by the user.  Description -------------------I am more general than Array; my size grows on demand. I store data inside an Array and remember the first and last index. If I need, I can replace this Array by a larger one.I am usually used to store an unknown amount of objects. When my contents size will not move, one can send me the #asArray message to get better performances, but I cannot grow anymore (add: and remove: are not supported on Array).Public API and Key Messages-------------------	- #new / #withAll: aCollection / #with: anObject 	are common constructors- #add: anObject / #at: anIndex put: anObject / #at: anIndex ifAbsentPut: anObject 	allow to add new elements to myself.- #remove: anObject / #removeIndex: anIndex 	allow to remove an element.	- #do: aBlock / #collect: aBlock / #select: aBlock / #reject: aBlock 	are common iterators.Examples-------------------			"There is many ways to create an OrderedCollection, here are some:"	ordCol := OrderedCollection new.	ordCol		add: 'one';		add: 'two';		addFirst: 'zero';		addLast: 'three'.	ordCol.		"returns: an OrderedCollection('zero' 'one' 'two' 'three')"	"or"	ordCol := OrderedCollection with: 'one' with: 'two' with: 'three'.	ordCol.		"returns: an OrderedCollection('one' 'two' 'three')"	"or from an other collection"	ordCol := OrderedCollection withAll: #('one' 'two' 'three').	ordCol.		"returns: an OrderedCollection('one' 'two' 'three')"	"or"	#('one' 'two' 'three') asOrderedCollection.	"Some manipulations"	ordCol := OrderedCollection ofSize: 2.	ordCol		at: 1 put: 'one';		at: 2 put: 'two';		at: 2 ifAbsentPut: 'three'.	ordCol.		"returns: an OrderedCollection('one' 'two')"	ordCol		remove: 'two';		removeIndex: 1.	ordCol.		"returns:  an OrderedCollection()"	"A last one"	ordCol := OrderedCollection with: $b with: $c with: $a.	ordCol sort: [ :first :second | first < second ].		"returns: an OrderedCollection($a $b $c)"	ordCol collect: [ :element | element asUppercase ].		"returns:  an OrderedCollection($A $B $C)"	ordCol select: [ :element | element >= $b ].		"returns:  an OrderedCollection($b $c)"	ordCol do: [ :element | element inspect ].	ordCol asArray		"returns: #($a $b $c)"			 Internal Representation and Key Implementation Points.-------------------	    Instance Variables	array:			<Array> 		An Array where I store my elements. If I need a bigger one I can remove this one and create a new one.	firstIndex:		<Integer> 	The index of my first element.	lastIndex:		<Integer> 	The index of my last element.Istore my elements inside an array. This array is ATLEAST of the size of my elements. If someone adds an element and my array is not large enough, I remove it and I create a new one larger with the same elements (usually, the size double).!!Number methodsFor: 'mathematical functions' stamp: 'NicolaiHess 5/25/2016 21:35' prior: 51008065!squared	"Answer the receiver multiplied by itself."	^self * self! !!WelcomeHelp class methodsFor: 'pages' stamp: 'NicolaiHess 5/25/2016 21:34' prior: 33663022!welcome	^ HelpTopic 		title: 'Welcome to Pharo 5.0'		contents: 'Pharo 5.0=========Welcome to Pharo, an immersive live programming environment.Pharo is a pure object-oriented programming language and a powerful environment, focused on simplicity and immediate feedback (think IDE and OS rolled into one).For more information, please visit here: http://pharo.org'! !"Collections-Sequenceable"!"Kernel"!"Pharo-Help"!"Spec-MorphicAdapters"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo50/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader50-TheIntegrator.968.mcz') load.ScriptLoader new update50760.!----End fileIn----!----QUIT----2016-06-03T15:39:01.676326+02:00 Pharo.image priorSource: 193223!----QUIT----2016-06-03T15:39:06.386544+02:00 Pharo.image priorSource: 214317!----QUIT----2016-06-03T15:39:14.753308+02:00 Pharo.image priorSource: 214396!----QUIT----2016-06-11T10:54:59.292776+02:00 Pharo.image priorSource: 214475!----QUIT----2016-06-11T10:55:02.246772+02:00 Pharo.image priorSource: 214554!----QUIT----2016-06-11T10:55:07.348308+02:00 Pharo.image priorSource: 214633!----QUIT----2016-06-21T12:36:36.28281+02:00 Pharo.image priorSource: 214712!----QUIT----2016-06-21T12:36:39.483485+02:00 Pharo.image priorSource: 214791!----QUIT----2016-06-21T12:36:45.259159+02:00 Pharo.image priorSource: 214869!----QUIT----2016-06-21T17:42:12.510336+02:00 Pharo-50760.image priorSource: 214948!----QUIT----2016-07-28T18:13:45.378046+02:00 Pharo.image priorSource: 215027!----QUIT----2016-07-28T18:13:50.542723+02:00 Pharo.image priorSource: 215112!----QUIT----2016-07-28T18:13:51.323634+02:00 Pharo.image priorSource: 215191!!ScriptLoader methodsFor: 'public' stamp: 'EstebanLorenzano 7/29/2016 10:51' prior: 33747825!commentForCurrentUpdate ^ '18757 Simple Shell Command Eval for 5.0	https://pharo.fogbugz.com/f/cases/1875718676 Endless loop parsing e-mail addresses containing an ampersand	https://pharo.fogbugz.com/f/cases/18676'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'EstebanLorenzano 7/29/2016 10:51'!script50761	^ 'AST-Core-TheIntegrator.418.mczAST-FFI-Pharo50Compatibility-TheIntegrator.2.mczAST-Tests-Core-TheIntegrator.95.mczAlien-eem.32.mczAnnouncements-Core-TheIntegrator.68.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.31.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-NicolaiHess.123.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-EstebanLorenzano.63.mczAthens-Text-NicolaiHess.16.mczBalloon-TheIntegrator.132.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfFileTree-ThierryGoubier.15.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfQualityAssistant-YuriyTymchuk.46.mczBaselineOfRenraku-YuriyTymchuk.5.mczBlueInk-Core-TheIntegrator.24.mczBlueInk-Extras-TheIntegrator.10.mczBlueInk-Tests-TheIntegrator.12.mczChroma-CubeHelix-TheIntegrator.2.mczCodeExport-TheIntegrator.19.mczCodeImport-TheIntegrator.88.mczCodeImportCommandLineHandlers-TheIntegrator.7.mczCollections-Abstract-TheIntegrator.313.mczCollections-Arithmetic-TheIntegrator.20.mczCollections-Atomic-TheIntegrator.16.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.246.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.188.mczCollections-Strings-TheIntegrator.415.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.49.mczCollections-Unordered-TheIntegrator.232.mczCollections-Weak-TheIntegrator.102.mczCompiler-TheIntegrator.602.mczCompression-TheIntegrator.176.mczCompression-Tests-TheIntegrator.2.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.4.mczDebuggerActions-TheIntegrator.85.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.126.mczDeprecated50-TheIntegrator.59.mczEmbeddedFreeType-TheIntegrator.26.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczFFI-Kernel-JanVanDeSandt.40.mczFFI-Pools-eem.3.mczFileSystem-Core-TheIntegrator.202.mczFileSystem-Disk-TheIntegrator.97.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.95.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.417.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-TheIntegrator.17.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.14.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.742.mczFreeType-Tests-TheIntegrator.2.mczFuel-MaxLeske.825.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-TheIntegrator.62.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.411.mczFuelTools-Debugger-TheIntegrator.10.mczGT-BytecodeDebugger-TudorGirba.31.mczGT-Debugger-AndreiChis.350.mczGT-EventRecorder-TheIntegrator.68.mczGT-EventRecorder-Tests-JurajKubelka.37.mczGT-Inspector-AndreiChis.421.mczGT-InspectorExtensions-Core-TheIntegrator.214.mczGT-Playground-DenisKudryashov.124.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-TudorGirba.397.mczGT-Spotter-EventRecorder-GuillermoPolito.112.mczGT-SpotterExtensions-Core-VincentBlondeau.203.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-StefanReichhart.56.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AliakseiSyrel.17.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-TudorGirba.322.mczGlamour-Examples-TudorGirba.303.mczGlamour-FastTable-AndreiChis.59.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-GuillermoPolito.418.mczGlamour-Morphic-Brick-Tests-TheIntegrator.14.mczGlamour-Morphic-Pager-GuillermoPolito.110.mczGlamour-Morphic-Renderer-AndreiChis.349.mczGlamour-Morphic-Theme-HenrikNergaard.222.mczGlamour-Morphic-Widgets-AndreiChis.195.mczGlamour-Presentations-AndreiChis.186.mczGlamour-Rubric-Presentations-AndreiChis.52.mczGlamour-Tests-Core-AndreiChis.111.mczGlamour-Tests-Morphic-TudorGirba.137.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.35.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.6.mczGraphics-Display Objects-TheIntegrator.175.mczGraphics-Files-TheIntegrator.76.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.189.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.80.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.41.mczHelpSystem-Core-TheIntegrator.144.mczHelpSystem-Tests-TheIntegrator.32.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.90.mczImportingResource-Help-TheIntegrator.4.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.28.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2293.mczKernel-Rules-TheIntegrator.2.mczKernel-Tests-TheIntegrator.65.mczKeymapping-Core-TheIntegrator.198.mczKeymapping-KeyCombinations-TheIntegrator.62.mczKeymapping-Pragmas-TheIntegrator.54.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.105.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.166.mczManifest-Core-TheIntegrator.239.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.51.mczMenuRegistration-TheIntegrator.78.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.824.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-EstebanLorenzano.733.mczMetacello-PharoCommonPlatform-TheIntegrator.22.mczMetacello-Platform-EstebanLorenzano.3.mczMetacello-ProfStef-EstebanLorenzano.18.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.7.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform.squeakCommon-EstebanLorenzano.23.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-EstebanLorenzano.148.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1132.mczMonticello-OldDataStreamCompatibility-TheIntegrator.8.mczMonticello-Tests-TheIntegrator.35.mczMonticelloConfigurations-TheIntegrator.72.mczMonticelloFileServices-TheIntegrator.6.mczMonticelloFileTree-Core-TheIntegrator.141.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.30.mczMonticelloGUI-TheIntegrator.415.mczMonticelloMocks-TheIntegrator.4.mczMonticelloRemoteRepositories-TheIntegrator.15.mczMoose-Algos-Graph-vincentBlondeau.31.mczMorphic-Base-TheIntegrator.546.mczMorphic-Core-TheIntegrator.278.mczMorphic-Examples-TheIntegrator.50.mczMorphic-Tests-TheIntegrator.11.mczMorphic-Widgets-Basic-TheIntegrator.86.mczMorphic-Widgets-ColorPicker-TheIntegrator.19.mczMorphic-Widgets-Extra-TheIntegrator.27.mczMorphic-Widgets-FastTable-StephanEggermont.177.mczMorphic-Widgets-List-TheIntegrator.21.mczMorphic-Widgets-NewList-TheIntegrator.9.mczMorphic-Widgets-Pluggable-TheIntegrator.66.mczMorphic-Widgets-PolyTabs-TheIntegrator.2.mczMorphic-Widgets-Scrolling-TheIntegrator.32.mczMorphic-Widgets-Tabs-TheIntegrator.20.mczMorphic-Widgets-Taskbar-TheIntegrator.21.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.50.mczMorphic-Widgets-Windows-TheIntegrator.97.mczMultilingual-Encodings-TheIntegrator.61.mczMultilingual-Languages-TheIntegrator.55.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.81.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.244.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1253.mczNautilus-GroupManager-TheIntegrator.20.mczNautilus-GroupManagerUI-TheIntegrator.31.mczNautilus-Tests-TheIntegrator.37.mczNautilusCommon-TheIntegrator.305.mczNautilusGroupAutoBuilder-TheIntegrator.11.mczNautilusRefactoring-TheIntegrator.272.mczNetwork-Kernel-TheIntegrator.133.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-EstebanLorenzano.47.mczNetwork-Protocols-TheIntegrator.103.mczNetwork-Tests-EstebanLorenzano.15.mczNetwork-UUID-TheIntegrator.44.mczNetwork-Url-MarcusDenker.99.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.55.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-RonieSalgado.107.mczOSWindow-SDL2-RonieSalgado.96.mczOSWindow-SDL2-Examples-RonieSalgado.13.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOpalCompiler-Core-TheIntegrator.799.mczOpalCompiler-Tests-TheIntegrator.334.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.31.mczPolymorph-TaskbarIcons-TheIntegrator.46.mczPolymorph-Widgets-TheIntegrator.1338.mczPragmaCollector-TheIntegrator.12.mczProfStef-Core-TheIntegrator.77.mczProfStef-Help-TheIntegrator.16.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.101.mczQualityAssistantRecording-YuriyTymchuk.20.mczRPackage-Core-TheIntegrator.430.mczRPackage-Tests-TheIntegrator.181.mczRandom-Core-TheIntegrator.4.mczRandom-Tests-TheIntegrator.4.mczRecentSubmissions-TheIntegrator.238.mczRefactoring-Changes-TheIntegrator.67.mczRefactoring-Core-TheIntegrator.298.mczRefactoring-Critics-TheIntegrator.261.mczRefactoring-Environment-TheIntegrator.76.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.131.mczRefactoring-Tests-Critics-TheIntegrator.38.mczRefactoring-Tests-Environment-TheIntegrator.23.mczReflectivity-TheIntegrator.297.mczReflectivity-Examples-TheIntegrator.28.mczReflectivity-Tests-TheIntegrator.202.mczReflectivity-Tools-TheIntegrator.24.mczReflectivity-Tools-Tests-TheIntegrator.11.mczRegex-Core-TheIntegrator.38.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.31.mczRenraku-YuriyTymchuk.111.mczRenraku-Test-YuriyTymchuk.19.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.237.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.90.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.364.mczRubric-Rules-YuriyTymchuk.3.mczSTON-Core-PavelKrivanek.73.mczSTON-Tests-SvenVanCaekenberghe.64.mczSUnit-Core-TheIntegrator.169.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.3.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-EstebanLorenzano.138.mczSUnit-UITesting-TheIntegrator.32.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.92.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TommasoDalSasso.3.mczShoreLine-Report-UI-TommasoDalSasso.17.mczShout-TheIntegrator.291.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.742.mczSlot-Tests-TheIntegrator.89.mczSmartSuggestions-TheIntegrator.234.mczSmartSuggestions-Tests-TheIntegrator.33.mczSpec-Core-TheIntegrator.465.mczSpec-Debugger-TheIntegrator.263.mczSpec-Examples-TheIntegrator.108.mczSpec-Help-TheIntegrator.10.mczSpec-Inspector-TheIntegrator.258.mczSpec-Layout-TheIntegrator.69.mczSpec-MorphicAdapters-TheIntegrator.269.mczSpec-PolyWidgets-TheIntegrator.66.mczSpec-Tests-TheIntegrator.63.mczSpec-Tools-TheIntegrator.324.mczStartupPreferences-TheIntegrator.149.mczSystem-Announcements-TheIntegrator.108.mczSystem-BasicCommandLineHandler-TheIntegrator.18.mczSystem-Caching-TheIntegrator.26.mczSystem-CachingTests-TheIntegrator.16.mczSystem-Changes-TheIntegrator.292.mczSystem-Changes-FileServices-TheIntegrator.2.mczSystem-Clipboard-TheIntegrator.40.mczSystem-CommandLine-TheIntegrator.181.mczSystem-CommandLine-TextSupport-TheIntegrator.4.mczSystem-CommandLineHandler-TheIntegrator.18.mczSystem-FileRegistry-TheIntegrator.50.mczSystem-Finalization-TheIntegrator.32.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.106.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.4.mczSystem-OSEnvironments-TheIntegrator.31.mczSystem-Object Events-TheIntegrator.25.mczSystem-Platforms-TheIntegrator.81.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.27.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.337.mczSystem-Settings-Tests-TheIntegrator.11.mczSystem-Sound-StephaneDucasse.18.mczSystem-Sources-TheIntegrator.50.mczSystem-Support-TheIntegrator.1215.mczSystem-SupportTests-TheIntegrator.2.mczSystem-VMEvents-TheIntegrator.17.mczTests-TheIntegrator.755.mczText-Core-TheIntegrator.50.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.114.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.140.mczTool-Catalog-GuillermoPolito.32.mczTool-CriticBrowser-TheIntegrator.21.mczTool-DependencyAnalyser-ChristopheDemarey.28.mczTool-DependencyAnalyser-Test-ChristopheDemarey.11.mczTool-DependencyAnalyser-UI-ChristopheDemarey.43.mczTool-Diff-TheIntegrator.31.mczTool-ExternalBrowser-TheIntegrator.49.mczTool-FileList-TheIntegrator.62.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.65.mczTool-ImageCleaner-TheIntegrator.17.mczTool-ProcessBrowser-TheIntegrator.20.mczTool-Profilers-TheIntegrator.22.mczTool-SystemReporter-TheIntegrator.15.mczTool-Transcript-TheIntegrator.25.mczTool-TxWorkspace-NicolaiHess.7.mczTool-Workspace-TheIntegrator.37.mczTools-TheIntegrator.1525.mczTools-Test-TheIntegrator.16.mczTraits-TheIntegrator.907.mczTranscript-TheIntegrator.50.mczTxText-Athens-GuillermoPolito.53.mczTxText-AthensTests-SeanDeNigris.10.mczTxText-Model-SeanDeNigris.61.mczTxText-Styler-MarcusDenker.17.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.187.mczUnicode-Initialization-TheIntegrator.15.mczUnifiedFFI-EstebanLorenzano.70.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.25.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-VincentBlondeau.32.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-StephaneDucasse.64.mczVersionner-Core-DependenciesModel-ChristopheDemarey.105.mczVersionner-Core-Model-ChristopheDemarey.52.mczVersionner-Spec-Browser-PabloTesone.189.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczZinc-Character-Encoding-Core-TheIntegrator.48.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.27.mczZinc-FileSystem-SvenVanCaekenberghe.12.mczZinc-HTTP-SvenVanCaekenberghe.448.mczZinc-Resource-Meta-Core-TheIntegrator.58.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.36.mczZinc-Tests-SvenVanCaekenberghe.236.mczZinc-Zodiac-TheIntegrator.37.mczZodiac-Core-SvenVanCaekenberghe.42.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.13.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'EstebanLorenzano 7/29/2016 10:51'!update50761	"self new update50761"	self withUpdateLog: '18757 Simple Shell Command Eval for 5.0	https://pharo.fogbugz.com/f/cases/1875718676 Endless loop parsing e-mail addresses containing an ampersand	https://pharo.fogbugz.com/f/cases/18676'.	self loadTogether: self script50761 merge: false.	self flushCaches.self cleanRepositories.! !ScriptLoader removeSelector: #update50760!ScriptLoader removeSelector: #script50760!"ScriptLoader50"!!LibC class methodsFor: 'fuctions' stamp: 'SeanDeNigris 7/12/2016 16:49'!system: command	"LibC system: 'sleep 3'"		^ self ffiCall: #(int system #(char * command)) module: self! !!MailAddressParserTest methodsFor: 'tests' stamp: 'BernhardPieber 7/2/2016 21:03' prior: 30697581!testAddressesIn	| testString correctAnswer |	testString := 'joe@lama.com, joe2@lama.com joe3@lama.com joe4 , Not an Address <joe5@address>, joe.(annoying (nested) comment)literal@[1.2.3.4], "an annoying" group : joe1@groupie, joe2@groupie, "Joey" joe3@groupy, "joe6"."joe8"@group.com;,  Lex''s email account <lex>'.correctAnswer := #('joe@lama.com' 'joe2@lama.com' 'joe3@lama.com' 'joe4' 'joe5@address' 'joe.literal@[1.2.3.4]' 'joe1@groupie' 'joe2@groupie' '"Joey"' 'joe3@groupy' '"joe6"."joe8"@group.com' 'lex') asOrderedCollection.	self assert: (MailAddressParser addressesIn: testString) equals:  correctAnswer! !!MailAddressParserTest methodsFor: 'tests' stamp: 'BernhardPieber 7/2/2016 21:05'!testAmpersand	| testString correctAnswer |	testString := '&@example.com, romeo&julia@verona.it'.	correctAnswer := #('&@example.com' 'romeo&julia@verona.it') asOrderedCollection.	self assert: (MailAddressParser addressesIn: testString) equals: correctAnswer! !!MailAddressTokenizer class methodsFor: 'initialization' stamp: 'BernhardPieber 6/26/2016 20:02' prior: 30703143!initialize	"Initalize class variables using   MailAddressTokenizer initialize"	| atomChars |	CSParens := CharacterSet empty.	CSParens addAll: '()'.	CSSpecials := CharacterSet empty.	CSSpecials addAll: '()<>@,;:\".[]'.	CSNonSeparators := CharacterSet separators complement.	"(from RFC 2822)"	atomChars := CharacterSet empty.	atomChars addAll: ($A to: $Z).	atomChars addAll: ($a to: $z).	atomChars addAll: ($0 to: $9).	atomChars addAll: '!!#$%&''*+-/=?^_`{|}~'.	CSNonAtom :=  atomChars complement.! !"Network-Mail"!"Network-Tests"!"UnifiedFFI"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo50/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader50-EstebanLorenzano.975.mcz') load.ScriptLoader new update50761.!----End fileIn----!----QUIT----2016-07-29T12:18:23.980837+02:00 Pharo.image priorSource: 215270!----QUIT----2016-07-29T12:18:29.473484+02:00 Pharo.image priorSource: 234661!----QUIT----2016-08-01T11:36:53.920534+02:00 Pharo-50761.image priorSource: 234740!----QUIT----2016-08-01T11:37:06.163657+02:00 Pharo-50761.image priorSource: 234819!----QUIT----2016-08-06T23:06:44.784459+02:00 Pharo.image priorSource: 234904!----QUIT----2016-08-06T23:06:50.030292+02:00 Pharo.image priorSource: 234989!----QUIT----2016-08-06T23:06:50.906972+02:00 Pharo.image priorSource: 235068!----QUIT----2016-08-09T15:17:53.216211+02:00 Pharo-50761.image priorSource: 235147!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 10/25/2016 10:07' prior: 33769876!commentForCurrentUpdate ^ '19205 [Backport] Pharo 5: Enable / Disable options in context Menu in FastTable	https://pharo.fogbugz.com/f/cases/19205'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 10/25/2016 10:07'!script50762	^ 'AST-Core-TheIntegrator.418.mczAST-FFI-Pharo50Compatibility-TheIntegrator.2.mczAST-Tests-Core-TheIntegrator.95.mczAlien-eem.32.mczAnnouncements-Core-TheIntegrator.68.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.31.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-NicolaiHess.123.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-EstebanLorenzano.63.mczAthens-Text-NicolaiHess.16.mczBalloon-TheIntegrator.132.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfFileTree-ThierryGoubier.15.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfQualityAssistant-YuriyTymchuk.46.mczBaselineOfRenraku-YuriyTymchuk.5.mczBlueInk-Core-TheIntegrator.24.mczBlueInk-Extras-TheIntegrator.10.mczBlueInk-Tests-TheIntegrator.12.mczChroma-CubeHelix-TheIntegrator.2.mczCodeExport-TheIntegrator.19.mczCodeImport-TheIntegrator.88.mczCodeImportCommandLineHandlers-TheIntegrator.7.mczCollections-Abstract-TheIntegrator.313.mczCollections-Arithmetic-TheIntegrator.20.mczCollections-Atomic-TheIntegrator.16.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.246.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.188.mczCollections-Strings-TheIntegrator.415.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.49.mczCollections-Unordered-TheIntegrator.232.mczCollections-Weak-TheIntegrator.102.mczCompiler-TheIntegrator.602.mczCompression-TheIntegrator.176.mczCompression-Tests-TheIntegrator.2.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.4.mczDebuggerActions-TheIntegrator.85.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.126.mczDeprecated50-TheIntegrator.59.mczEmbeddedFreeType-TheIntegrator.26.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczFFI-Kernel-JanVanDeSandt.40.mczFFI-Pools-eem.3.mczFileSystem-Core-TheIntegrator.202.mczFileSystem-Disk-TheIntegrator.97.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.95.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.417.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-TheIntegrator.17.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.14.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.742.mczFreeType-Tests-TheIntegrator.2.mczFuel-MaxLeske.825.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-TheIntegrator.62.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.411.mczFuelTools-Debugger-TheIntegrator.10.mczGT-BytecodeDebugger-TudorGirba.31.mczGT-Debugger-AndreiChis.350.mczGT-EventRecorder-TheIntegrator.68.mczGT-EventRecorder-Tests-JurajKubelka.37.mczGT-Inspector-AndreiChis.421.mczGT-InspectorExtensions-Core-TheIntegrator.214.mczGT-Playground-DenisKudryashov.124.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-TudorGirba.397.mczGT-Spotter-EventRecorder-GuillermoPolito.112.mczGT-SpotterExtensions-Core-VincentBlondeau.203.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-StefanReichhart.56.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AliakseiSyrel.17.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-TudorGirba.322.mczGlamour-Examples-TudorGirba.303.mczGlamour-FastTable-AndreiChis.59.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-GuillermoPolito.418.mczGlamour-Morphic-Brick-Tests-TheIntegrator.14.mczGlamour-Morphic-Pager-GuillermoPolito.110.mczGlamour-Morphic-Renderer-AndreiChis.349.mczGlamour-Morphic-Theme-HenrikNergaard.222.mczGlamour-Morphic-Widgets-AndreiChis.195.mczGlamour-Presentations-AndreiChis.186.mczGlamour-Rubric-Presentations-AndreiChis.52.mczGlamour-Tests-Core-AndreiChis.111.mczGlamour-Tests-Morphic-TudorGirba.137.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.35.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.6.mczGraphics-Display Objects-TheIntegrator.175.mczGraphics-Files-TheIntegrator.76.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.189.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.80.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.41.mczHelpSystem-Core-TheIntegrator.144.mczHelpSystem-Tests-TheIntegrator.32.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.90.mczImportingResource-Help-TheIntegrator.4.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.28.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2293.mczKernel-Rules-TheIntegrator.2.mczKernel-Tests-TheIntegrator.65.mczKeymapping-Core-TheIntegrator.198.mczKeymapping-KeyCombinations-TheIntegrator.62.mczKeymapping-Pragmas-TheIntegrator.54.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.105.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.166.mczManifest-Core-TheIntegrator.239.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.51.mczMenuRegistration-TheIntegrator.78.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.824.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-EstebanLorenzano.733.mczMetacello-PharoCommonPlatform-TheIntegrator.22.mczMetacello-Platform-EstebanLorenzano.3.mczMetacello-ProfStef-EstebanLorenzano.18.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.7.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform.squeakCommon-EstebanLorenzano.23.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-EstebanLorenzano.148.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1132.mczMonticello-OldDataStreamCompatibility-TheIntegrator.8.mczMonticello-Tests-TheIntegrator.35.mczMonticelloConfigurations-TheIntegrator.72.mczMonticelloFileServices-TheIntegrator.6.mczMonticelloFileTree-Core-TheIntegrator.141.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.30.mczMonticelloGUI-TheIntegrator.415.mczMonticelloMocks-TheIntegrator.4.mczMonticelloRemoteRepositories-TheIntegrator.15.mczMoose-Algos-Graph-vincentBlondeau.31.mczMorphic-Base-TheIntegrator.546.mczMorphic-Core-TheIntegrator.278.mczMorphic-Examples-TheIntegrator.50.mczMorphic-Tests-TheIntegrator.11.mczMorphic-Widgets-Basic-TheIntegrator.86.mczMorphic-Widgets-ColorPicker-TheIntegrator.19.mczMorphic-Widgets-Extra-TheIntegrator.27.mczMorphic-Widgets-FastTable-StephanEggermont.177.mczMorphic-Widgets-List-TheIntegrator.21.mczMorphic-Widgets-NewList-TheIntegrator.9.mczMorphic-Widgets-Pluggable-TheIntegrator.66.mczMorphic-Widgets-PolyTabs-TheIntegrator.2.mczMorphic-Widgets-Scrolling-TheIntegrator.32.mczMorphic-Widgets-Tabs-TheIntegrator.20.mczMorphic-Widgets-Taskbar-TheIntegrator.21.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.50.mczMorphic-Widgets-Windows-TheIntegrator.97.mczMultilingual-Encodings-TheIntegrator.61.mczMultilingual-Languages-TheIntegrator.55.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.81.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.244.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1253.mczNautilus-GroupManager-TheIntegrator.20.mczNautilus-GroupManagerUI-TheIntegrator.31.mczNautilus-Tests-TheIntegrator.37.mczNautilusCommon-TheIntegrator.305.mczNautilusGroupAutoBuilder-TheIntegrator.11.mczNautilusRefactoring-TheIntegrator.272.mczNetwork-Kernel-TheIntegrator.133.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-EstebanLorenzano.47.mczNetwork-Protocols-TheIntegrator.103.mczNetwork-Tests-EstebanLorenzano.15.mczNetwork-UUID-TheIntegrator.44.mczNetwork-Url-MarcusDenker.99.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.55.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-RonieSalgado.107.mczOSWindow-SDL2-RonieSalgado.96.mczOSWindow-SDL2-Examples-RonieSalgado.13.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOpalCompiler-Core-TheIntegrator.799.mczOpalCompiler-Tests-TheIntegrator.334.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.31.mczPolymorph-TaskbarIcons-TheIntegrator.46.mczPolymorph-Widgets-TheIntegrator.1338.mczPragmaCollector-TheIntegrator.12.mczProfStef-Core-TheIntegrator.77.mczProfStef-Help-TheIntegrator.16.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.101.mczQualityAssistantRecording-YuriyTymchuk.20.mczRPackage-Core-TheIntegrator.430.mczRPackage-Tests-TheIntegrator.181.mczRandom-Core-TheIntegrator.4.mczRandom-Tests-TheIntegrator.4.mczRecentSubmissions-TheIntegrator.238.mczRefactoring-Changes-TheIntegrator.67.mczRefactoring-Core-TheIntegrator.298.mczRefactoring-Critics-TheIntegrator.261.mczRefactoring-Environment-TheIntegrator.76.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.131.mczRefactoring-Tests-Critics-TheIntegrator.38.mczRefactoring-Tests-Environment-TheIntegrator.23.mczReflectivity-TheIntegrator.297.mczReflectivity-Examples-TheIntegrator.28.mczReflectivity-Tests-TheIntegrator.202.mczReflectivity-Tools-TheIntegrator.24.mczReflectivity-Tools-Tests-TheIntegrator.11.mczRegex-Core-TheIntegrator.38.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.31.mczRenraku-YuriyTymchuk.111.mczRenraku-Test-YuriyTymchuk.19.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.237.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.90.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.364.mczRubric-Rules-YuriyTymchuk.3.mczSTON-Core-PavelKrivanek.73.mczSTON-Tests-SvenVanCaekenberghe.64.mczSUnit-Core-TheIntegrator.169.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.3.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-EstebanLorenzano.138.mczSUnit-UITesting-TheIntegrator.32.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.92.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TommasoDalSasso.3.mczShoreLine-Report-UI-TommasoDalSasso.17.mczShout-TheIntegrator.291.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.742.mczSlot-Tests-TheIntegrator.89.mczSmartSuggestions-TheIntegrator.234.mczSmartSuggestions-Tests-TheIntegrator.33.mczSpec-Core-TheIntegrator.465.mczSpec-Debugger-TheIntegrator.263.mczSpec-Examples-TheIntegrator.108.mczSpec-Help-TheIntegrator.10.mczSpec-Inspector-TheIntegrator.258.mczSpec-Layout-TheIntegrator.69.mczSpec-MorphicAdapters-TheIntegrator.269.mczSpec-PolyWidgets-TheIntegrator.66.mczSpec-Tests-TheIntegrator.63.mczSpec-Tools-TheIntegrator.324.mczStartupPreferences-TheIntegrator.149.mczSystem-Announcements-TheIntegrator.108.mczSystem-BasicCommandLineHandler-TheIntegrator.18.mczSystem-Caching-TheIntegrator.26.mczSystem-CachingTests-TheIntegrator.16.mczSystem-Changes-TheIntegrator.292.mczSystem-Changes-FileServices-TheIntegrator.2.mczSystem-Clipboard-TheIntegrator.40.mczSystem-CommandLine-TheIntegrator.181.mczSystem-CommandLine-TextSupport-TheIntegrator.4.mczSystem-CommandLineHandler-TheIntegrator.18.mczSystem-FileRegistry-TheIntegrator.50.mczSystem-Finalization-TheIntegrator.32.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.106.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.4.mczSystem-OSEnvironments-TheIntegrator.31.mczSystem-Object Events-TheIntegrator.25.mczSystem-Platforms-TheIntegrator.81.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.27.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.337.mczSystem-Settings-Tests-TheIntegrator.11.mczSystem-Sound-StephaneDucasse.18.mczSystem-Sources-TheIntegrator.50.mczSystem-Support-TheIntegrator.1215.mczSystem-SupportTests-TheIntegrator.2.mczSystem-VMEvents-TheIntegrator.17.mczTests-TheIntegrator.755.mczText-Core-TheIntegrator.50.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.114.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.140.mczTool-Catalog-GuillermoPolito.32.mczTool-CriticBrowser-TheIntegrator.21.mczTool-DependencyAnalyser-ChristopheDemarey.28.mczTool-DependencyAnalyser-Test-ChristopheDemarey.11.mczTool-DependencyAnalyser-UI-ChristopheDemarey.43.mczTool-Diff-TheIntegrator.31.mczTool-ExternalBrowser-TheIntegrator.49.mczTool-FileList-TheIntegrator.62.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.65.mczTool-ImageCleaner-TheIntegrator.17.mczTool-ProcessBrowser-TheIntegrator.20.mczTool-Profilers-TheIntegrator.22.mczTool-SystemReporter-TheIntegrator.15.mczTool-Transcript-TheIntegrator.25.mczTool-TxWorkspace-NicolaiHess.7.mczTool-Workspace-TheIntegrator.37.mczTools-TheIntegrator.1525.mczTools-Test-TheIntegrator.16.mczTraits-TheIntegrator.907.mczTranscript-TheIntegrator.50.mczTxText-Athens-GuillermoPolito.53.mczTxText-AthensTests-SeanDeNigris.10.mczTxText-Model-SeanDeNigris.61.mczTxText-Styler-MarcusDenker.17.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.187.mczUnicode-Initialization-TheIntegrator.15.mczUnifiedFFI-EstebanLorenzano.70.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.25.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-VincentBlondeau.32.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-StephaneDucasse.64.mczVersionner-Core-DependenciesModel-ChristopheDemarey.105.mczVersionner-Core-Model-ChristopheDemarey.52.mczVersionner-Spec-Browser-PabloTesone.189.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczZinc-Character-Encoding-Core-TheIntegrator.48.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.27.mczZinc-FileSystem-SvenVanCaekenberghe.12.mczZinc-HTTP-SvenVanCaekenberghe.448.mczZinc-Resource-Meta-Core-TheIntegrator.58.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.36.mczZinc-Tests-SvenVanCaekenberghe.236.mczZinc-Zodiac-TheIntegrator.37.mczZodiac-Core-SvenVanCaekenberghe.42.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.13.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 10/25/2016 10:07'!update50762	"self new update50762"	self withUpdateLog: '19205 [Backport] Pharo 5: Enable / Disable options in context Menu in FastTable	https://pharo.fogbugz.com/f/cases/19205'.	self loadTogether: self script50762 merge: false.	self loadConfiguration: 'GlamourCore' version: '4.19.1'.self flushCaches.! !ScriptLoader removeSelector: #update50761!ScriptLoader removeSelector: #script50761!"ScriptLoader50"!!ConfigurationOfGlamourCore methodsFor: 'baselines' stamp: 'PavelKrivanek 6/3/2016 11:03' prior: 20479297!baseline33: spec	<version: '3.3-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec description: 'Load FastTable renderer for Glamour'.		spec repository: 'http://smalltalkhub.com/mc/Moose/Glamour/main'.				spec project: 'Rubric' with: [				spec					className: #ConfigurationOfRubric;					versionString: #'development';					repository: 'http://www.smalltalkhub.com/mc/Pharo/Rubric/main' ].		spec project: 'FastTable' with: [				spec					className: #ConfigurationOfFastTable;					versionString: #'development';					repository: 'http://smalltalkhub.com/mc/estebanlm/FastTable/main/' ].		spec 			package: 'Glamour-Announcements';			package: 'Glamour-Helpers';			package: 'Glamour-FastTable' with: [				spec requires: #('FastTable' 'Glamour-Examples' 'Glamour-Core' 'Glamour-Morphic-Renderer' 'Glamour-Tests-Morphic'). ];			package: 'Glamour-Core' with: [				spec requires: #('Glamour-Helpers' 'Glamour-Announcements' ). ];			package: 'Glamour-Presentations' with: [				spec requires: #('Glamour-Core' ). ];			package: 'Glamour-Browsers' with: [				spec requires: #('Glamour-Core' ). ];			package: 'Glamour-Examples' with: [				spec requires: #('Glamour-Core' ). ];			package: 'Glamour-Morphic-Brick' with: [				spec requires: #('Glamour-Core' ). ];			package: 'Glamour-Morphic-Brick-Tests' with: [				spec requires: #('Glamour-Morphic-Brick' ). ];			package: 'Glamour-Tests-Core';			package: 'Glamour-Tests-Resources';			package: 'Glamour-Morphic-Theme' with: [				spec requires: #('Rubric' ). ];			package: 'Glamour-Morphic-Widgets' with: [				spec requires: #('Rubric' 'Glamour-Morphic-Brick' ). ];			package: 'Glamour-Morphic-Renderer' with: [				spec requires: #('Glamour-Morphic-Widgets' 'Glamour-Core' ). ];			package: 'Glamour-Morphic-Pager' with: [				spec requires: #('Glamour-Morphic-Renderer' 'Glamour-Morphic-Brick' ). ];			package: 'Glamour-Tests-Morphic' with: [				spec requires: #('Glamour-Morphic-Renderer' 'Glamour-Morphic-Brick' 'Glamour-Morphic-Pager' ). ];			package: 'Glamour-Rubric-Presentations' with: [				spec requires: #('Rubric' 'Glamour-Presentations' ). ];			package: 'Glamour-Tests-Rubric' with: [				spec requires: #('Glamour-Tests-Morphic' 'Glamour-Rubric-Presentations' ). ].		spec 			group: 'Core' with: #('Glamour-Announcements' 'Glamour-Helpers' 'Glamour-Core' 'Glamour-Presentations' 'Glamour-Browsers' 'Glamour-Examples' 'Glamour-Rubric-Presentations' );			group: 'Morphic' with: #('Glamour-Morphic-Brick' 'Glamour-Morphic-Widgets' 'Glamour-Morphic-Renderer' 'Glamour-Morphic-Theme' 'Glamour-Morphic-Pager' 'Glamour-FastTable' );			group: 'Tests' with: #('Glamour-Tests-Core' 'Glamour-Tests-Morphic' 'Glamour-Tests-Rubric' 'Glamour-Tests-Resources' 'Glamour-Morphic-Brick-Tests' );			group: 'default' with: #('Core' 'Morphic' 'Tests' ). ].! !!ConfigurationOfGlamourCore methodsFor: 'baselines' stamp: 'AndreiChis 6/24/2016 09:10'!baseline34: spec	<version: '3.4-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec description: 'Removed Rubric dependency'.		spec repository: 'http://smalltalkhub.com/mc/Moose/Glamour/main'.				spec project: 'FastTable' with: [				spec					className: #ConfigurationOfFastTable;					versionString: #'development';					repository: 'http://smalltalkhub.com/mc/estebanlm/FastTable/main/' ].		spec 			package: 'Glamour-Announcements';			package: 'Glamour-Helpers';			package: 'Glamour-FastTable' with: [				spec requires: #('FastTable' 'Glamour-Examples' 'Glamour-Core' 'Glamour-Morphic-Renderer' 'Glamour-Tests-Morphic'). ];			package: 'Glamour-Core' with: [				spec requires: #('Glamour-Helpers' 'Glamour-Announcements' ). ];			package: 'Glamour-Presentations' with: [				spec requires: #('Glamour-Core' ). ];			package: 'Glamour-Browsers' with: [				spec requires: #('Glamour-Core' ). ];			package: 'Glamour-Examples' with: [				spec requires: #('Glamour-Core' ). ];			package: 'Glamour-Morphic-Brick' with: [				spec requires: #('Glamour-Core' ). ];			package: 'Glamour-Morphic-Brick-Tests' with: [				spec requires: #('Glamour-Morphic-Brick' ). ];			package: 'Glamour-Tests-Core';			package: 'Glamour-Tests-Resources';			package: 'Glamour-Morphic-Theme';			package: 'Glamour-Morphic-Widgets' with: [				spec requires: #('Glamour-Morphic-Brick' ). ];			package: 'Glamour-Morphic-Renderer' with: [				spec requires: #('Glamour-Morphic-Widgets' 'Glamour-Core' ). ];			package: 'Glamour-Morphic-Pager' with: [				spec requires: #('Glamour-Morphic-Renderer' 'Glamour-Morphic-Brick' ). ];			package: 'Glamour-Tests-Morphic' with: [				spec requires: #('Glamour-Morphic-Renderer' 'Glamour-Morphic-Brick' 'Glamour-Morphic-Pager' ). ];			package: 'Glamour-Rubric-Presentations' with: [				spec requires: #('Glamour-Presentations' ). ];			package: 'Glamour-Tests-Rubric' with: [				spec requires: #('Glamour-Tests-Morphic' 'Glamour-Rubric-Presentations' ). ].		spec 			group: 'Core' with: #('Glamour-Announcements' 'Glamour-Helpers' 'Glamour-Core' 'Glamour-Presentations' 'Glamour-Browsers' 'Glamour-Examples' 'Glamour-Rubric-Presentations' );			group: 'Morphic' with: #('Glamour-Morphic-Brick' 'Glamour-Morphic-Widgets' 'Glamour-Morphic-Renderer' 'Glamour-Morphic-Theme' 'Glamour-Morphic-Pager' 'Glamour-FastTable' );			group: 'Tests' with: #('Glamour-Tests-Core' 'Glamour-Tests-Morphic' 'Glamour-Tests-Rubric' 'Glamour-Tests-Resources' 'Glamour-Morphic-Brick-Tests' );			group: 'default' with: #('Core' 'Morphic' 'Tests' ). ].! !!ConfigurationOfGlamourCore methodsFor: 'baselines' stamp: 'TudorGirba 8/17/2016 07:43'!baseline40: spec	<version: '4.0-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec description: 'For Pharo 6.0'.		spec repository: 'http://smalltalkhub.com/mc/Moose/Glamour/main'.				spec project: 'FastTable' with: [				spec					className: #ConfigurationOfFastTable;					versionString: #'development';					repository: 'http://smalltalkhub.com/mc/estebanlm/FastTable/main/' ].		spec 			package: 'Glamour-Announcements';			package: 'Glamour-Helpers';			package: 'Glamour-FastTable' with: [				spec requires: #('FastTable' 'Glamour-Examples' 'Glamour-Core' 'Glamour-Morphic-Renderer' 'Glamour-Tests-Morphic'). ];			package: 'Glamour-Core' with: [				spec requires: #('Glamour-Helpers' 'Glamour-Announcements' ). ];			package: 'Glamour-Presentations' with: [				spec requires: #('Glamour-Core' ). ];			package: 'Glamour-Browsers' with: [				spec requires: #('Glamour-Core' ). ];			package: 'Glamour-Examples' with: [				spec requires: #('Glamour-Core' ). ];			package: 'Glamour-Morphic-Brick' with: [				spec requires: #('Glamour-Core' ). ];			package: 'Glamour-Morphic-Brick-Tests' with: [				spec requires: #('Glamour-Morphic-Brick' ). ];			package: 'Glamour-Tests-Core';			package: 'Glamour-Tests-Resources';			package: 'Glamour-Morphic-Theme';			package: 'Glamour-Morphic-Widgets' with: [				spec requires: #('Glamour-Morphic-Brick' ). ];			package: 'Glamour-Morphic-Renderer' with: [				spec requires: #('Glamour-Morphic-Widgets' 'Glamour-Core' ). ];			package: 'Glamour-Morphic-Pager' with: [				spec requires: #('Glamour-Morphic-Renderer' 'Glamour-Morphic-Brick' ). ];			package: 'Glamour-Tests-Morphic' with: [				spec requires: #('Glamour-Morphic-Renderer' 'Glamour-Morphic-Brick' 'Glamour-Morphic-Pager' ). ];			package: 'Glamour-Rubric-Presentations' with: [				spec requires: #('Glamour-Presentations' ). ];			package: 'Glamour-Tests-Rubric' with: [				spec requires: #('Glamour-Tests-Morphic' 'Glamour-Rubric-Presentations' ). ].		spec 			group: 'Core' with: #('Glamour-Announcements' 'Glamour-Helpers' 'Glamour-Core' 'Glamour-Presentations' 'Glamour-Browsers' 'Glamour-Examples' 'Glamour-Rubric-Presentations' );			group: 'Morphic' with: #('Glamour-Morphic-Brick' 'Glamour-Morphic-Widgets' 'Glamour-Morphic-Renderer' 'Glamour-Morphic-Theme' 'Glamour-Morphic-Pager' 'Glamour-FastTable' );			group: 'Tests' with: #('Glamour-Tests-Core' 'Glamour-Tests-Morphic' 'Glamour-Tests-Rubric' 'Glamour-Tests-Resources' 'Glamour-Morphic-Brick-Tests' );			group: 'default' with: #('Core' 'Morphic' 'Tests' ). ].! !!ConfigurationOfGlamourCore methodsFor: 'symbolic versions' stamp: 'AndreiChis 10/4/2016 12:00' prior: 20526478!development: spec	<symbolicVersion: #'development'>	spec for: #'common' version: '4.0-baseline'.	spec for: #'pharo4.x' version: '3.1.4.Moose51'.	spec for: #'pharo5.x' version: '4.19'.	spec for: #'pharo6.x' version: '4.0-baseline'.! !!ConfigurationOfGlamourCore methodsFor: 'symbolic versions' stamp: 'PabloTesone 10/20/2016 16:17' prior: 20555380!stable: spec	<symbolicVersion: #'stable'>	spec for: #'common' version: '4.23'.	spec for: #'pharo3.x' version: '3.0.7'.	spec for: #'pharo4.x' version: '3.1.4.Moose51'.	spec for: #'pharo5.x' version: '4.19.1'.	spec for: #'pharo6.x' version: '4.23'.! !!ConfigurationOfGlamourCore methodsFor: 'versions' stamp: 'AndreiChis 5/31/2016 15:10'!version415: spec	<version: '4.15' imports: #('3.3-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'Glamour version 4.15'.		spec author: 'AndreiChis'.		spec timestamp: '5/31/2016 15:02'.		spec 			project: 'Rubric' with: '2.19.3';			project: 'FastTable' with: '0.10.2'.		spec 			package: 'Glamour-Announcements' with: 'Glamour-Announcements-AndreiChis.8';			package: 'Glamour-Helpers' with: 'Glamour-Helpers-TudorGirba.40';			package: 'Glamour-FastTable' with: 'Glamour-FastTable-AndreiChis.59';			package: 'Glamour-Core' with: 'Glamour-Core-TudorGirba.322';			package: 'Glamour-Presentations' with: 'Glamour-Presentations-AndreiChis.186';			package: 'Glamour-Browsers' with: 'Glamour-Browsers-AndreiChis.112';			package: 'Glamour-Examples' with: 'Glamour-Examples-TudorGirba.303';			package: 'Glamour-Morphic-Brick' with: 'Glamour-Morphic-Brick-AndreiChis.421';			package: 'Glamour-Morphic-Brick-Tests' with: 'Glamour-Morphic-Brick-Tests-TheIntegrator.14';			package: 'Glamour-Tests-Core' with: 'Glamour-Tests-Core-CyrilFerlciot.112';			package: 'Glamour-Tests-Resources' with: 'Glamour-Tests-Resources-AndreiChis.5';			package: 'Glamour-Morphic-Theme' with: 'Glamour-Morphic-Theme-HenrikNergaard.222';			package: 'Glamour-Morphic-Widgets' with: 'Glamour-Morphic-Widgets-AndreiChis.195';			package: 'Glamour-Morphic-Renderer' with: 'Glamour-Morphic-Renderer-AndreiChis.349';			package: 'Glamour-Morphic-Pager' with: 'Glamour-Morphic-Pager-GuillermoPolito.110';			package: 'Glamour-Tests-Morphic' with: 'Glamour-Tests-Morphic-TudorGirba.137';			package: 'Glamour-Rubric-Presentations' with: 'Glamour-Rubric-Presentations-TheIntegrator.54';			package: 'Glamour-Tests-Rubric' with: 'Glamour-Tests-Rubric-AndreiChis.35'. ].! !!ConfigurationOfGlamourCore methodsFor: 'versions' stamp: 'PavelKrivanek 6/6/2016 16:08'!version416: spec	<version: '4.16' imports: #('3.3-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'Glamour version 4.16'.		spec author: 'PavelKrivanek'.		spec timestamp: '6/5/2016 16:02'.		spec 			project: 'Rubric' with: '2.19.3';			project: 'FastTable' with: '0.10.2'.		spec 			package: 'Glamour-Announcements' with: 'Glamour-Announcements-AndreiChis.8';			package: 'Glamour-Helpers' with: 'Glamour-Helpers-TudorGirba.40';			package: 'Glamour-FastTable' with: 'Glamour-FastTable-AndreiChis.59';			package: 'Glamour-Core' with: 'Glamour-Core-TudorGirba.322';			package: 'Glamour-Presentations' with: 'Glamour-Presentations-AndreiChis.186';			package: 'Glamour-Browsers' with: 'Glamour-Browsers-AndreiChis.112';			package: 'Glamour-Examples' with: 'Glamour-Examples-TudorGirba.303';			package: 'Glamour-Morphic-Brick' with: 'Glamour-Morphic-Brick-AndreiChis.421';			package: 'Glamour-Morphic-Brick-Tests' with: 'Glamour-Morphic-Brick-Tests-TheIntegrator.14';			package: 'Glamour-Tests-Core' with: 'Glamour-Tests-Core-PavelKrivanek.113';			package: 'Glamour-Tests-Resources' with: 'Glamour-Tests-Resources-AndreiChis.5';			package: 'Glamour-Morphic-Theme' with: 'Glamour-Morphic-Theme-HenrikNergaard.222';			package: 'Glamour-Morphic-Widgets' with: 'Glamour-Morphic-Widgets-AndreiChis.195';			package: 'Glamour-Morphic-Renderer' with: 'Glamour-Morphic-Renderer-AndreiChis.349';			package: 'Glamour-Morphic-Pager' with: 'Glamour-Morphic-Pager-GuillermoPolito.110';			package: 'Glamour-Tests-Morphic' with: 'Glamour-Tests-Morphic-TudorGirba.137';			package: 'Glamour-Rubric-Presentations' with: 'Glamour-Rubric-Presentations-TheIntegrator.54';			package: 'Glamour-Tests-Rubric' with: 'Glamour-Tests-Rubric-AndreiChis.35'. ].! !!ConfigurationOfGlamourCore methodsFor: 'versions' stamp: 'AndreiChis 6/27/2016 12:09'!version417: spec	<version: '4.17' imports: #('3.4-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'GToolkit Version 3.23'.		spec author: 'AndreiChis'.		spec timestamp: '6/27/2016 12:09'.		spec project: 'FastTable' with: '0.10.2'.		spec 			package: 'Glamour-Announcements' with: 'Glamour-Announcements-AndreiChis.8';			package: 'Glamour-Helpers' with: 'Glamour-Helpers-TudorGirba.40';			package: 'Glamour-FastTable' with: 'Glamour-FastTable-AndreiChis.59';			package: 'Glamour-Core' with: 'Glamour-Core-EstebanLorenzano.323';			package: 'Glamour-Presentations' with: 'Glamour-Presentations-AndreiChis.186';			package: 'Glamour-Browsers' with: 'Glamour-Browsers-AndreiChis.112';			package: 'Glamour-Examples' with: 'Glamour-Examples-TudorGirba.307';			package: 'Glamour-Morphic-Brick' with: 'Glamour-Morphic-Brick-HenrikNergaard.424';			package: 'Glamour-Morphic-Brick-Tests' with: 'Glamour-Morphic-Brick-Tests-TheIntegrator.14';			package: 'Glamour-Tests-Core' with: 'Glamour-Tests-Core-PavelKrivanek.113';			package: 'Glamour-Tests-Resources' with: 'Glamour-Tests-Resources-AndreiChis.5';			package: 'Glamour-Morphic-Theme' with: 'Glamour-Morphic-Theme-TheIntegrator.224';			package: 'Glamour-Morphic-Widgets' with: 'Glamour-Morphic-Widgets-EstebanLorenzano.197';			package: 'Glamour-Morphic-Renderer' with: 'Glamour-Morphic-Renderer-EstebanLorenzano.350';			package: 'Glamour-Morphic-Pager' with: 'Glamour-Morphic-Pager-GuillermoPolito.110';			package: 'Glamour-Tests-Morphic' with: 'Glamour-Tests-Morphic-TudorGirba.137';			package: 'Glamour-Rubric-Presentations' with: 'Glamour-Rubric-Presentations-TheIntegrator.54';			package: 'Glamour-Tests-Rubric' with: 'Glamour-Tests-Rubric-AndreiChis.35'. ].! !!ConfigurationOfGlamourCore methodsFor: 'versions' stamp: 'JurajKubelka 7/21/2016 17:44'!version418: spec	<version: '4.18' imports: #('3.4-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'Integration for case 18773.Fixes these issues:- case 18691- case 18471- case 18244- case 18708Apart from the issues:- GT-InspectorExtensions: only show methods for the current class, added basic example for RBCondition- Uses Pragma>>#methodSelector instead of Pragma>>#selector (case 18665).- Uses Behavior>>#classLayout instead of Behavior>>#layout (case 16636).- Uses CompiledMethod>>#sourceCode instead of CompiledMethod>>#getSource (case 18694).- GT-EventRecorder: Add a basic recorder event'.		spec author: 'JurajKubelka'.		spec timestamp: '7/13/2016 10:05'.		spec project: 'FastTable' with: '0.10.2'.		spec 			package: 'Glamour-Announcements' with: 'Glamour-Announcements-AndreiChis.8';			package: 'Glamour-Helpers' with: 'Glamour-Helpers-TudorGirba.40';			package: 'Glamour-FastTable' with: 'Glamour-FastTable-AndreiChis.59';			package: 'Glamour-Core' with: 'Glamour-Core-EstebanLorenzano.323';			package: 'Glamour-Presentations' with: 'Glamour-Presentations-AndreiChis.186';			package: 'Glamour-Browsers' with: 'Glamour-Browsers-AndreiChis.112';			package: 'Glamour-Examples' with: 'Glamour-Examples-TheIntegrator.309';			package: 'Glamour-Morphic-Brick' with: 'Glamour-Morphic-Brick-JurajKubelka.428';			package: 'Glamour-Morphic-Brick-Tests' with: 'Glamour-Morphic-Brick-Tests-JurajKubelka.15';			package: 'Glamour-Tests-Core' with: 'Glamour-Tests-Core-PavelKrivanek.113';			package: 'Glamour-Tests-Resources' with: 'Glamour-Tests-Resources-AndreiChis.5';			package: 'Glamour-Morphic-Theme' with: 'Glamour-Morphic-Theme-TheIntegrator.224';			package: 'Glamour-Morphic-Widgets' with: 'Glamour-Morphic-Widgets-EstebanLorenzano.197';			package: 'Glamour-Morphic-Renderer' with: 'Glamour-Morphic-Renderer-EstebanLorenzano.350';			package: 'Glamour-Morphic-Pager' with: 'Glamour-Morphic-Pager-GuillermoPolito.110';			package: 'Glamour-Tests-Morphic' with: 'Glamour-Tests-Morphic-TudorGirba.137';			package: 'Glamour-Rubric-Presentations' with: 'Glamour-Rubric-Presentations-TheIntegrator.54';			package: 'Glamour-Tests-Rubric' with: 'Glamour-Tests-Rubric-AndreiChis.35'. ].! !!ConfigurationOfGlamourCore methodsFor: 'versions' stamp: 'PabloTesone 10/20/2016 16:16'!version4191: spec	<version: '4.19.1' imports: #('3.3-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'Stable version for Pharo 5.0.'.		spec author: 'JurajKubelka'.		spec timestamp: '7/14/2016 13:46'.		spec 			project: 'Rubric' with: '2.19.3';			project: 'FastTable' with: '0.10.2'.		spec 			package: 'Glamour-Announcements' with: 'Glamour-Announcements-AndreiChis.8';			package: 'Glamour-Helpers' with: 'Glamour-Helpers-TudorGirba.40';			package: 'Glamour-FastTable' with: 'Glamour-FastTable-AndreiChis.59';			package: 'Glamour-Core' with: 'Glamour-Core-EstebanLorenzano.323';			package: 'Glamour-Presentations' with: 'Glamour-Presentations-AndreiChis.186';			package: 'Glamour-Browsers' with: 'Glamour-Browsers-AndreiChis.112';			package: 'Glamour-Examples' with: 'Glamour-Examples-TudorGirba.303';			package: 'Glamour-Morphic-Brick' with: 'Glamour-Morphic-Brick-GuillermoPolito.418';			package: 'Glamour-Morphic-Brick-Tests' with: 'Glamour-Morphic-Brick-Tests-TheIntegrator.14';			package: 'Glamour-Tests-Core' with: 'Glamour-Tests-Core-AndreiChis.111';			package: 'Glamour-Tests-Resources' with: 'Glamour-Tests-Resources-AndreiChis.5';			package: 'Glamour-Morphic-Theme' with: 'Glamour-Morphic-Theme-HenrikNergaard.222';			package: 'Glamour-Morphic-Widgets' with: 'Glamour-Morphic-Widgets-AndreiChis.195';			package: 'Glamour-Morphic-Renderer' with: 'Glamour-Morphic-Renderer-AndreiChis.349';			package: 'Glamour-Morphic-Pager' with: 'Glamour-Morphic-Pager-GuillermoPolito.110';			package: 'Glamour-Tests-Morphic' with: 'Glamour-Tests-Morphic-TudorGirba.137';			package: 'Glamour-Rubric-Presentations' with: 'Glamour-Rubric-Presentations-AndreiChis.52';			package: 'Glamour-Tests-Rubric' with: 'Glamour-Tests-Rubric-AndreiChis.35'. ].! !!ConfigurationOfGlamourCore methodsFor: 'versions' stamp: 'JurajKubelka 7/14/2016 13:46'!version419: spec	<version: '4.19' imports: #('3.3-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'Stable version for Pharo 5.0.'.		spec author: 'JurajKubelka'.		spec timestamp: '7/14/2016 13:46'.		spec 			project: 'Rubric' with: '2.19.3';			project: 'FastTable' with: '0.10.2'.		spec 			package: 'Glamour-Announcements' with: 'Glamour-Announcements-AndreiChis.8';			package: 'Glamour-Helpers' with: 'Glamour-Helpers-TudorGirba.40';			package: 'Glamour-FastTable' with: 'Glamour-FastTable-AndreiChis.59';			package: 'Glamour-Core' with: 'Glamour-Core-TudorGirba.322';			package: 'Glamour-Presentations' with: 'Glamour-Presentations-AndreiChis.186';			package: 'Glamour-Browsers' with: 'Glamour-Browsers-AndreiChis.112';			package: 'Glamour-Examples' with: 'Glamour-Examples-TudorGirba.303';			package: 'Glamour-Morphic-Brick' with: 'Glamour-Morphic-Brick-GuillermoPolito.418';			package: 'Glamour-Morphic-Brick-Tests' with: 'Glamour-Morphic-Brick-Tests-TheIntegrator.14';			package: 'Glamour-Tests-Core' with: 'Glamour-Tests-Core-AndreiChis.111';			package: 'Glamour-Tests-Resources' with: 'Glamour-Tests-Resources-AndreiChis.5';			package: 'Glamour-Morphic-Theme' with: 'Glamour-Morphic-Theme-HenrikNergaard.222';			package: 'Glamour-Morphic-Widgets' with: 'Glamour-Morphic-Widgets-AndreiChis.195';			package: 'Glamour-Morphic-Renderer' with: 'Glamour-Morphic-Renderer-AndreiChis.349';			package: 'Glamour-Morphic-Pager' with: 'Glamour-Morphic-Pager-GuillermoPolito.110';			package: 'Glamour-Tests-Morphic' with: 'Glamour-Tests-Morphic-TudorGirba.137';			package: 'Glamour-Rubric-Presentations' with: 'Glamour-Rubric-Presentations-AndreiChis.52';			package: 'Glamour-Tests-Rubric' with: 'Glamour-Tests-Rubric-AndreiChis.35'. ].! !!ConfigurationOfGlamourCore methodsFor: 'versions' stamp: 'JurajKubelka 7/21/2016 18:13'!version420: spec	<version: '4.20' imports: #('3.4-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'Prevent infinite loop in GLMScrollListBrick>>#preventOverscrolling - in some cases it was moving band to the top and to the bottom.'.		spec author: 'JurajKubelka'.		spec timestamp: '7/21/2016 18:05'.		spec project: 'FastTable' with: #stable.		spec 			package: 'Glamour-Announcements' with: 'Glamour-Announcements-AndreiChis.8';			package: 'Glamour-Helpers' with: 'Glamour-Helpers-TudorGirba.40';			package: 'Glamour-FastTable' with: 'Glamour-FastTable-AndreiChis.59';			package: 'Glamour-Core' with: 'Glamour-Core-EstebanLorenzano.323';			package: 'Glamour-Presentations' with: 'Glamour-Presentations-AndreiChis.186';			package: 'Glamour-Browsers' with: 'Glamour-Browsers-AndreiChis.112';			package: 'Glamour-Examples' with: 'Glamour-Examples-TheIntegrator.309';			package: 'Glamour-Morphic-Brick' with: 'Glamour-Morphic-Brick-JurajKubelka.429';			package: 'Glamour-Morphic-Brick-Tests' with: 'Glamour-Morphic-Brick-Tests-JurajKubelka.15';			package: 'Glamour-Tests-Core' with: 'Glamour-Tests-Core-PavelKrivanek.113';			package: 'Glamour-Tests-Resources' with: 'Glamour-Tests-Resources-AndreiChis.5';			package: 'Glamour-Morphic-Theme' with: 'Glamour-Morphic-Theme-TheIntegrator.224';			package: 'Glamour-Morphic-Widgets' with: 'Glamour-Morphic-Widgets-EstebanLorenzano.197';			package: 'Glamour-Morphic-Renderer' with: 'Glamour-Morphic-Renderer-EstebanLorenzano.350';			package: 'Glamour-Morphic-Pager' with: 'Glamour-Morphic-Pager-GuillermoPolito.110';			package: 'Glamour-Tests-Morphic' with: 'Glamour-Tests-Morphic-TudorGirba.137';			package: 'Glamour-Rubric-Presentations' with: 'Glamour-Rubric-Presentations-TheIntegrator.54';			package: 'Glamour-Tests-Rubric' with: 'Glamour-Tests-Rubric-AndreiChis.35'. ].! !!ConfigurationOfGlamourCore methodsFor: 'versions' stamp: 'AndreiChis 8/25/2016 12:26'!version421: spec	<version: '4.21' imports: #('4.0-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 4.12'.		spec author: 'AndreiChis'.		spec timestamp: '8/25/2016 12:26'.		spec project: 'FastTable' with: '0.10.3'.		spec 			package: 'Glamour-Announcements' with: 'Glamour-Announcements-AndreiChis.8';			package: 'Glamour-Helpers' with: 'Glamour-Helpers-TudorGirba.40';			package: 'Glamour-FastTable' with: 'Glamour-FastTable-AndreiChis.59';			package: 'Glamour-Core' with: 'Glamour-Core-EstebanLorenzano.323';			package: 'Glamour-Presentations' with: 'Glamour-Presentations-AndreiChis.186';			package: 'Glamour-Browsers' with: 'Glamour-Browsers-AndreiChis.112';			package: 'Glamour-Examples' with: 'Glamour-Examples-MarcusDenker.310';			package: 'Glamour-Morphic-Brick' with: 'Glamour-Morphic-Brick-JurajKubelka.429';			package: 'Glamour-Morphic-Brick-Tests' with: 'Glamour-Morphic-Brick-Tests-JurajKubelka.15';			package: 'Glamour-Tests-Core' with: 'Glamour-Tests-Core-PavelKrivanek.113';			package: 'Glamour-Tests-Resources' with: 'Glamour-Tests-Resources-AndreiChis.5';			package: 'Glamour-Morphic-Theme' with: 'Glamour-Morphic-Theme-TheIntegrator.224';			package: 'Glamour-Morphic-Widgets' with: 'Glamour-Morphic-Widgets-EstebanLorenzano.197';			package: 'Glamour-Morphic-Renderer' with: 'Glamour-Morphic-Renderer-EstebanLorenzano.351';			package: 'Glamour-Morphic-Pager' with: 'Glamour-Morphic-Pager-GuillermoPolito.110';			package: 'Glamour-Tests-Morphic' with: 'Glamour-Tests-Morphic-TudorGirba.137';			package: 'Glamour-Rubric-Presentations' with: 'Glamour-Rubric-Presentations-TheIntegrator.54';			package: 'Glamour-Tests-Rubric' with: 'Glamour-Tests-Rubric-AndreiChis.35'. ].! !!ConfigurationOfGlamourCore methodsFor: 'versions' stamp: 'AndreiChis 9/22/2016 23:31'!version422: spec	<version: '4.22' imports: #('4.0-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'GToolkit Version 3.28'.		spec author: 'AndreiChis'.		spec timestamp: '9/22/2016 23:31'.		spec project: 'FastTable' with: '0.10.4'.		spec 			package: 'Glamour-Announcements' with: 'Glamour-Announcements-AndreiChis.8';			package: 'Glamour-Helpers' with: 'Glamour-Helpers-TudorGirba.40';			package: 'Glamour-FastTable' with: 'Glamour-FastTable-AndreiChis.59';			package: 'Glamour-Core' with: 'Glamour-Core-EstebanLorenzano.323';			package: 'Glamour-Presentations' with: 'Glamour-Presentations-AndreiChis.186';			package: 'Glamour-Browsers' with: 'Glamour-Browsers-AndreiChis.112';			package: 'Glamour-Examples' with: 'Glamour-Examples-MarcusDenker.310';			package: 'Glamour-Morphic-Brick' with: 'Glamour-Morphic-Brick-MarcusDenker.430';			package: 'Glamour-Morphic-Brick-Tests' with: 'Glamour-Morphic-Brick-Tests-JurajKubelka.15';			package: 'Glamour-Tests-Core' with: 'Glamour-Tests-Core-PavelKrivanek.113';			package: 'Glamour-Tests-Resources' with: 'Glamour-Tests-Resources-AndreiChis.5';			package: 'Glamour-Morphic-Theme' with: 'Glamour-Morphic-Theme-TheIntegrator.227';			package: 'Glamour-Morphic-Widgets' with: 'Glamour-Morphic-Widgets-EstebanLorenzano.197';			package: 'Glamour-Morphic-Renderer' with: 'Glamour-Morphic-Renderer-EstebanLorenzano.351';			package: 'Glamour-Morphic-Pager' with: 'Glamour-Morphic-Pager-GuillermoPolito.110';			package: 'Glamour-Tests-Morphic' with: 'Glamour-Tests-Morphic-TudorGirba.137';			package: 'Glamour-Rubric-Presentations' with: 'Glamour-Rubric-Presentations-TheIntegrator.54';			package: 'Glamour-Tests-Rubric' with: 'Glamour-Tests-Rubric-AndreiChis.35'. ].! !!ConfigurationOfGlamourCore methodsFor: 'versions' stamp: 'AndreiChis 10/4/2016 12:00'!version423: spec	<version: '4.23' imports: #('4.0-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'GToolkit Version 3.29'.		spec author: 'AndreiChis'.		spec timestamp: '10/4/2016 12:00'.		spec project: 'FastTable' with: '0.10.4'.		spec 			package: 'Glamour-Announcements' with: 'Glamour-Announcements-AndreiChis.8';			package: 'Glamour-Helpers' with: 'Glamour-Helpers-TudorGirba.40';			package: 'Glamour-FastTable' with: 'Glamour-FastTable-AndreiChis.59';			package: 'Glamour-Core' with: 'Glamour-Core-EstebanLorenzano.323';			package: 'Glamour-Presentations' with: 'Glamour-Presentations-AndreiChis.186';			package: 'Glamour-Browsers' with: 'Glamour-Browsers-AndreiChis.112';			package: 'Glamour-Examples' with: 'Glamour-Examples-MarcusDenker.310';			package: 'Glamour-Morphic-Brick' with: 'Glamour-Morphic-Brick-MarcusDenker.430';			package: 'Glamour-Morphic-Brick-Tests' with: 'Glamour-Morphic-Brick-Tests-JurajKubelka.15';			package: 'Glamour-Tests-Core' with: 'Glamour-Tests-Core-PavelKrivanek.113';			package: 'Glamour-Tests-Resources' with: 'Glamour-Tests-Resources-AndreiChis.5';			package: 'Glamour-Morphic-Theme' with: 'Glamour-Morphic-Theme-TheIntegrator.229';			package: 'Glamour-Morphic-Widgets' with: 'Glamour-Morphic-Widgets-EstebanLorenzano.197';			package: 'Glamour-Morphic-Renderer' with: 'Glamour-Morphic-Renderer-EstebanLorenzano.351';			package: 'Glamour-Morphic-Pager' with: 'Glamour-Morphic-Pager-GuillermoPolito.110';			package: 'Glamour-Tests-Morphic' with: 'Glamour-Tests-Morphic-TudorGirba.137';			package: 'Glamour-Rubric-Presentations' with: 'Glamour-Rubric-Presentations-TheIntegrator.56';			package: 'Glamour-Tests-Rubric' with: 'Glamour-Tests-Rubric-AndreiChis.35'. ].! !"ConfigurationOfGlamourCore"!!GLMPresentation methodsFor: 'scripting actions' stamp: 'EstebanLorenzano 6/17/2016 11:09'!selectionAct: aBlock entitled: aString enabledWhen: conditionBlock	 	self 		addSelectionAction: 			((GLMGenericAction new) 				action: aBlock; 				title: aString;				enabledCondition: conditionBlock; 				yourself)! !!GLMAction methodsFor: 'accessing' stamp: 'EstebanLorenzano 6/17/2016 11:12'!enabledCondition	^ enabledCondition ifNil: [ true ]! !!GLMAction methodsFor: 'accessing' stamp: 'EstebanLorenzano 6/17/2016 11:05'!enabledCondition: anObject	enabledCondition := anObject! !!GLMAction methodsFor: 'testing' stamp: 'EstebanLorenzano 6/17/2016 11:15'!isEnabledOn: aPresentation	^ self enabledCondition glamourValueWithArgs: 			(Array 				with: aPresentation 				withAll: aPresentation entity asGlamorousArray)! !"Glamour-Core"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo50/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader50-TheIntegrator.976.mcz') load.ScriptLoader new update50762.!----End fileIn----!----QUIT----2016-10-25T10:09:35.559139+02:00 Pharo.image priorSource: 235226!----QUIT----2016-10-25T10:09:40.959669+02:00 Pharo.image priorSource: 281774!----QUIT----2016-10-30T01:04:00.175059+02:00 Pharo.image priorSource: 281853!----QUIT----2016-10-30T01:04:05.851847+02:00 Pharo.image priorSource: 281932!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 11/22/2016 11:34' prior: 33789836!commentForCurrentUpdate ^ '18918 Typo on welcome screen	https://pharo.fogbugz.com/f/cases/18918'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 11/22/2016 11:34'!script50763	^ 'AST-Core-TheIntegrator.418.mczAST-FFI-Pharo50Compatibility-TheIntegrator.2.mczAST-Tests-Core-TheIntegrator.95.mczAlien-eem.32.mczAnnouncements-Core-TheIntegrator.68.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.31.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-NicolaiHess.123.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-EstebanLorenzano.63.mczAthens-Text-NicolaiHess.16.mczBalloon-TheIntegrator.132.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfFileTree-ThierryGoubier.15.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfQualityAssistant-YuriyTymchuk.46.mczBaselineOfRenraku-YuriyTymchuk.5.mczBlueInk-Core-TheIntegrator.24.mczBlueInk-Extras-TheIntegrator.10.mczBlueInk-Tests-TheIntegrator.12.mczChroma-CubeHelix-TheIntegrator.2.mczCodeExport-TheIntegrator.19.mczCodeImport-TheIntegrator.88.mczCodeImportCommandLineHandlers-TheIntegrator.7.mczCollections-Abstract-TheIntegrator.313.mczCollections-Arithmetic-TheIntegrator.20.mczCollections-Atomic-TheIntegrator.16.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.246.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.188.mczCollections-Strings-TheIntegrator.415.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.49.mczCollections-Unordered-TheIntegrator.232.mczCollections-Weak-TheIntegrator.102.mczCompiler-TheIntegrator.602.mczCompression-TheIntegrator.176.mczCompression-Tests-TheIntegrator.2.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.4.mczDebuggerActions-TheIntegrator.85.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.126.mczDeprecated50-TheIntegrator.59.mczEmbeddedFreeType-TheIntegrator.26.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczFFI-Kernel-JanVanDeSandt.40.mczFFI-Pools-eem.3.mczFileSystem-Core-TheIntegrator.202.mczFileSystem-Disk-TheIntegrator.97.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.95.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.417.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-TheIntegrator.17.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.14.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.742.mczFreeType-Tests-TheIntegrator.2.mczFuel-MaxLeske.825.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-TheIntegrator.62.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.411.mczFuelTools-Debugger-TheIntegrator.10.mczGT-BytecodeDebugger-TudorGirba.31.mczGT-Debugger-AndreiChis.350.mczGT-EventRecorder-TheIntegrator.68.mczGT-EventRecorder-Tests-JurajKubelka.37.mczGT-Inspector-AndreiChis.421.mczGT-InspectorExtensions-Core-TheIntegrator.214.mczGT-Playground-DenisKudryashov.124.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-TudorGirba.397.mczGT-Spotter-EventRecorder-GuillermoPolito.112.mczGT-SpotterExtensions-Core-VincentBlondeau.203.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-StefanReichhart.56.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AliakseiSyrel.17.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-EstebanLorenzano.323.mczGlamour-Examples-TudorGirba.303.mczGlamour-FastTable-AndreiChis.59.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-GuillermoPolito.418.mczGlamour-Morphic-Brick-Tests-TheIntegrator.14.mczGlamour-Morphic-Pager-GuillermoPolito.110.mczGlamour-Morphic-Renderer-AndreiChis.349.mczGlamour-Morphic-Theme-HenrikNergaard.222.mczGlamour-Morphic-Widgets-AndreiChis.195.mczGlamour-Presentations-AndreiChis.186.mczGlamour-Rubric-Presentations-AndreiChis.52.mczGlamour-Tests-Core-AndreiChis.111.mczGlamour-Tests-Morphic-TudorGirba.137.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.35.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.6.mczGraphics-Display Objects-TheIntegrator.175.mczGraphics-Files-TheIntegrator.76.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.189.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.80.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.41.mczHelpSystem-Core-TheIntegrator.144.mczHelpSystem-Tests-TheIntegrator.32.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.90.mczImportingResource-Help-TheIntegrator.4.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.28.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2293.mczKernel-Rules-TheIntegrator.2.mczKernel-Tests-TheIntegrator.65.mczKeymapping-Core-TheIntegrator.198.mczKeymapping-KeyCombinations-TheIntegrator.62.mczKeymapping-Pragmas-TheIntegrator.54.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.105.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.166.mczManifest-Core-TheIntegrator.239.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.51.mczMenuRegistration-TheIntegrator.78.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.824.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-EstebanLorenzano.733.mczMetacello-PharoCommonPlatform-TheIntegrator.22.mczMetacello-Platform-EstebanLorenzano.3.mczMetacello-ProfStef-EstebanLorenzano.18.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.7.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform.squeakCommon-EstebanLorenzano.23.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-EstebanLorenzano.148.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1132.mczMonticello-OldDataStreamCompatibility-TheIntegrator.8.mczMonticello-Tests-TheIntegrator.35.mczMonticelloConfigurations-TheIntegrator.72.mczMonticelloFileServices-TheIntegrator.6.mczMonticelloFileTree-Core-TheIntegrator.141.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.30.mczMonticelloGUI-TheIntegrator.415.mczMonticelloMocks-TheIntegrator.4.mczMonticelloRemoteRepositories-TheIntegrator.15.mczMoose-Algos-Graph-vincentBlondeau.31.mczMorphic-Base-TheIntegrator.546.mczMorphic-Core-TheIntegrator.278.mczMorphic-Examples-TheIntegrator.50.mczMorphic-Tests-TheIntegrator.11.mczMorphic-Widgets-Basic-TheIntegrator.86.mczMorphic-Widgets-ColorPicker-TheIntegrator.19.mczMorphic-Widgets-Extra-TheIntegrator.27.mczMorphic-Widgets-FastTable-StephanEggermont.177.mczMorphic-Widgets-List-TheIntegrator.21.mczMorphic-Widgets-NewList-TheIntegrator.9.mczMorphic-Widgets-Pluggable-TheIntegrator.66.mczMorphic-Widgets-PolyTabs-TheIntegrator.2.mczMorphic-Widgets-Scrolling-TheIntegrator.32.mczMorphic-Widgets-Tabs-TheIntegrator.20.mczMorphic-Widgets-Taskbar-TheIntegrator.21.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.50.mczMorphic-Widgets-Windows-TheIntegrator.97.mczMultilingual-Encodings-TheIntegrator.61.mczMultilingual-Languages-TheIntegrator.55.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.81.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.244.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1253.mczNautilus-GroupManager-TheIntegrator.20.mczNautilus-GroupManagerUI-TheIntegrator.31.mczNautilus-Tests-TheIntegrator.37.mczNautilusCommon-TheIntegrator.305.mczNautilusGroupAutoBuilder-TheIntegrator.11.mczNautilusRefactoring-TheIntegrator.272.mczNetwork-Kernel-TheIntegrator.133.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-EstebanLorenzano.47.mczNetwork-Protocols-TheIntegrator.103.mczNetwork-Tests-EstebanLorenzano.15.mczNetwork-UUID-TheIntegrator.44.mczNetwork-Url-MarcusDenker.99.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.55.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-RonieSalgado.107.mczOSWindow-SDL2-RonieSalgado.96.mczOSWindow-SDL2-Examples-RonieSalgado.13.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOpalCompiler-Core-TheIntegrator.799.mczOpalCompiler-Tests-TheIntegrator.334.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.31.mczPolymorph-TaskbarIcons-TheIntegrator.46.mczPolymorph-Widgets-TheIntegrator.1338.mczPragmaCollector-TheIntegrator.12.mczProfStef-Core-TheIntegrator.77.mczProfStef-Help-TheIntegrator.16.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.101.mczQualityAssistantRecording-YuriyTymchuk.20.mczRPackage-Core-TheIntegrator.430.mczRPackage-Tests-TheIntegrator.181.mczRandom-Core-TheIntegrator.4.mczRandom-Tests-TheIntegrator.4.mczRecentSubmissions-TheIntegrator.238.mczRefactoring-Changes-TheIntegrator.67.mczRefactoring-Core-TheIntegrator.298.mczRefactoring-Critics-TheIntegrator.261.mczRefactoring-Environment-TheIntegrator.76.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.131.mczRefactoring-Tests-Critics-TheIntegrator.38.mczRefactoring-Tests-Environment-TheIntegrator.23.mczReflectivity-TheIntegrator.297.mczReflectivity-Examples-TheIntegrator.28.mczReflectivity-Tests-TheIntegrator.202.mczReflectivity-Tools-TheIntegrator.24.mczReflectivity-Tools-Tests-TheIntegrator.11.mczRegex-Core-TheIntegrator.38.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.31.mczRenraku-YuriyTymchuk.111.mczRenraku-Test-YuriyTymchuk.19.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.237.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.90.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.364.mczRubric-Rules-YuriyTymchuk.3.mczSTON-Core-PavelKrivanek.73.mczSTON-Tests-SvenVanCaekenberghe.64.mczSUnit-Core-TheIntegrator.169.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.3.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-EstebanLorenzano.138.mczSUnit-UITesting-TheIntegrator.32.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.92.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TommasoDalSasso.3.mczShoreLine-Report-UI-TommasoDalSasso.17.mczShout-TheIntegrator.291.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.742.mczSlot-Tests-TheIntegrator.89.mczSmartSuggestions-TheIntegrator.234.mczSmartSuggestions-Tests-TheIntegrator.33.mczSpec-Core-TheIntegrator.465.mczSpec-Debugger-TheIntegrator.263.mczSpec-Examples-TheIntegrator.108.mczSpec-Help-TheIntegrator.10.mczSpec-Inspector-TheIntegrator.258.mczSpec-Layout-TheIntegrator.69.mczSpec-MorphicAdapters-TheIntegrator.269.mczSpec-PolyWidgets-TheIntegrator.66.mczSpec-Tests-TheIntegrator.63.mczSpec-Tools-TheIntegrator.324.mczStartupPreferences-TheIntegrator.149.mczSystem-Announcements-TheIntegrator.108.mczSystem-BasicCommandLineHandler-TheIntegrator.18.mczSystem-Caching-TheIntegrator.26.mczSystem-CachingTests-TheIntegrator.16.mczSystem-Changes-TheIntegrator.292.mczSystem-Changes-FileServices-TheIntegrator.2.mczSystem-Clipboard-TheIntegrator.40.mczSystem-CommandLine-TheIntegrator.181.mczSystem-CommandLine-TextSupport-TheIntegrator.4.mczSystem-CommandLineHandler-TheIntegrator.18.mczSystem-FileRegistry-TheIntegrator.50.mczSystem-Finalization-TheIntegrator.32.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.106.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.4.mczSystem-OSEnvironments-TheIntegrator.31.mczSystem-Object Events-TheIntegrator.25.mczSystem-Platforms-TheIntegrator.81.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.27.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.337.mczSystem-Settings-Tests-TheIntegrator.11.mczSystem-Sound-StephaneDucasse.18.mczSystem-Sources-TheIntegrator.50.mczSystem-Support-TheIntegrator.1215.mczSystem-SupportTests-TheIntegrator.2.mczSystem-VMEvents-TheIntegrator.17.mczTests-TheIntegrator.755.mczText-Core-TheIntegrator.50.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.114.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.140.mczTool-Catalog-GuillermoPolito.32.mczTool-CriticBrowser-TheIntegrator.21.mczTool-DependencyAnalyser-ChristopheDemarey.28.mczTool-DependencyAnalyser-Test-ChristopheDemarey.11.mczTool-DependencyAnalyser-UI-ChristopheDemarey.43.mczTool-Diff-TheIntegrator.31.mczTool-ExternalBrowser-TheIntegrator.49.mczTool-FileList-TheIntegrator.62.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.65.mczTool-ImageCleaner-TheIntegrator.17.mczTool-ProcessBrowser-TheIntegrator.20.mczTool-Profilers-TheIntegrator.22.mczTool-SystemReporter-TheIntegrator.15.mczTool-Transcript-TheIntegrator.25.mczTool-TxWorkspace-NicolaiHess.7.mczTool-Workspace-TheIntegrator.37.mczTools-TheIntegrator.1525.mczTools-Test-TheIntegrator.16.mczTraits-TheIntegrator.907.mczTranscript-TheIntegrator.50.mczTxText-Athens-GuillermoPolito.53.mczTxText-AthensTests-SeanDeNigris.10.mczTxText-Model-SeanDeNigris.61.mczTxText-Styler-MarcusDenker.17.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.187.mczUnicode-Initialization-TheIntegrator.15.mczUnifiedFFI-EstebanLorenzano.70.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.25.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-VincentBlondeau.32.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-StephaneDucasse.64.mczVersionner-Core-DependenciesModel-ChristopheDemarey.105.mczVersionner-Core-Model-ChristopheDemarey.52.mczVersionner-Spec-Browser-PabloTesone.189.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczZinc-Character-Encoding-Core-TheIntegrator.48.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.27.mczZinc-FileSystem-SvenVanCaekenberghe.12.mczZinc-HTTP-SvenVanCaekenberghe.448.mczZinc-Resource-Meta-Core-TheIntegrator.58.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.36.mczZinc-Tests-SvenVanCaekenberghe.236.mczZinc-Zodiac-TheIntegrator.37.mczZodiac-Core-SvenVanCaekenberghe.42.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.13.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 11/22/2016 11:34'!update50763	"self new update50763"	self withUpdateLog: '18918 Typo on welcome screen	https://pharo.fogbugz.com/f/cases/18918'.	self loadTogether: self script50763 merge: false.	(World windowsSatisfying: [ :window | 	(window label = 'Welcome to Pharo 5.0')]) do: #close.WelcomeHelp openForRelease.	self flushCaches.! !ScriptLoader removeSelector: #update50762!ScriptLoader removeSelector: #script50762!"ScriptLoader50"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo50/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader50-TheIntegrator.977.mcz') load.ScriptLoader new update50763.!----End fileIn----!----QUIT----2016-11-22T11:36:48.190434+01:00 Pharo.image priorSource: 282011!----QUIT----2016-11-22T11:36:59.50574+01:00 Pharo.image priorSource: 299311!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 11/25/2016 16:36' prior: 33836615!commentForCurrentUpdate ^ '19361 Morph>>#showActions broken	https://pharo.fogbugz.com/f/cases/19361'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 11/25/2016 16:36'!script50764	^ 'AST-Core-TheIntegrator.418.mczAST-FFI-Pharo50Compatibility-TheIntegrator.2.mczAST-Tests-Core-TheIntegrator.95.mczAlien-eem.32.mczAnnouncements-Core-TheIntegrator.68.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.31.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-NicolaiHess.123.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-EstebanLorenzano.63.mczAthens-Text-NicolaiHess.16.mczBalloon-TheIntegrator.132.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfFileTree-ThierryGoubier.15.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfQualityAssistant-YuriyTymchuk.46.mczBaselineOfRenraku-YuriyTymchuk.5.mczBlueInk-Core-TheIntegrator.24.mczBlueInk-Extras-TheIntegrator.10.mczBlueInk-Tests-TheIntegrator.12.mczChroma-CubeHelix-TheIntegrator.2.mczCodeExport-TheIntegrator.19.mczCodeImport-TheIntegrator.88.mczCodeImportCommandLineHandlers-TheIntegrator.7.mczCollections-Abstract-TheIntegrator.313.mczCollections-Arithmetic-TheIntegrator.20.mczCollections-Atomic-TheIntegrator.16.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.246.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.188.mczCollections-Strings-TheIntegrator.415.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.49.mczCollections-Unordered-TheIntegrator.232.mczCollections-Weak-TheIntegrator.102.mczCompiler-TheIntegrator.602.mczCompression-TheIntegrator.176.mczCompression-Tests-TheIntegrator.2.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.4.mczDebuggerActions-TheIntegrator.85.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.126.mczDeprecated50-TheIntegrator.59.mczEmbeddedFreeType-TheIntegrator.26.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczFFI-Kernel-JanVanDeSandt.40.mczFFI-Pools-eem.3.mczFileSystem-Core-TheIntegrator.202.mczFileSystem-Disk-TheIntegrator.97.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.95.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.417.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-TheIntegrator.17.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.14.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.742.mczFreeType-Tests-TheIntegrator.2.mczFuel-MaxLeske.825.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-TheIntegrator.62.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.411.mczFuelTools-Debugger-TheIntegrator.10.mczGT-BytecodeDebugger-TudorGirba.31.mczGT-Debugger-AndreiChis.350.mczGT-EventRecorder-TheIntegrator.68.mczGT-EventRecorder-Tests-JurajKubelka.37.mczGT-Inspector-AndreiChis.421.mczGT-InspectorExtensions-Core-TheIntegrator.214.mczGT-Playground-DenisKudryashov.124.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-TudorGirba.397.mczGT-Spotter-EventRecorder-GuillermoPolito.112.mczGT-SpotterExtensions-Core-VincentBlondeau.203.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-StefanReichhart.56.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AliakseiSyrel.17.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-EstebanLorenzano.323.mczGlamour-Examples-TudorGirba.303.mczGlamour-FastTable-AndreiChis.59.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-GuillermoPolito.418.mczGlamour-Morphic-Brick-Tests-TheIntegrator.14.mczGlamour-Morphic-Pager-GuillermoPolito.110.mczGlamour-Morphic-Renderer-AndreiChis.349.mczGlamour-Morphic-Theme-HenrikNergaard.222.mczGlamour-Morphic-Widgets-AndreiChis.195.mczGlamour-Presentations-AndreiChis.186.mczGlamour-Rubric-Presentations-AndreiChis.52.mczGlamour-Tests-Core-AndreiChis.111.mczGlamour-Tests-Morphic-TudorGirba.137.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.35.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.6.mczGraphics-Display Objects-TheIntegrator.175.mczGraphics-Files-TheIntegrator.76.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.189.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.80.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.41.mczHelpSystem-Core-TheIntegrator.144.mczHelpSystem-Tests-TheIntegrator.32.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.90.mczImportingResource-Help-TheIntegrator.4.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.28.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2293.mczKernel-Rules-TheIntegrator.2.mczKernel-Tests-TheIntegrator.65.mczKeymapping-Core-TheIntegrator.198.mczKeymapping-KeyCombinations-TheIntegrator.62.mczKeymapping-Pragmas-TheIntegrator.54.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.105.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.166.mczManifest-Core-TheIntegrator.239.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.51.mczMenuRegistration-TheIntegrator.78.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.824.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-EstebanLorenzano.733.mczMetacello-PharoCommonPlatform-TheIntegrator.22.mczMetacello-Platform-EstebanLorenzano.3.mczMetacello-ProfStef-EstebanLorenzano.18.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.7.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform.squeakCommon-EstebanLorenzano.23.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-EstebanLorenzano.148.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1132.mczMonticello-OldDataStreamCompatibility-TheIntegrator.8.mczMonticello-Tests-TheIntegrator.35.mczMonticelloConfigurations-TheIntegrator.72.mczMonticelloFileServices-TheIntegrator.6.mczMonticelloFileTree-Core-TheIntegrator.141.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.30.mczMonticelloGUI-TheIntegrator.415.mczMonticelloMocks-TheIntegrator.4.mczMonticelloRemoteRepositories-TheIntegrator.15.mczMoose-Algos-Graph-vincentBlondeau.31.mczMorphic-Base-TheIntegrator.548.mczMorphic-Core-TheIntegrator.278.mczMorphic-Examples-TheIntegrator.50.mczMorphic-Tests-TheIntegrator.11.mczMorphic-Widgets-Basic-TheIntegrator.86.mczMorphic-Widgets-ColorPicker-TheIntegrator.19.mczMorphic-Widgets-Extra-TheIntegrator.27.mczMorphic-Widgets-FastTable-StephanEggermont.177.mczMorphic-Widgets-List-TheIntegrator.21.mczMorphic-Widgets-NewList-TheIntegrator.9.mczMorphic-Widgets-Pluggable-TheIntegrator.66.mczMorphic-Widgets-PolyTabs-TheIntegrator.2.mczMorphic-Widgets-Scrolling-TheIntegrator.32.mczMorphic-Widgets-Tabs-TheIntegrator.20.mczMorphic-Widgets-Taskbar-TheIntegrator.21.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.50.mczMorphic-Widgets-Windows-TheIntegrator.97.mczMultilingual-Encodings-TheIntegrator.61.mczMultilingual-Languages-TheIntegrator.55.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.81.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.244.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1253.mczNautilus-GroupManager-TheIntegrator.20.mczNautilus-GroupManagerUI-TheIntegrator.31.mczNautilus-Tests-TheIntegrator.37.mczNautilusCommon-TheIntegrator.305.mczNautilusGroupAutoBuilder-TheIntegrator.11.mczNautilusRefactoring-TheIntegrator.272.mczNetwork-Kernel-TheIntegrator.133.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-EstebanLorenzano.47.mczNetwork-Protocols-TheIntegrator.103.mczNetwork-Tests-EstebanLorenzano.15.mczNetwork-UUID-TheIntegrator.44.mczNetwork-Url-MarcusDenker.99.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.55.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-RonieSalgado.107.mczOSWindow-SDL2-RonieSalgado.96.mczOSWindow-SDL2-Examples-RonieSalgado.13.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOpalCompiler-Core-TheIntegrator.799.mczOpalCompiler-Tests-TheIntegrator.334.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.31.mczPolymorph-TaskbarIcons-TheIntegrator.46.mczPolymorph-Widgets-TheIntegrator.1338.mczPragmaCollector-TheIntegrator.12.mczProfStef-Core-TheIntegrator.77.mczProfStef-Help-TheIntegrator.16.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.101.mczQualityAssistantRecording-YuriyTymchuk.20.mczRPackage-Core-TheIntegrator.430.mczRPackage-Tests-TheIntegrator.181.mczRandom-Core-TheIntegrator.4.mczRandom-Tests-TheIntegrator.4.mczRecentSubmissions-TheIntegrator.238.mczRefactoring-Changes-TheIntegrator.67.mczRefactoring-Core-TheIntegrator.298.mczRefactoring-Critics-TheIntegrator.261.mczRefactoring-Environment-TheIntegrator.76.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.131.mczRefactoring-Tests-Critics-TheIntegrator.38.mczRefactoring-Tests-Environment-TheIntegrator.23.mczReflectivity-TheIntegrator.297.mczReflectivity-Examples-TheIntegrator.28.mczReflectivity-Tests-TheIntegrator.202.mczReflectivity-Tools-TheIntegrator.24.mczReflectivity-Tools-Tests-TheIntegrator.11.mczRegex-Core-TheIntegrator.38.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.31.mczRenraku-YuriyTymchuk.111.mczRenraku-Test-YuriyTymchuk.19.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.237.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.90.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.364.mczRubric-Rules-YuriyTymchuk.3.mczSTON-Core-PavelKrivanek.73.mczSTON-Tests-SvenVanCaekenberghe.64.mczSUnit-Core-TheIntegrator.169.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.3.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-EstebanLorenzano.138.mczSUnit-UITesting-TheIntegrator.32.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.92.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TommasoDalSasso.3.mczShoreLine-Report-UI-TommasoDalSasso.17.mczShout-TheIntegrator.291.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.742.mczSlot-Tests-TheIntegrator.89.mczSmartSuggestions-TheIntegrator.234.mczSmartSuggestions-Tests-TheIntegrator.33.mczSpec-Core-TheIntegrator.465.mczSpec-Debugger-TheIntegrator.263.mczSpec-Examples-TheIntegrator.108.mczSpec-Help-TheIntegrator.10.mczSpec-Inspector-TheIntegrator.258.mczSpec-Layout-TheIntegrator.69.mczSpec-MorphicAdapters-TheIntegrator.269.mczSpec-PolyWidgets-TheIntegrator.66.mczSpec-Tests-TheIntegrator.63.mczSpec-Tools-TheIntegrator.324.mczStartupPreferences-TheIntegrator.149.mczSystem-Announcements-TheIntegrator.108.mczSystem-BasicCommandLineHandler-TheIntegrator.18.mczSystem-Caching-TheIntegrator.26.mczSystem-CachingTests-TheIntegrator.16.mczSystem-Changes-TheIntegrator.292.mczSystem-Changes-FileServices-TheIntegrator.2.mczSystem-Clipboard-TheIntegrator.40.mczSystem-CommandLine-TheIntegrator.181.mczSystem-CommandLine-TextSupport-TheIntegrator.4.mczSystem-CommandLineHandler-TheIntegrator.18.mczSystem-FileRegistry-TheIntegrator.50.mczSystem-Finalization-TheIntegrator.32.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.106.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.4.mczSystem-OSEnvironments-TheIntegrator.31.mczSystem-Object Events-TheIntegrator.25.mczSystem-Platforms-TheIntegrator.81.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.27.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.337.mczSystem-Settings-Tests-TheIntegrator.11.mczSystem-Sound-StephaneDucasse.18.mczSystem-Sources-TheIntegrator.50.mczSystem-Support-TheIntegrator.1215.mczSystem-SupportTests-TheIntegrator.2.mczSystem-VMEvents-TheIntegrator.17.mczTests-TheIntegrator.755.mczText-Core-TheIntegrator.50.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.114.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.140.mczTool-Catalog-GuillermoPolito.32.mczTool-CriticBrowser-TheIntegrator.21.mczTool-DependencyAnalyser-ChristopheDemarey.28.mczTool-DependencyAnalyser-Test-ChristopheDemarey.11.mczTool-DependencyAnalyser-UI-ChristopheDemarey.43.mczTool-Diff-TheIntegrator.31.mczTool-ExternalBrowser-TheIntegrator.49.mczTool-FileList-TheIntegrator.62.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.65.mczTool-ImageCleaner-TheIntegrator.17.mczTool-ProcessBrowser-TheIntegrator.20.mczTool-Profilers-TheIntegrator.22.mczTool-SystemReporter-TheIntegrator.15.mczTool-Transcript-TheIntegrator.25.mczTool-TxWorkspace-NicolaiHess.7.mczTool-Workspace-TheIntegrator.37.mczTools-TheIntegrator.1525.mczTools-Test-TheIntegrator.16.mczTraits-TheIntegrator.907.mczTranscript-TheIntegrator.50.mczTxText-Athens-GuillermoPolito.53.mczTxText-AthensTests-SeanDeNigris.10.mczTxText-Model-SeanDeNigris.61.mczTxText-Styler-MarcusDenker.17.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.187.mczUnicode-Initialization-TheIntegrator.15.mczUnifiedFFI-EstebanLorenzano.70.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.25.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-VincentBlondeau.32.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-StephaneDucasse.64.mczVersionner-Core-DependenciesModel-ChristopheDemarey.105.mczVersionner-Core-Model-ChristopheDemarey.52.mczVersionner-Spec-Browser-PabloTesone.189.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczZinc-Character-Encoding-Core-TheIntegrator.48.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.27.mczZinc-FileSystem-SvenVanCaekenberghe.12.mczZinc-HTTP-SvenVanCaekenberghe.448.mczZinc-Resource-Meta-Core-TheIntegrator.58.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.36.mczZinc-Tests-SvenVanCaekenberghe.236.mczZinc-Zodiac-TheIntegrator.37.mczZodiac-Core-SvenVanCaekenberghe.42.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.13.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 11/25/2016 16:36'!update50764	"self new update50764"	self withUpdateLog: '19361 Morph>>#showActions broken	https://pharo.fogbugz.com/f/cases/19361'.	self loadTogether: self script50764 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update50763!ScriptLoader removeSelector: #script50763!"ScriptLoader50"!!MorphicEventHandler methodsFor: 'access' stamp: 'PhilippeBack 11/17/2016 13:55' prior: 33438176!methodRefList	"Return a MethodReference for each message I can send."	| list |	list := OrderedCollection new.	subscriptions do: [		:subscriptionSet |				subscriptionSet do: [ 	 :s | 			s  ifNotNil: [list						add: (RGMethodDefinition								realClass: (s recipient class whichClassIncludesSelector: s selector)								selector: s selector)]							]		].	^ list! !"Morphic-Base"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo50/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader50-TheIntegrator.978.mcz') load.ScriptLoader new update50764.!----End fileIn----!----QUIT----2016-11-25T16:38:05.412728+01:00 Pharo.image priorSource: 299390!----QUIT----2016-11-25T16:38:20.375238+01:00 Pharo.image priorSource: 317065!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 12/12/2016 11:38' prior: 33853993!commentForCurrentUpdate ^ '19435 Silently ignore loading DelayScheduler setting when its the same as existing (Pharo 5 backport)	https://pharo.fogbugz.com/f/cases/19435'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 12/12/2016 11:38'!script50765	^ 'AST-Core-TheIntegrator.418.mczAST-FFI-Pharo50Compatibility-TheIntegrator.2.mczAST-Tests-Core-TheIntegrator.95.mczAlien-eem.32.mczAnnouncements-Core-TheIntegrator.68.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.31.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-NicolaiHess.123.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-EstebanLorenzano.63.mczAthens-Text-NicolaiHess.16.mczBalloon-TheIntegrator.132.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfFileTree-ThierryGoubier.15.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfQualityAssistant-YuriyTymchuk.46.mczBaselineOfRenraku-YuriyTymchuk.5.mczBlueInk-Core-TheIntegrator.24.mczBlueInk-Extras-TheIntegrator.10.mczBlueInk-Tests-TheIntegrator.12.mczChroma-CubeHelix-TheIntegrator.2.mczCodeExport-TheIntegrator.19.mczCodeImport-TheIntegrator.88.mczCodeImportCommandLineHandlers-TheIntegrator.7.mczCollections-Abstract-TheIntegrator.313.mczCollections-Arithmetic-TheIntegrator.20.mczCollections-Atomic-TheIntegrator.16.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.246.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.188.mczCollections-Strings-TheIntegrator.415.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.49.mczCollections-Unordered-TheIntegrator.232.mczCollections-Weak-TheIntegrator.102.mczCompiler-TheIntegrator.602.mczCompression-TheIntegrator.176.mczCompression-Tests-TheIntegrator.2.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.4.mczDebuggerActions-TheIntegrator.85.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.126.mczDeprecated50-TheIntegrator.59.mczEmbeddedFreeType-TheIntegrator.26.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczFFI-Kernel-JanVanDeSandt.40.mczFFI-Pools-eem.3.mczFileSystem-Core-TheIntegrator.202.mczFileSystem-Disk-TheIntegrator.97.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.95.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.417.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-TheIntegrator.17.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.14.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.742.mczFreeType-Tests-TheIntegrator.2.mczFuel-MaxLeske.825.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-TheIntegrator.62.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.411.mczFuelTools-Debugger-TheIntegrator.10.mczGT-BytecodeDebugger-TudorGirba.31.mczGT-Debugger-AndreiChis.350.mczGT-EventRecorder-TheIntegrator.68.mczGT-EventRecorder-Tests-JurajKubelka.37.mczGT-Inspector-AndreiChis.421.mczGT-InspectorExtensions-Core-TheIntegrator.214.mczGT-Playground-DenisKudryashov.124.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-TudorGirba.397.mczGT-Spotter-EventRecorder-GuillermoPolito.112.mczGT-SpotterExtensions-Core-VincentBlondeau.203.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-StefanReichhart.56.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AliakseiSyrel.17.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-EstebanLorenzano.323.mczGlamour-Examples-TudorGirba.303.mczGlamour-FastTable-AndreiChis.59.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-GuillermoPolito.418.mczGlamour-Morphic-Brick-Tests-TheIntegrator.14.mczGlamour-Morphic-Pager-GuillermoPolito.110.mczGlamour-Morphic-Renderer-AndreiChis.349.mczGlamour-Morphic-Theme-HenrikNergaard.222.mczGlamour-Morphic-Widgets-AndreiChis.195.mczGlamour-Presentations-AndreiChis.186.mczGlamour-Rubric-Presentations-AndreiChis.52.mczGlamour-Tests-Core-AndreiChis.111.mczGlamour-Tests-Morphic-TudorGirba.137.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.35.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.6.mczGraphics-Display Objects-TheIntegrator.175.mczGraphics-Files-TheIntegrator.76.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.189.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.80.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.41.mczHelpSystem-Core-TheIntegrator.144.mczHelpSystem-Tests-TheIntegrator.32.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.90.mczImportingResource-Help-TheIntegrator.4.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.28.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2295.mczKernel-Rules-TheIntegrator.2.mczKernel-Tests-TheIntegrator.65.mczKeymapping-Core-TheIntegrator.198.mczKeymapping-KeyCombinations-TheIntegrator.62.mczKeymapping-Pragmas-TheIntegrator.54.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.105.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.166.mczManifest-Core-TheIntegrator.239.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.51.mczMenuRegistration-TheIntegrator.78.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.824.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-EstebanLorenzano.733.mczMetacello-PharoCommonPlatform-TheIntegrator.22.mczMetacello-Platform-EstebanLorenzano.3.mczMetacello-ProfStef-EstebanLorenzano.18.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.7.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform.squeakCommon-EstebanLorenzano.23.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-EstebanLorenzano.148.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1132.mczMonticello-OldDataStreamCompatibility-TheIntegrator.8.mczMonticello-Tests-TheIntegrator.35.mczMonticelloConfigurations-TheIntegrator.72.mczMonticelloFileServices-TheIntegrator.6.mczMonticelloFileTree-Core-TheIntegrator.141.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.30.mczMonticelloGUI-TheIntegrator.415.mczMonticelloMocks-TheIntegrator.4.mczMonticelloRemoteRepositories-TheIntegrator.15.mczMoose-Algos-Graph-vincentBlondeau.31.mczMorphic-Base-TheIntegrator.548.mczMorphic-Core-TheIntegrator.278.mczMorphic-Examples-TheIntegrator.50.mczMorphic-Tests-TheIntegrator.11.mczMorphic-Widgets-Basic-TheIntegrator.86.mczMorphic-Widgets-ColorPicker-TheIntegrator.19.mczMorphic-Widgets-Extra-TheIntegrator.27.mczMorphic-Widgets-FastTable-StephanEggermont.177.mczMorphic-Widgets-List-TheIntegrator.21.mczMorphic-Widgets-NewList-TheIntegrator.9.mczMorphic-Widgets-Pluggable-TheIntegrator.66.mczMorphic-Widgets-PolyTabs-TheIntegrator.2.mczMorphic-Widgets-Scrolling-TheIntegrator.32.mczMorphic-Widgets-Tabs-TheIntegrator.20.mczMorphic-Widgets-Taskbar-TheIntegrator.21.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.50.mczMorphic-Widgets-Windows-TheIntegrator.97.mczMultilingual-Encodings-TheIntegrator.61.mczMultilingual-Languages-TheIntegrator.55.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.81.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.244.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1253.mczNautilus-GroupManager-TheIntegrator.20.mczNautilus-GroupManagerUI-TheIntegrator.31.mczNautilus-Tests-TheIntegrator.37.mczNautilusCommon-TheIntegrator.305.mczNautilusGroupAutoBuilder-TheIntegrator.11.mczNautilusRefactoring-TheIntegrator.272.mczNetwork-Kernel-TheIntegrator.133.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-EstebanLorenzano.47.mczNetwork-Protocols-TheIntegrator.103.mczNetwork-Tests-EstebanLorenzano.15.mczNetwork-UUID-TheIntegrator.44.mczNetwork-Url-MarcusDenker.99.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.55.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-RonieSalgado.107.mczOSWindow-SDL2-RonieSalgado.96.mczOSWindow-SDL2-Examples-RonieSalgado.13.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOpalCompiler-Core-TheIntegrator.799.mczOpalCompiler-Tests-TheIntegrator.334.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.31.mczPolymorph-TaskbarIcons-TheIntegrator.46.mczPolymorph-Widgets-TheIntegrator.1338.mczPragmaCollector-TheIntegrator.12.mczProfStef-Core-TheIntegrator.77.mczProfStef-Help-TheIntegrator.16.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.101.mczQualityAssistantRecording-YuriyTymchuk.20.mczRPackage-Core-TheIntegrator.430.mczRPackage-Tests-TheIntegrator.181.mczRandom-Core-TheIntegrator.4.mczRandom-Tests-TheIntegrator.4.mczRecentSubmissions-TheIntegrator.238.mczRefactoring-Changes-TheIntegrator.67.mczRefactoring-Core-TheIntegrator.298.mczRefactoring-Critics-TheIntegrator.261.mczRefactoring-Environment-TheIntegrator.76.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.131.mczRefactoring-Tests-Critics-TheIntegrator.38.mczRefactoring-Tests-Environment-TheIntegrator.23.mczReflectivity-TheIntegrator.297.mczReflectivity-Examples-TheIntegrator.28.mczReflectivity-Tests-TheIntegrator.202.mczReflectivity-Tools-TheIntegrator.24.mczReflectivity-Tools-Tests-TheIntegrator.11.mczRegex-Core-TheIntegrator.38.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.31.mczRenraku-YuriyTymchuk.111.mczRenraku-Test-YuriyTymchuk.19.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.237.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.90.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.364.mczRubric-Rules-YuriyTymchuk.3.mczSTON-Core-PavelKrivanek.73.mczSTON-Tests-SvenVanCaekenberghe.64.mczSUnit-Core-TheIntegrator.169.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.3.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-EstebanLorenzano.138.mczSUnit-UITesting-TheIntegrator.32.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.92.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TommasoDalSasso.3.mczShoreLine-Report-UI-TommasoDalSasso.17.mczShout-TheIntegrator.291.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.742.mczSlot-Tests-TheIntegrator.89.mczSmartSuggestions-TheIntegrator.234.mczSmartSuggestions-Tests-TheIntegrator.33.mczSpec-Core-TheIntegrator.465.mczSpec-Debugger-TheIntegrator.263.mczSpec-Examples-TheIntegrator.108.mczSpec-Help-TheIntegrator.10.mczSpec-Inspector-TheIntegrator.258.mczSpec-Layout-TheIntegrator.69.mczSpec-MorphicAdapters-TheIntegrator.269.mczSpec-PolyWidgets-TheIntegrator.66.mczSpec-Tests-TheIntegrator.63.mczSpec-Tools-TheIntegrator.324.mczStartupPreferences-TheIntegrator.149.mczSystem-Announcements-TheIntegrator.108.mczSystem-BasicCommandLineHandler-TheIntegrator.18.mczSystem-Caching-TheIntegrator.26.mczSystem-CachingTests-TheIntegrator.16.mczSystem-Changes-TheIntegrator.292.mczSystem-Changes-FileServices-TheIntegrator.2.mczSystem-Clipboard-TheIntegrator.40.mczSystem-CommandLine-TheIntegrator.181.mczSystem-CommandLine-TextSupport-TheIntegrator.4.mczSystem-CommandLineHandler-TheIntegrator.18.mczSystem-FileRegistry-TheIntegrator.50.mczSystem-Finalization-TheIntegrator.32.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.106.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.4.mczSystem-OSEnvironments-TheIntegrator.31.mczSystem-Object Events-TheIntegrator.25.mczSystem-Platforms-TheIntegrator.81.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.27.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.337.mczSystem-Settings-Tests-TheIntegrator.11.mczSystem-Sound-StephaneDucasse.18.mczSystem-Sources-TheIntegrator.50.mczSystem-Support-TheIntegrator.1215.mczSystem-SupportTests-TheIntegrator.2.mczSystem-VMEvents-TheIntegrator.17.mczTests-TheIntegrator.755.mczText-Core-TheIntegrator.50.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.114.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.140.mczTool-Catalog-GuillermoPolito.32.mczTool-CriticBrowser-TheIntegrator.21.mczTool-DependencyAnalyser-ChristopheDemarey.28.mczTool-DependencyAnalyser-Test-ChristopheDemarey.11.mczTool-DependencyAnalyser-UI-ChristopheDemarey.43.mczTool-Diff-TheIntegrator.31.mczTool-ExternalBrowser-TheIntegrator.49.mczTool-FileList-TheIntegrator.62.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.65.mczTool-ImageCleaner-TheIntegrator.17.mczTool-ProcessBrowser-TheIntegrator.20.mczTool-Profilers-TheIntegrator.22.mczTool-SystemReporter-TheIntegrator.15.mczTool-Transcript-TheIntegrator.25.mczTool-TxWorkspace-NicolaiHess.7.mczTool-Workspace-TheIntegrator.37.mczTools-TheIntegrator.1525.mczTools-Test-TheIntegrator.16.mczTraits-TheIntegrator.907.mczTranscript-TheIntegrator.50.mczTxText-Athens-GuillermoPolito.53.mczTxText-AthensTests-SeanDeNigris.10.mczTxText-Model-SeanDeNigris.61.mczTxText-Styler-MarcusDenker.17.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.187.mczUnicode-Initialization-TheIntegrator.15.mczUnifiedFFI-EstebanLorenzano.70.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.25.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-VincentBlondeau.32.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-StephaneDucasse.64.mczVersionner-Core-DependenciesModel-ChristopheDemarey.105.mczVersionner-Core-Model-ChristopheDemarey.52.mczVersionner-Spec-Browser-PabloTesone.189.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczZinc-Character-Encoding-Core-TheIntegrator.48.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.27.mczZinc-FileSystem-SvenVanCaekenberghe.12.mczZinc-HTTP-SvenVanCaekenberghe.448.mczZinc-Resource-Meta-Core-TheIntegrator.58.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.36.mczZinc-Tests-SvenVanCaekenberghe.236.mczZinc-Zodiac-TheIntegrator.37.mczZodiac-Core-SvenVanCaekenberghe.42.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.13.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 12/12/2016 11:38'!update50765	"self new update50765"	self withUpdateLog: '19435 Silently ignore loading DelayScheduler setting when its the same as existing (Pharo 5 backport)	https://pharo.fogbugz.com/f/cases/19435'.	self loadTogether: self script50765 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update50764!ScriptLoader removeSelector: #script50764!"ScriptLoader50"!!Delay class methodsFor: 'settings' stamp: 'BenComan 12/7/2016 22:43' prior: 21968863!delaySchedulerClass: aSchedulerClass 	| newScheduler |	self delaySchedulerClass = aSchedulerClass ifTrue:[ ^self ].	newScheduler := aSchedulerClass new.	(newScheduler respondsTo: #startTimerEventLoop) ifFalse: [ self error: 'New delay scheduler must respond to #startTimerEventLoop' ].	Scheduler stopTimerEventLoop.	Scheduler := newScheduler.	Scheduler startTimerEventLoop.	self inform: 'Delay scheduler set to ' , aSchedulerClass printString.		! !!ManifestKernel class methodsFor: 'code-critics' stamp: 'BenComan 12/7/2016 22:43'!ruleRBBadMessageRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#'Delay class' #delaySchedulerClass: #true)) #'2016-12-07T22:43:31.787633+08:00') )! !"Kernel"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo50/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader50-TheIntegrator.979.mcz') load.ScriptLoader new update50765.!----End fileIn----!----QUIT----2016-12-12T19:07:23.147635+01:00 Pharo.image priorSource: 317144!----QUIT----2016-12-12T19:07:26.435589+01:00 Pharo.image priorSource: 335261!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 1/23/2017 10:45' prior: 33871748!commentForCurrentUpdate ^ '19477 Fuel out Stack uses old debugger API in Pharo 5	https://pharo.fogbugz.com/f/cases/19477'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 1/23/2017 10:45'!script50766	^ 'AST-Core-TheIntegrator.418.mczAST-FFI-Pharo50Compatibility-TheIntegrator.2.mczAST-Tests-Core-TheIntegrator.95.mczAlien-eem.32.mczAnnouncements-Core-TheIntegrator.68.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.31.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-NicolaiHess.123.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-EstebanLorenzano.63.mczAthens-Text-NicolaiHess.16.mczBalloon-TheIntegrator.132.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfFileTree-ThierryGoubier.15.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfQualityAssistant-YuriyTymchuk.46.mczBaselineOfRenraku-YuriyTymchuk.5.mczBlueInk-Core-TheIntegrator.24.mczBlueInk-Extras-TheIntegrator.10.mczBlueInk-Tests-TheIntegrator.12.mczChroma-CubeHelix-TheIntegrator.2.mczCodeExport-TheIntegrator.19.mczCodeImport-TheIntegrator.88.mczCodeImportCommandLineHandlers-TheIntegrator.7.mczCollections-Abstract-TheIntegrator.313.mczCollections-Arithmetic-TheIntegrator.20.mczCollections-Atomic-TheIntegrator.16.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.246.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.188.mczCollections-Strings-TheIntegrator.415.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.49.mczCollections-Unordered-TheIntegrator.232.mczCollections-Weak-TheIntegrator.102.mczCompiler-TheIntegrator.602.mczCompression-TheIntegrator.176.mczCompression-Tests-TheIntegrator.2.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.4.mczDebuggerActions-TheIntegrator.85.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.126.mczDeprecated50-TheIntegrator.59.mczEmbeddedFreeType-TheIntegrator.26.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczFFI-Kernel-JanVanDeSandt.40.mczFFI-Pools-eem.3.mczFileSystem-Core-TheIntegrator.202.mczFileSystem-Disk-TheIntegrator.97.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.95.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.417.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-TheIntegrator.17.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.14.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.742.mczFreeType-Tests-TheIntegrator.2.mczFuel-MaxLeske.825.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-TheIntegrator.64.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.411.mczFuelTools-Debugger-TheIntegrator.12.mczGT-BytecodeDebugger-TudorGirba.31.mczGT-Debugger-AndreiChis.350.mczGT-EventRecorder-TheIntegrator.68.mczGT-EventRecorder-Tests-JurajKubelka.37.mczGT-Inspector-AndreiChis.421.mczGT-InspectorExtensions-Core-TheIntegrator.214.mczGT-Playground-DenisKudryashov.124.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-TudorGirba.397.mczGT-Spotter-EventRecorder-GuillermoPolito.112.mczGT-SpotterExtensions-Core-VincentBlondeau.203.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-StefanReichhart.56.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AliakseiSyrel.17.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-EstebanLorenzano.323.mczGlamour-Examples-TudorGirba.303.mczGlamour-FastTable-AndreiChis.59.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-GuillermoPolito.418.mczGlamour-Morphic-Brick-Tests-TheIntegrator.14.mczGlamour-Morphic-Pager-GuillermoPolito.110.mczGlamour-Morphic-Renderer-AndreiChis.349.mczGlamour-Morphic-Theme-HenrikNergaard.222.mczGlamour-Morphic-Widgets-AndreiChis.195.mczGlamour-Presentations-AndreiChis.186.mczGlamour-Rubric-Presentations-AndreiChis.52.mczGlamour-Tests-Core-AndreiChis.111.mczGlamour-Tests-Morphic-TudorGirba.137.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.35.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.6.mczGraphics-Display Objects-TheIntegrator.175.mczGraphics-Files-TheIntegrator.76.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.189.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.80.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.41.mczHelpSystem-Core-TheIntegrator.144.mczHelpSystem-Tests-TheIntegrator.32.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.90.mczImportingResource-Help-TheIntegrator.4.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.28.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2295.mczKernel-Rules-TheIntegrator.2.mczKernel-Tests-TheIntegrator.65.mczKeymapping-Core-TheIntegrator.198.mczKeymapping-KeyCombinations-TheIntegrator.62.mczKeymapping-Pragmas-TheIntegrator.54.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.105.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.166.mczManifest-Core-TheIntegrator.239.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.51.mczMenuRegistration-TheIntegrator.78.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.824.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-EstebanLorenzano.733.mczMetacello-PharoCommonPlatform-TheIntegrator.22.mczMetacello-Platform-EstebanLorenzano.3.mczMetacello-ProfStef-EstebanLorenzano.18.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.7.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform.squeakCommon-EstebanLorenzano.23.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-EstebanLorenzano.148.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1132.mczMonticello-OldDataStreamCompatibility-TheIntegrator.8.mczMonticello-Tests-TheIntegrator.35.mczMonticelloConfigurations-TheIntegrator.72.mczMonticelloFileServices-TheIntegrator.6.mczMonticelloFileTree-Core-TheIntegrator.141.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.30.mczMonticelloGUI-TheIntegrator.415.mczMonticelloMocks-TheIntegrator.4.mczMonticelloRemoteRepositories-TheIntegrator.15.mczMoose-Algos-Graph-vincentBlondeau.31.mczMorphic-Base-TheIntegrator.548.mczMorphic-Core-TheIntegrator.278.mczMorphic-Examples-TheIntegrator.50.mczMorphic-Tests-TheIntegrator.11.mczMorphic-Widgets-Basic-TheIntegrator.86.mczMorphic-Widgets-ColorPicker-TheIntegrator.19.mczMorphic-Widgets-Extra-TheIntegrator.27.mczMorphic-Widgets-FastTable-StephanEggermont.177.mczMorphic-Widgets-List-TheIntegrator.21.mczMorphic-Widgets-NewList-TheIntegrator.9.mczMorphic-Widgets-Pluggable-TheIntegrator.66.mczMorphic-Widgets-PolyTabs-TheIntegrator.2.mczMorphic-Widgets-Scrolling-TheIntegrator.32.mczMorphic-Widgets-Tabs-TheIntegrator.20.mczMorphic-Widgets-Taskbar-TheIntegrator.21.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.50.mczMorphic-Widgets-Windows-TheIntegrator.97.mczMultilingual-Encodings-TheIntegrator.61.mczMultilingual-Languages-TheIntegrator.55.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.81.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.244.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1253.mczNautilus-GroupManager-TheIntegrator.20.mczNautilus-GroupManagerUI-TheIntegrator.31.mczNautilus-Tests-TheIntegrator.37.mczNautilusCommon-TheIntegrator.305.mczNautilusGroupAutoBuilder-TheIntegrator.11.mczNautilusRefactoring-TheIntegrator.272.mczNetwork-Kernel-TheIntegrator.133.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-EstebanLorenzano.47.mczNetwork-Protocols-TheIntegrator.103.mczNetwork-Tests-EstebanLorenzano.15.mczNetwork-UUID-TheIntegrator.44.mczNetwork-Url-MarcusDenker.99.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.55.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-RonieSalgado.107.mczOSWindow-SDL2-RonieSalgado.96.mczOSWindow-SDL2-Examples-RonieSalgado.13.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOpalCompiler-Core-TheIntegrator.799.mczOpalCompiler-Tests-TheIntegrator.334.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.31.mczPolymorph-TaskbarIcons-TheIntegrator.46.mczPolymorph-Widgets-TheIntegrator.1338.mczPragmaCollector-TheIntegrator.12.mczProfStef-Core-TheIntegrator.77.mczProfStef-Help-TheIntegrator.16.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.101.mczQualityAssistantRecording-YuriyTymchuk.20.mczRPackage-Core-TheIntegrator.430.mczRPackage-Tests-TheIntegrator.181.mczRandom-Core-TheIntegrator.4.mczRandom-Tests-TheIntegrator.4.mczRecentSubmissions-TheIntegrator.238.mczRefactoring-Changes-TheIntegrator.67.mczRefactoring-Core-TheIntegrator.298.mczRefactoring-Critics-TheIntegrator.261.mczRefactoring-Environment-TheIntegrator.76.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.131.mczRefactoring-Tests-Critics-TheIntegrator.38.mczRefactoring-Tests-Environment-TheIntegrator.23.mczReflectivity-TheIntegrator.297.mczReflectivity-Examples-TheIntegrator.28.mczReflectivity-Tests-TheIntegrator.202.mczReflectivity-Tools-TheIntegrator.24.mczReflectivity-Tools-Tests-TheIntegrator.11.mczRegex-Core-TheIntegrator.38.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.31.mczRenraku-YuriyTymchuk.111.mczRenraku-Test-YuriyTymchuk.19.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.237.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.90.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.364.mczRubric-Rules-YuriyTymchuk.3.mczSTON-Core-PavelKrivanek.73.mczSTON-Tests-SvenVanCaekenberghe.64.mczSUnit-Core-TheIntegrator.169.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.3.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-EstebanLorenzano.138.mczSUnit-UITesting-TheIntegrator.32.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.92.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TommasoDalSasso.3.mczShoreLine-Report-UI-TommasoDalSasso.17.mczShout-TheIntegrator.291.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.742.mczSlot-Tests-TheIntegrator.89.mczSmartSuggestions-TheIntegrator.234.mczSmartSuggestions-Tests-TheIntegrator.33.mczSpec-Core-TheIntegrator.465.mczSpec-Debugger-TheIntegrator.263.mczSpec-Examples-TheIntegrator.108.mczSpec-Help-TheIntegrator.10.mczSpec-Inspector-TheIntegrator.258.mczSpec-Layout-TheIntegrator.69.mczSpec-MorphicAdapters-TheIntegrator.269.mczSpec-PolyWidgets-TheIntegrator.66.mczSpec-Tests-TheIntegrator.63.mczSpec-Tools-TheIntegrator.324.mczStartupPreferences-TheIntegrator.149.mczSystem-Announcements-TheIntegrator.108.mczSystem-BasicCommandLineHandler-TheIntegrator.18.mczSystem-Caching-TheIntegrator.26.mczSystem-CachingTests-TheIntegrator.16.mczSystem-Changes-TheIntegrator.292.mczSystem-Changes-FileServices-TheIntegrator.2.mczSystem-Clipboard-TheIntegrator.40.mczSystem-CommandLine-TheIntegrator.181.mczSystem-CommandLine-TextSupport-TheIntegrator.4.mczSystem-CommandLineHandler-TheIntegrator.18.mczSystem-FileRegistry-TheIntegrator.50.mczSystem-Finalization-TheIntegrator.32.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.106.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.4.mczSystem-OSEnvironments-TheIntegrator.31.mczSystem-Object Events-TheIntegrator.25.mczSystem-Platforms-TheIntegrator.81.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.27.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.337.mczSystem-Settings-Tests-TheIntegrator.11.mczSystem-Sound-StephaneDucasse.18.mczSystem-Sources-TheIntegrator.50.mczSystem-Support-TheIntegrator.1215.mczSystem-SupportTests-TheIntegrator.2.mczSystem-VMEvents-TheIntegrator.17.mczTests-TheIntegrator.755.mczText-Core-TheIntegrator.50.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.114.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.140.mczTool-Catalog-GuillermoPolito.32.mczTool-CriticBrowser-TheIntegrator.21.mczTool-DependencyAnalyser-ChristopheDemarey.28.mczTool-DependencyAnalyser-Test-ChristopheDemarey.11.mczTool-DependencyAnalyser-UI-ChristopheDemarey.43.mczTool-Diff-TheIntegrator.31.mczTool-ExternalBrowser-TheIntegrator.49.mczTool-FileList-TheIntegrator.62.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.65.mczTool-ImageCleaner-TheIntegrator.17.mczTool-ProcessBrowser-TheIntegrator.20.mczTool-Profilers-TheIntegrator.22.mczTool-SystemReporter-TheIntegrator.15.mczTool-Transcript-TheIntegrator.25.mczTool-TxWorkspace-NicolaiHess.7.mczTool-Workspace-TheIntegrator.37.mczTools-TheIntegrator.1525.mczTools-Test-TheIntegrator.16.mczTraits-TheIntegrator.907.mczTranscript-TheIntegrator.50.mczTxText-Athens-GuillermoPolito.53.mczTxText-AthensTests-SeanDeNigris.10.mczTxText-Model-SeanDeNigris.61.mczTxText-Styler-MarcusDenker.17.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.187.mczUnicode-Initialization-TheIntegrator.15.mczUnifiedFFI-EstebanLorenzano.70.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.25.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-VincentBlondeau.32.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-StephaneDucasse.64.mczVersionner-Core-DependenciesModel-ChristopheDemarey.105.mczVersionner-Core-Model-ChristopheDemarey.52.mczVersionner-Spec-Browser-PabloTesone.189.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczZinc-Character-Encoding-Core-TheIntegrator.48.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.27.mczZinc-FileSystem-SvenVanCaekenberghe.12.mczZinc-HTTP-SvenVanCaekenberghe.448.mczZinc-Resource-Meta-Core-TheIntegrator.58.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.36.mczZinc-Tests-SvenVanCaekenberghe.236.mczZinc-Zodiac-TheIntegrator.37.mczZodiac-Core-SvenVanCaekenberghe.42.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.13.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 1/23/2017 10:45'!update50766	"self new update50766"	self withUpdateLog: '19477 Fuel out Stack uses old debugger API in Pharo 5	https://pharo.fogbugz.com/f/cases/19477'.	self loadTogether: self script50766 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update50765!ScriptLoader removeSelector: #script50765!"ScriptLoader50"!!FLPharo5Platform methodsFor: 'as yet unclassified' stamp: 'HolgerHansPeterFreyther 1/18/2017 12:45'!openDebuggerOnContext: aContext label: aLabel	UIManager default		debugProcess: Processor activeProcess		context: aContext		label: aLabel		fullView: false		notification: aLabel! !!FLPlatform methodsFor: 'accessing-debugger' stamp: 'HolgerHansPeterFreyther 1/18/2017 11:43'!openDebuggerOnContext: aContext label: aLabel	Smalltalk tools debugger		openOn: Processor activeProcess 		context: aContext		label: aLabel		contents: nil 		fullView: false! !!FuelOutStackDebugAction class methodsFor: 'serialization' stamp: 'HolgerHansPeterFreyther 1/18/2017 11:42' prior: 25093940!serializeTestFailureContext: aContext toFileNamed: aFilename	| serializer |		serializer := FLSerializer newDefault.	self encodeDebugInformationOn: serializer. 	serializer addPostMaterializationAction: [ :materialization |		FLPlatform current			openDebuggerOnContext: materialization root label: 'External stack'].			serializer		" use the sender context, generally the current context is not interesting"		serialize: aContext		toFileNamed: aFilename! !"FuelPlatform"!"FuelTools-Debugger"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo50/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader50-TheIntegrator.980.mcz') load.ScriptLoader new update50766.!----End fileIn----!----QUIT----2017-01-23T10:59:32.66672+01:00 Pharo.image priorSource: 335340!----QUIT----2017-01-23T10:59:40.920481+01:00 Pharo.image priorSource: 353755!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 1/27/2017 12:35' prior: 33889943!commentForCurrentUpdate ^ '19568 Socket local host/port has incorrect guard	https://pharo.fogbugz.com/f/cases/1956819518 Backport Pharo5: LabelModel defaultColor is Color black, should be theme aware	https://pharo.fogbugz.com/f/cases/19518'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 1/27/2017 12:35'!script50767	^ 'AST-Core-TheIntegrator.418.mczAST-FFI-Pharo50Compatibility-TheIntegrator.2.mczAST-Tests-Core-TheIntegrator.95.mczAlien-eem.32.mczAnnouncements-Core-TheIntegrator.68.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.31.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-NicolaiHess.123.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-EstebanLorenzano.63.mczAthens-Text-NicolaiHess.16.mczBalloon-TheIntegrator.132.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfFileTree-ThierryGoubier.15.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfQualityAssistant-YuriyTymchuk.46.mczBaselineOfRenraku-YuriyTymchuk.5.mczBlueInk-Core-TheIntegrator.24.mczBlueInk-Extras-TheIntegrator.10.mczBlueInk-Tests-TheIntegrator.12.mczChroma-CubeHelix-TheIntegrator.2.mczCodeExport-TheIntegrator.19.mczCodeImport-TheIntegrator.88.mczCodeImportCommandLineHandlers-TheIntegrator.7.mczCollections-Abstract-TheIntegrator.313.mczCollections-Arithmetic-TheIntegrator.20.mczCollections-Atomic-TheIntegrator.16.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.246.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.188.mczCollections-Strings-TheIntegrator.415.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.49.mczCollections-Unordered-TheIntegrator.232.mczCollections-Weak-TheIntegrator.102.mczCompiler-TheIntegrator.602.mczCompression-TheIntegrator.176.mczCompression-Tests-TheIntegrator.2.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.4.mczDebuggerActions-TheIntegrator.85.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.126.mczDeprecated50-TheIntegrator.59.mczEmbeddedFreeType-TheIntegrator.26.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczFFI-Kernel-JanVanDeSandt.40.mczFFI-Pools-eem.3.mczFileSystem-Core-TheIntegrator.202.mczFileSystem-Disk-TheIntegrator.97.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.95.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.417.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-TheIntegrator.17.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.14.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.742.mczFreeType-Tests-TheIntegrator.2.mczFuel-MaxLeske.825.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-TheIntegrator.64.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.411.mczFuelTools-Debugger-TheIntegrator.12.mczGT-BytecodeDebugger-TudorGirba.31.mczGT-Debugger-AndreiChis.350.mczGT-EventRecorder-TheIntegrator.68.mczGT-EventRecorder-Tests-JurajKubelka.37.mczGT-Inspector-AndreiChis.421.mczGT-InspectorExtensions-Core-TheIntegrator.214.mczGT-Playground-DenisKudryashov.124.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-TudorGirba.397.mczGT-Spotter-EventRecorder-GuillermoPolito.112.mczGT-SpotterExtensions-Core-VincentBlondeau.203.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-StefanReichhart.56.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AliakseiSyrel.17.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-EstebanLorenzano.323.mczGlamour-Examples-TudorGirba.303.mczGlamour-FastTable-AndreiChis.59.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-GuillermoPolito.418.mczGlamour-Morphic-Brick-Tests-TheIntegrator.14.mczGlamour-Morphic-Pager-GuillermoPolito.110.mczGlamour-Morphic-Renderer-AndreiChis.349.mczGlamour-Morphic-Theme-HenrikNergaard.222.mczGlamour-Morphic-Widgets-AndreiChis.195.mczGlamour-Presentations-AndreiChis.186.mczGlamour-Rubric-Presentations-AndreiChis.52.mczGlamour-Tests-Core-AndreiChis.111.mczGlamour-Tests-Morphic-TudorGirba.137.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.35.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.6.mczGraphics-Display Objects-TheIntegrator.175.mczGraphics-Files-TheIntegrator.76.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.189.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.80.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.41.mczHelpSystem-Core-TheIntegrator.144.mczHelpSystem-Tests-TheIntegrator.32.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.90.mczImportingResource-Help-TheIntegrator.4.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.28.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2295.mczKernel-Rules-TheIntegrator.2.mczKernel-Tests-TheIntegrator.65.mczKeymapping-Core-TheIntegrator.198.mczKeymapping-KeyCombinations-TheIntegrator.62.mczKeymapping-Pragmas-TheIntegrator.54.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.105.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.166.mczManifest-Core-TheIntegrator.239.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.51.mczMenuRegistration-TheIntegrator.78.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.824.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-EstebanLorenzano.733.mczMetacello-PharoCommonPlatform-TheIntegrator.22.mczMetacello-Platform-EstebanLorenzano.3.mczMetacello-ProfStef-EstebanLorenzano.18.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.7.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform.squeakCommon-EstebanLorenzano.23.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-EstebanLorenzano.148.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1132.mczMonticello-OldDataStreamCompatibility-TheIntegrator.8.mczMonticello-Tests-TheIntegrator.35.mczMonticelloConfigurations-TheIntegrator.72.mczMonticelloFileServices-TheIntegrator.6.mczMonticelloFileTree-Core-TheIntegrator.141.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.30.mczMonticelloGUI-TheIntegrator.415.mczMonticelloMocks-TheIntegrator.4.mczMonticelloRemoteRepositories-TheIntegrator.15.mczMoose-Algos-Graph-vincentBlondeau.31.mczMorphic-Base-TheIntegrator.548.mczMorphic-Core-TheIntegrator.278.mczMorphic-Examples-TheIntegrator.50.mczMorphic-Tests-TheIntegrator.11.mczMorphic-Widgets-Basic-TheIntegrator.86.mczMorphic-Widgets-ColorPicker-TheIntegrator.19.mczMorphic-Widgets-Extra-TheIntegrator.27.mczMorphic-Widgets-FastTable-StephanEggermont.177.mczMorphic-Widgets-List-TheIntegrator.21.mczMorphic-Widgets-NewList-TheIntegrator.9.mczMorphic-Widgets-Pluggable-TheIntegrator.66.mczMorphic-Widgets-PolyTabs-TheIntegrator.2.mczMorphic-Widgets-Scrolling-TheIntegrator.32.mczMorphic-Widgets-Tabs-TheIntegrator.20.mczMorphic-Widgets-Taskbar-TheIntegrator.21.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.50.mczMorphic-Widgets-Windows-TheIntegrator.97.mczMultilingual-Encodings-TheIntegrator.61.mczMultilingual-Languages-TheIntegrator.55.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.81.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.244.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1253.mczNautilus-GroupManager-TheIntegrator.20.mczNautilus-GroupManagerUI-TheIntegrator.31.mczNautilus-Tests-TheIntegrator.37.mczNautilusCommon-TheIntegrator.305.mczNautilusGroupAutoBuilder-TheIntegrator.11.mczNautilusRefactoring-TheIntegrator.272.mczNetwork-Kernel-TheIntegrator.136.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-EstebanLorenzano.47.mczNetwork-Protocols-TheIntegrator.103.mczNetwork-Tests-EstebanLorenzano.15.mczNetwork-UUID-TheIntegrator.44.mczNetwork-Url-MarcusDenker.99.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.55.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-RonieSalgado.107.mczOSWindow-SDL2-RonieSalgado.96.mczOSWindow-SDL2-Examples-RonieSalgado.13.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOpalCompiler-Core-TheIntegrator.799.mczOpalCompiler-Tests-TheIntegrator.334.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.31.mczPolymorph-TaskbarIcons-TheIntegrator.46.mczPolymorph-Widgets-TheIntegrator.1338.mczPragmaCollector-TheIntegrator.12.mczProfStef-Core-TheIntegrator.77.mczProfStef-Help-TheIntegrator.16.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.101.mczQualityAssistantRecording-YuriyTymchuk.20.mczRPackage-Core-TheIntegrator.430.mczRPackage-Tests-TheIntegrator.181.mczRandom-Core-TheIntegrator.4.mczRandom-Tests-TheIntegrator.4.mczRecentSubmissions-TheIntegrator.238.mczRefactoring-Changes-TheIntegrator.67.mczRefactoring-Core-TheIntegrator.298.mczRefactoring-Critics-TheIntegrator.261.mczRefactoring-Environment-TheIntegrator.76.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.131.mczRefactoring-Tests-Critics-TheIntegrator.38.mczRefactoring-Tests-Environment-TheIntegrator.23.mczReflectivity-TheIntegrator.297.mczReflectivity-Examples-TheIntegrator.28.mczReflectivity-Tests-TheIntegrator.202.mczReflectivity-Tools-TheIntegrator.24.mczReflectivity-Tools-Tests-TheIntegrator.11.mczRegex-Core-TheIntegrator.38.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.31.mczRenraku-YuriyTymchuk.111.mczRenraku-Test-YuriyTymchuk.19.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.237.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.90.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.364.mczRubric-Rules-YuriyTymchuk.3.mczSTON-Core-PavelKrivanek.73.mczSTON-Tests-SvenVanCaekenberghe.64.mczSUnit-Core-TheIntegrator.169.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.3.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-EstebanLorenzano.138.mczSUnit-UITesting-TheIntegrator.32.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.92.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TommasoDalSasso.3.mczShoreLine-Report-UI-TommasoDalSasso.17.mczShout-TheIntegrator.291.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.742.mczSlot-Tests-TheIntegrator.89.mczSmartSuggestions-TheIntegrator.234.mczSmartSuggestions-Tests-TheIntegrator.33.mczSpec-Core-TheIntegrator.467.mczSpec-Debugger-TheIntegrator.263.mczSpec-Examples-TheIntegrator.108.mczSpec-Help-TheIntegrator.10.mczSpec-Inspector-TheIntegrator.258.mczSpec-Layout-TheIntegrator.69.mczSpec-MorphicAdapters-TheIntegrator.269.mczSpec-PolyWidgets-TheIntegrator.66.mczSpec-Tests-TheIntegrator.63.mczSpec-Tools-TheIntegrator.324.mczStartupPreferences-TheIntegrator.149.mczSystem-Announcements-TheIntegrator.108.mczSystem-BasicCommandLineHandler-TheIntegrator.18.mczSystem-Caching-TheIntegrator.26.mczSystem-CachingTests-TheIntegrator.16.mczSystem-Changes-TheIntegrator.292.mczSystem-Changes-FileServices-TheIntegrator.2.mczSystem-Clipboard-TheIntegrator.40.mczSystem-CommandLine-TheIntegrator.181.mczSystem-CommandLine-TextSupport-TheIntegrator.4.mczSystem-CommandLineHandler-TheIntegrator.18.mczSystem-FileRegistry-TheIntegrator.50.mczSystem-Finalization-TheIntegrator.32.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.106.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.4.mczSystem-OSEnvironments-TheIntegrator.31.mczSystem-Object Events-TheIntegrator.25.mczSystem-Platforms-TheIntegrator.81.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.27.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.337.mczSystem-Settings-Tests-TheIntegrator.11.mczSystem-Sound-StephaneDucasse.18.mczSystem-Sources-TheIntegrator.50.mczSystem-Support-TheIntegrator.1215.mczSystem-SupportTests-TheIntegrator.2.mczSystem-VMEvents-TheIntegrator.17.mczTests-TheIntegrator.755.mczText-Core-TheIntegrator.50.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.114.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.140.mczTool-Catalog-GuillermoPolito.32.mczTool-CriticBrowser-TheIntegrator.21.mczTool-DependencyAnalyser-ChristopheDemarey.28.mczTool-DependencyAnalyser-Test-ChristopheDemarey.11.mczTool-DependencyAnalyser-UI-ChristopheDemarey.43.mczTool-Diff-TheIntegrator.31.mczTool-ExternalBrowser-TheIntegrator.49.mczTool-FileList-TheIntegrator.62.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.65.mczTool-ImageCleaner-TheIntegrator.17.mczTool-ProcessBrowser-TheIntegrator.20.mczTool-Profilers-TheIntegrator.22.mczTool-SystemReporter-TheIntegrator.15.mczTool-Transcript-TheIntegrator.25.mczTool-TxWorkspace-NicolaiHess.7.mczTool-Workspace-TheIntegrator.37.mczTools-TheIntegrator.1525.mczTools-Test-TheIntegrator.16.mczTraits-TheIntegrator.907.mczTranscript-TheIntegrator.50.mczTxText-Athens-GuillermoPolito.53.mczTxText-AthensTests-SeanDeNigris.10.mczTxText-Model-SeanDeNigris.61.mczTxText-Styler-MarcusDenker.17.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.187.mczUnicode-Initialization-TheIntegrator.15.mczUnifiedFFI-EstebanLorenzano.70.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.25.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-VincentBlondeau.32.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-StephaneDucasse.64.mczVersionner-Core-DependenciesModel-ChristopheDemarey.105.mczVersionner-Core-Model-ChristopheDemarey.52.mczVersionner-Spec-Browser-PabloTesone.189.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczZinc-Character-Encoding-Core-TheIntegrator.48.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.27.mczZinc-FileSystem-SvenVanCaekenberghe.12.mczZinc-HTTP-SvenVanCaekenberghe.448.mczZinc-Resource-Meta-Core-TheIntegrator.58.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.36.mczZinc-Tests-SvenVanCaekenberghe.236.mczZinc-Zodiac-TheIntegrator.37.mczZodiac-Core-SvenVanCaekenberghe.42.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.13.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 1/27/2017 12:35'!update50767	"self new update50767"	self withUpdateLog: '19568 Socket local host/port has incorrect guard	https://pharo.fogbugz.com/f/cases/1956819518 Backport Pharo5: LabelModel defaultColor is Color black, should be theme aware	https://pharo.fogbugz.com/f/cases/19518'.	self loadTogether: self script50767 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update50766!ScriptLoader removeSelector: #script50766!"ScriptLoader50"!!LabelModel methodsFor: 'initialization' stamp: 'MarcusDenker 1/27/2017 10:52' prior: 29260227!defaultColor	^Smalltalk ui theme textColor! !!Socket methodsFor: 'accessing' stamp: 'HenrikSperreJohansen 1/20/2017 16:38' prior: 58312762!localAddress	"If in the process of connecting, wait for connection to be established and binding to address completed before resolving."	^ [ self primSocketLocalAddress: socketHandle ]		on: Error		do: [ :e | 			self isWaitingForConnection				ifTrue: [ self waitForConnectionFor: Socket standardTimeout ifTimedOut: nil.					self primSocketLocalAddress: socketHandle ]				ifFalse: [ e pass ] ]! !!Socket methodsFor: 'accessing' stamp: 'HenrikSperreJohansen 1/20/2017 16:40' prior: 58332375!localPort	"If in the process of connecting, wait for connection to be established and binding to address completed before resolving."	^ [ self primSocketLocalPort: socketHandle ]		on: Error		do: [ :e | 			self isWaitingForConnection				ifTrue: [ self waitForConnectionFor: Socket standardTimeout ifTimedOut: nil.					self primSocketLocalPort: socketHandle ]				ifFalse: [ e pass ] ]! !!Socket methodsFor: 'accessing' stamp: 'HenrikSperreJohansen 1/20/2017 16:40' prior: 58311697!remoteAddress	"If in the process of connecting, wait for connection to be established and binding to address completed before resolving."	^ [ self primSocketRemoteAddress: socketHandle ]		on: Error		do: [ :e | 			self isWaitingForConnection				ifTrue: [ self waitForConnectionFor: Socket standardTimeout ifTimedOut: nil.					self primSocketRemoteAddress: socketHandle ]				ifFalse: [ e pass ] ]! !!Socket methodsFor: 'accessing' stamp: 'HenrikSperreJohansen 1/20/2017 16:40' prior: 58306005!remotePort	"If in the process of connecting, wait for connection to be established and binding to address completed before resolving."	^ [ self primSocketRemotePort: socketHandle ]		on: Error		do: [ :e | 			self isWaitingForConnection				ifTrue: [ self waitForConnectionFor: Socket standardTimeout ifTimedOut: nil.					self primSocketRemotePort: socketHandle ]				ifFalse: [ e pass ] ]! !"Network-Kernel"!"Spec-Core"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo50/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader50-TheIntegrator.981.mcz') load.ScriptLoader new update50767.!----End fileIn----!----QUIT----2017-01-27T12:39:26.587644+01:00 Pharo.image priorSource: 353833!----QUIT----2017-01-27T12:39:30.017625+01:00 Pharo.image priorSource: 373461!----QUIT----2017-01-30T03:11:56.194126+01:00 Pharo.image priorSource: 373540!----QUIT----2017-01-30T03:12:01.446988+01:00 Pharo.image priorSource: 373619!----QUIT----2017-02-02T06:26:33.634589+01:00 Pharo.image priorSource: 373698!----QUIT----2017-02-02T06:26:38.995444+01:00 Pharo.image priorSource: 373777!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 2/3/2017 13:06' prior: 33908436!commentForCurrentUpdate ^ '19623 System Settings has "Menues" instead of "Menu"	https://pharo.fogbugz.com/f/cases/19623'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 2/3/2017 13:06'!script50768	^ 'AST-Core-TheIntegrator.418.mczAST-FFI-Pharo50Compatibility-TheIntegrator.2.mczAST-Tests-Core-TheIntegrator.95.mczAlien-eem.32.mczAnnouncements-Core-TheIntegrator.68.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.31.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-NicolaiHess.123.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-EstebanLorenzano.63.mczAthens-Text-NicolaiHess.16.mczBalloon-TheIntegrator.132.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfFileTree-ThierryGoubier.15.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfQualityAssistant-YuriyTymchuk.46.mczBaselineOfRenraku-YuriyTymchuk.5.mczBlueInk-Core-TheIntegrator.24.mczBlueInk-Extras-TheIntegrator.10.mczBlueInk-Tests-TheIntegrator.12.mczChroma-CubeHelix-TheIntegrator.2.mczCodeExport-TheIntegrator.19.mczCodeImport-TheIntegrator.88.mczCodeImportCommandLineHandlers-TheIntegrator.7.mczCollections-Abstract-TheIntegrator.313.mczCollections-Arithmetic-TheIntegrator.20.mczCollections-Atomic-TheIntegrator.16.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.246.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.188.mczCollections-Strings-TheIntegrator.415.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.49.mczCollections-Unordered-TheIntegrator.232.mczCollections-Weak-TheIntegrator.102.mczCompiler-TheIntegrator.602.mczCompression-TheIntegrator.176.mczCompression-Tests-TheIntegrator.2.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.4.mczDebuggerActions-TheIntegrator.85.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.126.mczDeprecated50-TheIntegrator.59.mczEmbeddedFreeType-TheIntegrator.26.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczFFI-Kernel-JanVanDeSandt.40.mczFFI-Pools-eem.3.mczFileSystem-Core-TheIntegrator.202.mczFileSystem-Disk-TheIntegrator.97.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.95.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.417.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-TheIntegrator.17.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.14.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.742.mczFreeType-Tests-TheIntegrator.2.mczFuel-MaxLeske.825.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-TheIntegrator.64.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.411.mczFuelTools-Debugger-TheIntegrator.12.mczGT-BytecodeDebugger-TudorGirba.31.mczGT-Debugger-AndreiChis.350.mczGT-EventRecorder-TheIntegrator.68.mczGT-EventRecorder-Tests-JurajKubelka.37.mczGT-Inspector-AndreiChis.421.mczGT-InspectorExtensions-Core-TheIntegrator.214.mczGT-Playground-DenisKudryashov.124.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-TudorGirba.397.mczGT-Spotter-EventRecorder-GuillermoPolito.112.mczGT-SpotterExtensions-Core-VincentBlondeau.203.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-StefanReichhart.56.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AliakseiSyrel.17.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-EstebanLorenzano.323.mczGlamour-Examples-TudorGirba.303.mczGlamour-FastTable-AndreiChis.59.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-GuillermoPolito.418.mczGlamour-Morphic-Brick-Tests-TheIntegrator.14.mczGlamour-Morphic-Pager-GuillermoPolito.110.mczGlamour-Morphic-Renderer-AndreiChis.349.mczGlamour-Morphic-Theme-HenrikNergaard.222.mczGlamour-Morphic-Widgets-AndreiChis.195.mczGlamour-Presentations-AndreiChis.186.mczGlamour-Rubric-Presentations-AndreiChis.52.mczGlamour-Tests-Core-AndreiChis.111.mczGlamour-Tests-Morphic-TudorGirba.137.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.35.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.6.mczGraphics-Display Objects-TheIntegrator.175.mczGraphics-Files-TheIntegrator.76.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.189.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.80.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.41.mczHelpSystem-Core-TheIntegrator.144.mczHelpSystem-Tests-TheIntegrator.32.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.90.mczImportingResource-Help-TheIntegrator.4.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.28.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2295.mczKernel-Rules-TheIntegrator.2.mczKernel-Tests-TheIntegrator.65.mczKeymapping-Core-TheIntegrator.198.mczKeymapping-KeyCombinations-TheIntegrator.62.mczKeymapping-Pragmas-TheIntegrator.54.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.105.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.166.mczManifest-Core-TheIntegrator.239.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.51.mczMenuRegistration-TheIntegrator.78.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.824.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-EstebanLorenzano.733.mczMetacello-PharoCommonPlatform-TheIntegrator.22.mczMetacello-Platform-EstebanLorenzano.3.mczMetacello-ProfStef-EstebanLorenzano.18.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.7.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform.squeakCommon-EstebanLorenzano.23.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-EstebanLorenzano.148.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1132.mczMonticello-OldDataStreamCompatibility-TheIntegrator.8.mczMonticello-Tests-TheIntegrator.35.mczMonticelloConfigurations-TheIntegrator.72.mczMonticelloFileServices-TheIntegrator.6.mczMonticelloFileTree-Core-TheIntegrator.141.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.30.mczMonticelloGUI-TheIntegrator.415.mczMonticelloMocks-TheIntegrator.4.mczMonticelloRemoteRepositories-TheIntegrator.15.mczMoose-Algos-Graph-vincentBlondeau.31.mczMorphic-Base-TheIntegrator.548.mczMorphic-Core-TheIntegrator.278.mczMorphic-Examples-TheIntegrator.50.mczMorphic-Tests-TheIntegrator.11.mczMorphic-Widgets-Basic-TheIntegrator.86.mczMorphic-Widgets-ColorPicker-TheIntegrator.19.mczMorphic-Widgets-Extra-TheIntegrator.27.mczMorphic-Widgets-FastTable-StephanEggermont.177.mczMorphic-Widgets-List-TheIntegrator.21.mczMorphic-Widgets-NewList-TheIntegrator.9.mczMorphic-Widgets-Pluggable-TheIntegrator.66.mczMorphic-Widgets-PolyTabs-TheIntegrator.2.mczMorphic-Widgets-Scrolling-TheIntegrator.32.mczMorphic-Widgets-Tabs-TheIntegrator.20.mczMorphic-Widgets-Taskbar-TheIntegrator.21.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.50.mczMorphic-Widgets-Windows-TheIntegrator.97.mczMultilingual-Encodings-TheIntegrator.61.mczMultilingual-Languages-TheIntegrator.55.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.81.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.244.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1253.mczNautilus-GroupManager-TheIntegrator.20.mczNautilus-GroupManagerUI-TheIntegrator.31.mczNautilus-Tests-TheIntegrator.37.mczNautilusCommon-TheIntegrator.305.mczNautilusGroupAutoBuilder-TheIntegrator.11.mczNautilusRefactoring-TheIntegrator.272.mczNetwork-Kernel-TheIntegrator.136.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-EstebanLorenzano.47.mczNetwork-Protocols-TheIntegrator.103.mczNetwork-Tests-EstebanLorenzano.15.mczNetwork-UUID-TheIntegrator.44.mczNetwork-Url-MarcusDenker.99.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.55.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-RonieSalgado.107.mczOSWindow-SDL2-RonieSalgado.96.mczOSWindow-SDL2-Examples-RonieSalgado.13.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOpalCompiler-Core-TheIntegrator.799.mczOpalCompiler-Tests-TheIntegrator.334.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.31.mczPolymorph-TaskbarIcons-TheIntegrator.46.mczPolymorph-Widgets-TheIntegrator.1338.mczPragmaCollector-TheIntegrator.12.mczProfStef-Core-TheIntegrator.77.mczProfStef-Help-TheIntegrator.16.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.101.mczQualityAssistantRecording-YuriyTymchuk.20.mczRPackage-Core-TheIntegrator.430.mczRPackage-Tests-TheIntegrator.181.mczRandom-Core-TheIntegrator.4.mczRandom-Tests-TheIntegrator.4.mczRecentSubmissions-TheIntegrator.238.mczRefactoring-Changes-TheIntegrator.67.mczRefactoring-Core-TheIntegrator.298.mczRefactoring-Critics-TheIntegrator.261.mczRefactoring-Environment-TheIntegrator.76.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.131.mczRefactoring-Tests-Critics-TheIntegrator.38.mczRefactoring-Tests-Environment-TheIntegrator.23.mczReflectivity-TheIntegrator.297.mczReflectivity-Examples-TheIntegrator.28.mczReflectivity-Tests-TheIntegrator.202.mczReflectivity-Tools-TheIntegrator.24.mczReflectivity-Tools-Tests-TheIntegrator.11.mczRegex-Core-TheIntegrator.38.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.31.mczRenraku-YuriyTymchuk.111.mczRenraku-Test-YuriyTymchuk.19.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.237.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.90.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.364.mczRubric-Rules-YuriyTymchuk.3.mczSTON-Core-PavelKrivanek.73.mczSTON-Tests-SvenVanCaekenberghe.64.mczSUnit-Core-TheIntegrator.169.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.3.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-EstebanLorenzano.138.mczSUnit-UITesting-TheIntegrator.32.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.94.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TommasoDalSasso.3.mczShoreLine-Report-UI-TommasoDalSasso.17.mczShout-TheIntegrator.291.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.742.mczSlot-Tests-TheIntegrator.89.mczSmartSuggestions-TheIntegrator.234.mczSmartSuggestions-Tests-TheIntegrator.33.mczSpec-Core-TheIntegrator.467.mczSpec-Debugger-TheIntegrator.263.mczSpec-Examples-TheIntegrator.108.mczSpec-Help-TheIntegrator.10.mczSpec-Inspector-TheIntegrator.258.mczSpec-Layout-TheIntegrator.69.mczSpec-MorphicAdapters-TheIntegrator.269.mczSpec-PolyWidgets-TheIntegrator.66.mczSpec-Tests-TheIntegrator.63.mczSpec-Tools-TheIntegrator.324.mczStartupPreferences-TheIntegrator.149.mczSystem-Announcements-TheIntegrator.108.mczSystem-BasicCommandLineHandler-TheIntegrator.18.mczSystem-Caching-TheIntegrator.26.mczSystem-CachingTests-TheIntegrator.16.mczSystem-Changes-TheIntegrator.292.mczSystem-Changes-FileServices-TheIntegrator.2.mczSystem-Clipboard-TheIntegrator.40.mczSystem-CommandLine-TheIntegrator.181.mczSystem-CommandLine-TextSupport-TheIntegrator.4.mczSystem-CommandLineHandler-TheIntegrator.18.mczSystem-FileRegistry-TheIntegrator.50.mczSystem-Finalization-TheIntegrator.32.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.106.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.4.mczSystem-OSEnvironments-TheIntegrator.31.mczSystem-Object Events-TheIntegrator.25.mczSystem-Platforms-TheIntegrator.81.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.27.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.337.mczSystem-Settings-Tests-TheIntegrator.11.mczSystem-Sound-StephaneDucasse.18.mczSystem-Sources-TheIntegrator.50.mczSystem-Support-TheIntegrator.1215.mczSystem-SupportTests-TheIntegrator.2.mczSystem-VMEvents-TheIntegrator.17.mczTests-TheIntegrator.755.mczText-Core-TheIntegrator.50.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.114.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.140.mczTool-Catalog-GuillermoPolito.32.mczTool-CriticBrowser-TheIntegrator.21.mczTool-DependencyAnalyser-ChristopheDemarey.28.mczTool-DependencyAnalyser-Test-ChristopheDemarey.11.mczTool-DependencyAnalyser-UI-ChristopheDemarey.43.mczTool-Diff-TheIntegrator.31.mczTool-ExternalBrowser-TheIntegrator.49.mczTool-FileList-TheIntegrator.62.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.65.mczTool-ImageCleaner-TheIntegrator.17.mczTool-ProcessBrowser-TheIntegrator.20.mczTool-Profilers-TheIntegrator.22.mczTool-SystemReporter-TheIntegrator.15.mczTool-Transcript-TheIntegrator.25.mczTool-TxWorkspace-NicolaiHess.7.mczTool-Workspace-TheIntegrator.37.mczTools-TheIntegrator.1525.mczTools-Test-TheIntegrator.16.mczTraits-TheIntegrator.907.mczTranscript-TheIntegrator.50.mczTxText-Athens-GuillermoPolito.53.mczTxText-AthensTests-SeanDeNigris.10.mczTxText-Model-SeanDeNigris.61.mczTxText-Styler-MarcusDenker.17.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.187.mczUnicode-Initialization-TheIntegrator.15.mczUnifiedFFI-EstebanLorenzano.70.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.25.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-VincentBlondeau.32.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-StephaneDucasse.64.mczVersionner-Core-DependenciesModel-ChristopheDemarey.105.mczVersionner-Core-Model-ChristopheDemarey.52.mczVersionner-Spec-Browser-PabloTesone.189.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczZinc-Character-Encoding-Core-TheIntegrator.48.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.27.mczZinc-FileSystem-SvenVanCaekenberghe.12.mczZinc-HTTP-SvenVanCaekenberghe.448.mczZinc-Resource-Meta-Core-TheIntegrator.58.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.36.mczZinc-Tests-SvenVanCaekenberghe.236.mczZinc-Zodiac-TheIntegrator.37.mczZodiac-Core-SvenVanCaekenberghe.42.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.13.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 2/3/2017 13:06'!update50768	"self new update50768"	self withUpdateLog: '19623 System Settings has "Menues" instead of "Menu"	https://pharo.fogbugz.com/f/cases/19623'.	self loadTogether: self script50768 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update50767!ScriptLoader removeSelector: #script50767!"ScriptLoader50"!!PolymorphSystemSettings class methodsFor: 'morphic' stamp: 'MarcusDenker 1/31/2017 16:50' prior: 53190375!morphicMenuSettingsOn: aBuilder 	(aBuilder group: #menu)		label: 'Menus';		parent: #morphic;		description: 'All menu settings' ;		target: UITheme;		targetSelector: #currentSettings;		noOrdering;		with: [			(aBuilder setting: #preferGradientFill)				label: 'Gradient filling' ;				description: 'If true, then menus will have a gradient look' .			(aBuilder setting: #flatMenu)				label: 'Flat appearance' ;				description: 'If true, then menu will without 3D like borders.' .			(aBuilder setting: #autoMenuColor)				label: 'Computed color' ;				description: 'If true, then the menu color will be computed from world dressing.' .			(aBuilder setting: #menuColor)				label: 'Menu color';				description: 'The menu color to use if it is not computed automatically (see the ''Computed color'' setting)' .			(aBuilder setting: #menuSelectionColor)				label: 'Menu selection color' ;				description: 'The background color of a selected menu item' .			(aBuilder setting: #menuSelectionTextColor)				description: 'The text color of a selected menu item' ;				label: 'Menu selection text color' .		]! !"Settings-Polymorph"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo50/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader50-TheIntegrator.982.mcz') load.ScriptLoader new update50768.!----End fileIn----!----QUIT----2017-02-03T13:07:56.357612+01:00 Pharo.image priorSource: 373856!----QUIT----2017-02-03T13:07:59.783244+01:00 Pharo.image priorSource: 392324!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 2/20/2017 08:17' prior: 33928458!commentForCurrentUpdate ^ '19310 Backport Pharo 5.0: Wrong border after dragging out of a window group (backport 19299)	https://pharo.fogbugz.com/f/cases/19310'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 2/20/2017 08:17'!script50769	^ 'AST-Core-TheIntegrator.418.mczAST-FFI-Pharo50Compatibility-TheIntegrator.2.mczAST-Tests-Core-TheIntegrator.95.mczAlien-eem.32.mczAnnouncements-Core-TheIntegrator.68.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.31.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-NicolaiHess.123.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-EstebanLorenzano.63.mczAthens-Text-NicolaiHess.16.mczBalloon-TheIntegrator.132.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfFileTree-ThierryGoubier.15.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfQualityAssistant-YuriyTymchuk.46.mczBaselineOfRenraku-YuriyTymchuk.5.mczBlueInk-Core-TheIntegrator.24.mczBlueInk-Extras-TheIntegrator.10.mczBlueInk-Tests-TheIntegrator.12.mczChroma-CubeHelix-TheIntegrator.2.mczCodeExport-TheIntegrator.19.mczCodeImport-TheIntegrator.88.mczCodeImportCommandLineHandlers-TheIntegrator.7.mczCollections-Abstract-TheIntegrator.313.mczCollections-Arithmetic-TheIntegrator.20.mczCollections-Atomic-TheIntegrator.16.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.246.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.188.mczCollections-Strings-TheIntegrator.415.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.49.mczCollections-Unordered-TheIntegrator.232.mczCollections-Weak-TheIntegrator.102.mczCompiler-TheIntegrator.602.mczCompression-TheIntegrator.176.mczCompression-Tests-TheIntegrator.2.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.4.mczDebuggerActions-TheIntegrator.85.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.126.mczDeprecated50-TheIntegrator.59.mczEmbeddedFreeType-TheIntegrator.26.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczFFI-Kernel-JanVanDeSandt.40.mczFFI-Pools-eem.3.mczFileSystem-Core-TheIntegrator.202.mczFileSystem-Disk-TheIntegrator.97.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.95.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.417.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-TheIntegrator.17.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.14.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.742.mczFreeType-Tests-TheIntegrator.2.mczFuel-MaxLeske.825.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-TheIntegrator.64.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.411.mczFuelTools-Debugger-TheIntegrator.12.mczGT-BytecodeDebugger-TudorGirba.31.mczGT-Debugger-AndreiChis.350.mczGT-EventRecorder-TheIntegrator.68.mczGT-EventRecorder-Tests-JurajKubelka.37.mczGT-Inspector-AndreiChis.421.mczGT-InspectorExtensions-Core-TheIntegrator.214.mczGT-Playground-DenisKudryashov.124.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-TudorGirba.397.mczGT-Spotter-EventRecorder-GuillermoPolito.112.mczGT-SpotterExtensions-Core-VincentBlondeau.203.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-StefanReichhart.56.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AliakseiSyrel.17.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-EstebanLorenzano.323.mczGlamour-Examples-TudorGirba.303.mczGlamour-FastTable-AndreiChis.59.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-GuillermoPolito.418.mczGlamour-Morphic-Brick-Tests-TheIntegrator.14.mczGlamour-Morphic-Pager-GuillermoPolito.110.mczGlamour-Morphic-Renderer-AndreiChis.349.mczGlamour-Morphic-Theme-HenrikNergaard.222.mczGlamour-Morphic-Widgets-AndreiChis.195.mczGlamour-Presentations-AndreiChis.186.mczGlamour-Rubric-Presentations-AndreiChis.52.mczGlamour-Tests-Core-AndreiChis.111.mczGlamour-Tests-Morphic-TudorGirba.137.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.35.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.6.mczGraphics-Display Objects-TheIntegrator.175.mczGraphics-Files-TheIntegrator.76.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.189.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.80.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.41.mczHelpSystem-Core-TheIntegrator.144.mczHelpSystem-Tests-TheIntegrator.32.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.90.mczImportingResource-Help-TheIntegrator.4.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.28.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2295.mczKernel-Rules-TheIntegrator.2.mczKernel-Tests-TheIntegrator.65.mczKeymapping-Core-TheIntegrator.198.mczKeymapping-KeyCombinations-TheIntegrator.62.mczKeymapping-Pragmas-TheIntegrator.54.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.105.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.166.mczManifest-Core-TheIntegrator.239.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.51.mczMenuRegistration-TheIntegrator.78.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.824.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-EstebanLorenzano.733.mczMetacello-PharoCommonPlatform-TheIntegrator.22.mczMetacello-Platform-EstebanLorenzano.3.mczMetacello-ProfStef-EstebanLorenzano.18.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.7.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform.squeakCommon-EstebanLorenzano.23.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-EstebanLorenzano.148.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1132.mczMonticello-OldDataStreamCompatibility-TheIntegrator.8.mczMonticello-Tests-TheIntegrator.35.mczMonticelloConfigurations-TheIntegrator.72.mczMonticelloFileServices-TheIntegrator.6.mczMonticelloFileTree-Core-TheIntegrator.141.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.30.mczMonticelloGUI-TheIntegrator.415.mczMonticelloMocks-TheIntegrator.4.mczMonticelloRemoteRepositories-TheIntegrator.15.mczMoose-Algos-Graph-vincentBlondeau.31.mczMorphic-Base-TheIntegrator.548.mczMorphic-Core-TheIntegrator.278.mczMorphic-Examples-TheIntegrator.50.mczMorphic-Tests-TheIntegrator.11.mczMorphic-Widgets-Basic-TheIntegrator.86.mczMorphic-Widgets-ColorPicker-TheIntegrator.19.mczMorphic-Widgets-Extra-TheIntegrator.27.mczMorphic-Widgets-FastTable-StephanEggermont.177.mczMorphic-Widgets-List-TheIntegrator.21.mczMorphic-Widgets-NewList-TheIntegrator.9.mczMorphic-Widgets-Pluggable-TheIntegrator.66.mczMorphic-Widgets-PolyTabs-TheIntegrator.2.mczMorphic-Widgets-Scrolling-TheIntegrator.32.mczMorphic-Widgets-Tabs-TheIntegrator.20.mczMorphic-Widgets-Taskbar-TheIntegrator.21.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.50.mczMorphic-Widgets-Windows-TheIntegrator.97.mczMultilingual-Encodings-TheIntegrator.61.mczMultilingual-Languages-TheIntegrator.55.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.81.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.244.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1253.mczNautilus-GroupManager-TheIntegrator.20.mczNautilus-GroupManagerUI-TheIntegrator.31.mczNautilus-Tests-TheIntegrator.37.mczNautilusCommon-TheIntegrator.305.mczNautilusGroupAutoBuilder-TheIntegrator.11.mczNautilusRefactoring-TheIntegrator.272.mczNetwork-Kernel-TheIntegrator.136.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-EstebanLorenzano.47.mczNetwork-Protocols-TheIntegrator.103.mczNetwork-Tests-EstebanLorenzano.15.mczNetwork-UUID-TheIntegrator.44.mczNetwork-Url-MarcusDenker.99.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.55.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-RonieSalgado.107.mczOSWindow-SDL2-RonieSalgado.96.mczOSWindow-SDL2-Examples-RonieSalgado.13.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOpalCompiler-Core-TheIntegrator.799.mczOpalCompiler-Tests-TheIntegrator.334.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.31.mczPolymorph-TaskbarIcons-TheIntegrator.46.mczPolymorph-Widgets-TheIntegrator.1340.mczPragmaCollector-TheIntegrator.12.mczProfStef-Core-TheIntegrator.77.mczProfStef-Help-TheIntegrator.16.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.101.mczQualityAssistantRecording-YuriyTymchuk.20.mczRPackage-Core-TheIntegrator.430.mczRPackage-Tests-TheIntegrator.181.mczRandom-Core-TheIntegrator.4.mczRandom-Tests-TheIntegrator.4.mczRecentSubmissions-TheIntegrator.238.mczRefactoring-Changes-TheIntegrator.67.mczRefactoring-Core-TheIntegrator.298.mczRefactoring-Critics-TheIntegrator.261.mczRefactoring-Environment-TheIntegrator.76.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.131.mczRefactoring-Tests-Critics-TheIntegrator.38.mczRefactoring-Tests-Environment-TheIntegrator.23.mczReflectivity-TheIntegrator.297.mczReflectivity-Examples-TheIntegrator.28.mczReflectivity-Tests-TheIntegrator.202.mczReflectivity-Tools-TheIntegrator.24.mczReflectivity-Tools-Tests-TheIntegrator.11.mczRegex-Core-TheIntegrator.38.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.31.mczRenraku-YuriyTymchuk.111.mczRenraku-Test-YuriyTymchuk.19.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.237.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.90.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.364.mczRubric-Rules-YuriyTymchuk.3.mczSTON-Core-PavelKrivanek.73.mczSTON-Tests-SvenVanCaekenberghe.64.mczSUnit-Core-TheIntegrator.169.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.3.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-EstebanLorenzano.138.mczSUnit-UITesting-TheIntegrator.32.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.94.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TommasoDalSasso.3.mczShoreLine-Report-UI-TommasoDalSasso.17.mczShout-TheIntegrator.291.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.742.mczSlot-Tests-TheIntegrator.89.mczSmartSuggestions-TheIntegrator.234.mczSmartSuggestions-Tests-TheIntegrator.33.mczSpec-Core-TheIntegrator.467.mczSpec-Debugger-TheIntegrator.263.mczSpec-Examples-TheIntegrator.108.mczSpec-Help-TheIntegrator.10.mczSpec-Inspector-TheIntegrator.258.mczSpec-Layout-TheIntegrator.69.mczSpec-MorphicAdapters-TheIntegrator.269.mczSpec-PolyWidgets-TheIntegrator.66.mczSpec-Tests-TheIntegrator.63.mczSpec-Tools-TheIntegrator.324.mczStartupPreferences-TheIntegrator.149.mczSystem-Announcements-TheIntegrator.108.mczSystem-BasicCommandLineHandler-TheIntegrator.18.mczSystem-Caching-TheIntegrator.26.mczSystem-CachingTests-TheIntegrator.16.mczSystem-Changes-TheIntegrator.292.mczSystem-Changes-FileServices-TheIntegrator.2.mczSystem-Clipboard-TheIntegrator.40.mczSystem-CommandLine-TheIntegrator.181.mczSystem-CommandLine-TextSupport-TheIntegrator.4.mczSystem-CommandLineHandler-TheIntegrator.18.mczSystem-FileRegistry-TheIntegrator.50.mczSystem-Finalization-TheIntegrator.32.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.106.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.4.mczSystem-OSEnvironments-TheIntegrator.31.mczSystem-Object Events-TheIntegrator.25.mczSystem-Platforms-TheIntegrator.81.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.27.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.337.mczSystem-Settings-Tests-TheIntegrator.11.mczSystem-Sound-StephaneDucasse.18.mczSystem-Sources-TheIntegrator.50.mczSystem-Support-TheIntegrator.1215.mczSystem-SupportTests-TheIntegrator.2.mczSystem-VMEvents-TheIntegrator.17.mczTests-TheIntegrator.755.mczText-Core-TheIntegrator.50.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.114.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.140.mczTool-Catalog-GuillermoPolito.32.mczTool-CriticBrowser-TheIntegrator.21.mczTool-DependencyAnalyser-ChristopheDemarey.28.mczTool-DependencyAnalyser-Test-ChristopheDemarey.11.mczTool-DependencyAnalyser-UI-ChristopheDemarey.43.mczTool-Diff-TheIntegrator.31.mczTool-ExternalBrowser-TheIntegrator.49.mczTool-FileList-TheIntegrator.62.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.65.mczTool-ImageCleaner-TheIntegrator.17.mczTool-ProcessBrowser-TheIntegrator.20.mczTool-Profilers-TheIntegrator.22.mczTool-SystemReporter-TheIntegrator.15.mczTool-Transcript-TheIntegrator.25.mczTool-TxWorkspace-NicolaiHess.7.mczTool-Workspace-TheIntegrator.37.mczTools-TheIntegrator.1525.mczTools-Test-TheIntegrator.16.mczTraits-TheIntegrator.907.mczTranscript-TheIntegrator.50.mczTxText-Athens-GuillermoPolito.53.mczTxText-AthensTests-SeanDeNigris.10.mczTxText-Model-SeanDeNigris.61.mczTxText-Styler-MarcusDenker.17.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.187.mczUnicode-Initialization-TheIntegrator.15.mczUnifiedFFI-EstebanLorenzano.70.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.25.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-VincentBlondeau.32.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-StephaneDucasse.64.mczVersionner-Core-DependenciesModel-ChristopheDemarey.105.mczVersionner-Core-Model-ChristopheDemarey.52.mczVersionner-Spec-Browser-PabloTesone.189.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczZinc-Character-Encoding-Core-TheIntegrator.48.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.27.mczZinc-FileSystem-SvenVanCaekenberghe.12.mczZinc-HTTP-SvenVanCaekenberghe.448.mczZinc-Resource-Meta-Core-TheIntegrator.58.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.36.mczZinc-Tests-SvenVanCaekenberghe.236.mczZinc-Zodiac-TheIntegrator.37.mczZodiac-Core-SvenVanCaekenberghe.42.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.13.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 2/20/2017 08:17'!update50769	"self new update50769"	self withUpdateLog: '19310 Backport Pharo 5.0: Wrong border after dragging out of a window group (backport 19299)	https://pharo.fogbugz.com/f/cases/19310'.	self loadTogether: self script50769 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update50768!ScriptLoader removeSelector: #script50768!"ScriptLoader50"!!Pharo3DarkTheme methodsFor: 'initialize-release' stamp: 'NicolaiHess 2/18/2017 09:15' prior: 52615639!initialize	"self beCurrent"	super initialize.	self windowActiveDropShadowStyle: #plain.	self settings preferGradientFill: false.! !!Pharo3Theme methodsFor: 'initialize-release' stamp: 'NicolaiHess 2/18/2017 09:15'!initialize	"self beCurrent"	super initialize.	self windowActiveDropShadowStyle: #plain.! !"Polymorph-Widgets"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo50/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader50-TheIntegrator.983.mcz') load.ScriptLoader new update50769.!----End fileIn----!----QUIT----2017-02-20T08:39:46.907065+01:00 Pharo.image priorSource: 392403!----QUIT----2017-02-20T08:39:50.461163+01:00 Pharo.image priorSource: 410147!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 2/22/2017 10:22' prior: 33947006!commentForCurrentUpdate ^ '19738 MCFtpRepository does not understand #koRemote	https://pharo.fogbugz.com/f/cases/19738'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 2/22/2017 10:22'!script50770	^ 'AST-Core-TheIntegrator.418.mczAST-FFI-Pharo50Compatibility-TheIntegrator.2.mczAST-Tests-Core-TheIntegrator.95.mczAlien-eem.32.mczAnnouncements-Core-TheIntegrator.68.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.31.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-NicolaiHess.123.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-EstebanLorenzano.63.mczAthens-Text-NicolaiHess.16.mczBalloon-TheIntegrator.132.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfFileTree-ThierryGoubier.15.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfQualityAssistant-YuriyTymchuk.46.mczBaselineOfRenraku-YuriyTymchuk.5.mczBlueInk-Core-TheIntegrator.24.mczBlueInk-Extras-TheIntegrator.10.mczBlueInk-Tests-TheIntegrator.12.mczChroma-CubeHelix-TheIntegrator.2.mczCodeExport-TheIntegrator.19.mczCodeImport-TheIntegrator.88.mczCodeImportCommandLineHandlers-TheIntegrator.7.mczCollections-Abstract-TheIntegrator.313.mczCollections-Arithmetic-TheIntegrator.20.mczCollections-Atomic-TheIntegrator.16.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.246.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.188.mczCollections-Strings-TheIntegrator.415.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.49.mczCollections-Unordered-TheIntegrator.232.mczCollections-Weak-TheIntegrator.102.mczCompiler-TheIntegrator.602.mczCompression-TheIntegrator.176.mczCompression-Tests-TheIntegrator.2.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.4.mczDebuggerActions-TheIntegrator.85.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.126.mczDeprecated50-TheIntegrator.59.mczEmbeddedFreeType-TheIntegrator.26.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczFFI-Kernel-JanVanDeSandt.40.mczFFI-Pools-eem.3.mczFileSystem-Core-TheIntegrator.202.mczFileSystem-Disk-TheIntegrator.97.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.95.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.417.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-TheIntegrator.17.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.14.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.742.mczFreeType-Tests-TheIntegrator.2.mczFuel-MaxLeske.825.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-TheIntegrator.64.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.411.mczFuelTools-Debugger-TheIntegrator.12.mczGT-BytecodeDebugger-TudorGirba.31.mczGT-Debugger-AndreiChis.350.mczGT-EventRecorder-TheIntegrator.68.mczGT-EventRecorder-Tests-JurajKubelka.37.mczGT-Inspector-AndreiChis.421.mczGT-InspectorExtensions-Core-TheIntegrator.214.mczGT-Playground-DenisKudryashov.124.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-TudorGirba.397.mczGT-Spotter-EventRecorder-GuillermoPolito.112.mczGT-SpotterExtensions-Core-VincentBlondeau.203.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-StefanReichhart.56.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AliakseiSyrel.17.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-EstebanLorenzano.323.mczGlamour-Examples-TudorGirba.303.mczGlamour-FastTable-AndreiChis.59.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-GuillermoPolito.418.mczGlamour-Morphic-Brick-Tests-TheIntegrator.14.mczGlamour-Morphic-Pager-GuillermoPolito.110.mczGlamour-Morphic-Renderer-AndreiChis.349.mczGlamour-Morphic-Theme-HenrikNergaard.222.mczGlamour-Morphic-Widgets-AndreiChis.195.mczGlamour-Presentations-AndreiChis.186.mczGlamour-Rubric-Presentations-AndreiChis.52.mczGlamour-Tests-Core-AndreiChis.111.mczGlamour-Tests-Morphic-TudorGirba.137.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.35.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.6.mczGraphics-Display Objects-TheIntegrator.175.mczGraphics-Files-TheIntegrator.76.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.189.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.80.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.41.mczHelpSystem-Core-TheIntegrator.144.mczHelpSystem-Tests-TheIntegrator.32.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.90.mczImportingResource-Help-TheIntegrator.4.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.28.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2295.mczKernel-Rules-TheIntegrator.2.mczKernel-Tests-TheIntegrator.65.mczKeymapping-Core-TheIntegrator.198.mczKeymapping-KeyCombinations-TheIntegrator.62.mczKeymapping-Pragmas-TheIntegrator.54.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.105.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.168.mczManifest-Core-TheIntegrator.239.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.51.mczMenuRegistration-TheIntegrator.78.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.824.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-EstebanLorenzano.733.mczMetacello-PharoCommonPlatform-TheIntegrator.22.mczMetacello-Platform-EstebanLorenzano.3.mczMetacello-ProfStef-EstebanLorenzano.18.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.7.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform.squeakCommon-EstebanLorenzano.23.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-EstebanLorenzano.148.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1132.mczMonticello-OldDataStreamCompatibility-TheIntegrator.8.mczMonticello-Tests-TheIntegrator.35.mczMonticelloConfigurations-TheIntegrator.72.mczMonticelloFileServices-TheIntegrator.6.mczMonticelloFileTree-Core-TheIntegrator.141.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.30.mczMonticelloGUI-TheIntegrator.415.mczMonticelloMocks-TheIntegrator.4.mczMonticelloRemoteRepositories-TheIntegrator.15.mczMoose-Algos-Graph-vincentBlondeau.31.mczMorphic-Base-TheIntegrator.548.mczMorphic-Core-TheIntegrator.278.mczMorphic-Examples-TheIntegrator.50.mczMorphic-Tests-TheIntegrator.11.mczMorphic-Widgets-Basic-TheIntegrator.86.mczMorphic-Widgets-ColorPicker-TheIntegrator.19.mczMorphic-Widgets-Extra-TheIntegrator.27.mczMorphic-Widgets-FastTable-StephanEggermont.177.mczMorphic-Widgets-List-TheIntegrator.21.mczMorphic-Widgets-NewList-TheIntegrator.9.mczMorphic-Widgets-Pluggable-TheIntegrator.66.mczMorphic-Widgets-PolyTabs-TheIntegrator.2.mczMorphic-Widgets-Scrolling-TheIntegrator.32.mczMorphic-Widgets-Tabs-TheIntegrator.20.mczMorphic-Widgets-Taskbar-TheIntegrator.21.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.50.mczMorphic-Widgets-Windows-TheIntegrator.97.mczMultilingual-Encodings-TheIntegrator.61.mczMultilingual-Languages-TheIntegrator.55.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.81.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.244.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1253.mczNautilus-GroupManager-TheIntegrator.20.mczNautilus-GroupManagerUI-TheIntegrator.31.mczNautilus-Tests-TheIntegrator.37.mczNautilusCommon-TheIntegrator.305.mczNautilusGroupAutoBuilder-TheIntegrator.11.mczNautilusRefactoring-TheIntegrator.272.mczNetwork-Kernel-TheIntegrator.136.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-EstebanLorenzano.47.mczNetwork-Protocols-TheIntegrator.103.mczNetwork-Tests-EstebanLorenzano.15.mczNetwork-UUID-TheIntegrator.44.mczNetwork-Url-MarcusDenker.99.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.55.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-RonieSalgado.107.mczOSWindow-SDL2-RonieSalgado.96.mczOSWindow-SDL2-Examples-RonieSalgado.13.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOpalCompiler-Core-TheIntegrator.799.mczOpalCompiler-Tests-TheIntegrator.334.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.31.mczPolymorph-TaskbarIcons-TheIntegrator.46.mczPolymorph-Widgets-TheIntegrator.1340.mczPragmaCollector-TheIntegrator.12.mczProfStef-Core-TheIntegrator.77.mczProfStef-Help-TheIntegrator.16.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.101.mczQualityAssistantRecording-YuriyTymchuk.20.mczRPackage-Core-TheIntegrator.430.mczRPackage-Tests-TheIntegrator.181.mczRandom-Core-TheIntegrator.4.mczRandom-Tests-TheIntegrator.4.mczRecentSubmissions-TheIntegrator.238.mczRefactoring-Changes-TheIntegrator.67.mczRefactoring-Core-TheIntegrator.298.mczRefactoring-Critics-TheIntegrator.261.mczRefactoring-Environment-TheIntegrator.76.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.131.mczRefactoring-Tests-Critics-TheIntegrator.38.mczRefactoring-Tests-Environment-TheIntegrator.23.mczReflectivity-TheIntegrator.297.mczReflectivity-Examples-TheIntegrator.28.mczReflectivity-Tests-TheIntegrator.202.mczReflectivity-Tools-TheIntegrator.24.mczReflectivity-Tools-Tests-TheIntegrator.11.mczRegex-Core-TheIntegrator.38.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.31.mczRenraku-YuriyTymchuk.111.mczRenraku-Test-YuriyTymchuk.19.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.237.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.90.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.364.mczRubric-Rules-YuriyTymchuk.3.mczSTON-Core-PavelKrivanek.73.mczSTON-Tests-SvenVanCaekenberghe.64.mczSUnit-Core-TheIntegrator.169.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.3.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-EstebanLorenzano.138.mczSUnit-UITesting-TheIntegrator.32.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.94.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TommasoDalSasso.3.mczShoreLine-Report-UI-TommasoDalSasso.17.mczShout-TheIntegrator.291.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.742.mczSlot-Tests-TheIntegrator.89.mczSmartSuggestions-TheIntegrator.234.mczSmartSuggestions-Tests-TheIntegrator.33.mczSpec-Core-TheIntegrator.467.mczSpec-Debugger-TheIntegrator.263.mczSpec-Examples-TheIntegrator.108.mczSpec-Help-TheIntegrator.10.mczSpec-Inspector-TheIntegrator.258.mczSpec-Layout-TheIntegrator.69.mczSpec-MorphicAdapters-TheIntegrator.269.mczSpec-PolyWidgets-TheIntegrator.66.mczSpec-Tests-TheIntegrator.63.mczSpec-Tools-TheIntegrator.324.mczStartupPreferences-TheIntegrator.149.mczSystem-Announcements-TheIntegrator.108.mczSystem-BasicCommandLineHandler-TheIntegrator.18.mczSystem-Caching-TheIntegrator.26.mczSystem-CachingTests-TheIntegrator.16.mczSystem-Changes-TheIntegrator.292.mczSystem-Changes-FileServices-TheIntegrator.2.mczSystem-Clipboard-TheIntegrator.40.mczSystem-CommandLine-TheIntegrator.181.mczSystem-CommandLine-TextSupport-TheIntegrator.4.mczSystem-CommandLineHandler-TheIntegrator.18.mczSystem-FileRegistry-TheIntegrator.50.mczSystem-Finalization-TheIntegrator.32.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.106.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.4.mczSystem-OSEnvironments-TheIntegrator.31.mczSystem-Object Events-TheIntegrator.25.mczSystem-Platforms-TheIntegrator.81.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.27.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.337.mczSystem-Settings-Tests-TheIntegrator.11.mczSystem-Sound-StephaneDucasse.18.mczSystem-Sources-TheIntegrator.50.mczSystem-Support-TheIntegrator.1215.mczSystem-SupportTests-TheIntegrator.2.mczSystem-VMEvents-TheIntegrator.17.mczTests-TheIntegrator.755.mczText-Core-TheIntegrator.50.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.114.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.140.mczTool-Catalog-GuillermoPolito.32.mczTool-CriticBrowser-TheIntegrator.21.mczTool-DependencyAnalyser-ChristopheDemarey.28.mczTool-DependencyAnalyser-Test-ChristopheDemarey.11.mczTool-DependencyAnalyser-UI-ChristopheDemarey.43.mczTool-Diff-TheIntegrator.31.mczTool-ExternalBrowser-TheIntegrator.49.mczTool-FileList-TheIntegrator.62.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.65.mczTool-ImageCleaner-TheIntegrator.17.mczTool-ProcessBrowser-TheIntegrator.20.mczTool-Profilers-TheIntegrator.22.mczTool-SystemReporter-TheIntegrator.15.mczTool-Transcript-TheIntegrator.25.mczTool-TxWorkspace-NicolaiHess.7.mczTool-Workspace-TheIntegrator.37.mczTools-TheIntegrator.1525.mczTools-Test-TheIntegrator.16.mczTraits-TheIntegrator.907.mczTranscript-TheIntegrator.50.mczTxText-Athens-GuillermoPolito.53.mczTxText-AthensTests-SeanDeNigris.10.mczTxText-Model-SeanDeNigris.61.mczTxText-Styler-MarcusDenker.17.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.187.mczUnicode-Initialization-TheIntegrator.15.mczUnifiedFFI-EstebanLorenzano.70.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.25.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-VincentBlondeau.32.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-StephaneDucasse.64.mczVersionner-Core-DependenciesModel-ChristopheDemarey.105.mczVersionner-Core-Model-ChristopheDemarey.52.mczVersionner-Spec-Browser-PabloTesone.189.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczZinc-Character-Encoding-Core-TheIntegrator.48.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.27.mczZinc-FileSystem-SvenVanCaekenberghe.12.mczZinc-HTTP-SvenVanCaekenberghe.448.mczZinc-Resource-Meta-Core-TheIntegrator.58.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.36.mczZinc-Tests-SvenVanCaekenberghe.236.mczZinc-Zodiac-TheIntegrator.37.mczZodiac-Core-SvenVanCaekenberghe.42.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.13.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 2/22/2017 10:22'!update50770	"self new update50770"	self withUpdateLog: '19738 MCFtpRepository does not understand #koRemote	https://pharo.fogbugz.com/f/cases/19738'.	self loadTogether: self script50770 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update50769!ScriptLoader removeSelector: #script50769!"ScriptLoader50"!!MCFtpRepository methodsFor: '*Komitter-Models' stamp: 'DirkRoeleveld 2/21/2017 22:39'!koRemote		^ KomitFtpRemote new		remote: self;		yourself! !!KomitFtpRemote methodsFor: '*Komitter-UI' stamp: 'DirkRoeleveld 2/21/2017 22:38'!icon	^ 'FTP'! !!KomitFtpRemote methodsFor: '*Komitter-UI' stamp: 'DirkRoeleveld 2/21/2017 22:38'!label		^ self remote location! !"Komitter"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo50/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader50-TheIntegrator.984.mcz') load.ScriptLoader new update50770.!----End fileIn----!----QUIT----2017-02-22T10:23:55.714756+01:00 Pharo.image priorSource: 410226!----QUIT----2017-02-22T10:23:59.186512+01:00 Pharo.image priorSource: 427828!----QUIT----2017-03-15T21:43:13.624113+01:00 Pharo.image priorSource: 427907!----QUIT----2017-03-15T21:43:19.4228+01:00 Pharo.image priorSource: 427986!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 3/21/2017 15:11' prior: 33964829!commentForCurrentUpdate ^ '19858 backport WinPlatform to Pharo5 to allow UFFI to load	https://pharo.fogbugz.com/f/cases/19858'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 3/21/2017 15:11'!script50771	^ 'AST-Core-TheIntegrator.418.mczAST-FFI-Pharo50Compatibility-TheIntegrator.2.mczAST-Tests-Core-TheIntegrator.95.mczAlien-eem.32.mczAnnouncements-Core-TheIntegrator.68.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.31.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-NicolaiHess.123.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-EstebanLorenzano.63.mczAthens-Text-NicolaiHess.16.mczBalloon-TheIntegrator.132.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfFileTree-ThierryGoubier.15.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfQualityAssistant-YuriyTymchuk.46.mczBaselineOfRenraku-YuriyTymchuk.5.mczBlueInk-Core-TheIntegrator.24.mczBlueInk-Extras-TheIntegrator.10.mczBlueInk-Tests-TheIntegrator.12.mczChroma-CubeHelix-TheIntegrator.2.mczCodeExport-TheIntegrator.19.mczCodeImport-TheIntegrator.88.mczCodeImportCommandLineHandlers-TheIntegrator.7.mczCollections-Abstract-TheIntegrator.313.mczCollections-Arithmetic-TheIntegrator.20.mczCollections-Atomic-TheIntegrator.16.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.246.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.188.mczCollections-Strings-TheIntegrator.415.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.49.mczCollections-Unordered-TheIntegrator.232.mczCollections-Weak-TheIntegrator.102.mczCompiler-TheIntegrator.602.mczCompression-TheIntegrator.176.mczCompression-Tests-TheIntegrator.2.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.4.mczDebuggerActions-TheIntegrator.85.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.126.mczDeprecated50-TheIntegrator.59.mczEmbeddedFreeType-TheIntegrator.26.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczFFI-Kernel-JanVanDeSandt.40.mczFFI-Pools-eem.3.mczFileSystem-Core-TheIntegrator.202.mczFileSystem-Disk-TheIntegrator.97.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.95.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.417.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-TheIntegrator.17.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.14.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.742.mczFreeType-Tests-TheIntegrator.2.mczFuel-MaxLeske.825.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-TheIntegrator.64.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.411.mczFuelTools-Debugger-TheIntegrator.12.mczGT-BytecodeDebugger-TudorGirba.31.mczGT-Debugger-AndreiChis.350.mczGT-EventRecorder-TheIntegrator.68.mczGT-EventRecorder-Tests-JurajKubelka.37.mczGT-Inspector-AndreiChis.421.mczGT-InspectorExtensions-Core-TheIntegrator.214.mczGT-Playground-DenisKudryashov.124.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-TudorGirba.397.mczGT-Spotter-EventRecorder-GuillermoPolito.112.mczGT-SpotterExtensions-Core-VincentBlondeau.203.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-StefanReichhart.56.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AliakseiSyrel.17.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-EstebanLorenzano.323.mczGlamour-Examples-TudorGirba.303.mczGlamour-FastTable-AndreiChis.59.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-GuillermoPolito.418.mczGlamour-Morphic-Brick-Tests-TheIntegrator.14.mczGlamour-Morphic-Pager-GuillermoPolito.110.mczGlamour-Morphic-Renderer-AndreiChis.349.mczGlamour-Morphic-Theme-HenrikNergaard.222.mczGlamour-Morphic-Widgets-AndreiChis.195.mczGlamour-Presentations-AndreiChis.186.mczGlamour-Rubric-Presentations-AndreiChis.52.mczGlamour-Tests-Core-AndreiChis.111.mczGlamour-Tests-Morphic-TudorGirba.137.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.35.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.6.mczGraphics-Display Objects-TheIntegrator.175.mczGraphics-Files-TheIntegrator.76.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.189.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.80.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.41.mczHelpSystem-Core-TheIntegrator.144.mczHelpSystem-Tests-TheIntegrator.32.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.90.mczImportingResource-Help-TheIntegrator.4.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.28.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2295.mczKernel-Rules-TheIntegrator.2.mczKernel-Tests-TheIntegrator.65.mczKeymapping-Core-TheIntegrator.198.mczKeymapping-KeyCombinations-TheIntegrator.62.mczKeymapping-Pragmas-TheIntegrator.54.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.105.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.168.mczManifest-Core-TheIntegrator.239.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.51.mczMenuRegistration-TheIntegrator.78.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.824.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-EstebanLorenzano.733.mczMetacello-PharoCommonPlatform-TheIntegrator.22.mczMetacello-Platform-EstebanLorenzano.3.mczMetacello-ProfStef-EstebanLorenzano.18.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.7.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform.squeakCommon-EstebanLorenzano.23.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-EstebanLorenzano.148.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1132.mczMonticello-OldDataStreamCompatibility-TheIntegrator.8.mczMonticello-Tests-TheIntegrator.35.mczMonticelloConfigurations-TheIntegrator.72.mczMonticelloFileServices-TheIntegrator.6.mczMonticelloFileTree-Core-TheIntegrator.141.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.30.mczMonticelloGUI-TheIntegrator.415.mczMonticelloMocks-TheIntegrator.4.mczMonticelloRemoteRepositories-TheIntegrator.15.mczMoose-Algos-Graph-vincentBlondeau.31.mczMorphic-Base-TheIntegrator.548.mczMorphic-Core-TheIntegrator.278.mczMorphic-Examples-TheIntegrator.50.mczMorphic-Tests-TheIntegrator.11.mczMorphic-Widgets-Basic-TheIntegrator.86.mczMorphic-Widgets-ColorPicker-TheIntegrator.19.mczMorphic-Widgets-Extra-TheIntegrator.27.mczMorphic-Widgets-FastTable-StephanEggermont.177.mczMorphic-Widgets-List-TheIntegrator.21.mczMorphic-Widgets-NewList-TheIntegrator.9.mczMorphic-Widgets-Pluggable-TheIntegrator.66.mczMorphic-Widgets-PolyTabs-TheIntegrator.2.mczMorphic-Widgets-Scrolling-TheIntegrator.32.mczMorphic-Widgets-Tabs-TheIntegrator.20.mczMorphic-Widgets-Taskbar-TheIntegrator.21.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.50.mczMorphic-Widgets-Windows-TheIntegrator.97.mczMultilingual-Encodings-TheIntegrator.61.mczMultilingual-Languages-TheIntegrator.55.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.81.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.244.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1253.mczNautilus-GroupManager-TheIntegrator.20.mczNautilus-GroupManagerUI-TheIntegrator.31.mczNautilus-Tests-TheIntegrator.37.mczNautilusCommon-TheIntegrator.305.mczNautilusGroupAutoBuilder-TheIntegrator.11.mczNautilusRefactoring-TheIntegrator.272.mczNetwork-Kernel-TheIntegrator.136.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-EstebanLorenzano.47.mczNetwork-Protocols-TheIntegrator.103.mczNetwork-Tests-EstebanLorenzano.15.mczNetwork-UUID-TheIntegrator.44.mczNetwork-Url-MarcusDenker.99.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.55.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-RonieSalgado.107.mczOSWindow-SDL2-RonieSalgado.96.mczOSWindow-SDL2-Examples-RonieSalgado.13.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOpalCompiler-Core-TheIntegrator.799.mczOpalCompiler-Tests-TheIntegrator.334.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.31.mczPolymorph-TaskbarIcons-TheIntegrator.46.mczPolymorph-Widgets-TheIntegrator.1340.mczPragmaCollector-TheIntegrator.12.mczProfStef-Core-TheIntegrator.77.mczProfStef-Help-TheIntegrator.16.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.101.mczQualityAssistantRecording-YuriyTymchuk.20.mczRPackage-Core-TheIntegrator.430.mczRPackage-Tests-TheIntegrator.181.mczRandom-Core-TheIntegrator.4.mczRandom-Tests-TheIntegrator.4.mczRecentSubmissions-TheIntegrator.238.mczRefactoring-Changes-TheIntegrator.67.mczRefactoring-Core-TheIntegrator.298.mczRefactoring-Critics-TheIntegrator.261.mczRefactoring-Environment-TheIntegrator.76.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.131.mczRefactoring-Tests-Critics-TheIntegrator.38.mczRefactoring-Tests-Environment-TheIntegrator.23.mczReflectivity-TheIntegrator.297.mczReflectivity-Examples-TheIntegrator.28.mczReflectivity-Tests-TheIntegrator.202.mczReflectivity-Tools-TheIntegrator.24.mczReflectivity-Tools-Tests-TheIntegrator.11.mczRegex-Core-TheIntegrator.38.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.31.mczRenraku-YuriyTymchuk.111.mczRenraku-Test-YuriyTymchuk.19.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.237.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.90.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.364.mczRubric-Rules-YuriyTymchuk.3.mczSTON-Core-PavelKrivanek.73.mczSTON-Tests-SvenVanCaekenberghe.64.mczSUnit-Core-TheIntegrator.169.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.3.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-EstebanLorenzano.138.mczSUnit-UITesting-TheIntegrator.32.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.94.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TommasoDalSasso.3.mczShoreLine-Report-UI-TommasoDalSasso.17.mczShout-TheIntegrator.291.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.742.mczSlot-Tests-TheIntegrator.89.mczSmartSuggestions-TheIntegrator.234.mczSmartSuggestions-Tests-TheIntegrator.33.mczSpec-Core-TheIntegrator.467.mczSpec-Debugger-TheIntegrator.263.mczSpec-Examples-TheIntegrator.108.mczSpec-Help-TheIntegrator.10.mczSpec-Inspector-TheIntegrator.258.mczSpec-Layout-TheIntegrator.69.mczSpec-MorphicAdapters-TheIntegrator.269.mczSpec-PolyWidgets-TheIntegrator.66.mczSpec-Tests-TheIntegrator.63.mczSpec-Tools-TheIntegrator.324.mczStartupPreferences-TheIntegrator.149.mczSystem-Announcements-TheIntegrator.108.mczSystem-BasicCommandLineHandler-TheIntegrator.18.mczSystem-Caching-TheIntegrator.26.mczSystem-CachingTests-TheIntegrator.16.mczSystem-Changes-TheIntegrator.292.mczSystem-Changes-FileServices-TheIntegrator.2.mczSystem-Clipboard-TheIntegrator.40.mczSystem-CommandLine-TheIntegrator.181.mczSystem-CommandLine-TextSupport-TheIntegrator.4.mczSystem-CommandLineHandler-TheIntegrator.18.mczSystem-FileRegistry-TheIntegrator.50.mczSystem-Finalization-TheIntegrator.32.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.106.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.4.mczSystem-OSEnvironments-TheIntegrator.31.mczSystem-Object Events-TheIntegrator.25.mczSystem-Platforms-TheIntegrator.83.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.27.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.337.mczSystem-Settings-Tests-TheIntegrator.11.mczSystem-Sound-StephaneDucasse.18.mczSystem-Sources-TheIntegrator.50.mczSystem-Support-TheIntegrator.1215.mczSystem-SupportTests-TheIntegrator.2.mczSystem-VMEvents-TheIntegrator.17.mczTests-TheIntegrator.755.mczText-Core-TheIntegrator.50.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.114.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.140.mczTool-Catalog-GuillermoPolito.32.mczTool-CriticBrowser-TheIntegrator.21.mczTool-DependencyAnalyser-ChristopheDemarey.28.mczTool-DependencyAnalyser-Test-ChristopheDemarey.11.mczTool-DependencyAnalyser-UI-ChristopheDemarey.43.mczTool-Diff-TheIntegrator.31.mczTool-ExternalBrowser-TheIntegrator.49.mczTool-FileList-TheIntegrator.62.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.65.mczTool-ImageCleaner-TheIntegrator.17.mczTool-ProcessBrowser-TheIntegrator.20.mczTool-Profilers-TheIntegrator.22.mczTool-SystemReporter-TheIntegrator.15.mczTool-Transcript-TheIntegrator.25.mczTool-TxWorkspace-NicolaiHess.7.mczTool-Workspace-TheIntegrator.37.mczTools-TheIntegrator.1525.mczTools-Test-TheIntegrator.16.mczTraits-TheIntegrator.907.mczTranscript-TheIntegrator.50.mczTxText-Athens-GuillermoPolito.53.mczTxText-AthensTests-SeanDeNigris.10.mczTxText-Model-SeanDeNigris.61.mczTxText-Styler-MarcusDenker.17.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.187.mczUnicode-Initialization-TheIntegrator.15.mczUnifiedFFI-EstebanLorenzano.70.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.25.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-VincentBlondeau.32.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-StephaneDucasse.64.mczVersionner-Core-DependenciesModel-ChristopheDemarey.105.mczVersionner-Core-Model-ChristopheDemarey.52.mczVersionner-Spec-Browser-PabloTesone.189.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczZinc-Character-Encoding-Core-TheIntegrator.48.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.27.mczZinc-FileSystem-SvenVanCaekenberghe.12.mczZinc-HTTP-SvenVanCaekenberghe.448.mczZinc-Resource-Meta-Core-TheIntegrator.58.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.36.mczZinc-Tests-SvenVanCaekenberghe.236.mczZinc-Zodiac-TheIntegrator.37.mczZodiac-Core-SvenVanCaekenberghe.42.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.13.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 3/21/2017 15:11'!update50771	"self new update50771"	self withUpdateLog: '19858 backport WinPlatform to Pharo5 to allow UFFI to load	https://pharo.fogbugz.com/f/cases/19858'.	self loadTogether: self script50771 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update50770!ScriptLoader removeSelector: #script50770!"ScriptLoader50"!!WinPlatform commentStamp: '<historical>' prior: 0!I am a an object representing a Windows platform. Use myself to access platform specific features.Please keep me polymorphic to the the other platform objects.To get the current platform, you can evaluate:OSPlatform current.!"System-Platforms"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo50/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader50-TheIntegrator.985.mcz') load.ScriptLoader new update50771.!----End fileIn----!----QUIT----2017-03-21T15:12:59.958045+01:00 Pharo.image priorSource: 428065!----QUIT----2017-03-21T15:13:04.999903+01:00 Pharo.image priorSource: 445601!----QUIT----2017-03-24T07:39:59.261256+01:00 Pharo.image priorSource: 445680!----QUIT----2017-03-24T07:40:04.862679+01:00 Pharo.image priorSource: 445759!----QUIT----2017-04-02T04:04:36.669366+02:00 Pharo.image priorSource: 445838!----QUIT----2017-04-02T04:04:41.883721+02:00 Pharo.image priorSource: 445917!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 4/26/2017 11:43' prior: 33982666!commentForCurrentUpdate ^ '19974 backport Traits methods flattened (case 19938)	https://pharo.fogbugz.com/f/cases/19974'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 4/26/2017 11:43'!script50772	^ 'AST-Core-TheIntegrator.418.mczAST-FFI-Pharo50Compatibility-TheIntegrator.2.mczAST-Tests-Core-TheIntegrator.95.mczAlien-eem.32.mczAnnouncements-Core-TheIntegrator.68.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.31.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-NicolaiHess.123.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-EstebanLorenzano.63.mczAthens-Text-NicolaiHess.16.mczBalloon-TheIntegrator.132.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfFileTree-ThierryGoubier.15.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfQualityAssistant-YuriyTymchuk.46.mczBaselineOfRenraku-YuriyTymchuk.5.mczBlueInk-Core-TheIntegrator.24.mczBlueInk-Extras-TheIntegrator.10.mczBlueInk-Tests-TheIntegrator.12.mczChroma-CubeHelix-TheIntegrator.2.mczCodeExport-TheIntegrator.19.mczCodeImport-TheIntegrator.88.mczCodeImportCommandLineHandlers-TheIntegrator.7.mczCollections-Abstract-TheIntegrator.313.mczCollections-Arithmetic-TheIntegrator.20.mczCollections-Atomic-TheIntegrator.16.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.246.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.188.mczCollections-Strings-TheIntegrator.415.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.49.mczCollections-Unordered-TheIntegrator.232.mczCollections-Weak-TheIntegrator.102.mczCompiler-TheIntegrator.602.mczCompression-TheIntegrator.176.mczCompression-Tests-TheIntegrator.2.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.4.mczDebuggerActions-TheIntegrator.85.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.126.mczDeprecated50-TheIntegrator.59.mczEmbeddedFreeType-TheIntegrator.26.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczFFI-Kernel-JanVanDeSandt.40.mczFFI-Pools-eem.3.mczFileSystem-Core-TheIntegrator.202.mczFileSystem-Disk-TheIntegrator.97.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.95.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.417.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-TheIntegrator.17.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.14.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.742.mczFreeType-Tests-TheIntegrator.2.mczFuel-MaxLeske.825.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-TheIntegrator.64.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.411.mczFuelTools-Debugger-TheIntegrator.12.mczGT-BytecodeDebugger-TudorGirba.31.mczGT-Debugger-AndreiChis.350.mczGT-EventRecorder-TheIntegrator.68.mczGT-EventRecorder-Tests-JurajKubelka.37.mczGT-Inspector-AndreiChis.421.mczGT-InspectorExtensions-Core-TheIntegrator.214.mczGT-Playground-DenisKudryashov.124.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-TudorGirba.397.mczGT-Spotter-EventRecorder-GuillermoPolito.112.mczGT-SpotterExtensions-Core-VincentBlondeau.203.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-StefanReichhart.56.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AliakseiSyrel.17.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-EstebanLorenzano.323.mczGlamour-Examples-TudorGirba.303.mczGlamour-FastTable-AndreiChis.59.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-GuillermoPolito.418.mczGlamour-Morphic-Brick-Tests-TheIntegrator.14.mczGlamour-Morphic-Pager-GuillermoPolito.110.mczGlamour-Morphic-Renderer-AndreiChis.349.mczGlamour-Morphic-Theme-HenrikNergaard.222.mczGlamour-Morphic-Widgets-AndreiChis.195.mczGlamour-Presentations-AndreiChis.186.mczGlamour-Rubric-Presentations-AndreiChis.52.mczGlamour-Tests-Core-AndreiChis.111.mczGlamour-Tests-Morphic-TudorGirba.137.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.35.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.6.mczGraphics-Display Objects-TheIntegrator.175.mczGraphics-Files-TheIntegrator.76.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.189.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.80.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.41.mczHelpSystem-Core-TheIntegrator.144.mczHelpSystem-Tests-TheIntegrator.32.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.90.mczImportingResource-Help-TheIntegrator.4.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.28.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2295.mczKernel-Rules-TheIntegrator.2.mczKernel-Tests-TheIntegrator.65.mczKeymapping-Core-TheIntegrator.198.mczKeymapping-KeyCombinations-TheIntegrator.62.mczKeymapping-Pragmas-TheIntegrator.54.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.105.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.168.mczManifest-Core-TheIntegrator.239.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.51.mczMenuRegistration-TheIntegrator.78.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.824.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-EstebanLorenzano.733.mczMetacello-PharoCommonPlatform-TheIntegrator.22.mczMetacello-Platform-EstebanLorenzano.3.mczMetacello-ProfStef-EstebanLorenzano.18.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.7.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform.squeakCommon-EstebanLorenzano.23.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-EstebanLorenzano.148.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1132.mczMonticello-OldDataStreamCompatibility-TheIntegrator.8.mczMonticello-Tests-TheIntegrator.35.mczMonticelloConfigurations-TheIntegrator.72.mczMonticelloFileServices-TheIntegrator.6.mczMonticelloFileTree-Core-TheIntegrator.141.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.30.mczMonticelloGUI-TheIntegrator.415.mczMonticelloMocks-TheIntegrator.4.mczMonticelloRemoteRepositories-TheIntegrator.15.mczMoose-Algos-Graph-vincentBlondeau.31.mczMorphic-Base-TheIntegrator.548.mczMorphic-Core-TheIntegrator.278.mczMorphic-Examples-TheIntegrator.50.mczMorphic-Tests-TheIntegrator.11.mczMorphic-Widgets-Basic-TheIntegrator.86.mczMorphic-Widgets-ColorPicker-TheIntegrator.19.mczMorphic-Widgets-Extra-TheIntegrator.27.mczMorphic-Widgets-FastTable-StephanEggermont.177.mczMorphic-Widgets-List-TheIntegrator.21.mczMorphic-Widgets-NewList-TheIntegrator.9.mczMorphic-Widgets-Pluggable-TheIntegrator.66.mczMorphic-Widgets-PolyTabs-TheIntegrator.2.mczMorphic-Widgets-Scrolling-TheIntegrator.32.mczMorphic-Widgets-Tabs-TheIntegrator.20.mczMorphic-Widgets-Taskbar-TheIntegrator.21.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.50.mczMorphic-Widgets-Windows-TheIntegrator.97.mczMultilingual-Encodings-TheIntegrator.61.mczMultilingual-Languages-TheIntegrator.55.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.81.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.244.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1253.mczNautilus-GroupManager-TheIntegrator.20.mczNautilus-GroupManagerUI-TheIntegrator.31.mczNautilus-Tests-TheIntegrator.37.mczNautilusCommon-TheIntegrator.305.mczNautilusGroupAutoBuilder-TheIntegrator.11.mczNautilusRefactoring-TheIntegrator.272.mczNetwork-Kernel-TheIntegrator.136.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-EstebanLorenzano.47.mczNetwork-Protocols-TheIntegrator.103.mczNetwork-Tests-EstebanLorenzano.15.mczNetwork-UUID-TheIntegrator.44.mczNetwork-Url-MarcusDenker.99.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.55.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-RonieSalgado.107.mczOSWindow-SDL2-RonieSalgado.96.mczOSWindow-SDL2-Examples-RonieSalgado.13.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOpalCompiler-Core-TheIntegrator.799.mczOpalCompiler-Tests-TheIntegrator.334.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.31.mczPolymorph-TaskbarIcons-TheIntegrator.46.mczPolymorph-Widgets-TheIntegrator.1340.mczPragmaCollector-TheIntegrator.12.mczProfStef-Core-TheIntegrator.77.mczProfStef-Help-TheIntegrator.16.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.101.mczQualityAssistantRecording-YuriyTymchuk.20.mczRPackage-Core-TheIntegrator.432.mczRPackage-Tests-TheIntegrator.181.mczRandom-Core-TheIntegrator.4.mczRandom-Tests-TheIntegrator.4.mczRecentSubmissions-TheIntegrator.238.mczRefactoring-Changes-TheIntegrator.67.mczRefactoring-Core-TheIntegrator.298.mczRefactoring-Critics-TheIntegrator.261.mczRefactoring-Environment-TheIntegrator.76.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.131.mczRefactoring-Tests-Critics-TheIntegrator.38.mczRefactoring-Tests-Environment-TheIntegrator.23.mczReflectivity-TheIntegrator.297.mczReflectivity-Examples-TheIntegrator.28.mczReflectivity-Tests-TheIntegrator.202.mczReflectivity-Tools-TheIntegrator.24.mczReflectivity-Tools-Tests-TheIntegrator.11.mczRegex-Core-TheIntegrator.38.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.31.mczRenraku-YuriyTymchuk.111.mczRenraku-Test-YuriyTymchuk.19.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.237.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.90.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.364.mczRubric-Rules-YuriyTymchuk.3.mczSTON-Core-PavelKrivanek.73.mczSTON-Tests-SvenVanCaekenberghe.64.mczSUnit-Core-TheIntegrator.169.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.3.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-EstebanLorenzano.138.mczSUnit-UITesting-TheIntegrator.32.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.94.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TommasoDalSasso.3.mczShoreLine-Report-UI-TommasoDalSasso.17.mczShout-TheIntegrator.291.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.742.mczSlot-Tests-TheIntegrator.89.mczSmartSuggestions-TheIntegrator.234.mczSmartSuggestions-Tests-TheIntegrator.33.mczSpec-Core-TheIntegrator.467.mczSpec-Debugger-TheIntegrator.263.mczSpec-Examples-TheIntegrator.108.mczSpec-Help-TheIntegrator.10.mczSpec-Inspector-TheIntegrator.258.mczSpec-Layout-TheIntegrator.69.mczSpec-MorphicAdapters-TheIntegrator.269.mczSpec-PolyWidgets-TheIntegrator.66.mczSpec-Tests-TheIntegrator.63.mczSpec-Tools-TheIntegrator.324.mczStartupPreferences-TheIntegrator.149.mczSystem-Announcements-TheIntegrator.108.mczSystem-BasicCommandLineHandler-TheIntegrator.18.mczSystem-Caching-TheIntegrator.26.mczSystem-CachingTests-TheIntegrator.16.mczSystem-Changes-TheIntegrator.292.mczSystem-Changes-FileServices-TheIntegrator.2.mczSystem-Clipboard-TheIntegrator.40.mczSystem-CommandLine-TheIntegrator.181.mczSystem-CommandLine-TextSupport-TheIntegrator.4.mczSystem-CommandLineHandler-TheIntegrator.18.mczSystem-FileRegistry-TheIntegrator.50.mczSystem-Finalization-TheIntegrator.32.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.106.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.4.mczSystem-OSEnvironments-TheIntegrator.31.mczSystem-Object Events-TheIntegrator.25.mczSystem-Platforms-TheIntegrator.83.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.27.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.337.mczSystem-Settings-Tests-TheIntegrator.11.mczSystem-Sound-StephaneDucasse.18.mczSystem-Sources-TheIntegrator.50.mczSystem-Support-TheIntegrator.1215.mczSystem-SupportTests-TheIntegrator.2.mczSystem-VMEvents-TheIntegrator.17.mczTests-TheIntegrator.755.mczText-Core-TheIntegrator.50.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.114.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.140.mczTool-Catalog-GuillermoPolito.32.mczTool-CriticBrowser-TheIntegrator.21.mczTool-DependencyAnalyser-ChristopheDemarey.28.mczTool-DependencyAnalyser-Test-ChristopheDemarey.11.mczTool-DependencyAnalyser-UI-ChristopheDemarey.43.mczTool-Diff-TheIntegrator.31.mczTool-ExternalBrowser-TheIntegrator.49.mczTool-FileList-TheIntegrator.62.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.65.mczTool-ImageCleaner-TheIntegrator.17.mczTool-ProcessBrowser-TheIntegrator.20.mczTool-Profilers-TheIntegrator.22.mczTool-SystemReporter-TheIntegrator.15.mczTool-Transcript-TheIntegrator.25.mczTool-TxWorkspace-NicolaiHess.7.mczTool-Workspace-TheIntegrator.37.mczTools-TheIntegrator.1525.mczTools-Test-TheIntegrator.16.mczTraits-TheIntegrator.907.mczTranscript-TheIntegrator.50.mczTxText-Athens-GuillermoPolito.53.mczTxText-AthensTests-SeanDeNigris.10.mczTxText-Model-SeanDeNigris.61.mczTxText-Styler-MarcusDenker.17.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.187.mczUnicode-Initialization-TheIntegrator.15.mczUnifiedFFI-EstebanLorenzano.70.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.25.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-VincentBlondeau.32.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-StephaneDucasse.64.mczVersionner-Core-DependenciesModel-ChristopheDemarey.105.mczVersionner-Core-Model-ChristopheDemarey.52.mczVersionner-Spec-Browser-PabloTesone.189.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczZinc-Character-Encoding-Core-TheIntegrator.48.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.27.mczZinc-FileSystem-SvenVanCaekenberghe.12.mczZinc-HTTP-SvenVanCaekenberghe.448.mczZinc-Resource-Meta-Core-TheIntegrator.58.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.36.mczZinc-Tests-SvenVanCaekenberghe.236.mczZinc-Zodiac-TheIntegrator.37.mczZodiac-Core-SvenVanCaekenberghe.42.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.13.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 4/26/2017 11:43'!update50772	"self new update50772"	self withUpdateLog: '19974 backport Traits methods flattened (case 19938)	https://pharo.fogbugz.com/f/cases/19974'.	self loadTogether: self script50772 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update50771!ScriptLoader removeSelector: #script50771!"ScriptLoader50"!!RPackage methodsFor: 'private' stamp: 'PavelKrivanek 4/19/2017 13:04' prior: 55205739!importProtocol: aProtocol forClass: aClass 	"import all the methods of a protocol as defined in the receiver." 			(aClass organization listAtCategoryNamed: aProtocol)			do: [:each | 				| aCompiledMethod |				aCompiledMethod := (aClass >> each).				aCompiledMethod isFromTrait ifFalse: [ self addMethod: aCompiledMethod ]].		! !"RPackage-Core"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo50/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader50-TheIntegrator.986.mcz') load.ScriptLoader new update50772.!----End fileIn----!----QUIT----2017-04-26T12:55:51.298419+02:00 Pharo.image priorSource: 445996!----QUIT----2017-04-26T12:55:54.811359+02:00 Pharo.image priorSource: 463661!Object subclass: #WebService	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Flexin'!!WebService commentStamp: '<historical>' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State a one line summary. For example, "I represent a paragraph of text".For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Implementation Points!!WebService methodsFor: 'sql' stamp: 'BasileDyment 4/8/2017 16:02'!sqlQuery: sqlcommand	"Treat the sql command"|result stream next list connection|	list := OrderedCollection new.	connection := GADriver fromConnectionString: 'postgresV2://webtp.fil.univ-lille1.fr:5432/dyment?&user=dyment&password=dymentbouziane'.	connection connect.	Transcript show: connection isConnected.	result  := connection execute: sqlcommand.	stream := result readStream.	[next := stream next. next isNil] whileFalse: [list add: (next dataKeyedByFieldName)].	connection close.	^ list.! !!WebService methodsFor: 'connection' stamp: 'BasileDyment 4/30/2017 13:07'!restRoute	"route the method"|teapot| 	teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');		GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; start.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!WebService class	instanceVariableNames: ''!!WebService class methodsFor: 'WebService' stamp: 'BasileDyment 3/23/2017 12:38'!getMateriel	"comment stating purpose of message"	| connection result teapot next json collection stream |connection := GADriver fromConnectionString:	'postgresV2://webtp.fil.univ-lille1.fr:5432/dyment?&user=dyment&password=bdym1992'.connection connect.json := NeoJSONWriter new.collection := OrderedCollection new.result := connection execute: 'SELECT nom FROM "Materiel"'.stream := result readStream.connection close.[ next := stream next. next isNil ] whileFalse: [   collection add:((next data)at: 1).].teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.teapot   GET: '/materiel' -> collection  ;	GET: '/sous' -> 'Salut Basile'; start.! !!WebService class methodsFor: 'WebService' stamp: 'BasileDyment 3/23/2017 12:38'!connectionSQL	"comment stating purpose of message"	| connection result|connection := GADriver fromConnectionString:	'postgresV2://webtp.fil.univ-lille1.fr:5432/dyment?&user=dyment&password=bdym1992'.connection connect.result := connection execute: 'SELECT nom FROM "Materiel"'.connection close.! !----End fileIn----!Object subclass: #WebService	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Flexin'!!WebService methodsFor: 'sql' stamp: 'BasileDyment 4/8/2017 16:02' prior: 34019141!sqlQuery: sqlcommand	"Treat the sql command"|result stream next list connection|	list := OrderedCollection new.	connection := GADriver fromConnectionString: 'postgresV2://webtp.fil.univ-lille1.fr:5432/dyment?&user=dyment&password=dymentbouziane'.	connection connect.	Transcript show: connection isConnected.	result  := connection execute: sqlcommand.	stream := result readStream.	[next := stream next. next isNil] whileFalse: [list add: (next dataKeyedByFieldName)].	connection close.	^ list.! !!WebService methodsFor: 'connection' stamp: 'BasileDyment 4/30/2017 13:07' prior: 34019725!restRoute	"route the method"|teapot| 	teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');		GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; start.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!WebService class	instanceVariableNames: ''!!WebService class methodsFor: 'WebService' stamp: 'BasileDyment 3/23/2017 12:38' prior: 34020504!getMateriel	"comment stating purpose of message"	| connection result teapot next json collection stream |connection := GADriver fromConnectionString:	'postgresV2://webtp.fil.univ-lille1.fr:5432/dyment?&user=dyment&password=bdym1992'.connection connect.json := NeoJSONWriter new.collection := OrderedCollection new.result := connection execute: 'SELECT nom FROM "Materiel"'.stream := result readStream.connection close.[ next := stream next. next isNil ] whileFalse: [   collection add:((next data)at: 1).].teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.teapot   GET: '/materiel' -> collection  ;	GET: '/sous' -> 'Salut Basile'; start.! !!WebService class methodsFor: 'WebService' stamp: 'BasileDyment 3/23/2017 12:38' prior: 34021293!connectionSQL	"comment stating purpose of message"	| connection result|connection := GADriver fromConnectionString:	'postgresV2://webtp.fil.univ-lille1.fr:5432/dyment?&user=dyment&password=bdym1992'.connection connect.result := connection execute: 'SELECT nom FROM "Materiel"'.connection close.! !----End fileIn----!----End fileIn----!----End fileIn----!----QUIT----2017-04-30T16:07:43.98045+02:00 Pharo5.0.image priorSource: 463740!----End fileIn----!!ConfigurationOfTeapot commentStamp: 'TorstenBergmann 10/12/2015 10:01' prior: 0!Configuration for Teapot micro web framework.See http://smalltalkhub.com/#!!/~zeroflag/Teapot!!ConfigurationOfTeapot class methodsFor: 'development support' stamp: 'AttilaMagyar 8/24/2014 18:38'!DevelopmentSupport"See the methods in the 'development support' category on the class-side of MetacelloBaseConfiguration. Decide what development support methods you would like to use and copy them the the class-side of your configuration."	<apiDocumentation>! !!ConfigurationOfTeapot class methodsFor: 'private' stamp: 'AttilaMagyar 8/24/2014 18:38'!baseConfigurationClassIfAbsent: aBlock	^Smalltalk		at: #MetacelloBaseConfiguration		ifAbsent: [ 			self ensureMetacelloBaseConfiguration.			Smalltalk at: #MetacelloBaseConfiguration ifAbsent: aBlock ].! !!ConfigurationOfTeapot class methodsFor: 'catalog' stamp: 'TorstenBergmann 10/12/2015 10:02'!catalogChangeLog	"Returns a paragraph describing the most important changes in the configuration class."	^ ' '! !!ConfigurationOfTeapot class methodsFor: 'catalog' stamp: 'TorstenBergmann 10/12/2015 10:01'!catalogContactInfo	"Returns a paragraph describing contact information such as email, mailing lists and website."	^ 'Contact the authors on the Pharo developer list (http://lists.pharo.org)'! !!ConfigurationOfTeapot class methodsFor: 'catalog' stamp: 'TorstenBergmann 10/12/2015 10:02'!catalogDescription	"Returns a paragraph describing the project"	^ 'Teapot is micro web framework on top of the Zinc HTTP components, that focuses on simplicity and ease of use.'! !!ConfigurationOfTeapot class methodsFor: 'catalog' stamp: 'TorstenBergmann 10/12/2015 10:03'!catalogKeyClassesAndExample	"Returns a paragraph or more describing the key classes of your project. You can use Pillar/Pier syntax to layout out the text i.e., ==Code== and - for bullet."	^ 'Checkout the class ==Teapot=='! !!ConfigurationOfTeapot class methodsFor: 'catalog' stamp: 'TorstenBergmann 10/12/2015 10:03'!catalogKeywords	"Returns an array of symbols"	^ #(micro web framework http sinatra) ! !!ConfigurationOfTeapot class methodsFor: 'private' stamp: 'AttilaMagyar 8/24/2014 18:38'!ensureMetacello	(self baseConfigurationClassIfAbsent: []) ensureMetacello! !!ConfigurationOfTeapot class methodsFor: 'private' stamp: 'AttilaMagyar 8/24/2014 18:38'!ensureMetacelloBaseConfiguration	Smalltalk		at: #MetacelloBaseConfiguration		ifAbsent: [ 			| repository version |			repository := MCHttpRepository location: 'http://seaside.gemstone.com/ss/metacello' user: '' password: ''.			repository				versionReaderForFileNamed: 'Metacello-Base-DaleHenrichs.2.mcz'				do: [ :reader | 					version := reader version.					version load.					version workingCopy repositoryGroup addRepository: repository ] ]! !!ConfigurationOfTeapot class methodsFor: 'metacello tool support' stamp: 'AttilaMagyar 8/24/2014 18:38'!isMetacelloConfig	"Answer true and the Metacello tools will operate on you"		^true! !!ConfigurationOfTeapot class methodsFor: 'loading' stamp: 'AttilaMagyar 8/24/2014 18:38'!load	"Load the #stable version defined for this platform. The #stable version is the version that is recommended to be used on this platform."	"self load"	<apiDocumentation>	^(self project version: #stable) load! !!ConfigurationOfTeapot class methodsFor: 'loading' stamp: 'AttilaMagyar 8/24/2014 18:38'!loadBleedingEdge	"Load the latest versions of the mcz files defined for this project. It is not likely that the #bleedingEdge has been tested."	"self loadBleedingEdge"	<apiDocumentation>	^(self project version: #bleedingEdge) load! !!ConfigurationOfTeapot class methodsFor: 'loading' stamp: 'AttilaMagyar 8/24/2014 18:38'!loadDevelopment	"Load the #development version defined for this platform. The #development version will change over time and is not expected to be stable."	"self loadDevelopment"	<apiDocumentation>	^(self project version: #development) load! !!ConfigurationOfTeapot class methodsFor: 'accessing' stamp: 'AttilaMagyar 8/24/2014 18:38'!project	^self new project! !!ConfigurationOfTeapot class methodsFor: 'development support' stamp: 'AttilaMagyar 8/24/2014 18:38'!validate	"Check the configuration for Errors, Critical Warnings, and Warnings (see class comment for MetacelloMCVersionValidator for more information). 	Errors identify specification issues that will result in unexpected behaviour when you load the configuration. 	Critical Warnings identify specification issues that may result in unexpected behavior when you load the configuration.	Warnings identify specification issues that are technically correct, but are worth take a look at."	"self validate"	<apiDocumentation>	self ensureMetacello.	^ ((Smalltalk at: #MetacelloToolBox) validateConfiguration: self debug: #() recurse: false) explore! !!ConfigurationOfTeapot methodsFor: 'baselines' stamp: 'AttilaMagyar 8/24/2014 18:40'!baseline01: spec	<version: '0.1-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec repository: 'http://smalltalkhub.com/mc/zeroflag/Teapot/main/'.		spec package: 'Teapot-Core'. ].! !!ConfigurationOfTeapot methodsFor: 'baselines' stamp: 'TorstenBergmann 10/12/2015 13:26'!baseline20: spec	<version: '2.0-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec repository: 'http://smalltalkhub.com/mc/zeroflag/Teapot/main/'.		spec project: 'NeoJSON' with: [				spec					className: #ConfigurationOfNeoJSON;					versionString: #'stable';					repository: 'http://mc.stfx.eu/Neo' ].						spec 			package: 'Teapot-Core' with: [				spec requires: #('NeoJSON' ). ];			package: 'Teapot-Tools' with: [				spec requires: #('Teapot-Core' ). ];			package: 'Teapot-Tests' with: [				spec requires: #('Teapot-Core' ). ].		spec 			group: 'Core' with: #('Teapot-Core' );			group: 'Tools' with: #('Teapot-Tools' );			group: 'Tests' with: #('Teapot-Tests' );			group: 'default' with: #('Tools' 'Tests' ). ].! !!ConfigurationOfTeapot methodsFor: 'baselines' stamp: 'TorstenBergmann 4/13/2016 22:08'!baseline21: spec	<version: '2.1-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec repository: 'http://smalltalkhub.com/mc/zeroflag/Teapot/main/'.		spec 			project: 'NeoJSON' with: [				spec					className: #ConfigurationOfNeoJSON;					versionString: #'stable';					repository: 'http://mc.stfx.eu/Neo' ];			project: 'WebBrowser' with: [				spec					className: #ConfigurationOfWebBrowser;					versionString: #'stable';					repository: 'http://smalltalkhub.com/mc/TorstenBergmann/WebBrowser/main/' ].		spec 			package: 'Teapot-Core' with: [				spec requires: #('NeoJSON' ). ];			package: 'Teapot-Tools' with: [				spec requires: #('Teapot-Core' 'WebBrowser' ). ];			package: 'Teapot-Tests' with: [				spec requires: #('Teapot-Core' ). ].		spec 			group: 'Core' with: #('Teapot-Core' );			group: 'Tools' with: #('Teapot-Tools' );			group: 'Tests' with: #('Teapot-Tests' );			group: 'default' with: #('Tools' 'Tests' ). ].! !!ConfigurationOfTeapot methodsFor: 'baselines' stamp: 'TorstenBergmann 4/13/2016 22:10'!baseline22: spec	<version: '2.2-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec repository: 'http://smalltalkhub.com/mc/zeroflag/Teapot/main/'.		spec 			project: 'NeoJSON' with: [				spec					className: #ConfigurationOfNeoJSON;					versionString: #'stable';					repository: 'http://mc.stfx.eu/Neo' ];			project: 'WebBrowser' with: [				spec					className: #ConfigurationOfWebBrowser;					versionString: #'stable';					repository: 'http://smalltalkhub.com/mc/TorstenBergmann/WebBrowser/main/' ].		spec 			package: 'Teapot-Core' with: [				spec requires: #('NeoJSON' ). ];			package: 'Teapot-Tools' with: [				spec requires: #('Teapot-Core' 'WebBrowser' ). ];			package: 'Teapot-Tests' with: [				spec requires: #('Teapot-Core' ). ].		spec 			group: 'Core' with: #('Teapot-Core' );			group: 'Tools' with: #('Teapot-Tools' );			group: 'Tests' with: #('Teapot-Tests' );			group: 'default' with: #('Tools' 'Tests' ). ].! !!ConfigurationOfTeapot methodsFor: 'baselines' stamp: 'TorstenBergmann 10/5/2016 22:14'!baseline23: spec	<version: '2.3-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec repository: 'http://smalltalkhub.com/mc/zeroflag/Teapot/main/'.		spec 			project: 'NeoJSON' with: [				spec					className: #ConfigurationOfNeoJSON;					versionString: #'stable';					repository: 'http://mc.stfx.eu/Neo' ];			project: 'WebBrowser' with: [				spec					className: #ConfigurationOfWebBrowser;					versionString: #'stable';					repository: 'http://smalltalkhub.com/mc/TorstenBergmann/WebBrowser/main/' ].		spec 			package: 'Teapot-Core' with: [				spec requires: #('NeoJSON' ). ];			package: 'Teapot-Tools' with: [				spec requires: #('Teapot-Core' 'WebBrowser' ). ];			package: 'Teapot-Tests' with: [				spec requires: #('Teapot-Core' ). ].		spec 			group: 'Core' with: #('Teapot-Core' );			group: 'Tools' with: #('Teapot-Tools' );			group: 'Tests' with: #('Teapot-Tests' );			group: 'default' with: #('Tools' 'Tests' ). ].! !!ConfigurationOfTeapot methodsFor: 'baselines' stamp: 'TorstenBergmann 10/5/2016 22:14'!baseline24: spec	<version: '2.4-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec repository: 'http://smalltalkhub.com/mc/zeroflag/Teapot/main/'.		spec 			project: 'NeoJSON' with: [				spec					className: #ConfigurationOfNeoJSON;					versionString: #'stable';					repository: 'http://mc.stfx.eu/Neo' ];			project: 'WebBrowser' with: [				spec					className: #ConfigurationOfWebBrowser;					versionString: #'stable';					repository: 'http://smalltalkhub.com/mc/TorstenBergmann/WebBrowser/main/' ].		spec 			package: 'Teapot-Core' with: [				spec requires: #('NeoJSON' ). ];			package: 'Teapot-Tools' with: [				spec requires: #('Teapot-Core' 'WebBrowser' ). ];			package: 'Teapot-Tests' with: [				spec requires: #('Teapot-Core' ). ].		spec 			group: 'Core' with: #('Teapot-Core' );			group: 'Tools' with: #('Teapot-Tools' );			group: 'Tests' with: #('Teapot-Tests' );			group: 'default' with: #('Tools' 'Tests' ). ].! !!ConfigurationOfTeapot methodsFor: 'accessing' stamp: 'AttilaMagyar 8/24/2014 18:38'!customProjectAttributes	 "Edit to return a collection of any custom attributes e.g. for conditional loading: Array with: #'Condition1' with: #'Condition2.	For more information see: http://code.google.com/p/metacello/wiki/CustomProjectAttrributes"	^ #().! !!ConfigurationOfTeapot methodsFor: 'symbolic versions' stamp: 'TorstenBergmann 10/5/2016 22:14'!development: spec	<symbolicVersion: #'development'>	spec for: #'common' version: '2.4-baseline'.! !!ConfigurationOfTeapot methodsFor: 'accessing' stamp: 'AttilaMagyar 8/24/2014 18:38'!project	^ project ifNil: [ 		"Bootstrap Metacello if it is not already loaded"		(self class baseConfigurationClassIfAbsent: []) ensureMetacello.		"Construct Metacello project"		project := MetacelloMCProject new projectAttributes: self customProjectAttributes. 		(Smalltalk at: #MetacelloVersionConstructor) on: self project: project.		project loadType: #linear. "change to #atomic if desired"		project ]! !!ConfigurationOfTeapot methodsFor: 'symbolic versions' stamp: 'TorstenBergmann 10/5/2016 22:20'!stable: spec	<symbolicVersion: #'stable'>	spec for: #'common' version: '2.3'.! !!ConfigurationOfTeapot methodsFor: 'versions' stamp: 'AttilaMagyar 8/24/2014 20:01'!version08: spec	<version: '0.8' imports: #('0.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.8'.		spec author: 'AttilaMagyar'.		spec timestamp: '8/24/2014 20:01'.		spec package: 'Teapot-Core' with: 'Teapot-Core-AttilaMagyar.52'. ].! !!ConfigurationOfTeapot methodsFor: 'versions' stamp: 'AttilaMagyar 5/9/2015 20:40'!version091: spec	<version: '0.91' imports: #('0.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.91'.		spec author: 'AttilaMagyar'.		spec timestamp: '5/9/2015 18:18'.		spec package: 'Teapot-Core' with: 'Teapot-Core-AttilaMagyar.76'. ].! !!ConfigurationOfTeapot methodsFor: 'versions' stamp: 'AttilaMagyar 3/1/2015 20:57'!version09: spec	<version: '0.9' imports: #('0.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.9'.		spec author: 'AttilaMagyar'.		spec timestamp: '1/3/2015 20:01'.		spec package: 'Teapot-Core' with: 'Teapot-Core-AttilaMagyar.69'. ].! !!ConfigurationOfTeapot methodsFor: 'versions' stamp: 'TorstenBergmann 10/12/2015 14:07'!version20: spec	<version: '2.0' imports: #('2.0-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 2.0'.		spec author: 'TorstenBergmann'.		spec timestamp: '10/12/2015 13:11'.		spec project: 'NeoJSON' with: #'stable'.		spec 			package: 'Teapot-Core' with: 'Teapot-Core-TorstenBergmann.80';			package: 'Teapot-Tools' with: 'Teapot-Tools-TorstenBergmann.4';			package: 'Teapot-Tests' with: 'Teapot-Tests-AttilaMagyar.53'. ].! !!ConfigurationOfTeapot methodsFor: 'versions' stamp: 'TorstenBergmann 4/13/2016 22:09'!version21: spec	<version: '2.1' imports: #('2.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 2.1'.		spec author: 'TorstenBergmann'.		spec timestamp: '4/13/2016 22:09'.		spec 			project: 'NeoJSON' with: #'stable';			project: 'WebBrowser' with: #'stable'.		spec 			package: 'Teapot-Core' with: 'Teapot-Core-TorstenBergmann.80';			package: 'Teapot-Tools' with: 'Teapot-Tools-TorstenBergmann.5';			package: 'Teapot-Tests' with: 'Teapot-Tests-AttilaMagyar.53'. ].! !!ConfigurationOfTeapot methodsFor: 'versions' stamp: 'AttilaMagyar 7/11/2016 21:48'!version22: spec	<version: '2.2' imports: #('2.2-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 2.2'.		spec author: 'AttilaMagyar'.		spec timestamp: '11/7/2016 21:45'.		spec 			project: 'NeoJSON' with: #'stable';			project: 'WebBrowser' with: #'stable'.		spec 			package: 'Teapot-Core' with: 'Teapot-Core-AttilaMagyar.84';			package: 'Teapot-Tools' with: 'Teapot-Tools-AttilaMagyar.14';			package: 'Teapot-Tests' with: 'Teapot-Tests-AttilaMagyar.54'. ].! !!ConfigurationOfTeapot methodsFor: 'versions' stamp: 'TorstenBergmann 10/7/2016 23:08'!version23: spec	<version: '2.3' imports: #('2.2-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 2.3'.		spec author: 'TorstenBergmann'.		spec timestamp: '05/10/2016 21:45'.		spec 			project: 'NeoJSON' with: #'stable';			project: 'WebBrowser' with: #'stable'.		spec 			package: 'Teapot-Core' with: 'Teapot-Core-AttilaMagyar.84';			package: 'Teapot-Tools' with: 'Teapot-Tools-TorstenBergmann.19';			package: 'Teapot-Tests' with: 'Teapot-Tests-AttilaMagyar.54'. ].! !"ConfigurationOfTeapot"!!ConfigurationOfNeoJSON commentStamp: '<historical>' prior: 0!I am ConfigurationOfNeoJSON, a Metacello configuration for NeoJSON.NeoJSON is a flexible and efficient reader and writer for JSON.!!ConfigurationOfNeoJSON class methodsFor: 'development support' stamp: 'SvenVanCaekenberghe 6/22/2012 16:48'!DevelopmentSupport"See the methods in the 'development support' category on the class-side of MetacelloBaseConfiguration. Decide what development support methods you would like to use and copy them the the class-side of your configuration."	<apiDocumentation>! !!ConfigurationOfNeoJSON class methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/22/2012 16:48'!baseConfigurationClassIfAbsent: aBlock	^Smalltalk		at: #MetacelloBaseConfiguration		ifAbsent: [ 			self ensureMetacelloBaseConfiguration.			Smalltalk at: #MetacelloBaseConfiguration ifAbsent: aBlock ].! !!ConfigurationOfNeoJSON class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/5/2016 09:38'!catalogContactInfo	^ 'Written and maintained by Sven Van Caekenberghe (http://stfx.eu) and the community. Discussions on the Pharo mailing lists.'! !!ConfigurationOfNeoJSON class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/5/2016 09:39'!catalogDescription	^ 'JSON (JavaScript Object Notation) is a popular data-interchange format. NeoJSON is an elegant and efficient standalone Smalltalk framework to read and write JSON converting to or from Smalltalk objects.'! !!ConfigurationOfNeoJSON class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/5/2016 09:39'!catalogKeywords	^ #(format input output json serialization encoding text javascript)! !!ConfigurationOfNeoJSON class methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/22/2012 16:48'!ensureMetacello	(self baseConfigurationClassIfAbsent: []) ensureMetacello! !!ConfigurationOfNeoJSON class methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/22/2012 16:48'!ensureMetacelloBaseConfiguration	Smalltalk		at: #MetacelloBaseConfiguration		ifAbsent: [ 			| repository version |			repository := MCHttpRepository location: 'http://seaside.gemstone.com/ss/metacello' user: '' password: ''.			repository				versionReaderForFileNamed: 'Metacello-Base-DaleHenrichs.2.mcz'				do: [ :reader | 					version := reader version.					version load.					version workingCopy repositoryGroup addRepository: repository ] ]! !!ConfigurationOfNeoJSON class methodsFor: 'metacello tool support' stamp: 'SvenVanCaekenberghe 6/22/2012 16:48'!isMetacelloConfig	"Answer true and the Metacello tools will operate on you"		^true! !!ConfigurationOfNeoJSON class methodsFor: 'loading' stamp: 'SvenVanCaekenberghe 6/22/2012 16:48'!load	"Load the #stable version defined for this platform. The #stable version is the version that is recommended to be used on this platform."	"self load"	<apiDocumentation>	^(self project version: #stable) load! !!ConfigurationOfNeoJSON class methodsFor: 'loading' stamp: 'SvenVanCaekenberghe 6/22/2012 16:48'!loadBleedingEdge	"Load the latest versions of the mcz files defined for this project. It is not likely that the #bleedingEdge has been tested."	"self loadBleedingEdge"	<apiDocumentation>	^(self project version: #bleedingEdge) load! !!ConfigurationOfNeoJSON class methodsFor: 'loading' stamp: 'SvenVanCaekenberghe 6/22/2012 16:48'!loadDevelopment	"Load the #development version defined for this platform. The #development version will change over time and is not expected to be stable."	"self loadDevelopment"	<apiDocumentation>	^(self project version: #development) load! !!ConfigurationOfNeoJSON class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/22/2012 16:48'!project	^self new project! !!ConfigurationOfNeoJSON class methodsFor: 'development support' stamp: 'SvenVanCaekenberghe 6/22/2012 16:48'!validate	"Check the configuration for Errors, Critical Warnings, and Warnings (see class comment for MetacelloMCVersionValidator for more information). 	Errors identify specification issues that will result in unexpected behaviour when you load the configuration. 	Critical Warnings identify specification issues that may result in unexpected behavior when you load the configuration.	Warnings identify specification issues that are technically correct, but are worth take a look at."	"self validate"	<apiDocumentation>	self ensureMetacello.	^ ((Smalltalk at: #MetacelloToolBox) validateConfiguration: self debug: #() recurse: false) explore! !!ConfigurationOfNeoJSON methodsFor: 'baselines' stamp: 'SvenVanCaekenberghe 6/22/2012 16:53'!baseline1: spec	<version: '1-baseline'>		spec for: #common do: [		spec 			blessing: #baseline;			repository: 'http://mc.stfx.eu/Neo';			package: 'Neo-JSON-Core';			package: 'Neo-JSON-Tests' with: [ spec requires: 'Neo-JSON-Core' ];			group: 'default' with: #('Neo-JSON-Core' 'Neo-JSON-Tests');			group: 'Core' with: #('Neo-JSON-Core');			group: 'Tests' with: #('Neo-JSON-Tests') ]! !!ConfigurationOfNeoJSON methodsFor: 'baselines' stamp: 'PaulDeBruicker 11/2/2014 20:39'!baseline2: spec	<version: '2-baseline'>	spec		for: #common		do: [ 			spec				blessing: #baseline;				repository: 'http://mc.stfx.eu/Neo';				package: 'Neo-JSON-Core';				package: 'Neo-JSON-Tests' with: [ spec requires: 'Neo-JSON-Core' ];				group: 'default' with: #('Neo-JSON-Core' 'Neo-JSON-Tests');				group: 'Core' with: #('Neo-JSON-Core');				group: 'Tests' with: #('Neo-JSON-Tests') ].	spec		for: #gemstone		do: [ 			spec				baseline: 'NeoJSON' with: [ spec repository: 'github://GsDevKit/NeoJSON:master/repository' ];				import: 'NeoJSON' ]! !!ConfigurationOfNeoJSON methodsFor: 'symbolic versions' stamp: 'SvenVanCaekenberghe 7/11/2016 10:22'!bleedingEdge: spec	<symbolicVersion: #'bleedingEdge'>! !!ConfigurationOfNeoJSON methodsFor: 'symbolic versions' stamp: 'SvenVanCaekenberghe 7/11/2016 10:22'!development: spec	<symbolicVersion: #'development'>! !!ConfigurationOfNeoJSON methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/22/2012 16:48'!project	^ project ifNil: [ | constructor |		"Bootstrap Metacello if it is not already loaded"		(self class baseConfigurationClassIfAbsent: []) ensureMetacello.		"Construct Metacello project"		constructor := (Smalltalk at: #MetacelloVersionConstructor) on: self.		project := constructor project.		project loadType: #linear. "change to #atomic if desired"		project ]! !!ConfigurationOfNeoJSON methodsFor: 'symbolic versions' stamp: 'SvenVanCaekenberghe 2/2/2017 13:50'!stable: spec	<symbolicVersion: #'stable'>		spec for: #common version: '15'.		spec for: #gemstone version: '13'.! !!ConfigurationOfNeoJSON methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 3/29/2015 11:39'!version10: spec	<version: '10' imports: #('1-baseline')>		spec for: #common do: [		spec			blessing: #release;			package: 'Neo-JSON-Core' with: 'Neo-JSON-Core-SvenVanCaekenberghe.29';			package: 'Neo-JSON-Tests' with: 'Neo-JSON-Tests-SvenVanCaekenberghe.26' ]! !!ConfigurationOfNeoJSON methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 11/25/2015 09:34'!version11: spec	<version: '11' imports: #('1-baseline')>		spec for: #common do: [		spec			blessing: #release;			package: 'Neo-JSON-Core' with: 'Neo-JSON-Core-SvenVanCaekenberghe.30';			package: 'Neo-JSON-Tests' with: 'Neo-JSON-Tests-SvenVanCaekenberghe.30' ]! !!ConfigurationOfNeoJSON methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 1/22/2016 12:58'!version12: spec	<version: '12' imports: #('1-baseline')>		spec for: #common do: [		spec			blessing: #release;			package: 'Neo-JSON-Core' with: 'Neo-JSON-Core-SvenVanCaekenberghe.31';			package: 'Neo-JSON-Tests' with: 'Neo-JSON-Tests-SvenVanCaekenberghe.31' ]! !!ConfigurationOfNeoJSON methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 7/4/2016 14:58'!version13: spec	<version: '13' imports: #('1-baseline')>		spec for: #common do: [		spec			blessing: #release;			package: 'Neo-JSON-Core' with: 'Neo-JSON-Core-SvenVanCaekenberghe.33';			package: 'Neo-JSON-Tests' with: 'Neo-JSON-Tests-SvenVanCaekenberghe.33' ]! !!ConfigurationOfNeoJSON methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 2/2/2017 13:46'!version14: spec	<version: '14' imports: #('1-baseline')>		spec for: #common do: [		spec			blessing: #release;			package: 'Neo-JSON-Core' with: 'Neo-JSON-Core-SvenVanCaekenberghe.37';			package: 'Neo-JSON-Tests' with: 'Neo-JSON-Tests-SvenVanCaekenberghe.35' ]! !!ConfigurationOfNeoJSON methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 2/2/2017 13:50'!version15: spec	<version: '15' imports: #('1-baseline')>		spec for: #common do: [		spec			blessing: #release;			package: 'Neo-JSON-Core' with: 'Neo-JSON-Core-SvenVanCaekenberghe.37';			package: 'Neo-JSON-Tests' with: 'Neo-JSON-Tests-SvenVanCaekenberghe.36' ]! !!ConfigurationOfNeoJSON methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 9/27/2012 20:29'!version1: spec	<version: '1' imports: #('1-baseline')>		spec for: #common do: [		spec			blessing: #release;			package: 'Neo-JSON-Core' with: 'Neo-JSON-Core-SvenVanCaekenberghe.17';			package: 'Neo-JSON-Tests' with: 'Neo-JSON-Tests-SvenVanCaekenberghe.15' ]! !!ConfigurationOfNeoJSON methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 12/18/2012 10:27'!version2: spec	<version: '2' imports: #('1-baseline')>		spec for: #common do: [		spec			blessing: #release;			package: 'Neo-JSON-Core' with: 'Neo-JSON-Core-SvenVanCaekenberghe.19';			package: 'Neo-JSON-Tests' with: 'Neo-JSON-Tests-SvenVanCaekenberghe.16' ]! !!ConfigurationOfNeoJSON methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 5/29/2013 15:54'!version3: spec	<version: '3' imports: #('1-baseline')>		spec for: #common do: [		spec			blessing: #release;			package: 'Neo-JSON-Core' with: 'Neo-JSON-Core-SvenVanCaekenberghe.20';			package: 'Neo-JSON-Tests' with: 'Neo-JSON-Tests-SvenVanCaekenberghe.16' ]! !!ConfigurationOfNeoJSON methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 8/30/2013 11:12'!version4: spec	<version: '4' imports: #('1-baseline')>		spec for: #common do: [		spec			blessing: #release;			package: 'Neo-JSON-Core' with: 'Neo-JSON-Core-SvenVanCaekenberghe.23';			package: 'Neo-JSON-Tests' with: 'Neo-JSON-Tests-SvenVanCaekenberghe.18' ]! !!ConfigurationOfNeoJSON methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 9/3/2013 12:22'!version5: spec	<version: '5' imports: #('1-baseline')>		spec for: #common do: [		spec			blessing: #release;			package: 'Neo-JSON-Core' with: 'Neo-JSON-Core-SvenVanCaekenberghe.24';			package: 'Neo-JSON-Tests' with: 'Neo-JSON-Tests-SvenVanCaekenberghe.19' ]! !!ConfigurationOfNeoJSON methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 12/27/2013 19:02'!version6: spec	<version: '6' imports: #('1-baseline')>		spec for: #common do: [		spec			blessing: #release;			package: 'Neo-JSON-Core' with: 'Neo-JSON-Core-SvenVanCaekenberghe.24';			package: 'Neo-JSON-Tests' with: 'Neo-JSON-Tests-SvenVanCaekenberghe.20' ]! !!ConfigurationOfNeoJSON methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 12/27/2013 21:44'!version7: spec	<version: '7' imports: #('1-baseline')>		spec for: #common do: [		spec			blessing: #release;			package: 'Neo-JSON-Core' with: 'Neo-JSON-Core-SvenVanCaekenberghe.24';			package: 'Neo-JSON-Tests' with: 'Neo-JSON-Tests-SvenVanCaekenberghe.21' ]! !!ConfigurationOfNeoJSON methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 1/21/2014 20:08'!version8: spec	<version: '8' imports: #('1-baseline')>		spec for: #common do: [		spec			blessing: #release;			package: 'Neo-JSON-Core' with: 'Neo-JSON-Core-SvenVanCaekenberghe.24';			package: 'Neo-JSON-Tests' with: 'Neo-JSON-Tests-SvenVanCaekenberghe.22' ]! !!ConfigurationOfNeoJSON methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 4/24/2014 13:29'!version9: spec	<version: '9' imports: #('1-baseline')>		spec for: #common do: [		spec			blessing: #release;			package: 'Neo-JSON-Core' with: 'Neo-JSON-Core-SvenVanCaekenberghe.27';			package: 'Neo-JSON-Tests' with: 'Neo-JSON-Tests-SvenVanCaekenberghe.24' ]! !"ConfigurationOfNeoJSON"!!ConfigurationOfWebBrowser commentStamp: 'TorstenBergmann 4/13/2016 08:47' prior: 0!General and platform independent WebBrowser access for Pharo 5.0 onwards based on UFFI!!ConfigurationOfWebBrowser class methodsFor: 'development support' stamp: 'TorstenBergmann 4/13/2016 08:45'!DevelopmentSupport"See the methods in the 'development support' category on the class-side of MetacelloBaseConfiguration. Decide what development support methods you would like to use and copy them the the class-side of your configuration."	<apiDocumentation>! !!ConfigurationOfWebBrowser class methodsFor: 'private' stamp: 'TorstenBergmann 4/13/2016 08:45'!baseConfigurationClassIfAbsent: aBlock	^Smalltalk		at: #'ConfigurationOf'		ifAbsent: [ 			self ensureMetacelloBaseConfiguration.			Smalltalk at: #'ConfigurationOf' ifAbsent: aBlock ].! !!ConfigurationOfWebBrowser class methodsFor: 'catalog' stamp: 'TorstenBergmann 4/13/2016 08:48'!catalogChangeLog	"Returns a paragraph describing the most important changes in the configuration class."	^ ''! !!ConfigurationOfWebBrowser class methodsFor: 'catalog' stamp: 'TorstenBergmann 4/13/2016 08:49'!catalogContactInfo	"Returns a paragraph describing contact information such as email, mailing lists and website."	^ 'You can get in contact with the author on the Pharo mailinglist (http://lists.pharo.org)'! !!ConfigurationOfWebBrowser class methodsFor: 'catalog' stamp: 'TorstenBergmann 4/13/2016 09:22'!catalogDescription	"Returns a paragraph describing the project"	^ 'General and platform independent WebBrowser access for Pharo 4.0 onwards based on NativeBoost, for Pharo 5.0 onwards based on UFFI'! !!ConfigurationOfWebBrowser class methodsFor: 'catalog' stamp: 'TorstenBergmann 4/13/2016 08:49'!catalogKeyClassesAndExample	"Returns a paragraph or more describing the key classes of your project. You can use Pillar/Pier syntax to layout out the text i.e., ==Code== and - for bullet."	^ 'Check the example on the class side of class ==WebBrowser==.'! !!ConfigurationOfWebBrowser class methodsFor: 'catalog' stamp: 'TorstenBergmann 4/13/2016 08:50'!catalogKeywords	"Returns an array of symbols"	^ #(webbrowser utility url platform web internet) ! !!ConfigurationOfWebBrowser class methodsFor: 'private' stamp: 'TorstenBergmann 4/13/2016 08:45'!ensureMetacello	(self baseConfigurationClassIfAbsent: []) ensureMetacello! !!ConfigurationOfWebBrowser class methodsFor: 'private' stamp: 'TorstenBergmann 4/13/2016 08:45'!ensureMetacelloBaseConfiguration  Smalltalk    at: #'ConfigurationOf'    ifAbsent: [       | repository version |      repository := MCHttpRepository        location: 'http://smalltalkhub.com/mc/dkh/metacello/main'        user: ''        password: ''.      repository        versionReaderForFileNamed: 'Metacello-Base-dkh.107'        do: [ :reader |           version := reader version.          version load.          version workingCopy repositoryGroup addRepository: repository ] ]! !!ConfigurationOfWebBrowser class methodsFor: 'metacello tool support' stamp: 'TorstenBergmann 4/13/2016 08:45'!isMetacelloConfig	"Answer true and the Metacello tools will operate on you"		^true! !!ConfigurationOfWebBrowser class methodsFor: 'loading' stamp: 'TorstenBergmann 4/13/2016 08:45'!load	"Load the #stable version defined for this platform. The #stable version is the version that is recommended to be used on this platform."	"self load"	<apiDocumentation>	^(self project version: #stable) load! !!ConfigurationOfWebBrowser class methodsFor: 'loading' stamp: 'TorstenBergmann 4/13/2016 08:45'!loadBleedingEdge	"Load the latest versions of the mcz files defined for this project. It is not likely that the #bleedingEdge has been tested."	"self loadBleedingEdge"	<apiDocumentation>	^(self project version: #bleedingEdge) load! !!ConfigurationOfWebBrowser class methodsFor: 'loading' stamp: 'TorstenBergmann 4/13/2016 08:45'!loadDevelopment	"Load the #development version defined for this platform. The #development version will change over time and is not expected to be stable."	"self loadDevelopment"	<apiDocumentation>	^(self project version: #development) load! !!ConfigurationOfWebBrowser class methodsFor: 'accessing' stamp: 'TorstenBergmann 4/13/2016 08:45'!project	^self new project! !!ConfigurationOfWebBrowser class methodsFor: 'development support' stamp: 'TorstenBergmann 4/13/2016 08:45'!validate	"Check the configuration for Errors, Critical Warnings, and Warnings (see class comment for MetacelloMCVersionValidator for more information). 	Errors identify specification issues that will result in unexpected behaviour when you load the configuration. 	Critical Warnings identify specification issues that may result in unexpected behavior when you load the configuration.	Warnings identify specification issues that are technically correct, but are worth take a look at."	"self validate"	<apiDocumentation>	self ensureMetacello.	^ ((Smalltalk at: #MetacelloToolBox) validateConfiguration: self debug: #() recurse: false) explore! !!ConfigurationOfWebBrowser methodsFor: 'baselines' stamp: 'TorstenBergmann 4/13/2016 08:46'!baseline01: spec	<version: '0.1-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec repository: 'http://smalltalkhub.com/mc/TorstenBergmann/WebBrowser/main/'.		spec package: #'WebBrowser-Core'.		spec 			group: 'Core' with: #(#'WebBrowser-Core' );			group: 'all' with: #('Core' );			group: 'default' with: #('all' ). ].! !!ConfigurationOfWebBrowser methodsFor: 'baselines' stamp: 'TorstenBergmann 4/13/2016 09:47'!baseline02: spec	<version: '0.2-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec repository: 'http://smalltalkhub.com/mc/TorstenBergmann/WebBrowser/main/'.		spec package: #'WebBrowser-Core'.		spec 			group: 'Core' with: #(#'WebBrowser-Core' );			group: 'all' with: #('Core' );			group: 'default' with: #('all' ). ].! !!ConfigurationOfWebBrowser methodsFor: 'baselines' stamp: 'TorstenBergmann 4/13/2016 09:48'!baseline03: spec	<version: '0.3-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec repository: 'http://smalltalkhub.com/mc/TorstenBergmann/WebBrowser/main/'.		spec package: #'WebBrowser-Core'.		spec 			group: 'Core' with: #(#'WebBrowser-Core' );			group: 'all' with: #('Core' );			group: 'default' with: #('all' ). ].! !!ConfigurationOfWebBrowser methodsFor: 'accessing' stamp: 'TorstenBergmann 4/13/2016 08:45'!customProjectAttributes    "Edit to return a collection of any custom attributes e.g. for conditional loading: Array with: #'Condition1' with: #'Condition2.	For more information see: http://code.google.com/p/metacello/wiki/CustomProjectAttrributes "    ^ #()! !!ConfigurationOfWebBrowser methodsFor: 'symbolic versions' stamp: 'TorstenBergmann 4/13/2016 09:48'!development: spec	<symbolicVersion: #'development'>	spec for: #'common' version: '0.3-baseline'.! !!ConfigurationOfWebBrowser methodsFor: 'accessing' stamp: 'TorstenBergmann 4/13/2016 08:45'!project    ^ project        ifNil: [             "Bootstrap Metacello if it is not already loaded"            self class ensureMetacello.            project := MetacelloMCProject new projectAttributes: self customProjectAttributes.	"Create the Metacello project"            (Smalltalk at: #'MetacelloVersionConstructor') on: self project: project.	"Construct the project"            project loadType: #'linear'.	"change to #atomic if desired"            project ]! !!ConfigurationOfWebBrowser methodsFor: 'symbolic versions' stamp: 'TorstenBergmann 4/13/2016 09:48'!stable: spec	<symbolicVersion: #'stable'>	spec for: #'pharo4.x' version: '0.1.0'.	spec for: #'common' version: '0.2.0'.! !!ConfigurationOfWebBrowser methodsFor: 'versions' stamp: 'TorstenBergmann 4/13/2016 09:22'!version010: spec	<version: '0.1.0' imports: #('0.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'Version 0.1.0 for Pharo 4 based on NB'.		spec author: 'TorstenBergmann'.		spec timestamp: '4/13/2016 08:46'.		spec package: #'WebBrowser-Core' with: 'WebBrowser-Core-TorstenBergmann.1'. ].! !!ConfigurationOfWebBrowser methodsFor: 'versions' stamp: 'TorstenBergmann 4/13/2016 09:47'!version020: spec	<version: '0.2.0' imports: #('0.2-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'Version 0.2.0 for Pharo 5 based on UFFI'.		spec author: 'TorstenBergmann'.		spec timestamp: '4/13/2016 08:46'.		spec package: #'WebBrowser-Core' with: 'WebBrowser-Core-TorstenBergmann.5'. ].! !"ConfigurationOfWebBrowser"!!NeoJSONMapper commentStamp: '<historical>' prior: 0!I am NeoJSONMapper.I hold a mapping from schema identifiers to objects that known how to read or write instances from or to JSON.Schema identifiers are either Smalltalk classes or Symbols.I offer a builder interface to construct mappings. The standard object mapping represents a Smalltalk object as a map, mapping some or all instance variables, or a set of accessors (getter/setter methods). Furthermore, for each value an optional schema can be specified.Using a custom mapping, a reader and/or writer block can deal with special cases such as specific collection types with an optional schema for the elements, or a direct mapping of semi primitive types such as Date or DateAndTime.A mapping can be specified explicitely on a mapper, or can be resolved using the #neoJsonMapping: class method.Here are some examples:	mapper mapAllInstVarsFor: Point.	mapper for: TestObject do: [ :mapping |		mapping mapInstVars: #(id name).		(mapping mapInstVar: #timestamp to: 'created-at') valueSchema: DateAndTime.		(mapping mapInstVar: #points) valueSchema: #ArrayOfPoints.		(mapping mapInstVar: #bytes) valueSchema: ByteArray ].	mapper for: DateAndTime customDo: [ :mapping |		mapping decoder: [ :string | DateAndTime fromString: string ].		mapping encoder: [ :dateAndTime | dateAndTime printString ] ].	mapper for: #ArrayOfPoints customDo: [ :mapping |		mapping listOfElementSchema: Point ].  	mapper for: ByteArray customDo: [ :mapping |		mapping listOfType: ByteArray ]!!NeoJSONReader commentStamp: 'SvenVanCaekenberghe 3/16/2016 11:23' prior: 0!I am NeoJSONReader.I am a NeoJSONMapper.I parse a JSON representation from a textual stream into Smalltalk objects.Primitive types are automatically mapped to their Smalltalk counterpart: Numbers, Strings, Booleans and UndefinedObject.When parsing using #next, lists normally become Arrays and maps become Dictionaries.An alternative listClass or mapClass can be specified.When parsing using #nextAs: a schema can be specified. This schema defines a mapping to be used.Here are some examples:	NeoJSONReader fromString: ' [ 1,2,3 ] '.	NeoJSONReader fromString: ' [ 3.14159, true, false, null, "string" ] '.	NeoJSONReader fromString: ' { "x" : 1, "y" : 2 } '.		(NeoJSONReader on: ' { "x" : 1, "y" : 2 } ' readStream)		mapInstVarsFor: Point;		nextAs: Point.					(NeoJSONReader on: '[ { "x" : 1, "y" : 2 }, { "x" : 3, "y" : 4 } ]' readStream)		mapInstVarsFor: Point;		for: #ArrayOfPoints customDo: [ :mapping |			mapping listOfElementSchema: Point ];		nextAs: #ArrayOfPoints.	(NeoJSONReader on: '[ { "x" : 1, "y" : 2 }, { "x" : 3, "y" : 4 } ]' readStream)		mapInstVarsFor: Point;		nextListAs: Point.!!NeoJSONWriter commentStamp: '<historical>' prior: 0!I am NeoJSONWriter.I am a NeoJSONMapper.I write a JSON representation of Smalltalk objects to a textual stream.Objects implementing #neoJsonOn: can be encoded.A number of primitive types, like Strings, Numbers, Booleans and UndefinedObject are treated specially.Collection are encoded as lists, except for Dictionaries that are encoded as maps.All other objects need a mapping to help in doing the encoding.Here are some examples:	NeoJSONWriter toString: #(1 2 3).	NeoJSONWriter toString: { Float pi. true. false. 'string' }.	NeoJSONWriter toStringPretty: (Dictionary new at: #x put: 1; at: #y put: 2; yourself).		String streamContents: [ :stream |		(NeoJSONWriter on: stream)			prettyPrint: true;			mapInstVarsFor: Point;			nextPut: (Array with: 1@3 with: -1@3) ].	!!NeoJSONMapping commentStamp: 'SvenVanCaekenberghe 3/23/2014 19:22' prior: 0!I am NeoJSONMapping, an abstract superclass for mapping definitions.!!NeoJSONCustomMapping commentStamp: '<historical>' prior: 0!I am NeoJSONCustomMapping.I read the next JSON value and turn it into a Smalltalk object using a converter block.!!NeoJSONObjectMapping commentStamp: '<historical>' prior: 0!I am NeoJSONObjectMapping.I describe how instances of a Smalltalk class are mapped to a JSON map.I do this using set of NeoJSONPropertyMappings.I know the Smalltalk class that I am a mapping for. This class is the schema identifier and is used to instanciate new objects.A mapping can be based on any combination of instance variables or accessors (getter/setter pairs). I offer a builder interface to constuct property mappings.!!NeoJSONPropertyMapping commentStamp: '<historical>' prior: 0!I am NeoJSONPropertyMapping.I describe how a property of a Smalltalk class maps to a JSON property.A property is either an instance variable or getter/setter pair.I hold a getter and setter block to do the actual work. The property name is used in JSON.Optionally, the schema for the value of my property can be specified. This is then used recursively.!!NeoJSONStreamingWriter commentStamp: '<historical>' prior: 0!I am NeoJSONStreamingWriter.I help in writing streamed maps and lists.This is an internal class used by NeoJSONWriter to deal with interleaving elements and separators as well as pretty printing.!!NeoJSONObject commentStamp: 'SvenVanCaekenberghe 9/8/2014 13:34' prior: 0!I am NeoJSONObject.I am a Dictionary.I behave more like a JavaScript object. I return nil for missing keys. I allow any property to be read or set by using a normal accessor message.The following are equivalent:	self foo.	self at: #foo.As are the following	self foo: 1. 	self at: #foo put: 1.	I can optionally be used by NeoJSONReader as mapClass (see #mapClass:).For output, I act just like my superclass (it is thus not necessary to do any conversions).Example:	NeoJSONObject fromString: '{"foo":1,"bar":-2}'.	I use JSON as my printed representation.!!NeoJSONParseError commentStamp: '<historical>' prior: 0!I am NeoJSONParseError.I am an Error.I am signalled when JSON input is not valid while parsing.!!NeoJSONMappingNotFound commentStamp: '<historical>' prior: 0!I am NeoJSONMappingNotFound.I am a NotFound exception.I am signalled when no mapping is found for a schema.!!NeoJSONMapper methodsFor: 'private' stamp: 'SvenVanCaekenberghe 3/22/2014 10:57'!customMappingFor: schemaName	^ self mappings		at: schemaName		ifAbsentPut: [ 			NeoJSONCustomMapping new				schemaName: schemaName;				yourself ]! !!NeoJSONMapper methodsFor: 'mapping' stamp: 'SvenVanCaekenberghe 3/22/2014 10:56'!for: schemaName customDo: block	"Execute the code in block to further customize the mapping for schemaName.	Create and add a new custom mapping for schemaName if necessary."		| mapping |	mapping := self customMappingFor: schemaName.	block value: mapping.	^ mapping! !!NeoJSONMapper methodsFor: 'mapping' stamp: 'SvenVanCaekenberghe 3/22/2014 10:57'!for: smalltalkClass do: block	"Execute the code in block to further customize the mapping for schemaName.	Create and add a new standard object mapping for schemaName if necessary."		| mapping |	mapping := self objectMappingFor: smalltalkClass.	block value: mapping.	^ mapping! !!NeoJSONMapper methodsFor: 'convencience' stamp: 'SvenVanCaekenberghe 3/22/2014 10:54'!mapAllInstVarsFor: smalltalkClass	"Map the instance variables of smalltalkClass and all its super classes"	| mapping |	mapping := self objectMappingFor: smalltalkClass.	mapping mapAllInstVars.	^ mapping! !!NeoJSONMapper methodsFor: 'convencience' stamp: 'SvenVanCaekenberghe 3/22/2014 10:54'!mapInstVarsFor: smalltalkClass	"Map the instance variables of smalltalkClass"	| mapping |	mapping := self objectMappingFor: smalltalkClass.	mapping mapInstVars.	^ mapping! !!NeoJSONMapper methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/12/2012 15:48'!mappingFor: schema	^ self 		mappingFor: schema 		ifAbsent: [ NeoJSONMappingNotFound signalFor: schema in: self ]! !!NeoJSONMapper methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/9/2012 18:24'!mappingFor: schema ifAbsent: block	(self mappings includesKey: schema)		ifFalse: [ self resolveMappingFor: schema ].	^ self mappings		at: schema		ifAbsent: block! !!NeoJSONMapper methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/7/2012 14:55'!mappings	^ mappings		ifNil: [ mappings := Dictionary new ]! !!NeoJSONMapper methodsFor: 'private' stamp: 'SvenVanCaekenberghe 3/22/2014 10:54'!objectMappingFor: smalltalkClass	^ self mappings		at: smalltalkClass		ifAbsentPut: [ 			NeoJSONObjectMapping new				subjectClass: smalltalkClass;				yourself ]! !!NeoJSONMapper methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/9/2012 18:29'!resolveMappingFor: class	(class respondsTo: #neoJsonMapping:)		ifTrue: [ 			class perform: #neoJsonMapping: with: self ]! !!NeoJSONReader class methodsFor: 'convenience' stamp: 'SvenVanCaekenberghe 6/9/2012 18:26'!fromString: string	^ (self on: string readStream) next! !!NeoJSONReader class methodsFor: 'convenience' stamp: 'SvenVanCaekenberghe 6/9/2012 18:30'!fromString: string as: schema	^ (self on: string readStream) nextAs: schema! !!NeoJSONReader class methodsFor: 'instance creation' stamp: 'SvenVanCaekenberghe 6/13/2012 16:10'!on: readStream	"Initialize on readStream, which should be a character stream that 	implements #next, #peek, #atEnd and (optionally) #close."	^ self new		on: readStream;		yourself! !!NeoJSONReader methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 3/6/2013 14:46'!atEnd	^ readStream atEnd! !!NeoJSONReader methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 6/2/2012 13:50'!close	readStream ifNotNil: [		readStream close.		readStream := nil ]! !!NeoJSONReader methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/2/2012 21:26'!consumeWhitespace	"Strip whitespaces from the input stream."	[ readStream atEnd not and: [ readStream peek isSeparator ] ]		whileTrue: [ 			readStream next ]! !!NeoJSONReader methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/12/2012 15:54'!error: text	NeoJSONParseError signal: text! !!NeoJSONReader methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/2/2012 14:01'!expectChar: character	"Expect character and consume input and optional whitespace at the end,	 throw an error otherwise."	(self matchChar: character)		ifFalse: [ self error: character asString, ' expected' ]! !!NeoJSONReader methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 6/13/2012 09:39'!initialize 	super initialize.	propertyNamesAsSymbols := false! !!NeoJSONReader methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/13/2012 09:37'!listClass	"Return the collection type to use for JSON lists"		^ listClass ifNil: [ Array ]! !!NeoJSONReader methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 6/13/2012 09:38'!listClass: collectionClass	listClass := collectionClass! !!NeoJSONReader methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/13/2012 09:37'!mapClass	"Return the collection type to use for JSON maps"		^ mapClass ifNil: [ Dictionary ]! !!NeoJSONReader methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 6/13/2012 09:38'!mapClass: collectionClass	mapClass := collectionClass! !!NeoJSONReader methodsFor: 'private' stamp: 'SvenVanCaekenberghe 12/3/2012 10:57'!match: string do: block	"Try to read and consume string and execute block if successful.	Else do nothing (but do not back up)"	(string allSatisfy: [ :each | readStream peekFor: each ])		ifTrue: [ 			self consumeWhitespace.			block value ]! !!NeoJSONReader methodsFor: 'private' stamp: 'SvenVanCaekenberghe 12/3/2012 10:51'!matchChar: character	"Tries to match character, consume input and 	answer true if successful and consumes whitespace at the end.	When character does not match, return false and leave stream untouched."	^ (readStream peekFor: character)		ifTrue: [ 			self consumeWhitespace.			true ]		ifFalse: [ false ]! !!NeoJSONReader methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/7/2012 16:56'!next	"Primary interface to parse a JSON value.	Return either primitives, a listClass or a mapClass instance."		^ self 		consumeWhitespace; 		parseValue! !!NeoJSONReader methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 3/16/2016 11:21'!nextAs: schema	"Secondary interface to parse JSON.	Return an object according to schema.	If schema is nil, act like #next"		| mapping |	schema ifNil: [ ^ self next ].	self consumeWhitespace.	mapping := self mappingFor: schema.	^ mapping readFrom: self! !!NeoJSONReader methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 3/16/2016 10:58'!nextListAs: schema	"Secondary interface to parse JSON.	Return a list of objects, each element according to schema."		^ self listClass streamContents: [ :stream |			self parseListDo: [ 				stream nextPut: (self nextAs: schema) ] ]! !!NeoJSONReader methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 6/13/2012 16:10'!on: aReadStream	"Initialize on aReadStream, which should be a character stream that 	implements #next, #peek, #atEnd and (optionally) #close."		readStream := aReadStream! !!NeoJSONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 6/7/2012 16:59'!parseCharacter	| char |	(char := readStream next) = $\ 		ifFalse: [ ^ char ].	('/"\' includes: (char := readStream next))		ifTrue: [ ^ char ].	('bfnrt' includes: char)		ifTrue: [ ^ self unescapeChar: char ].	char = $u		ifTrue: [ ^ self parseCharacterHex ].	self error: 'invalid escape character \' , (String with: char)! !!NeoJSONReader methodsFor: 'private' stamp: 'SvenVanCaekenberghe 2/24/2016 14:48'!parseCharacterHex	| value codePoint |	value := self parseCharacterHex4Value.	(value < 16rD800 or: [ value > 16rDBFF ])		ifTrue: [ codePoint := value ]		ifFalse: [ | leadSurrogate trailSurrogate |			"Characters not in the Basic Multilingual Plane are encoded as a UTF-16 surrogate pair"			"See https://tools.ietf.org/html/rfc7159#section-7"			leadSurrogate := value.			trailSurrogate := self parseTrailingSurrogateHexEscape.			codePoint := (leadSurrogate - 16rD800) * 16r400 + (trailSurrogate - 16rDC00).			codePoint := 16r10000 + codePoint ].	^ Character codePoint: codePoint! !!NeoJSONReader methodsFor: 'private' stamp: 'SvenVanCaekenberghe 2/24/2016 14:41'!parseCharacterHex4Value	| value |	value := self parseCharacterHexDigit.	3 timesRepeat: [ 		value := (value << 4) + self parseCharacterHexDigit ].	^ value! !!NeoJSONReader methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/2/2012 14:21'!parseCharacterHexDigit	| digit |	readStream atEnd 		ifFalse: [ 			digit := readStream next asInteger.			(digit between: "$0" 48 and: "$9" 57)				ifTrue: [ ^ digit - 48 ].			(digit between: "$A" 65 and: "$F" 70)				ifTrue: [ ^ digit - 55 ].			(digit between: "$a" 97 and: "$f" 102)				ifTrue: [ ^ digit - 87 ] ].	self error: 'hex-digit expected'! !!NeoJSONReader methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/2/2012 14:16'!parseConstantDo: block	"Parse and consume either true|false|nil|null and execute block 	or else do nothing (but do not back up).	Hand written implementation to avoid the use of #position:"		(readStream peek = $t)		ifTrue: [			^ self match: 'true' do: [ block value: true ] ].	(readStream peek = $f)		ifTrue: [			^ self match: 'false' do: [ block value: false ] ].	(readStream peek = $n)		ifTrue: [			^ self match: 'null' do: [ block value: nil ] ]! !!NeoJSONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 6/7/2012 17:17'!parseList	^ self listClass 		streamContents: [ :stream |			self parseListElementsDo: [ :each |				stream nextPut: each ] ]		! !!NeoJSONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 6/7/2012 17:15'!parseListDo: block	self expectChar: $[.	(self matchChar: $]) 		ifTrue: [ ^ self ].	[ readStream atEnd ] 		whileFalse: [			block value.			(self matchChar: $]) 				ifTrue: [ ^ self ].			self expectChar: $, ].	self error: 'end of list expected'! !!NeoJSONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 6/7/2012 17:16'!parseListElementsDo: block	self parseListDo: [ 		block value: self parseValue ]! !!NeoJSONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 6/7/2012 17:23'!parseMap	| map |	map := self mapClass new.	self parseMapKeysAndValuesDo: [ :key :value |		map at: key put: value ].	^ map! !!NeoJSONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 6/7/2012 17:23'!parseMapDo: block	self expectChar: ${.	(self matchChar: $})		ifTrue: [ ^ self ].	[ readStream atEnd ] whileFalse: [		block value.		(self matchChar: $}) 			ifTrue: [ ^ self ].		self expectChar: $, ].	self error: 'end of map expected'! !!NeoJSONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 6/7/2012 17:22'!parseMapKeysAndValuesDo: block	self parseMapKeysDo: [ :key |		block value: key value: self parseValue ]! !!NeoJSONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 6/7/2012 17:23'!parseMapKeysDo: block	self parseMapDo: [ | key |		key := self parsePropertyName.		self expectChar: $:.		block value: key ]! !!NeoJSONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 12/3/2012 11:08'!parseNumber	| negated number |	negated := readStream peekFor: $-.	number := self parseNumberInteger.	(readStream peekFor: $.)		ifTrue: [ number := number + self parseNumberFraction ].	((readStream peekFor: $e) or: [ readStream peekFor: $E ])		ifTrue: [ number := number * self parseNumberExponent ].	negated		ifTrue: [ number := number negated ].	self consumeWhitespace.	^ number! !!NeoJSONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 12/3/2012 11:08'!parseNumberExponent	| number negated |	number := 0.	(negated := readStream peekFor: $-)		ifFalse: [ readStream peekFor: $+ ].	[ readStream atEnd not and: [ readStream peek isDigit ] ]		whileTrue: [ number := 10 * number + readStream next digitValue ].	negated		ifTrue: [ number := number negated ].	^ 10 raisedTo: number! !!NeoJSONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 6/2/2012 14:00'!parseNumberFraction	| number power |	number := 0.	power := 1.0.	[ readStream atEnd not and: [ readStream peek isDigit ] ] 		whileTrue: [			number := 10 * number + readStream next digitValue.			power := power * 10.0 ].	^ number / power! !!NeoJSONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 6/12/2012 16:15'!parseNumberInteger	| number |	number := nil.	[ readStream atEnd not and: [ readStream peek isDigit ] ] 		whileTrue: [ 			number := 10 * (number ifNil: [ 0 ]) + readStream next digitValue ].	number ifNil: [ self error: 'Integer digit expected' ].	^ number! !!NeoJSONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 6/13/2012 09:40'!parsePropertyName	| name |	name := self parseValue.	^ name isString		ifTrue: [ 			propertyNamesAsSymbols 				ifTrue: [ name asSymbol ]				ifFalse: [ name ] ]		ifFalse: [ 			self error: 'property name must be a string, not ', name asString ]! !!NeoJSONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 6/2/2012 13:58'!parseString	| result |	self expectChar: $".	result := self stringStreamContents: [ :stream |		[ readStream atEnd or: [ readStream peek = $"] ] 			whileFalse: [ 				stream nextPut: self parseCharacter ] ].	self expectChar: $".	^ result! !!NeoJSONReader methodsFor: 'private' stamp: 'SvenVanCaekenberghe 2/24/2016 14:49'!parseTrailingSurrogateHexEscape	(readStream next = $\ and: [ readStream next = $u ])		ifTrue: [ ^ self parseCharacterHex4Value ]		ifFalse: [ self error: 'trailing surrogate hex escape expected' ]! !!NeoJSONReader methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 6/12/2012 15:56'!parseValue	| char |	readStream atEnd ifFalse: [ 		char := readStream peek.		char = ${			ifTrue: [ ^ self parseMap ].		char = $[			ifTrue: [ ^ self parseList ].		char = $"			ifTrue: [ ^ self parseString ].		(char = $- or: [ char isDigit ])			ifTrue: [ ^ self parseNumber ].		self parseConstantDo: [ :value | ^ value ] ].	self error: 'invalid input: ', char asString! !!NeoJSONReader methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 6/13/2012 09:39'!propertyNamesAsSymbols: boolean	propertyNamesAsSymbols := boolean! !!NeoJSONReader methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/7/2012 16:54'!stringStreamContents: block	"Like String streamContents: block	but reusing the underlying buffer for improved efficiency"		stringStream 		ifNil: [ 			stringStream := (String new: 32) writeStream ].	stringStream reset.	block value: stringStream.	^ stringStream contents! !!NeoJSONReader methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/7/2012 16:55'!unescapeChar: char	"Handle one of the named character escapes, b, f, n, r or t. Else fail."		char = $b		ifTrue: [ ^ Character backspace ].	char = $f		ifTrue: [ ^ Character newPage ].	char = $n		ifTrue: [ ^ Character lf ].	char = $r		ifTrue: [ ^ Character cr ].	char = $t		ifTrue: [ ^ Character tab ].	self error: 'Unknown escape char: ', (String with: char)! !!NeoJSONWriter class methodsFor: 'instance creation' stamp: 'SvenVanCaekenberghe 6/14/2012 09:54'!on: writeStream	"Initialize on writeStream, which should be a character stream that 	implements #nextPut:, #nextPutAll:, #space and (optionally) #close."	^ self new		on: writeStream;		yourself! !!NeoJSONWriter class methodsFor: 'convenience' stamp: 'SvenVanCaekenberghe 6/9/2012 18:27'!toString: object	^ String streamContents: [ :stream |			(self on: stream) nextPut: object ]! !!NeoJSONWriter class methodsFor: 'convenience' stamp: 'SvenVanCaekenberghe 6/9/2012 18:28'!toStringPretty: object	^ String streamContents: [ :stream |			(self on: stream)				prettyPrint: true; 				nextPut: object ]! !!NeoJSONWriter methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 9/3/2013 12:00'!asciiOnly: boolean	asciiOnly := boolean! !!NeoJSONWriter methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 6/2/2012 22:06'!close	writeStream ifNotNil: [		writeStream close.		writeStream := nil ]! !!NeoJSONWriter methodsFor: 'private' stamp: 'SvenVanCaekenberghe 9/3/2013 11:58'!doesCodePointNeedEscaping: code	code < 32 ifTrue: [ ^ true ].	( code = 34 or: [ code = 92 ]) ifTrue: [ ^ true ].	^ asciiOnly and: [ code > 126 ]	! !!NeoJSONWriter methodsFor: 'private' stamp: 'SvenVanCaekenberghe 9/3/2013 11:55'!encodeChar: char	| code |	code := char codePoint.	(self doesCodePointNeedEscaping: code)		ifTrue: [ self escapeChar: code ]		ifFalse: [ writeStream nextPut: char ]! !!NeoJSONWriter methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/3/2012 19:41'!encodeKey: key value: value	self nextPut: key.	self prettyPrintSpace.	writeStream nextPut: $:.	self prettyPrintSpace.	self nextPut: value! !!NeoJSONWriter methodsFor: 'private' stamp: 'SvenVanCaekenberghe 3/23/2014 21:53'!encodeKey: key value: value as: valueSchema	self nextPut: key.	self prettyPrintSpace.	writeStream nextPut: $:.	self prettyPrintSpace.	self nextPut: value as: valueSchema! !!NeoJSONWriter methodsFor: 'private' stamp: 'SvenVanCaekenberghe 2/24/2016 14:17'!escapeChar: code	code = 34		ifTrue: [ ^ writeStream nextPutAll: '\"' ].	code = 92		ifTrue: [ ^ writeStream nextPutAll: '\\' ].	code = 47		ifTrue: [ ^ writeStream nextPutAll: '\/' ].	code = 8		ifTrue: [ ^ writeStream nextPutAll: '\b' ].	code = 12		ifTrue: [ ^ writeStream nextPutAll: '\f' ].			code = 10		ifTrue: [ ^ writeStream nextPutAll: '\n' ].			code = 13		ifTrue: [ ^ writeStream nextPutAll: '\r' ].			code = 9		ifTrue: [ ^ writeStream nextPutAll: '\t' ].			self escapeUnicode: code! !!NeoJSONWriter methodsFor: 'private' stamp: 'SvenVanCaekenberghe 2/24/2016 14:29'!escapeUnicode4: codePoint	writeStream nextPutAll: '\u'.	codePoint printOn: writeStream base: 16 nDigits: 4! !!NeoJSONWriter methodsFor: 'private' stamp: 'SvenVanCaekenberghe 11/24/2016 10:06'!escapeUnicode: codePoint	codePoint <= 16rFFFF		ifTrue: [ self escapeUnicode4: codePoint ]		ifFalse: [ 			codePoint <= 16r10FFFF				ifTrue: [ | leadSurrogate trailSurrogate shifted |					"Characters not in the Basic Multilingual Plane are encoded as a UTF-16 surrogate pair"					"See https://tools.ietf.org/html/rfc7159#section-7"					shifted := codePoint - 16r10000.					leadSurrogate := 16rD800 + (shifted // 16r400).					trailSurrogate := 16rDC00 + (shifted \\ 16r400).					self escapeUnicode4: leadSurrogate.					self escapeUnicode4: trailSurrogate ]				ifFalse: [ self error: 'Character Unicode code point outside encoder range' ] ]! !!NeoJSONWriter methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/3/2012 19:31'!indentedDo: block	level := level + 1.	block value.	level := level - 1! !!NeoJSONWriter methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 5/28/2014 20:43'!initialize	super initialize.	self newLine: String cr.	self prettyPrint: false.	self asciiOnly: false.	self writeNil: false.	level := 0! !!NeoJSONWriter methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/3/2012 19:32'!listElementSeparator	writeStream nextPut: $,.	self newlineIndent! !!NeoJSONWriter methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/3/2012 19:32'!mapElementSeparator	writeStream nextPut: $,.	self newlineIndent! !!NeoJSONWriter methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 12/10/2012 16:27'!newLine: string	newLine := string! !!NeoJSONWriter methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 4/17/2014 11:58'!newline	"Write a newline on the stream that I wrap.	What gets written depends on the configuration, see #newLine:"		writeStream nextPutAll: newLine! !!NeoJSONWriter methodsFor: 'private' stamp: 'SvenVanCaekenberghe 4/17/2014 11:55'!newlineIndent	prettyPrint		ifTrue: [ 			self newline.			level timesRepeat: [ writeStream nextPut: Character tab ] ]! !!NeoJSONWriter methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/2/2012 22:11'!nextPut: anObject	anObject neoJsonOn: self! !!NeoJSONWriter methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 3/23/2014 21:57'!nextPut: anObject as: schema	"Secondary interface to write JSON.	Write objects according to schema."		| mapping |	schema ifNil: [ ^ self nextPut: anObject ].	mapping := self mappingFor: schema.	^ mapping writeObject: anObject on: self! !!NeoJSONWriter methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 6/14/2012 09:54'!on: aWriteStream	"Initialize on aWriteStream, which should be a character stream that 	implements #nextPut:, #nextPutAll:, #space and (optionally) #close."	writeStream := aWriteStream! !!NeoJSONWriter methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 6/2/2012 22:06'!prettyPrint: boolean	prettyPrint := boolean! !!NeoJSONWriter methodsFor: 'private' stamp: 'SvenVanCaekenberghe 12/10/2012 16:33'!prettyPrintSpace	prettyPrint		ifTrue: [ writeStream nextPut: Character space ]! !!NeoJSONWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 6/2/2012 22:18'!writeBoolean: boolean	boolean printOn: writeStream! !!NeoJSONWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 6/2/2012 22:19'!writeFloat: float	float printOn: writeStream! !!NeoJSONWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 6/2/2012 22:18'!writeInteger: integer	integer printOn: writeStream	! !!NeoJSONWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 6/6/2012 15:20'!writeList: collection	self writeListStreamingDo: [ :jsonListWriter |		collection do: [ :each |			jsonListWriter writeElement: each ] ]! !!NeoJSONWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 6/6/2012 15:19'!writeListStreamingDo: block	writeStream nextPut: $[.	self writeStreamingDo: block.	writeStream nextPut: $]! !!NeoJSONWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 6/6/2012 15:04'!writeMap: keyValueCollection	self writeMapStreamingDo: [ :jsonMapWriter |		keyValueCollection keysAndValuesDo: [ :key :value |			jsonMapWriter writeKey: key value: value ] ]! !!NeoJSONWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 6/6/2012 15:19'!writeMapStreamingDo: block	writeStream nextPut: ${.	self writeStreamingDo: block.	writeStream nextPut: $}! !!NeoJSONWriter methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 5/28/2014 20:44'!writeNil	^ writeNil! !!NeoJSONWriter methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 5/28/2014 20:43'!writeNil: boolean	writeNil := boolean! !!NeoJSONWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 6/2/2012 22:15'!writeNull	writeStream nextPutAll: 'null'! !!NeoJSONWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 6/7/2012 15:55'!writeObject: anObject	| mapping |	mapping := self mappingFor: anObject class.	mapping		writeObject: anObject		on: self! !!NeoJSONWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 6/6/2012 15:19'!writeStreamingDo: block	| mapWriter |	mapWriter := NeoJSONStreamingWriter on: self.	self indentedDo: [		block value: mapWriter ].	mapWriter wasUsed		ifTrue: [ self newlineIndent ]		ifFalse: [ self prettyPrintSpace ]! !!NeoJSONWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 6/3/2012 19:42'!writeString: string	writeStream nextPut: $".	string do: [ :each |		self encodeChar: each ].	writeStream nextPut: $"! !!NeoJSONCustomMapping methodsFor: 'mapping' stamp: 'SvenVanCaekenberghe 6/13/2012 11:14'!decoder: block	"Set a decoder block that accepts the next object representation read 	and converts it into the actual object to be returned."	self reader: [ :jsonReader | | representation |		representation := jsonReader next.		block value: representation ]! !!NeoJSONCustomMapping methodsFor: 'mapping' stamp: 'SvenVanCaekenberghe 6/13/2012 11:14'!encoder: block	"Set a encoder block that accepts the next object to be written 	and converts it into the actual representation to be written."	self writer: [ :jsonWriter :anObject | | representation |		representation := block value: anObject.		jsonWriter nextPut: representation ]! !!NeoJSONCustomMapping methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 3/23/2014 19:24'!identifier	^ schemaName ! !!NeoJSONCustomMapping methodsFor: 'mapping' stamp: 'SvenVanCaekenberghe 6/13/2012 11:38'!listOfElementSchema: elementSchema	"Set the reader to a block that will create an instance of the	standard listClass while reading a list of elements of type elementSchema"	self reader: [ :jsonReader |		jsonReader listClass streamContents: [ :stream |			jsonReader parseListDo: [ | element |				element := jsonReader nextAs: elementSchema.				stream nextPut: element ] ] ]	"we do not set a writer, #neoJsonOn: should be sufficient"! !!NeoJSONCustomMapping methodsFor: 'mapping' stamp: 'SvenVanCaekenberghe 6/13/2012 11:25'!listOfType: collectionClass	"Set the reader to a block that will create an instance of collectionClass 	using #streamContents: while reading a list of elements"	self reader: [ :jsonReader |		collectionClass streamContents: [ :stream |			jsonReader parseListDo: [ | element |				element := jsonReader next.				stream nextPut: element ] ] ]	"we do not set a writer, #neoJsonOn: should be sufficient"! !!NeoJSONCustomMapping methodsFor: 'mapping' stamp: 'SvenVanCaekenberghe 6/13/2012 11:39'!listOfType: collectionClass andElementSchema: elementSchema	"Set the reader to a block that will create an instance of collectionClass 	using #streamContents: while reading a list of elements of type elementSchema"	self reader: [ :jsonReader |		collectionClass streamContents: [ :stream |			jsonReader parseListDo: [ | element |				element := jsonReader nextAs: elementSchema.				stream nextPut: element ] ] ]	"we do not set a writer, #neoJsonOn: should be sufficient"! !!NeoJSONCustomMapping methodsFor: 'mapping' stamp: 'SvenVanCaekenberghe 8/30/2013 11:04'!mapWithValueSchema: valueSchema	"Set the reader to a block that will create an instance of the	standard mapClass while reading values of type valueSchema,	with standard keys"	self reader: [ :jsonReader | | map |		map := jsonReader mapClass new.		jsonReader parseMapKeysDo: [ :key | | value |				value := jsonReader nextAs: valueSchema.				map at: key put: value ].		map ]	"we do not set a writer, #neoJsonOn: should be sufficient"! !!NeoJSONCustomMapping methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 3/24/2014 10:34'!readFrom: jsonReader	^ reader 		ifNil: [ jsonReader next ]		ifNotNil: [ reader value: jsonReader ]! !!NeoJSONCustomMapping methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 3/24/2014 10:36'!reader: block	"Set the reader to block, a 1 argument block that when given 	a jsonReader as argument reads the object that I represent.	When there is no reader block, the default #next will be used."		reader := block! !!NeoJSONCustomMapping methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/8/2012 21:09'!schemaName: schema	schemaName := schema! !!NeoJSONCustomMapping methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 3/23/2014 22:10'!writeObject: anObject on: jsonWriter	writer 		ifNil: [ anObject neoJsonOn: jsonWriter ]		ifNotNil: [ writer value: jsonWriter value: anObject ]! !!NeoJSONCustomMapping methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 3/23/2014 22:12'!writer: block	"Set the writer to block, a 2 argument block that when given: a jsonWriter 	and the object to write will write the object that I represent.	When there is no writer block, the default #neoJsonOn: will be used."		writer := block! !!NeoJSONMapping methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 3/23/2014 19:22'!identifier	self subclassResponsibility ! !!NeoJSONMapping methodsFor: 'printing' stamp: 'SvenVanCaekenberghe 3/23/2014 19:24'!printOn: stream	super printOn: stream.	stream nextPut: $(; print: self identifier; nextPut: $)! !!NeoJSONMapping methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 3/23/2014 19:23'!readFrom: jsonReader	self subclassResponsibility ! !!NeoJSONMapping methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 3/23/2014 19:23'!writeObject: anObject on: jsonWriter	self subclassResponsibility ! !!NeoJSONObjectMapping methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 12/30/2015 11:44'!allowNil	allowNil := true! !!NeoJSONObjectMapping methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 3/23/2014 19:25'!identifier	^ subjectClass ! !!NeoJSONObjectMapping methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 7/11/2016 10:54'!initialize	super initialize.	properties := OrderedCollection new.	allowNil := false! !!NeoJSONObjectMapping methodsFor: 'mapping' stamp: 'SvenVanCaekenberghe 6/12/2012 13:13'!mapAccessor: accessor	^ self mapAccessor: accessor to: accessor ! !!NeoJSONObjectMapping methodsFor: 'mapping' stamp: 'SvenVanCaekenberghe 6/12/2012 13:12'!mapAccessor: accessor mutator: mutator to: propertyName	^ self 		mapProperty: propertyName		getter: [ :object | object perform: accessor ]		setter: [ :object :value | object perform: mutator with: value ] ! !!NeoJSONObjectMapping methodsFor: 'mapping' stamp: 'SvenVanCaekenberghe 6/12/2012 13:13'!mapAccessor: accessor to: propertyName	^ self 		mapProperty: propertyName		getter: [ :object | object perform: accessor ]		setter: [ :object :value | object perform: accessor asMutator with: value ] ! !!NeoJSONObjectMapping methodsFor: 'mapping' stamp: 'SvenVanCaekenberghe 6/12/2012 13:14'!mapAccessors: accessors	accessors do: [ :each |		self mapAccessor: each ]! !!NeoJSONObjectMapping methodsFor: 'convenience' stamp: 'SvenVanCaekenberghe 6/6/2012 16:00'!mapAllInstVars	self mapInstVars: subjectClass allInstVarNames! !!NeoJSONObjectMapping methodsFor: 'mapping' stamp: 'SvenVanCaekenberghe 6/9/2012 18:37'!mapInstVar: instVarName	^ self mapInstVar: instVarName to: instVarName ! !!NeoJSONObjectMapping methodsFor: 'mapping' stamp: 'SvenVanCaekenberghe 6/9/2012 18:36'!mapInstVar: instVarName to: propertyName	| index |	index := subjectClass 		instVarIndexFor: instVarName 		ifAbsent: [ self error: 'Inst var not found: ', instVarName printString ].	^ self 		mapProperty: propertyName		getter: [ :object | object instVarAt: index ]		setter: [ :object :value | object instVarAt: index put: value ] ! !!NeoJSONObjectMapping methodsFor: 'convenience' stamp: 'SvenVanCaekenberghe 6/6/2012 15:59'!mapInstVars	self mapInstVars: subjectClass instVarNames! !!NeoJSONObjectMapping methodsFor: 'mapping' stamp: 'SvenVanCaekenberghe 6/6/2012 16:00'!mapInstVars: instVarNames	instVarNames do: [ :each |		self mapInstVar: each ]! !!NeoJSONObjectMapping methodsFor: 'mapping' stamp: 'SvenVanCaekenberghe 7/11/2016 11:01'!mapProperty: propertyName getter: readBlock setter: writeBlock	| propertyMapping |	propertyMapping := NeoJSONPropertyMapping new.	propertyMapping 		propertyName: propertyName;		getter: readBlock;		setter: writeBlock.	properties removeAllSuchThat: [ :each | each propertyName = propertyName ].	properties addLast: propertyMapping.	^ propertyMapping ! !!NeoJSONObjectMapping methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 7/11/2016 10:58'!propertyNamed: propertyName ifAbsent: block	^ properties detect: [ :each | each propertyName = propertyName ] ifNone: block! !!NeoJSONObjectMapping methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 12/30/2015 11:48'!readFrom: jsonReader	| anObject |	anObject := subjectClass new.	allowNil ifTrue: [ 		jsonReader parseConstantDo: [ :value | 			^ value ifNotNil: [ jsonReader error: 'Unexpected boolean constant' ] ] ].	jsonReader parseMapKeysDo: [ :key |		(self propertyNamed: key ifAbsent: [ nil ])			ifNil: [				"read, skip & ignore value"				jsonReader next ]			ifNotNil: [ :mapping |				mapping readObject: anObject from: jsonReader ] ].	^ anObject! !!NeoJSONObjectMapping methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/6/2012 15:32'!subjectClass: smalltalkClass	subjectClass := smalltalkClass! !!NeoJSONObjectMapping methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 7/11/2016 10:54'!writeObject: anObject on: jsonWriter	jsonWriter writeMapStreamingDo: [ :jsonMapWriter |		properties do: [ :each |			each writeObject: anObject on: jsonMapWriter ] ]! !!NeoJSONPropertyMapping methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/6/2012 15:34'!getter: block	getter := block! !!NeoJSONPropertyMapping methodsFor: 'printing' stamp: 'SvenVanCaekenberghe 7/4/2013 19:07'!printOn: stream	super printOn: stream.	stream nextPut: $(; print: propertyName; nextPut: $)! !!NeoJSONPropertyMapping methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 7/11/2016 10:59'!propertyName	^ propertyName ! !!NeoJSONPropertyMapping methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/6/2012 15:34'!propertyName: string	propertyName := string! !!NeoJSONPropertyMapping methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 6/8/2012 17:04'!readObject: anObject from: jsonReader	| value |	value := jsonReader nextAs: valueSchema.	setter value: anObject value: value! !!NeoJSONPropertyMapping methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/6/2012 15:34'!setter: block	setter := block! !!NeoJSONPropertyMapping methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/8/2012 17:01'!valueSchema: schemaName	valueSchema := schemaName! !!NeoJSONPropertyMapping methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 5/28/2014 20:46'!writeObject: anObject on: jsonMapWriter	| value |	value := getter value: anObject.	(value notNil or: [ jsonMapWriter writeNil ])		ifTrue: [ jsonMapWriter writeKey: propertyName value: value as: valueSchema ] ! !!NeoJSONStreamingWriter class methodsFor: 'instance creation' stamp: 'SvenVanCaekenberghe 6/6/2012 15:05'!on: jsonWriter	^ self new		on: jsonWriter;		yourself! !!NeoJSONStreamingWriter methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 6/6/2012 14:48'!initialize	super initialize.	first := true! !!NeoJSONStreamingWriter methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 6/6/2012 14:49'!on: aJSONWriter	jsonWriter := aJSONWriter! !!NeoJSONStreamingWriter methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/6/2012 15:00'!wasUsed	^ first not! !!NeoJSONStreamingWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 6/6/2012 15:15'!writeElement: value	first 		ifTrue: [ 			jsonWriter newlineIndent. 			first := false ]		ifFalse: [ 			jsonWriter listElementSeparator ].	jsonWriter nextPut: value ! !!NeoJSONStreamingWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 6/6/2012 15:01'!writeKey: key value: value	first 		ifTrue: [ 			jsonWriter newlineIndent. 			first := false ]		ifFalse: [ 			jsonWriter mapElementSeparator ].	jsonWriter encodeKey: key value: value ! !!NeoJSONStreamingWriter methodsFor: 'writing' stamp: 'SvenVanCaekenberghe 3/23/2014 21:53'!writeKey: key value: value as: valueSchema	first 		ifTrue: [ 			jsonWriter newlineIndent. 			first := false ]		ifFalse: [ 			jsonWriter mapElementSeparator ].	jsonWriter encodeKey: key value: value as: valueSchema! !!NeoJSONStreamingWriter methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 5/28/2014 20:45'!writeNil	^ jsonWriter writeNil! !!Object methodsFor: '*neo-json-core' stamp: 'SvenVanCaekenberghe 6/5/2012 22:29'!neoJsonOn: neoJSONWriter	neoJSONWriter writeObject: self! !!Number methodsFor: '*neo-json-core' stamp: 'SvenVanCaekenberghe 6/2/2012 22:17'!neoJsonOn: neoJSONWriter	neoJSONWriter writeFloat: self asFloat! !!Dictionary methodsFor: '*neo-json-core' stamp: 'SvenVanCaekenberghe 6/3/2012 19:30'!neoJsonOn: neoJSONWriter	neoJSONWriter writeMap: self! !!NeoJSONObject class methodsFor: 'convenience' stamp: 'SvenVanCaekenberghe 9/8/2014 13:33'!fromString: string	"Parse string as JSON, so that maps become instances of me"	^ (NeoJSONReader on: string readStream)			mapClass: NeoJSONObject;			propertyNamesAsSymbols: true;			next! !!NeoJSONObject methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 9/8/2014 11:43'!at: key	"I return nil for missing keys.	My superclass would signal a KeyNotFound."		^ self at: key ifAbsent: [ nil ]! !!NeoJSONObject methodsFor: 'reflective operations' stamp: 'SvenVanCaekenberghe 9/8/2014 12:32'!doesNotUnderstand: message	"Overwritten so that 'self foo' becomes 'self at: #foo'	and 'self foo: 1' becomes 'self at: #foo put: 1'"		| key |	key := message selector.	key isUnary		ifTrue: [ ^ self at: key ].	^ (key isKeyword and: [ key numArgs = 1 ])		ifTrue: [ self at: key allButLast asSymbol put: message arguments first ]		ifFalse: [ super doesNotUnderstand: message ]! !!NeoJSONObject methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 9/8/2014 11:46'!name	"Overwritten to make this accessor available as key"		^ self at: #name! !!NeoJSONObject methodsFor: 'printing' stamp: 'SvenVanCaekenberghe 9/8/2014 11:45'!printOn: stream	"I use my JSON representation when printing myself"		(NeoJSONWriter on: stream) nextPut: self! !!NeoJSONObject methodsFor: 'evaluating' stamp: 'SvenVanCaekenberghe 9/8/2014 11:46'!value	"Overwritten to make this accessor available as key"		^ self at: #value! !!UndefinedObject methodsFor: '*neo-json-core' stamp: 'SvenVanCaekenberghe 6/2/2012 22:15'!neoJsonOn: neoJSONWriter	neoJSONWriter writeNull! !!String methodsFor: '*neo-json-core' stamp: 'SvenVanCaekenberghe 6/2/2012 22:26'!neoJsonOn: neoJSONWriter	neoJSONWriter writeString: self! !!Boolean methodsFor: '*neo-json-core' stamp: 'SvenVanCaekenberghe 6/2/2012 22:14'!neoJsonOn: neoJSONWriter	neoJSONWriter writeBoolean: self! !!Integer methodsFor: '*neo-json-core' stamp: 'SvenVanCaekenberghe 6/2/2012 22:17'!neoJsonOn: neoJSONWriter	neoJSONWriter writeInteger: self! !!OrderedDictionary methodsFor: '*neo-json-core' stamp: 'SvenVanCaekenberghe 8/26/2015 12:03'!neoJsonOn: neoJSONWriter	neoJSONWriter writeMap: self! !!Collection methodsFor: '*neo-json-core' stamp: 'SvenVanCaekenberghe 6/3/2012 19:29'!neoJsonOn: neoJSONWriter	neoJSONWriter writeList: self! !!SmallDictionary methodsFor: '*neo-json-core' stamp: 'SvenVanCaekenberghe 6/3/2012 19:30'!neoJsonOn: neoJSONWriter	neoJSONWriter writeMap: self! !!NeoJSONMappingNotFound methodsFor: 'printing' stamp: 'SvenVanCaekenberghe 6/12/2012 15:47'!standardMessageText	^ String streamContents: [ :stream |		stream << 'No mapping found for '.		stream print: self object.		stream << ' in '.		stream print: self collection class ]! !"Neo-JSON-Core"!!NeoJSONBenchmarkTests commentStamp: 'SvenVanCaekenberghe 6/5/2012 10:05' prior: 0!I am NeoJSONBenchmarkTests.This test is obviously dependent on hardware, but the margin is quite high.!!NeoJSONObjectTests commentStamp: 'SvenVanCaekenberghe 9/8/2014 12:39' prior: 0!I am NeoJSONObjectTests, I hold unit tests for NeoJSONObject.!!NeoJSONReaderTests commentStamp: 'SvenVanCaekenberghe 6/2/2012 14:02' prior: 0!I am NeoJSONReaderTests, a test suite for NeoJSONReader.!!NeoJSONWriteReadTests commentStamp: 'SvenVanCaekenberghe 6/4/2012 15:34' prior: 0!I am NeoJSONWriteReadTests.!!NeoJSONWriteReadAsciiOnlyTests commentStamp: 'SvenVanCaekenberghe 11/24/2016 10:07' prior: 0!I am NeoJSONWriteReadAsciiOnlyTests.!!NeoJSONWriteReadMockStreamTests commentStamp: 'SvenVanCaekenberghe 11/24/2016 10:07' prior: 0!I am NeoJSONWriteReadMockStreamTests.!!NeoJSONWriteReadPrettyPrintedTests commentStamp: 'SvenVanCaekenberghe 6/5/2012 09:50' prior: 0!I am NeoJSONWriteReadPrettyPrintedTests.!!NeoJSONWriterTests commentStamp: 'SvenVanCaekenberghe 6/2/2012 22:20' prior: 0!I am NeoJSONWriterTests, a test suite for NeoJSONWriter.!!NeoJSONBenchmark commentStamp: 'SvenVanCaekenberghe 6/5/2012 09:48' prior: 0!I am NeoJSONBenchmark.I hold 1000 objects of the form Dictionary('color'->'green' 'enabled'->false 'id'->1 'name'->'Name-1' 'value'->0.002 ) in an Array.I hold the JSON serialization of that as a String of the form '[{"value":0.002,"enabled":false,"name":"Name-1","color":"green","id":1}, ...| benchmark |benchmark := NeoJSONBenchmark new.[benchmark read] bench.| benchmark |benchmark := NeoJSONBenchmark new.[benchmark write] bench.| benchmark |benchmark := NeoJSONBenchmark new.[benchmark read] timeToRun.| benchmark |benchmark := NeoJSONBenchmark new.[benchmark write] timeToRun.!!NeoJSONMockStream commentStamp: '<historical>' prior: 0!I am NeoJSONMockStream.I wrap another stream to validate the limited API used.!!NeoJSONTestObject1 commentStamp: '<historical>' prior: 0!I am NeoJSONTestObject1.I repesent a domain model object.I have the following properties:- id <Integer>- name <String>- timestamp <DateAndTime>- points <Array of: Point>- bytes <ByteArray>My JSON representation is like this:- id <Number>- name <String>- created-at <ISO8601 String>- points <Array of: <Map x,y>- bytes <Array of: Number>!!NeoJSONTestObject2 commentStamp: 'SvenVanCaekenberghe 3/22/2014 09:36' prior: 0!I am NeoJSONTestObject2.Instance Variables	data:		<String>	height:		<Integer>	id:			<Integer>	width:		<Integer>Used for benchmarking and other tests.!!NeoJSONTestObject3 commentStamp: 'SvenVanCaekenberghe 3/22/2014 09:40' prior: 0!I am NeoJSONTestObject3, a subclass of NeoJSONTestObject2.Instance Variables	color:			<String>	transparent :	<Boolean>I am used for inheritance testing.!!NeoJSONBenchmarkTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/10/2012 20:20'!testObject2	| json |	json := NeoJSONWriter toString: NeoJSONTestObject2 new.	self 		assert: (NeoJSONReader fromString: json as: NeoJSONTestObject2)		equals: NeoJSONTestObject2 new! !!NeoJSONBenchmarkTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/15/2014 19:29'!testPrettyPrinted	| benchmark |	benchmark := NeoJSONBenchmark new.	self		assert: benchmark writePrettyPrintedRead		equals: benchmark read! !!NeoJSONBenchmarkTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/15/2014 19:30'!testRead	| benchmark |	benchmark := NeoJSONBenchmark new.	benchmark read! !!NeoJSONBenchmarkTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/15/2014 19:30'!testWrite	| benchmark |	benchmark := NeoJSONBenchmark new.	benchmark write! !!NeoJSONObjectTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 9/8/2014 12:39'!testCRUD	| object |	object := NeoJSONObject new.	self assert: object isEmpty.	self assert: object foo equals: nil.	object foo: 123.	self assert: object foo equals: 123.	self assert: object printString equals: '{"foo":123}'.	object name: 'test'.	object value: Float pi.	self assert: object name equals: 'test'.	self assert: (object value closeTo: Float pi).	self assert: object keys asSet equals: #(foo name value) asSet.	object removeKey: #foo.	self assert: object foo equals: nil.	object removeAll.	self assert: object isEmpty! !!NeoJSONObjectTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 11/25/2015 09:19'!testJSON	| data  json object |	data := { #foo->1. #bar->2. #str->'Str!!'. #bool->true. #flt->1.5 } as: NeoJSONObject.	json := NeoJSONWriter toString: data .	object := NeoJSONObject fromString: json.	self assert: object class equals: NeoJSONObject.	self assert: object equals: data.	json := (NeoJSONWriter toString: object).	self assert: (NeoJSONObject fromString: json) equals: object! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 12/30/2015 12:29'!testAllowNil	self 		should: [ 			(NeoJSONReader on: 'null' readStream)				mapInstVarsFor: Point;				nextAs: Point ] 		raise: NeoJSONParseError.	self		assert: ((NeoJSONReader on: 'null' readStream)						mapInstVarsFor: Point;						for: Point do: [ :mapping | mapping allowNil ];						nextAs: Point)		equals: nil.	self		assert: ((NeoJSONReader on: '[ { "x" : 1, "y" : 2 }, null, { "x" : 3, "y" : -1 } ]' readStream)						mapInstVarsFor: Point;						for: Point do: [ :mapping | mapping allowNil ];						for: #ArrayOfPoints customDo: [ :mapping | mapping listOfElementSchema: Point ];						nextAs: #ArrayOfPoints)		equals: { 1 @ 2. nil. 3 @ -1 }.! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/12/2012 12:32'!testArrayOfPoints	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			for: Point do: [ :mapping |				mapping mapInstVars: #(x y) ];			for: #ArrayOfPoints customDo: [ :mapping |				mapping listOfElementSchema: Point ];			nextAs: #ArrayOfPoints ].	self assert: (reader value: '[ { "x":1, "y":2 }, { "x":-1, "y":-2 } ]') equals: { 1@2. -1@ -2 }. 	self assert: (reader value: '[ ]') equals: #().	self assert: (reader value: '[ { } ]') equals: { Point new }! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 3/16/2016 10:58'!testArrayOfPointsUsingNextListAs	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			mapInstVarsFor: Point;			nextListAs: Point ].	self assert: (reader value: '[ { "x":1, "y":2 }, { "y":-2, "x":-1 } ]') equals: { 1@2. -1@ -2 }. 	self assert: (reader value: '[ ]') equals: #().	self assert: (reader value: '[ { } ]') equals: { Point new }! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/12/2012 13:18'!testAssociation	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			for: Association do: [ :mapping |				mapping mapAccessors: #(key value) ]; 			nextAs: Association ].	self assert: (reader value: '{"key":"foo","value":42}') equals: 'foo' -> 42. 	self assert: (reader value: '{}') equals: Association new! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/13/2012 14:44'!testBooleans	self assert: (NeoJSONReader on: 'true' readStream) next equals: true.	self assert: (NeoJSONReader on: 'false' readStream) next equals: false.	self should: [ (NeoJSONReader on: 'tru' readStream) next ] raise: NeoJSONParseError.	self should: [ (NeoJSONReader on: 'falsE' readStream) next ] raise: NeoJSONParseError.! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/12/2012 12:32'!testByteArray	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			for: ByteArray customDo: [ :mapping |				mapping listOfType: ByteArray ];			nextAs: ByteArray ].	self assert: (reader value: '[ 1, 2, 3 ]') equals: #[1 2 3].	self assert: (reader value: '[ ]') equals: ByteArray new! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/12/2012 12:02'!testDate	| reader |	reader := [ :input | 		(NeoJSONReader on: input readStream) 			for: Date customDo: [ :mapping |				mapping decoder: [ :string | Date fromString: string ] ];			nextAs: Date ].	self assert: (reader value: ' "2012-06-08" ') equals: (Date newDay: 8 month: 6 year: 2012)! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/12/2012 12:02'!testDateAndTime 	| reader |	reader := [ :input | 		(NeoJSONReader on: input readStream) 			for: DateAndTime customDo: [ :mapping |				mapping decoder: [ :string | DateAndTime fromString: string ] ];			nextAs: DateAndTime ].	self 		assert: (reader value: ' "2012-02-14T16:40:18+01:00" ') 		equals: (DateAndTime year: 2012 month: 2 day: 14 hour: 16 minute: 40 second: 18 offset: 1 hour)! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/2/2012 21:49'!testFloats	| reader |	reader := [ :string |		(NeoJSONReader on: string readStream) next ].	self assert: ((reader value: '123.0') closeTo: 123.0).	self assert: ((reader value: '-123.0') closeTo: -123.0).	self assert: ((reader value: '123.0e0') closeTo: 123.0).	self assert: ((reader value: '123e6') closeTo: 123e6).	self assert: ((reader value: '123e+6') closeTo: 123e6).	self assert: ((reader value: '123e-6') closeTo: 123e-6).	self assert: ((reader value: '123E6') closeTo: 123e6).	self assert: ((reader value: '123E+6') closeTo: 123e6).	self assert: ((reader value: '123E-6') closeTo: 123e-6).	self assert: ((reader value: '-123e6') closeTo: -123e6).	self assert: ((reader value: '-123e-6') closeTo: -123e-6).	self assert: ((reader value: '-123E6') closeTo: -123e6).	self assert: ((reader value: '-123E-6') closeTo: -123e-6).	self assert: ((reader value: '3.14159') closeTo: Float pi).	self assert: ((reader value: '0.123e6') closeTo: 0.123e6).	self assert: ((reader value: '0.123e-6') closeTo: 0.123e-6).	self assert: ((reader value: '-0.123E6') closeTo: -0.123e6).	self assert: ((reader value: '-0.123E-6') closeTo: -0.123e-6).! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/12/2012 16:08'!testIntegers	| reader |	reader := [ :string |		(NeoJSONReader on: string readStream) next ].	self assert: (reader value: '123') equals: 123.	self assert: (reader value: '00123') equals: 123.	self assert: (reader value: '-123') equals: -123.	self assert: (reader value: '-0123') equals: -123.	self assert: (reader value: '0') equals: 0.	self assert: (reader value: '-0') equals: 0.	self assert: (reader value: '00') equals: 0.	self assert: (reader value: ' 123	') equals: 123.	self should: [ reader value: '+1' ] raise: NeoJSONParseError.	self should: [ reader value: ' - ' ] raise: NeoJSONParseError.! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/12/2012 16:16'!testLists	| reader |	reader := [ :string |		(NeoJSONReader on: string readStream) next ].	self assert: (reader value: '[1,2,3]') equals: #(1 2 3).	self assert: (reader value: '[]') equals: #().	self assert: (reader value: ' [ 1 , 2 , 3 ] ') equals: #(1 2 3).	self assert: (reader value: ' [ ] ') equals: #().	self should: [ reader value: '[1,]' ] raise: NeoJSONParseError. 	self should: [ reader value: '[' ] raise: NeoJSONParseError.	self should: [ reader value: ']' ] raise: NeoJSONParseError.	self should: [ reader value: '[}' ] raise: NeoJSONParseError! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/12/2012 16:16'!testMaps	| reader |	reader := [ :string |		(NeoJSONReader on: string readStream) next ].	self assert: (reader value: '{"x":1,"y":2}') equals: (Dictionary newFromPairs: #( 'x' 1 'y' 2)).	self assert: (reader value: '{}') equals: Dictionary new.	self assert: (reader value: ' { "x" : 1 , "y" : 2 } ' ) equals: (Dictionary newFromPairs: #( 'x' 1 'y' 2)).	self assert: (reader value: ' { } ') equals: Dictionary new.	self should: [ reader value: '{"foo":}' ] raise: NeoJSONParseError. 	self should: [ reader value: '{"foo":9,}' ] raise: NeoJSONParseError. 	self should: [ reader value: '{9:true,}' ] raise: NeoJSONParseError. 	self should: [ reader value: '{' ] raise: NeoJSONParseError.	self should: [ reader value: '}' ] raise: NeoJSONParseError.	self should: [ reader value: '{]' ] raise: NeoJSONParseError! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 3/24/2014 11:58'!testNextStringAsHex	| string |	string := (NeoJSONReader on: '"466F6F2062617221"' readStream)		for: #StringAsHex			customDo: [ :mapping | 					mapping						encoder: [ :x | x asByteArray hex asUppercase ];						decoder: [ :x | (ByteArray readHexFrom: x) asString ] ];		nextAs: #StringAsHex.	self assert: string equals: 'Foo bar!!'! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 2/24/2016 14:15'!testNonBMPCharacterDecoding	"Characters not in the Basic Multilingual Plane are encoded as a UTF-16 surrogate pair"	| string object |	string := String with: 16r1D11E asCharacter. "MUSICAL SYMBOL G CLEF"	object := (NeoJSONReader fromString: '"\uD834\uDD1E"').	self assert: object equals: string! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/13/2012 14:29'!testNull	self assert: (NeoJSONReader on: 'null' readStream) next equals: nil.	self assert: (NeoJSONReader on: '	null ' readStream) next equals: nil.	self should: [ (NeoJSONReader on: '	nil ' readStream) next ] raise: NeoJSONParseError.! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/13/2012 10:18'!testOrderedCollection	| json list |	json := '[ 1, 2, 3 ]'.	list := (NeoJSONReader on: json readStream) 		listClass: OrderedCollection;		next.	self 		assert: list 		equals: (OrderedCollection with: 1 with: 2 with: 3).	self 		assert: list class 		equals: OrderedCollection! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/12/2012 12:33'!testOrderedCollectionOfPoints	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			for: Point do: [ :mapping |				mapping mapInstVars: #(x y) ];			for: #OrderedCollectionOfPoints customDo: [ :mapping |				mapping listOfType: OrderedCollection andElementSchema: Point ];			nextAs: #OrderedCollectionOfPoints ].	self assert: (reader value: '[ { "x":1, "y":2 }, { "x":-1, "y":-2 } ]') equals: { 1@2. -1@ -2 } asOrderedCollection. 	self assert: (reader value: '[ ]') equals: OrderedCollection new.	self assert: (reader value: '[ { } ]') equals: (OrderedCollection with: Point new)! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/12/2012 16:01'!testParseErrors	self should: [ NeoJSONReader fromString: 'zero' ] raise: NeoJSONParseError.	self should: [ NeoJSONReader fromString: '#' ] raise: NeoJSONParseError.	self should: [ NeoJSONReader fromString: '@' ] raise: NeoJSONParseError.! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/12/2012 15:58'!testPoint	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) nextAs: Point ].	self should: [ reader value: '{"x":1,"y":2}' ] raise: NeoJSONMappingNotFound! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/8/2012 14:04'!testPoint1	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			for: Point do: [ :mapping |				mapping mapProperty: 'x' getter: [ :point | point x ] setter: [ :point :value | point setX: value setY: point y ].				mapping mapProperty: 'y' getter: [ :point | point y ] setter: [ :point :value | point setX: point x setY: value ]. ];			nextAs: Point ].	self assert: (reader value: '{"x":1,"y":2}') equals: 1@2. 	self assert: (reader value: '{}') equals: Point new! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/7/2012 15:23'!testPoint2	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			mapAllInstVarsFor: Point;			nextAs: Point ].	self assert: (reader value: '{"x":1,"y":2}') equals: 1@2. 	self assert: (reader value: '{}') equals: Point new! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/8/2012 14:04'!testPoint3	| reader |	reader := [ :string | 		(NeoJSONReader on: string readStream) 			for: Point do: [ :mapping |				mapping mapInstVars: #(x y) ];			nextAs: Point ].	self assert: (reader value: '{"x":1,"y":2}') equals: 1@2. 	self assert: (reader value: '{}') equals: Point new! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 3/24/2014 10:43'!testPointUsingAsString	| point |	point := (NeoJSONReader on: '{"x":"1","y":"2"}' readStream)		for: Point			do: [ :mapping | 					(mapping 						mapProperty: #x 						getter: [ :object | object x ] 						setter: [ :object :value | object setX: value setY: object y ])						valueSchema: #AsString.					(mapping						mapProperty: #y						getter: [ :object | object y ]						setter: [ :object :value | object setX: object x setY: value ]) 						valueSchema: #AsString ];		for: #AsString			customDo: [ :mapping | 					mapping						encoder: [ :x | x asString ];						decoder: [ :x | x asNumber ] ];		nextAs: Point.	self assert: point equals: 1 @ 2! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/13/2012 10:00'!testPropertyNamesAsSymbols	| json map |	json := '{ "x" : true, "y" : false, "key-1" : 1 }'.	map := (NeoJSONReader on: json readStream) 		propertyNamesAsSymbols: true; 		next.	self 		assert: map 		equals: (Dictionary new at: #x put: true; at: #y put: false; at: #'key-1' put: 1; yourself).	self assert: (map keys allSatisfy: [ :each | each isSymbol ])! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 7/4/2013 18:38'!testSmallDictionary	| json map smallDictionaryClass |	json := '{ "x" : true, "y" : false, "key-1" : 1 }'.	smallDictionaryClass := Smalltalk at: #SmallDictionary ifAbsent: [ Dictionary ].	map := (NeoJSONReader on: json readStream) 		mapClass: smallDictionaryClass;		next.	self 		assert: map 		equals: (smallDictionaryClass new at: #x put: true; at: #y put: false; at: #'key-1' put: 1; yourself).	self 		assert: map class 		equals: smallDictionaryClass! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/12/2012 16:04'!testStrings	| reader |	reader := [ :string |		(NeoJSONReader on: string readStream) next ].	self assert: (reader value: '"foo"') equals: 'foo'.	self assert: (reader value: '""') equals: ''.	self assert: (reader value: '"Foo BAR"') equals: 'Foo BAR'.	self assert: (reader value: '"\u00E9l\u00E8ve en Fran\u00E7ais"') equals: 'lve en Franais'.	self 		assert: (reader value: '"\"\\\/\t\r\n\f\b"') 		equals: (String withAll: { 					$". $\. $/. Character tab. Character cr. Character lf.  Character newPage. Character backspace }).	self should: [ reader value: '"open' ] raise: NeoJSONParseError.	self should: [ reader value: '"\uAA"' ] raise: NeoJSONParseError.	self should: [ reader value: '"\uZZ"' ] raise: NeoJSONParseError.	self should: [ reader value: '"\x"' ] raise: NeoJSONParseError.	self should: [ reader value: ' " ' ] raise: NeoJSONParseError.! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/12/2012 12:02'!testSymbol	| reader |	reader := [ :input | 		(NeoJSONReader on: input readStream) 			for: Symbol customDo: [ :mapping |				mapping decoder: [ :string | string asSymbol ] ];			nextAs: Symbol ].	self assert: (reader value: ' "foo" ') equals: #foo.	self assert: (reader value: ' "FOO-1" ') equals: #'FOO-1'! !!NeoJSONReaderTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/12/2012 12:02'!testTime	| reader |	reader := [ :input | 		(NeoJSONReader on: input readStream) 			for: Time customDo: [ :mapping |				mapping decoder: [ :string | Time fromString: string ] ];			nextAs: Time ].	self assert: (reader value: ' "14:30:08" ') equals: (Time hour: 14 minute: 30 second: 8)! !!NeoJSONWriteReadAsciiOnlyTests methodsFor: 'private' stamp: 'SvenVanCaekenberghe 11/24/2016 10:03'!writeRead: object	| json |	json := String streamContents: [ :stream |		(NeoJSONWriter on: stream) asciiOnly: true; nextPut: object ].	^ (NeoJSONReader on: json readStream) next ! !!NeoJSONWriteReadMockStreamTests methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/13/2012 16:28'!writeRead: object	| json |	json := String streamContents: [ :stream |		(NeoJSONWriter on: (NeoJSONMockStream on: stream))			prettyPrint: true;			nextPut: object ].	^ (NeoJSONReader on: (NeoJSONMockStream on: json readStream)) next ! !!NeoJSONWriteReadPrettyPrintedTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 8/30/2013 11:05'!testDictionaryOfObject2	| data json reader |	data := Dictionary new.	data 		at: #one put: NeoJSONTestObject2 example1;		at: #two put: NeoJSONTestObject2 example1.	json := NeoJSONWriter toStringPretty: data.	reader := NeoJSONReader on: json readStream.	reader for: #DictionaryOfObject2 customDo: [ :mapping |		mapping mapWithValueSchema: NeoJSONTestObject2 ].  	self 		assert: (reader nextAs: #DictionaryOfObject2)		equals: data! !!NeoJSONWriteReadPrettyPrintedTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/9/2012 18:49'!testObject1	| json |	json := NeoJSONWriter toStringPretty: NeoJSONTestObject1 example1.	self 		assert: (NeoJSONReader fromString: json as: NeoJSONTestObject1)		equals: NeoJSONTestObject1 example1! !!NeoJSONWriteReadPrettyPrintedTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 8/30/2013 11:05'!testObject2	| json |	json := NeoJSONWriter toStringPretty: NeoJSONTestObject2 example1.	self 		assert: (NeoJSONReader fromString: json as: NeoJSONTestObject2)		equals: NeoJSONTestObject2 example1! !!NeoJSONWriteReadPrettyPrintedTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 3/22/2014 10:59'!testObject3	| json |	json := NeoJSONWriter toStringPretty: NeoJSONTestObject3 example1.	self 		assert: (NeoJSONReader fromString: json as: NeoJSONTestObject3)		equals: NeoJSONTestObject3 example1! !!NeoJSONWriteReadPrettyPrintedTests methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/4/2012 15:45'!writeRead: object	| json |	json := String streamContents: [ :stream |		(NeoJSONWriter on: stream) 			prettyPrint: true;			nextPut: object ].	^ (NeoJSONReader on: json readStream) next ! !!NeoJSONWriteReadTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 8/30/2013 11:03'!testDictionaryOfObject2	| data json reader |	data := Dictionary new.	data 		at: #one put: NeoJSONTestObject2 example1;		at: #two put: NeoJSONTestObject2 example1.	json := NeoJSONWriter toString: data.	reader := NeoJSONReader on: json readStream.	reader for: #DictionaryOfObject2 customDo: [ :mapping |		mapping mapWithValueSchema: NeoJSONTestObject2 ].  	self 		assert: (reader nextAs: #DictionaryOfObject2)		equals: data! !!NeoJSONWriteReadTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/4/2012 15:51'!testFloats	| objects |	objects := { Float pi . 1.0 . -1.0 . 0.0 . 1.5e6 . -1.5e6 . 1.5e-6 . -1.5e-6 }.	(self writeRead: objects) 		with: objects 		do: [ :first :second | self assert: (first closeTo: second) ]! !!NeoJSONWriteReadTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/4/2012 15:46'!testIntegers	| objects |	objects := { 1. -1. 0. 123467890. -1234567890 }.	self 		assert: (self writeRead: objects)		equals: objects! !!NeoJSONWriteReadTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/4/2012 15:51'!testLists	| objects |	objects := { #(1 2 3). #(). #( 'foo' 'bar') }.	self 		assert: (self writeRead: objects)		equals: objects! !!NeoJSONWriteReadTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/4/2012 15:53'!testMaps	| objects |	objects := { 		Dictionary new.		Dictionary with: 'x' -> 1.		Dictionary newFromPairs: #( 'foo' true 'bar' false 'zero' 0 'null' nil 'string' 'Hello World!!' ) }.	self 		assert: (self writeRead: objects)		equals: objects! !!NeoJSONWriteReadTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/9/2012 18:48'!testObject1	| json |	json := NeoJSONWriter toString: NeoJSONTestObject1 example1.	self 		assert: (NeoJSONReader fromString: json as: NeoJSONTestObject1)		equals: NeoJSONTestObject1 example1! !!NeoJSONWriteReadTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 8/30/2013 10:12'!testObject2	| json |	json := NeoJSONWriter toString: NeoJSONTestObject2 example1.	self 		assert: (NeoJSONReader fromString: json as: NeoJSONTestObject2)		equals: NeoJSONTestObject2 example1! !!NeoJSONWriteReadTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 3/22/2014 10:14'!testObject3	| json |	json := NeoJSONWriter toString: NeoJSONTestObject3 example1.	self 		assert: (NeoJSONReader fromString: json as: NeoJSONTestObject3)		equals: NeoJSONTestObject3 example1! !!NeoJSONWriteReadTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/4/2012 15:46'!testSpecials	| objects |	objects := { true. false. nil }.	self 		assert: (self writeRead: objects)		equals: objects! !!NeoJSONWriteReadTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 11/24/2016 10:04'!testStrings	| objects |	objects := { 		'foo'. 'Foo BAR'. ''. '	\\'''. 		'lve en Franais'. 		String with: (Character codePoint: 12354) "HIRAGANA LETTER A" }.	self 		assert: (self writeRead: objects)		equals: objects! !!NeoJSONWriteReadTests methodsFor: 'private' stamp: 'SvenVanCaekenberghe 6/4/2012 15:36'!writeRead: object	| json |	json := String streamContents: [ :stream |		(NeoJSONWriter on: stream) nextPut: object ].	^ (NeoJSONReader on: json readStream) next ! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 9/3/2013 12:06'!testAsciiOnlyStrings	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				asciiOnly: true;				nextPut: object ] ].	self assert: (writer value: 'lve franais') equals: '"\u00E9l\u00E8ve fran\u00E7ais"'.	self assert: (writer value: 'foo') equals: '"foo"'.	self assert: (writer value: 'Foo BAR') equals: '"Foo BAR"'.	self assert: (writer value: '') equals: '""'.	self		assert: (writer value: (String withAll: { 					$". $\. $/. Character tab. Character cr. Character lf.  Character newPage. Character backspace }))		equals: '"\"\\/\t\r\n\f\b"'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/12/2012 13:19'!testAssociation	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: Association do: [ :mapping |					mapping mapAccessors: #(key value) ]; 				nextPut: object ] ].	self assert: (writer value: 'foo' -> 42) equals: '{"key":"foo","value":42}'.	self assert: (writer value: Association new) equals: '{}'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/3/2012 19:56'!testBooleans	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: true) equals: 'true'.	self assert: (writer value: false) equals: 'false'.! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/8/2012 21:54'!testByteArray	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: #[1 2 3]) equals: '[1,2,3]'.	self assert: (writer value: #[]) equals: '[]'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/12/2012 12:02'!testDate	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: Date customDo: [ :mapping |					mapping encoder: [ :date | date yyyymmdd ] ];				nextPut: object ] ].	self assert: (writer value: (Date newDay: 8 month: 6 year: 2012)) equals: '"2012-06-08"'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/12/2012 12:02'!testDateAndTime 	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: DateAndTime customDo: [ :mapping |					mapping encoder: [ :dateAndTime | dateAndTime printString ] ];				nextPut: object ] ].	self 		assert: (writer value: (DateAndTime year: 2012 month: 2 day: 14 hour: 16 minute: 40 second: 18 offset: 1 hour)) 		equals: '"2012-02-14T16:40:18+01:00"'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/2/2012 22:24'!testFloats	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: 123.0) equals: '123.0'.	self assert: (writer value: -123.0) equals: '-123.0'.	self assert: (writer value: 0.0) equals: '0.0'.! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/2/2012 22:24'!testIntegers	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: 123) equals: '123'.	self assert: (writer value: -123) equals: '-123'.	self assert: (writer value: 0) equals: '0'.! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/3/2012 19:39'!testLists	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: #(1 2 3)) equals: '[1,2,3]'.	self assert: (writer value: #()) equals: '[]'.! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 9/4/2015 14:02'!testListsExtra	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	#( OrderedCollection LinkedList ByteArray IntegerArray SortedCollection ) do: [ :each |		Smalltalk at: each ifPresent: [ :collectionClass |			self assert: (writer value: (collectionClass withAll: #(1 2 3))) equals: '[1,2,3]'.			self assert: (writer value: collectionClass new) equals: '[]' ] ]! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/3/2012 19:40'!testMaps	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: (Dictionary newFromPairs: #( 'x' 1 'y' 2))) equals: '{"x":1,"y":2}'.	self assert: (writer value: Dictionary new) equals: '{}'.! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 8/26/2015 14:05'!testMapsExtra	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: (IdentityDictionary newFromPairs: #( 'x' 1))) equals: '{"x":1}'.	self assert: (writer value: IdentityDictionary new) equals: '{}'.	#( SmallDictionary OrderedDictionary OrderedIdentityDictionary ) do: [ :each |		| dictionaryClass |		dictionaryClass := Smalltalk at: each ifAbsent: [ nil ].		dictionaryClass ifNotNil: [				self assert: (writer value: (dictionaryClass new at: 'x' put: 1; at: 'y' put: 2; yourself)) equals: '{"x":1,"y":2}'.			self assert: (writer value: dictionaryClass new) equals: '{}'] ]! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 3/24/2014 11:57'!testNextPutStringAsHex	| output |	output := String		streamContents: [ :out | 			(NeoJSONWriter on: out)				for: #StringAsHex					customDo: [ :mapping | 							mapping								encoder: [ :x | x asByteArray hex asUppercase ];								decoder: [ :x | (ByteArray readHexFrom: x) asString ] ];				nextPut: 'Foo bar!!' as: #StringAsHex ].	self assert: output equals: '"466F6F2062617221"'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 2/24/2016 14:15'!testNonBMPCharacterEncoding	"Characters not in the Basic Multilingual Plane are encoded as a UTF-16 surrogate pair"	| string json |	string := String with: 16r1D11E asCharacter. "MUSICAL SYMBOL G CLEF"	json := String streamContents: [ :out |		(NeoJSONWriter on: out) asciiOnly: true; nextPut: string ].	self assert: json equals: '"\uD834\uDD1E"'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/2/2012 22:23'!testNull	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: nil) equals: 'null'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/12/2012 15:58'!testPoint	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self should: [ writer value: 1@2 ] raise: NeoJSONMappingNotFound! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/8/2012 14:04'!testPoint1	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: Point do: [ :mapping |					mapping mapProperty: 'x' getter: [ :point | point x ] setter: [ :point :value | point x: value ].					mapping mapProperty: 'y' getter: [ :point | point y ] setter: [ :point :value | point y: value ]. ];				nextPut: object ] ].	self assert: (writer value: 1@2) equals: '{"x":1,"y":2}'.	self assert: (writer value: Point new) equals: '{}'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/6/2012 17:29'!testPoint2	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				mapAllInstVarsFor: Point;				nextPut: object ] ].	self assert: (writer value: 1@2) equals: '{"x":1,"y":2}'.	self assert: (writer value: Point new) equals: '{}'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/8/2012 14:04'!testPoint3	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: Point do: [ :mapping |					mapping mapInstVars: #(x y) ];				nextPut: object ] ].	self assert: (writer value: 1@2) equals: '{"x":1,"y":2}'.	self assert: (writer value: Point new) equals: '{}'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 3/24/2014 10:41'!testPointUsingAsString	| output |	output := String		streamContents: [ :out | 			(NeoJSONWriter on: out)				for: Point					do: [ :mapping | 							(mapping 								mapProperty: #x 								getter: [ :object | object x ] 								setter: [ :object :value | object setX: value setY: object y ])								valueSchema: #AsString.							(mapping								mapProperty: #y								getter: [ :object | object y ]								setter: [ :object :value | object setX: object x setY: value ]) 								valueSchema: #AsString ];				for: #AsString					customDo: [ :mapping | 							mapping								encoder: [ :x | x asString ];								decoder: [ :x | x asNumber ] ];				nextPut: 1 @ 2 ].	self assert: output equals: '{"x":"1","y":"2"}'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 5/28/2014 20:49'!testPointWriteNil	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				writeNil: true;				mapAllInstVarsFor: Point;				nextPut: object ] ].	self assert: (writer value: 1@2) equals: '{"x":1,"y":2}'.	self assert: (writer value: Point new) equals: '{"x":null,"y":null}'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 7/1/2016 23:50'!testPreservePropertyOrder	| writer testObject |	(testObject := NeoJSONTestObject2 new)		id: 123;		width: 100;		height: 50;		data: 'test'.	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: NeoJSONTestObject2 do: [ :mapping | mapping mapInstVars: #(id width height data) ];				nextPut: object ] ].	self assert: (writer value: testObject) equals: '{"id":123,"width":100,"height":50,"data":"test"}'.	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: NeoJSONTestObject2 do: [ :mapping | mapping mapInstVars: #(width height data id) ];				nextPut: object ] ].	self assert: (writer value: testObject) equals: '{"width":100,"height":50,"data":"test","id":123}'.	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: NeoJSONTestObject2 do: [ :mapping | mapping mapInstVars: #(data id height width) ];				nextPut: object ] ].	self assert: (writer value: testObject) equals: '{"data":"test","id":123,"height":50,"width":100}'.! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/10/2012 21:15'!testStrings	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: 'foo') equals: '"foo"'.	self assert: (writer value: 'Foo BAR') equals: '"Foo BAR"'.	self assert: (writer value: '') equals: '""'.	self		assert: (writer value: (String withAll: { 					$". $\. $/. Character tab. Character cr. Character lf.  Character newPage. Character backspace }))		equals: '"\"\\/\t\r\n\f\b"'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/8/2012 21:56'!testSymbol	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) nextPut: object ] ].	self assert: (writer value: #foo) equals: '"foo"'.	self assert: (writer value: #'FOO-1') equals: '"FOO-1"'! !!NeoJSONWriterTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/12/2012 12:02'!testTime	| writer |	writer := [ :object | 		String streamContents: [ :stream |			(NeoJSONWriter on: stream) 				for: Time customDo: [ :mapping |					mapping encoder: [ :time | time print24 ] ];				nextPut: object ] ].	self assert: (writer value: (Time hour: 14 minute: 30 second: 8)) equals: '"14:30:08"'! !!NeoJSONBenchmark methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 6/4/2012 18:49'!initialize	super initialize.	objects := Array new: 1000.	1 to: 1000 do: [ :each |		| map |		(map := Dictionary new)			at: 'id' put: each;			at: 'name' put: 'Name-', each asString;			at: 'enabled' put: (#( true false) at: (each \\ 2) + 1);			at: 'color' put: (#( 'red' 'green' 'blue' ) at: (each \\ 3) + 1);			at: 'value' put: each + each / 1000.0.		objects at: each put: map ].	json := String streamContents: [ :stream |		(NeoJSONWriter on: stream) nextPut: objects ]		! !!NeoJSONBenchmark methodsFor: 'public' stamp: 'SvenVanCaekenberghe 6/4/2012 17:02'!read	^ (NeoJSONReader on: json readStream) next! !!NeoJSONBenchmark methodsFor: 'public' stamp: 'SvenVanCaekenberghe 6/4/2012 17:26'!write	^ String streamContents: [ :stream |		(NeoJSONWriter on: stream) nextPut: objects ]! !!NeoJSONBenchmark methodsFor: 'public' stamp: 'SvenVanCaekenberghe 6/6/2012 15:07'!writePrettyPrintedRead	| output |	output := String streamContents: [ :stream |		(NeoJSONWriter on: stream) 			prettyPrint: true;			nextPut: objects ].	^ (NeoJSONReader on: output readStream) 		next! !!NeoJSONMockStream class methodsFor: 'instance creation' stamp: 'SvenVanCaekenberghe 6/13/2012 16:25'!on: stream	^ self new		stream: stream;		yourself! !!NeoJSONMockStream methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/13/2012 16:23'!atEnd	^ stream atEnd! !!NeoJSONMockStream methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/13/2012 16:23'!close	^ stream close! !!NeoJSONMockStream methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/13/2012 16:22'!next	^ stream next! !!NeoJSONMockStream methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/13/2012 16:23'!nextPut: character	^ stream nextPut: character! !!NeoJSONMockStream methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/13/2012 16:23'!nextPutAll: string	^ stream nextPutAll: string! !!NeoJSONMockStream methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/13/2012 16:22'!peek	^ stream peek! !!NeoJSONMockStream methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 12/3/2012 10:53'!peekFor: char	^ stream peekFor: char! !!NeoJSONMockStream methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/13/2012 16:23'!space	^ stream space! !!NeoJSONMockStream methodsFor: 'initialize-release' stamp: 'SvenVanCaekenberghe 6/13/2012 16:22'!stream: anObject	stream := anObject! !!NeoJSONTestObject1 class methodsFor: 'instance creation' stamp: 'SvenVanCaekenberghe 6/9/2012 18:06'!example1	^ self new		id: 123;		name: 'Example1';		timestamp: (DateAndTime year: 2012 month: 06 day: 08 hour: 14 minute: 30 second: 15 offset: 1 hour);		points: { 1@2. 3@4 };		bytes: #[ 2 4 6 8 ];		yourself! !!NeoJSONTestObject1 class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/12/2012 12:34'!neoJsonMapping: mapper	mapper for: self do: [ :mapping |		mapping mapInstVars: #(id name).		(mapping mapInstVar: #timestamp to: 'created-at') valueSchema: DateAndTime.		(mapping mapInstVar: #points) valueSchema: #ArrayOfPoints.		(mapping mapInstVar: #bytes) valueSchema: ByteArray ].	mapper for: DateAndTime customDo: [ :mapping |		mapping decoder: [ :string | DateAndTime fromString: string ].		mapping encoder: [ :dateAndTime | dateAndTime printString ] ].	mapper for: #ArrayOfPoints customDo: [ :mapping |		mapping listOfElementSchema: Point ].  	mapper mapAllInstVarsFor: Point.	mapper for: ByteArray customDo: [ :mapping |		mapping listOfType: ByteArray ]! !!NeoJSONTestObject1 methodsFor: 'comparing' stamp: 'SvenVanCaekenberghe 6/9/2012 18:45'!= anObject	self == anObject		ifTrue: [ ^ true ].	self class = anObject class		ifFalse: [ ^ false ].	^ id = anObject id		and: [			name = anObject name				and: [					timestamp = anObject timestamp						and: [							points = anObject points								and: [ bytes = anObject bytes ] ] ] ]! !!NeoJSONTestObject1 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/9/2012 18:03'!bytes	^ bytes! !!NeoJSONTestObject1 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/9/2012 18:04'!bytes: byteArray	bytes := byteArray! !!NeoJSONTestObject1 methodsFor: 'comparing' stamp: 'SvenVanCaekenberghe 6/9/2012 18:46'!hash	^ id hash bitXor: (name hash bitXor: (timestamp hash bitXor: (points hash bitXor: bytes hash)))! !!NeoJSONTestObject1 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/9/2012 18:02'!id	^ id! !!NeoJSONTestObject1 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/9/2012 18:03'!id: integer	id := integer! !!NeoJSONTestObject1 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/9/2012 18:02'!name	^ name! !!NeoJSONTestObject1 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/9/2012 18:03'!name: string	name := string! !!NeoJSONTestObject1 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/9/2012 18:03'!points	^ points! !!NeoJSONTestObject1 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/9/2012 18:04'!points: arrayOfPoints	points := arrayOfPoints ! !!NeoJSONTestObject1 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/9/2012 18:03'!timestamp	^ timestamp! !!NeoJSONTestObject1 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/9/2012 18:03'!timestamp: dateAndTime 	timestamp := dateAndTime ! !!NeoJSONTestObject2 class methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/10/2012 20:53'!benchmark10k	"self benchmark10k"		self benchmark: 10000! !!NeoJSONTestObject2 class methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/10/2012 20:54'!benchmark10kAsDictionary	"self benchmark10kAsDictionary"		self benchmarkAsDictionary: 10000! !!NeoJSONTestObject2 class methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/10/2012 20:54'!benchmark200k	"self benchmark200k"		self benchmark: 200000! !!NeoJSONTestObject2 class methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/10/2012 20:52'!benchmark: count	"self benchmark: 1000"		| collection json size |	collection := Array new: count withAll: self example1.	size := 2 + (count * (NeoJSONWriter toString: self example1) size) + count - 1.	Transcript 		cr;		<< ('Serializing {1} objects took ms ' format: { count });		show: [ json := String new: size streamContents: [ :stream |								(NeoJSONWriter on: stream) nextPut: collection ] ] timeToRun.	Transcript 		cr;		<< ('Deserializing {1} objects took ms ' format: { count });		show: [ NeoJSONReader fromString: json ] timeToRun.! !!NeoJSONTestObject2 class methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 6/10/2012 20:53'!benchmarkAsDictionary: count	"self benchmarkAsDictionary: 1000"		| collection json size |	collection := Array new: count withAll: self example1 asDictionary.	size := 2 + (count * (NeoJSONWriter toString: self example1 asDictionary) size) + count - 1.	Transcript 		cr;		<< ('Serializing {1} objects took ms ' format: { count });		show: [ json := String new: size streamContents: [ :stream |								(NeoJSONWriter on: stream) nextPut: collection ] ] timeToRun.	Transcript 		cr;		<< ('Deserializing {1} objects took ms ' format: { count });		show: [ NeoJSONReader fromString: json ] timeToRun.! !!NeoJSONTestObject2 class methodsFor: 'instance creation' stamp: 'SvenVanCaekenberghe 6/10/2012 20:04'!example1	^ self new		id: 13;		width: 250;		height: 110;		data: (String new: 512 withAll: $a);		yourself! !!NeoJSONTestObject2 class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 3/22/2014 10:50'!neoJsonMapping: mapper	"For inheritance mapping to work, the schema/classname must be self,	but the instance variables have to be enumerated manually per class"	mapper for: self do: [ :mapping |		mapping mapInstVars: #(id width height data) ] ! !!NeoJSONTestObject2 methodsFor: 'comparing' stamp: 'SvenVanCaekenberghe 6/10/2012 20:22'!= anObject	self == anObject		ifTrue: [ ^ true ].	self class = anObject class		ifFalse: [ ^ false ].	^ id = anObject id		and: [			height = anObject height				and: [					width = anObject width						and: [							data = anObject data ] ] ]! !!NeoJSONTestObject2 methodsFor: 'converting' stamp: 'SvenVanCaekenberghe 6/10/2012 20:47'!asDictionary	^ Dictionary new		at: #id put: id;		at: #height put: height;		at: #width put: width;		at: #data put: data;		yourself! !!NeoJSONTestObject2 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/10/2012 20:04'!data	^ data! !!NeoJSONTestObject2 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/10/2012 20:04'!data: anObject	data := anObject! !!NeoJSONTestObject2 methodsFor: 'comparing' stamp: 'SvenVanCaekenberghe 6/10/2012 20:22'!hash	^ id hash bitXor: (width hash bitXor: (height hash bitXor: data hash))! !!NeoJSONTestObject2 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/10/2012 20:04'!height	^ height! !!NeoJSONTestObject2 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/10/2012 20:04'!height: anObject	height := anObject! !!NeoJSONTestObject2 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/10/2012 20:04'!id	^ id! !!NeoJSONTestObject2 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/10/2012 20:04'!id: anObject	id := anObject! !!NeoJSONTestObject2 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/10/2012 20:04'!width	^ width! !!NeoJSONTestObject2 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 6/10/2012 20:04'!width: anObject	width := anObject! !!NeoJSONTestObject3 class methodsFor: 'instance creation' stamp: 'SvenVanCaekenberghe 3/22/2014 09:43'!example1	^ super example1		data: (String new: 8 withAll: $a);		color: 'red';		transparent: true;		yourself! !!NeoJSONTestObject3 class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 3/22/2014 10:50'!neoJsonMapping: mapper	"For inheritance mapping to work, the schema/classname must be self,	but the instance variables have to be enumerated manually per class"		super neoJsonMapping: mapper.	mapper for: self do: [ :mapping |		mapping mapInstVars: #(color transparent) ]! !!NeoJSONTestObject3 methodsFor: 'comparing' stamp: 'SvenVanCaekenberghe 3/22/2014 09:45'!= anObject	^ super = anObject 		and: [ color = anObject color			and: [ transparent = anObject transparent ] ]! !!NeoJSONTestObject3 methodsFor: 'converting' stamp: 'SvenVanCaekenberghe 3/22/2014 09:46'!asDictionary	^ super asDictionary		at: #color put: color;		at: #transparent put: transparent;		yourself! !!NeoJSONTestObject3 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 3/22/2014 09:43'!color	^ color! !!NeoJSONTestObject3 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 3/22/2014 09:43'!color: anObject	color := anObject! !!NeoJSONTestObject3 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 3/22/2014 09:43'!transparent	^ transparent! !!NeoJSONTestObject3 methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 3/22/2014 09:43'!transparent: anObject	transparent := anObject! !"Neo-JSON-Tests"!!WBMacWebBrowser commentStamp: 'TorstenBergmann 4/13/2016 08:24' prior: 0!Access to the web browser on Mac!!WBUnixWebBrowser commentStamp: 'TorstenBergmann 4/13/2016 08:24' prior: 0!Access to the web browser on Unix!!WBWindowsWebBrowser commentStamp: 'TorstenBergmann 4/13/2016 08:24' prior: 0!Access to the web browser on Windows!!WebBrowser commentStamp: 'TorstenBergmann 4/13/2016 08:25' prior: 0!General access to a webbrowser!!WBMacWebBrowser class methodsFor: 'examples' stamp: 'TorstenBergmann 4/13/2016 08:35'!example	self openOn: 'http://www.pharo.org'! !!WBMacWebBrowser class methodsFor: 'instance creation' stamp: 'TorstenBergmann 4/13/2016 08:36'!openOn: anURLString	"	self openOn: 'http://www.pharo.org'	"	| openCommand |	openCommand := 'open "{1}"' format: { anURLString }.	self system: openCommand.! !!WBMacWebBrowser class methodsFor: 'private - uffi' stamp: 'TorstenBergmann 4/13/2016 09:46'!system: command	^ self ffiCall: #(#int #system #(#char #* #command)) module: LibC! !!WBUnixWebBrowser class methodsFor: 'examples' stamp: 'TorstenBergmann 4/13/2016 08:31'!example	self openOn: 'http://www.pharo.org'! !!WBUnixWebBrowser class methodsFor: 'instance creation' stamp: 'TorstenBergmann 4/13/2016 08:36'!openOn: anURLString	"	self openOn: 'http://www.pharo.org'	"	| openCommand |	openCommand := 'xdg-open {1} &' format: { anURLString }.	self system: openCommand.! !!WBUnixWebBrowser class methodsFor: 'private - uffi' stamp: 'TorstenBergmann 4/13/2016 09:45'!system: command	^ self ffiCall: #(#int #system #(#char #* #command)) module: LibC! !!WBWindowsWebBrowser class methodsFor: 'examples' stamp: 'TorstenBergmann 4/13/2016 08:28'!example	self openOn: 'http://www.pharo.org'! !!WBWindowsWebBrowser class methodsFor: 'instance creation' stamp: 'TorstenBergmann 4/13/2016 08:36'!openOn: anURLString	"	self openOn: 'http://www.pharo.org'	"	^self shellExecute: 'open' file: anURLString parameters: '' directory: '' show: 5 "SW_SHOW"! !!WBWindowsWebBrowser class methodsFor: 'private - uffi' stamp: 'TorstenBergmann 4/13/2016 09:45'!shellExecute: lpOperation file: lpFile parameters: lpParameters directory: lpDirectory show: nShowCmd			^self ffiCall: #( 			FFIConstantHandle ShellExecuteA(     				0,     				String* lpOperation,         			String* lpFile,     				String* lpParameters,     				String* lpDirectory,        			int nShowCmd)) module: #shell32! !!WebBrowser class methodsFor: 'example' stamp: 'TorstenBergmann 4/13/2016 08:41'!example	self openOn: 'http://www.pharo.org'! !!WebBrowser class methodsFor: 'instance-creation' stamp: 'TorstenBergmann 4/13/2016 08:40'!openOn: aURLString	"Open the webbrowser on the given URL"		^self webbrowserClassForPlatform openOn: aURLString	! !!WebBrowser class methodsFor: 'private - accessing' stamp: 'TorstenBergmann 4/13/2016 08:39'!webbrowserClassForPlatform	Smalltalk os isUnix ifTrue: [ ^WBUnixWebBrowser ].	Smalltalk os isWindows ifTrue: [ ^WBWindowsWebBrowser ].	(Smalltalk os isMacOS or: [ Smalltalk os isMacOSX ])  		ifTrue: [ ^WBMacWebBrowser ].	self error: 'No web browser class for platform provided'! !"WebBrowser-Core"!!TeaNoSuchParam commentStamp: 'AttilaMagyar 11/16/2014 17:04' prior: 0!This exception indicates that the given parameter was not found in the TeaRequest.!!TeaAbort commentStamp: 'AttilaMagyar 8/9/2014 22:55' prior: 0!I'm an exception that immediately stops a request within a filter or route.!!IsObject commentStamp: 'AttilaMagyar 8/13/2014 22:09' prior: 0!I'm the base class of the type constraints. I match to any object. My subclasses can restict the type of placeholders.Example:Teapot on	GET: '/user/<id:IsInteger>' -> [:req | users findById: (req at: #id)];	start.This route matches to the '/users/12' but does not match to '/users/foobar'. In case of matching, the the path paramter "id" will be converted to an integer.You can extend the built in type constraints with your own constraints, by implementing the "placeholder type constraint" protocol. Then you can use the class name in the URL.!!IsInteger commentStamp: 'AttilaMagyar 8/3/2014 17:27' prior: 0!I'm a type constraint that matches to positive or negative integers.!!IsNumber commentStamp: 'AttilaMagyar 8/3/2014 17:27' prior: 0!I'm a type constraint that matches to positive or negative floats or integers.!!Send commentStamp: 'AttilaMagyar 8/2/2014 19:53' prior: 0!I can send messages to objects on a http requests. The selector of the message can take maximum 2 arguments ( TeaRequest and TeaResponse).Example:Teapot on	GET: '/hi' -> (Send message: #greet to: controller);	start.	!!TeaErrorHandler commentStamp: 'AttilaMagyar 8/24/2014 18:02' prior: 0!An error handler handles Exceptions signaled by the Routes or before actions.!!TeaFilter commentStamp: 'AttilaMagyar 9/27/2014 23:54' prior: 0!After and Before filters!!TeaAfterFilter commentStamp: 'AttilaMagyar 9/27/2014 23:58' prior: 0!An after filter is evaluated after each (matching) request. This filter has access to the response object generated by the matching route. The response can be modified from the filter, e.g. addition headers can be added.!!TeaBeforeFilter commentStamp: 'AttilaMagyar 9/27/2014 23:59' prior: 0!A before filter is evaluated before (matching) each request. This filter has access to the request object. For example, a before filter can be used to validate session attributes for authentication.!!TeaGlobUrlSegment commentStamp: 'AttilaMagyar 8/14/2014 21:23' prior: 0!My subclasses form the elements of TeaGlobUrlPatterns!!TeaLiteral commentStamp: 'AttilaMagyar 7/27/2014 12:28' prior: 0!A literal url pattern segment that matches to a string.!!TeaLiteralStop commentStamp: 'AttilaMagyar 8/10/2014 23:30' prior: 0!I'm a placeholder at the last position.!!TeaPlaceholder commentStamp: 'AttilaMagyar 7/27/2014 14:33' prior: 0!I'm a placeholder with a key. My content is substituted with a value.!!TeaPlaceholderStop commentStamp: 'AttilaMagyar 7/27/2014 14:34' prior: 0!I'm a placeholder at the last position.!!TeaWildcard commentStamp: 'AttilaMagyar 7/27/2014 12:29' prior: 0!A wildcard url pattern segment that matches to anything.!!TeaWildcardStop commentStamp: 'AttilaMagyar 7/27/2014 14:34' prior: 0!I'm a Wildcard at the last position.!!TeaMethodMatcher commentStamp: 'AttilaMagyar 8/12/2014 21:11' prior: 0!I can be matched against an HTTP method. I will return either true or false.!!TeaOutput commentStamp: 'AttilaMagyar 8/10/2014 23:18' prior: 0!I have various response transformer methods on my class side, that can be used as follows:Teapot on	GET: '/books' -> books; output: #json;	start.	Some of the transformers require optional dependencies, like Neo-JSON, STON, or Mustache.!!TeaPadding commentStamp: 'AttilaMagyar 7/27/2014 12:35' prior: 0!An url is padded by me, if its size is to short. I don't match to any literal URL, so it's like I'm not there.!!TeaRequest commentStamp: 'AttilaMagyar 7/30/2014 22:32' prior: 0!I extend the ZnRequest with addition methods for convenience.!!TeaRequestMatcher commentStamp: 'AttilaMagyar 9/27/2014 23:54' prior: 0!I can be matched against a ZnRequest. I check the http method and url of the request. !!TeaResponse commentStamp: 'AttilaMagyar 9/28/2014 20:26' prior: 0!A TeaResponse represents an HTTP response returned by a Route. The ZnResponse is generated from the TeaResponse by the given response transformer.!!TeaRoute commentStamp: 'AttilaMagyar 8/10/2014 23:24' prior: 0!A route handles http requests if it matches to the route. I have four major parts.- A handler that can be a block, a value or a message send.- An url pattern that can be matched against actual urls.- An http method that can be matched against the actual http method.- A response transformer for creating ZnResponse from the object returned by the handler.!!TeaRouter commentStamp: 'AttilaMagyar 8/2/2014 23:09' prior: 0!A zn delegate baseclass!!TeaCompositeRouter commentStamp: 'AttilaMagyar 8/10/2014 23:27' prior: 0!I'm a composite zn delegate, built from other zn delegates. I forward the request to the first delegate that returns other than 404 as response. Errors are handled with the help of the registered error handlers.!!TeaDynamicRouter commentStamp: 'AttilaMagyar 8/10/2014 23:26' prior: 0!I'm a ZnDelegate. I serve dynamically generated contents. The request is handled by the first route object, that returns other than 404 as response.!!TeaStaticRouter commentStamp: 'AttilaMagyar 8/2/2014 23:12' prior: 0!I'm a ZnDelegate based on ZnStaticFileServerDelegate. I serve static content from a file system directory.!!TeaUrlPattern commentStamp: 'AttilaMagyar 8/14/2014 21:26' prior: 0!An URL pattern can be matched agains actual urls. The pattern may collect named parameters from the URL in case of match.!!TeaGlobUrlPattern commentStamp: 'AttilaMagyar 8/14/2014 21:26' prior: 0!An UrlPattern is made from segments. I can be matched against an actual URL. '*' and <named-parameters> can be used inside the pattern.I can parse the pattern from a string by saying:	self parseString: '/foo/*/<id>/bar'Which will create a pattern that matches to an URL like this: 	/foo/xyz/12/bar!!TeaRxUrlPattern commentStamp: 'AttilaMagyar 8/14/2014 21:27' prior: 0!I'm an URL pattern that uses a regular expression internally. I collect subexpressions in case of matching.!!TeaUrlPatternSet commentStamp: 'AttilaMagyar 6/16/2015 18:31' prior: 0!I match to the given url if any of my elements match.E.g.Teapot on	GET: {'/a'. '/b'} -> 'ab';	start.		Both ZnEasy get: '/a' and ZnEasy get: '/b' returns 'ab'!!Teapot commentStamp: 'AttilaMagyar 6/8/2016 22:12' prior: 0!I'm the Teapot server on top of ZnServer. I can handle URL routing as follows:Teapot on      GET: '/hi' -> 'Hello World!!';      GET: '/a/*/b' -> (Send message: #ab: to: controller);      GET: '/users' -> [ users ]; output: #json	      GET: '/user/<id>' -> [ :req | (req at: #id) ]; output: #ston;      PUT: '/books/<id>' -> [ :req | | book |	  book := Book author: (req at: #author) title: (req at: #title).        books at: (req at: #id) put: book ]; 	  output: #ston;      start.For more configuration option see the Teapot class>>configure method.!!ZnResponse methodsFor: '*Teapot-Core' stamp: 'AttilaMagyar 9/28/2014 18:48'!teaTransform: aResponseTransformer request: aTeaRequest	^ self! !!RxMatcher methodsFor: '*Teapot-Core' stamp: 'AttilaMagyar 8/14/2014 22:32'!asTeaUrlPattern	^ TeaRxUrlPattern fromRxMatcher: self! !!String methodsFor: '*Teapot-Core' stamp: 'AttilaMagyar 8/14/2014 22:33'!asTeaUrlPattern	^ TeaGlobUrlPattern parseString: self! !!TeaNoSuchParam class methodsFor: 'signaling' stamp: 'AttilaNamed 2/28/2015 22:54'!signalWithParam: aSymbol	(self new setParam: aSymbol) signal: 'Param ', aSymbol printString, ' not found'! !!TeaNoSuchParam methodsFor: 'accessing' stamp: 'AttilaNamed 2/28/2015 22:43'!param	^ param! !!TeaNoSuchParam methodsFor: 'initialization' stamp: 'AttilaNamed 2/28/2015 22:42'!setParam: aSymbol	param := aSymbol.	^ self! !!TeaAbort class methodsFor: 'instance creation' stamp: 'AttilaMagyar 8/17/2014 19:14'!response: aZnResponse	^ self new setResponse: aZnResponse! !!TeaAbort methodsFor: 'converting' stamp: 'AttilaMagyar 10/13/2014 20:30'!response	^ response! !!TeaAbort methodsFor: 'initialization' stamp: 'AttilaMagyar 8/17/2014 19:14'!setResponse: aZnResponse	response := aZnResponse.	^ self! !!BlockClosure methodsFor: '*Teapot-Core' stamp: 'AttilaMagyar 9/28/2014 19:41'!teaEvalActionOnException: anException request: aTeaRequest	^ self cull: anException cull: aTeaRequest! !!BlockClosure methodsFor: '*Teapot-Core' stamp: 'AttilaMagyar 9/28/2014 19:41'!teaEvalActionOnRequest: aTeaRequest	^ self cull: aTeaRequest! !!BlockClosure methodsFor: '*Teapot-Core' stamp: 'AttilaMagyar 10/8/2014 19:48'!teaEvalActionOnRequest: aTeaRequest response: aZnResponse	^ self cull: aTeaRequest cull: aZnResponse! !!IsInteger class methodsFor: 'type constraint' stamp: 'AttilaMagyar 8/3/2014 17:23'!matchesTo: aString	^ '-?\d+' asRegex matches: aString! !!IsInteger class methodsFor: 'type constraint' stamp: 'AttilaMagyar 8/3/2014 17:55'!parseString: aString	^ aString asInteger! !!IsNumber class methodsFor: 'type constraint' stamp: 'AttilaMagyar 8/16/2014 14:23'!matchesTo: aString	Number readFrom: aString ifFail: [ ^false ].	^ true! !!IsNumber class methodsFor: 'type constraint' stamp: 'AttilaMagyar 8/3/2014 17:56'!parseString: aString	^ aString asNumber! !!IsObject class methodsFor: 'type constraint' stamp: 'AttilaMagyar 8/3/2014 17:09'!matchesTo: aString	^ true! !!IsObject class methodsFor: 'type constraint' stamp: 'AttilaMagyar 8/3/2014 17:07'!parseString: aString	^ aString! !!Object methodsFor: '*Teapot-Core' stamp: 'AttilaMagyar 9/28/2014 19:41'!teaEvalActionOnException: anException request: aTeaRequest	^ self! !!Object methodsFor: '*Teapot-Core' stamp: 'AttilaMagyar 9/28/2014 19:41'!teaEvalActionOnRequest: aTeaRequest	^ self! !!Object methodsFor: '*Teapot-Core' stamp: 'AttilaNamed 2/28/2015 23:27'!teaTransform: aResponseTransformer request: aTeaRequest	^ aResponseTransformer cull: (TeaResponse ok body: self) cull: aTeaRequest! !!Send class methodsFor: 'instance creation' stamp: 'AttilaMagyar 8/10/2014 21:16'!message: aSymbol to: anObject	^ self new 		setSelector: aSymbol 		receiver: anObject! !!Send methodsFor: 'printing' stamp: 'AttilaMagyar 8/16/2014 18:28'!printOn: aStream	aStream 		nextPutAll: '(Send message: ';		nextPutAll: selector printString;		nextPutAll: ' to: '.	receiver printOn: aStream.	aStream nextPut: $)! !!Send methodsFor: 'initialization' stamp: 'AttilaMagyar 8/10/2014 20:53'!setSelector: aSymbol receiver: anObject	selector := aSymbol.	receiver := anObject.	^ self	! !!Send methodsFor: 'tea action' stamp: 'AttilaMagyar 9/28/2014 19:41'!teaEvalActionOnException: anException request: aTeaRequest	^ receiver 		perform: selector 		withEnoughArguments: { anException. aTeaRequest }	! !!Send methodsFor: 'tea action' stamp: 'AttilaMagyar 9/28/2014 19:41'!teaEvalActionOnRequest: aTeaRequest	^ receiver 		perform: selector 		withEnoughArguments: { aTeaRequest }	! !!Send methodsFor: 'tea action' stamp: 'AttilaMagyar 10/8/2014 19:48'!teaEvalActionOnRequest: aTeaRequest response: aZnResponse	^ receiver 		perform: selector 		withEnoughArguments: { aTeaRequest. aZnResponse }	! !!TeaErrorHandler class methodsFor: 'instance creation' stamp: 'AttilaMagyar 8/24/2014 16:35'!for: anExceptionSet action: aTeaAction responseTransformer: aResponseTransformer	^ self new 		setExceptions: anExceptionSet 		action: aTeaAction 		responseTransformer: aResponseTransformer! !!TeaErrorHandler methodsFor: 'error handler' stamp: 'AttilaMagyar 8/24/2014 17:56'!canHandleError: anException	^ exceptions handles: anException! !!TeaErrorHandler methodsFor: 'error handler' stamp: 'AttilaMagyar 9/28/2014 19:41'!handleError: anException request: aTeaRequest	| result |	^ (self canHandleError: anException)		ifTrue:			[ result := action teaEvalActionOnException: anException request: aTeaRequest.			result teaTransform: responseTransformer request: aTeaRequest ]		ifFalse: 			[ self error: 'Cannot handle ', anException printString ]! !!TeaErrorHandler methodsFor: 'error handler' stamp: 'AttilaMagyar 8/24/2014 17:00'!responseTransformer: aResponseTransformer 	responseTransformer := aResponseTransformer! !!TeaErrorHandler methodsFor: 'initialization' stamp: 'AttilaMagyar 8/24/2014 18:00'!setExceptions: anExceptionSet action: aTeaAction responseTransformer: aResponseTransformer	exceptions := anExceptionSet.	action := aTeaAction.	responseTransformer := aResponseTransformer.	^ self! !!TeaAfterFilter methodsFor: 'response handling' stamp: 'AttilaMagyar 10/8/2014 19:55'!handleRequest: aZnRequest response: aZnResponse	requestMatcher 		matchRequest: aZnRequest 		ifMatch: [ :aTeaRequest | action teaEvalActionOnRequest: aTeaRequest response: aZnResponse ]		ifNoMatch: [ ]! !!TeaBeforeFilter methodsFor: 'request handling' stamp: 'AttilaMagyar 10/8/2014 19:53'!handleRequest: aZnRequest	requestMatcher 		matchRequest: aZnRequest 		ifMatch: [ :aTeaRequest | action teaEvalActionOnRequest: aTeaRequest ]		ifNoMatch: [ ]! !!TeaFilter class methodsFor: 'instance creation' stamp: 'AttilaMagyar 9/27/2014 22:29'!urlPattern: anUrlPattern action: aTeaAction	^ self new 		setMatcher: (TeaRequestMatcher method: TeaMethodMatcher any url: anUrlPattern)		action: aTeaAction! !!TeaFilter methodsFor: 'initialization' stamp: 'AttilaMagyar 9/27/2014 22:33'!setMatcher: aTeaRequestMatcher action: aTeaAction	requestMatcher := aTeaRequestMatcher.	action := aTeaAction.	^ self! !!TeaFilter methodsFor: 'acccessing' stamp: 'AttilaMagyar 5/8/2015 19:01'!whenClause: aBlockClosure 	requestMatcher whenClause: aBlockClosure ! !!TeaGlobUrlSegment methodsFor: 'url pattern segment' stamp: 'AttilaMagyar 7/27/2014 15:09'!matches: urlSegments rest: adjacentPatterns placeholders: aDictionary	self subclassResponsibility! !!TeaLiteral class methodsFor: 'instance creation' stamp: 'AttilaMagyar 7/30/2014 22:00'!fromString: aString atLast: aBoolean	| class |	class := aBoolean ifTrue: [ TeaLiteralStop ] ifFalse: [ TeaLiteral ].	^ class new setLiteral: aString! !!TeaLiteral methodsFor: 'url pattern segment' stamp: 'AttilaMagyar 8/3/2014 18:22'!matches: urlSegments rest: adjacentPatterns placeholders: aDictionary	^ literal = urlSegments first and: 		[ adjacentPatterns first 			matches: urlSegments allButFirst 			rest: adjacentPatterns allButFirst 			placeholders: aDictionary ]! !!TeaLiteral methodsFor: 'printing' stamp: 'AttilaMagyar 7/30/2014 22:20'!printOn: aStream	aStream nextPutAll: literal.	! !!TeaLiteral methodsFor: 'initialization' stamp: 'AttilaMagyar 7/27/2014 16:30'!setLiteral: aString	literal := aString.	^ self! !!TeaLiteralStop methodsFor: 'url pattern segment' stamp: 'AttilaMagyar 8/3/2014 18:11'!matches: urlSegments rest: adjacentPatterns placeholders: aDictionary	^ urlSegments size = 1 and: [ literal = urlSegments first ]! !!TeaPlaceholder class methodsFor: 'private' stamp: 'AttilaMagyar 8/3/2014 17:33'!createPlaceholderName: key typeConstraint: aTypeConstraint atLast: aBoolean	| class |	class := aBoolean		ifTrue: [ TeaPlaceholderStop ]		ifFalse: [ TeaPlaceholder ].	^ class new 		setPlaceholderName: key 		typeConstraint: aTypeConstraint! !!TeaPlaceholder class methodsFor: 'instance creation' stamp: 'AttilaMagyar 8/3/2014 17:31'!fromString: aString atLast: aBoolean	| spec typeConstraint key |	self mustBeValidPlaceholder: aString.	spec := aString allButFirst allButLast findTokens: ':'.	key := spec first.	typeConstraint := spec at: 2 ifAbsent: #IsObject.	^ self 		createPlaceholderName: key 		typeConstraint: (Smalltalk at: typeConstraint asSymbol)		atLast: aBoolean! !!TeaPlaceholder class methodsFor: 'private' stamp: 'AttilaMagyar 7/28/2014 22:28'!mustBeValidPlaceholder: aString	((aString beginsWith: '<') and: [ aString endsWith: '>' ])		ifFalse: [ self error: 'Invalid placeholder name: ', aString ]! !!TeaPlaceholder methodsFor: 'url pattern segment' stamp: 'AttilaMagyar 8/3/2014 17:58'!matches: urlSegments rest: adjacentPatterns placeholders: aDictionary	(typeConstraint matchesTo: urlSegments first) 		ifFalse: [ ^ false ].				aDictionary 		at: placeholderName 		put: (typeConstraint parseString: urlSegments first).					^ adjacentPatterns first 		matches: urlSegments allButFirst 		rest: adjacentPatterns allButFirst 		placeholders: aDictionary! !!TeaPlaceholder methodsFor: 'printing' stamp: 'AttilaMagyar 7/28/2014 22:28'!printOn: aStream	aStream 		nextPut: $<;		nextPutAll: placeholderName;		nextPut: $>! !!TeaPlaceholder methodsFor: 'initialization' stamp: 'AttilaMagyar 8/3/2014 17:32'!setPlaceholderName: aString typeConstraint: aTypeConstraint	placeholderName := aString asSymbol.	typeConstraint := aTypeConstraint.	^ self! !!TeaPlaceholderStop methodsFor: 'url pattern segment' stamp: 'AttilaMagyar 8/3/2014 18:00'!matches: urlSegments rest: adjacentPatterns placeholders: aDictionary	| match |	match := urlSegments size = 1 		and: [ urlSegments first ~= TeaPadding 		and: [ (typeConstraint matchesTo: urlSegments first) ] ].	match ifTrue:		 [ aDictionary			at: placeholderName 			put: (typeConstraint parseString: urlSegments first) ].	^ match! !!TeaWildcard class methodsFor: 'instance creation' stamp: 'AttilaMagyar 7/30/2014 22:00'!atLast: aBoolean	^ aBoolean		ifTrue: [ TeaWildcardStop new ]		ifFalse: [ TeaWildcard new ]! !!TeaWildcard methodsFor: 'url pattern segment' stamp: 'AttilaMagyar 7/27/2014 15:10'!matches: urlSegments rest: adjacentPatterns placeholders: aDictionary	^ adjacentPatterns first 		matches: urlSegments allButFirst 		rest: adjacentPatterns allButFirst 		placeholders: aDictionary! !!TeaWildcard methodsFor: 'printing' stamp: 'AttilaMagyar 7/27/2014 12:54'!printOn: aStream	aStream nextPut: $*! !!TeaWildcardStop methodsFor: 'url pattern segment' stamp: 'AttilaMagyar 7/27/2014 15:10'!matches: urlSegments rest: adjacentPatterns placeholders: aDictionary	^ true! !!TeaMethodMatcher class methodsFor: 'instance creation' stamp: 'AttilaMagyar 8/16/2014 18:12'!any	^ self new 		setMatcherBlock: [ :anyMethod | true ] 		name: 'ANY'! !!TeaMethodMatcher class methodsFor: 'instance creation' stamp: 'AttilaMagyar 8/16/2014 18:12'!exactly: aSymbol	^ self new 		setMatcherBlock: [ :actual | actual = aSymbol ] 		name: aSymbol asString! !!TeaMethodMatcher methodsFor: 'http method matcher' stamp: 'AttilaMagyar 8/12/2014 20:58'!matchesHttpMethod: aSymbol	^ matcherBlock value: aSymbol	! !!TeaMethodMatcher methodsFor: 'printing' stamp: 'AttilaMagyar 8/16/2014 18:15'!printOn: aStream	aStream 		nextPutAll: name;		nextPut: $:! !!TeaMethodMatcher methodsFor: 'initialization' stamp: 'AttilaMagyar 8/16/2014 18:11'!setMatcherBlock: aBlockClosure name: aString	matcherBlock := aBlockClosure.	name := aString.	^ self! !!TeaOutput class methodsFor: 'response transformers' stamp: 'AttilaMagyar 8/16/2014 13:52'!html	^ self stringWithContentType: ZnMimeType textHtml! !!TeaOutput class methodsFor: 'response transformers' stamp: 'AttilaMagyar 5/9/2015 17:00'!json	^ [ :aTeaResponse | | entity |		entity := ZnStringEntity 			with: ((self optionalClass: #NeoJSONWriter) toString: aTeaResponse body) 			type: (ZnMimeType applicationJson charSet: aTeaResponse charSet; yourself).		self 			znEntity: entity			code: aTeaResponse code 			headers: aTeaResponse headers ]! !!TeaOutput class methodsFor: 'response transformers' stamp: 'AttilaMagyar 9/28/2014 19:20'!mustache: templateStringOrStream contentType: contentType	^ [ :aTeaResponse | | model object entity |		object := aTeaResponse body.		model := (object respondsTo: #asDictionary) ifTrue: [ object asDictionary ] ifFalse: [ object ].				entity := (ZnStringEntity 			with: (((self optionalClass: #MustacheTemplate) on: templateStringOrStream) value: model) 			type: contentType).		self 			znEntity: entity			code: aTeaResponse code 			headers: aTeaResponse headers ]! !!TeaOutput class methodsFor: 'response transformers' stamp: 'AttilaMagyar 7/30/2014 22:09'!mustacheHtml: templateString 	^ self mustache: templateString contentType: ZnMimeType textHtml.! !!TeaOutput class methodsFor: 'private' stamp: 'AttilaMagyar 9/5/2014 15:40'!optionalClass: aSymbol	[ ^ Smalltalk at: aSymbol ]		on: KeyNotFound		do: [ self error: 'An optional dependency ', aSymbol, ' was not found. Please load it first.' ]! !!TeaOutput class methodsFor: 'response transformers' stamp: 'AttilaMagyar 5/9/2015 17:02'!ston	^ [ :aTeaResponse | | entity |		entity := ZnStringEntity 			with: ((self optionalClass: #STON) toString: aTeaResponse body) 			type: (ZnMimeType textPlain charSet: aTeaResponse charSet; yourself).		self 			znEntity: entity			code: aTeaResponse code 			headers: aTeaResponse headers ]! !!TeaOutput class methodsFor: 'response transformers' stamp: 'AttilaMagyar 8/8/2014 20:07'!stream	^ self stream: ZnMimeType applicationOctetStream ! !!TeaOutput class methodsFor: 'response transformers' stamp: 'AttilaMagyar 9/28/2014 19:20'!stream: aZnMimeType	^ [ :aTeaResponse | | entity |		entity := ZnStreamingEntity 			readFrom: aTeaResponse body			usingType: aZnMimeType			andLength: aTeaResponse body size.		self 			znEntity: entity			code: aTeaResponse code 			headers: aTeaResponse headers ]! !!TeaOutput class methodsFor: 'response transformers' stamp: 'AttilaMagyar 5/9/2015 17:18'!stringWithContentType: aZnMimeType 	^ [ :aTeaResponse | | entity |		entity := ZnStringEntity new			contentType: (aZnMimeType charSet: aTeaResponse charSet; yourself);			string: aTeaResponse body asString;			yourself.		self 			znEntity: entity 			code: aTeaResponse code 			headers: aTeaResponse headers ]! !!TeaOutput class methodsFor: 'response transformers' stamp: 'AttilaMagyar 8/16/2014 13:52'!text	^ self stringWithContentType: ZnMimeType textPlain! !!TeaOutput class methodsFor: 'private' stamp: 'AttilaNamed 2/28/2015 23:58'!znEntity: aZnEntity code: anInteger headers: aDictionary	| headers |	headers := ZnHeaders defaultResponseHeaders.	headers addAll: aDictionary.	^ ZnResponse new		statusLine: (ZnStatusLine code: anInteger);		headers: headers;		entity: aZnEntity;		yourself! !!TeaRequest class methodsFor: 'instance creation' stamp: 'AttilaMagyar 8/12/2014 21:41'!fromZnRequest: aZnRequest	^ self fromZnRequest: aZnRequest pathParams: Dictionary new! !!TeaRequest class methodsFor: 'instance creation' stamp: 'AttilaMagyar 8/12/2014 21:42'!fromZnRequest: aZnRequest pathParams: aDictionary	^ self new setZnRequest: aZnRequest pathParams: aDictionary! !!TeaRequest methodsFor: 'aborting' stamp: 'AttilaNamed 3/1/2015 20:01'!abort: response	(TeaAbort response: response) signal! !!TeaRequest methodsFor: 'acccessing - params' stamp: 'AttilaNamed 2/28/2015 22:40'!at: aSymbol	^ self 		at: aSymbol 		ifAbsent: [ TeaNoSuchParam signalWithParam: aSymbol ]! !!TeaRequest methodsFor: 'acccessing - params' stamp: 'AttilaMagyar 7/30/2014 16:51'!at: aSymbol ifAbsent: aBlock	"Gets the value of a path parameter, query parameter for form parameter.		E.g. /foo/<path-param>/bar		E.g. /foo?queryParam=value"	^ pathParams at: aSymbol ifAbsent: [ self queryOrFormParam: aSymbol ifAbsent: aBlock	"XXX do something better" ]! !!TeaRequest methodsFor: 'reflective operations' stamp: 'AttilaMagyar 7/28/2014 20:31'!doesNotUnderstand: aMessage	^ aMessage sendTo: znRequest! !!TeaRequest methodsFor: 'private' stamp: 'AttilaMagyar 7/30/2014 16:40'!formParam: aSymbol ifAbsent: aBlock	^ (znRequest entity isKindOf: ZnApplicationFormUrlEncodedEntity) "XXX do something better" 		ifTrue: [ znRequest entity at: aSymbol ifAbsent: aBlock ]		ifFalse: aBlock! !!TeaRequest methodsFor: 'private' stamp: 'AttilaMagyar 7/30/2014 16:40'!queryOrFormParam: aSymbol ifAbsent: aBlock	^ znRequest uri 		queryAt: aSymbol 		ifAbsent: [ self formParam: aSymbol ifAbsent: aBlock ]! !!TeaRequest methodsFor: 'initialization' stamp: 'AttilaMagyar 7/28/2014 21:04'!setZnRequest: aZnRequest pathParams: aDictionary	znRequest := aZnRequest.	pathParams := aDictionary.	^ self! !!TeaRequestMatcher class methodsFor: 'instance creation' stamp: 'AttilaMagyar 9/27/2014 22:25'!method: aMethodMatcher url: anUrlPattern	^ self new setPattern: anUrlPattern method: aMethodMatcher! !!TeaRequestMatcher methodsFor: 'request matcher' stamp: 'AttilaMagyar 9/27/2014 21:19'!matchRequest: aZnRequest ifMatch: matchBlock ifNoMatch: noMatchBlock	| matches placeholders |	placeholders := Dictionary new.	matches := self matchesRequest: aZnRequest placeholders: placeholders.	^ matches		ifTrue: [ matchBlock value: (TeaRequest fromZnRequest: aZnRequest pathParams: placeholders) ]		ifFalse: [ noMatchBlock value ]! !!TeaRequestMatcher methodsFor: 'private' stamp: 'AttilaMagyar 5/8/2015 19:25'!matchesRequest: aZnRequest placeholders: placeholders	| matchesPartially |	matchesPartially := (methodMatcher matchesHttpMethod: aZnRequest method)		and: [ urlPattern matchesUrl: aZnRequest url placeholders: placeholders ].		matchesPartially ifFalse: [ ^ false ].	^ whenClause cull: (TeaRequest fromZnRequest: aZnRequest pathParams: placeholders).! !!TeaRequestMatcher methodsFor: 'printing' stamp: 'AttilaMagyar 10/26/2015 21:54'!printOn: aStream	methodMatcher printOn: aStream.	aStream space.	urlPattern printOn: aStream.! !!TeaRequestMatcher methodsFor: 'initialization' stamp: 'AttilaMagyar 5/4/2015 22:17'!setPattern: anUrlPattern method: aMethodMatcher	urlPattern := anUrlPattern.	methodMatcher := aMethodMatcher.	whenClause := [ :anyRequest | true ].	^ self! !!TeaRequestMatcher methodsFor: 'accessing' stamp: 'AttilaMagyar 5/4/2015 21:49'!whenClause: aBlockClosure 	whenClause := aBlockClosure! !!TeaResponse class methodsFor: 'instance creation' stamp: 'AttilaNamed 2/28/2015 23:09'!badRequest	^ self code: ZnStatusLine badRequest code! !!TeaResponse class methodsFor: 'instance creation' stamp: 'AttilaNamed 2/28/2015 23:21'!code: anInteger	^ self new code: anInteger! !!TeaResponse class methodsFor: 'instance creation' stamp: 'AttilaNamed 2/28/2015 23:23'!created	^ self code: ZnStatusLine created code! !!TeaResponse class methodsFor: 'instance creation' stamp: 'AttilaNamed 2/28/2015 23:10'!methodNotAllowed	^ self code: ZnStatusLine methodNotAllowed code ! !!TeaResponse class methodsFor: 'instance creation' stamp: 'AttilaNamed 2/28/2015 23:11'!notFound	^ self code: ZnStatusLine notFound code ! !!TeaResponse class methodsFor: 'instance creation' stamp: 'AttilaNamed 2/28/2015 23:11'!notModified	^ self code: ZnStatusLine notModified code! !!TeaResponse class methodsFor: 'instance creation' stamp: 'AttilaNamed 2/28/2015 23:44'!ok	^ self code: ZnStatusLine ok code! !!TeaResponse class methodsFor: 'instance creation' stamp: 'AttilaNamed 2/28/2015 23:11'!redirect	^ self code: ZnStatusLine redirect code! !!TeaResponse class methodsFor: 'instance creation' stamp: 'AttilaNamed 2/28/2015 23:11'!serverError	^ self code: ZnStatusLine internalServerError code! !!TeaResponse class methodsFor: 'instance creation' stamp: 'AttilaNamed 2/28/2015 23:54'!unauthorized	^ self code: ZnStatusLine unauthorized code! !!TeaResponse methodsFor: 'accessing' stamp: 'AttilaMagyar 9/28/2014 18:51'!body	^ body! !!TeaResponse methodsFor: 'accessing' stamp: 'AttilaNamed 2/28/2015 23:21'!body: anObject	body := anObject.	^ self! !!TeaResponse methodsFor: 'accessing' stamp: 'AttilaMagyar 5/9/2015 16:53'!charSet	^ charSet! !!TeaResponse methodsFor: 'accessing' stamp: 'AttilaMagyar 5/9/2015 18:05'!charSet: aString	charSet := aString.	^ self! !!TeaResponse methodsFor: 'accessing' stamp: 'AttilaMagyar 9/28/2014 19:00'!code	^ code! !!TeaResponse methodsFor: 'accessing' stamp: 'AttilaNamed 2/28/2015 23:21'!code: anInteger	code := anInteger.	^ self! !!TeaResponse methodsFor: 'accessing' stamp: 'AttilaNamed 2/28/2015 23:29'!headerName: nameString value: valueString	headers at: nameString put: valueString.	^ self! !!TeaResponse methodsFor: 'accessing' stamp: 'AttilaMagyar 9/28/2014 19:11'!headers	^ headers! !!TeaResponse methodsFor: 'accessing' stamp: 'AttilaNamed 2/28/2015 23:30'!headers: aDictionary	headers := aDictionary asDictionary.	^ self! !!TeaResponse methodsFor: 'initialization' stamp: 'AttilaMagyar 5/9/2015 16:54'!initialize	super initialize.	headers := Dictionary new.	body := String crlf.	code := ZnStatusLine ok code.	charSet := 'utf-8'.! !!TeaResponse methodsFor: 'accessing' stamp: 'AttilaNamed 2/28/2015 23:41'!location: url	self headerName: 'Location' value: url asString.	^ self! !!TeaResponse methodsFor: 'response transforming' stamp: 'AttilaMagyar 9/28/2014 18:49'!teaTransform: aResponseTransformer request: aTeaRequest	^ aResponseTransformer cull: self cull: aTeaRequest! !!TeaRoute class methodsFor: 'instance creation' stamp: 'AttilaMagyar 11/8/2015 18:31'!matcher: aTeaRequestMatcher action: aTeaAction transformer: aResponseTransformer port: portNumber	^ self new 		setMatcher: aTeaRequestMatcher		action: aTeaAction		transformer: aResponseTransformer		port: portNumber "XXX only used by teapsoon inspector"! !!TeaRoute methodsFor: 'request handling' stamp: 'AttilaMagyar 9/28/2014 19:41'!handleRequest: aZnRequest	^ requestMatcher 		matchRequest: aZnRequest 		ifMatch: 			[ :aTeaRequest | | result |			result := action teaEvalActionOnRequest: aTeaRequest.			result teaTransform: responseTransformer request: aTeaRequest ]		ifNoMatch: 			[ ZnResponse notFound: aZnRequest uri ]! !!TeaRoute methodsFor: 'printing' stamp: 'AttilaMagyar 10/26/2015 21:52'!printOn: aStream	requestMatcher printOn: aStream.	aStream nextPutAll: ' -> '.	action printOn: aStream.! !!TeaRoute methodsFor: 'accessing' stamp: 'AttilaMagyar 7/31/2014 21:18'!responseTransformer: aBlock	responseTransformer := aBlock! !!TeaRoute methodsFor: 'initialization' stamp: 'AttilaMagyar 11/8/2015 18:32'!setMatcher: aTeaRequestMatcher action: aTeaAction transformer: aResponseTransformer port: portNumber	requestMatcher := aTeaRequestMatcher.	action := aTeaAction.	responseTransformer := aResponseTransformer.	port := portNumber.	^ self! !!TeaRoute methodsFor: 'acccessing' stamp: 'AttilaMagyar 5/8/2015 18:55'!whenClause: aBlockClosure 	requestMatcher whenClause: aBlockClosure! !!TeaCompositeRouter class methodsFor: 'instance creation' stamp: 'AttilaMagyar 8/3/2014 11:25'!routers: teaRouterCollection	^ self new setRouters: teaRouterCollection! !!TeaCompositeRouter methodsFor: 'filters' stamp: 'AttilaMagyar 5/8/2015 19:00'!addAfterFilter: aTeaFilter	^ afterFilters add: aTeaFilter! !!TeaCompositeRouter methodsFor: 'filters' stamp: 'AttilaMagyar 5/8/2015 19:00'!addBeforeFilter: aTeaFilter	^ beforeFilters add: aTeaFilter! !!TeaCompositeRouter methodsFor: 'error handing' stamp: 'AttilaMagyar 8/24/2014 17:10'!addErrorHandler: aTeaErrorHandler	^ errorhandlers add: aTeaErrorHandler! !!TeaCompositeRouter methodsFor: 'private' stamp: 'AttilaMagyar 9/27/2014 21:40'!evaluateAfterFilters: aZnRequest response: aZnResponse	afterFilters do: [ :each | each handleRequest: aZnRequest response: aZnResponse ]! !!TeaCompositeRouter methodsFor: 'private' stamp: 'AttilaMagyar 9/27/2014 19:54'!evaluateBeforeFilters: aZnRequest	beforeFilters do: [ :each | each handleRequest: aZnRequest ]! !!TeaCompositeRouter methodsFor: 'private' stamp: 'AttilaMagyar 9/27/2014 22:43'!evaluateRouters: aZnRequest	routers do: [ :each | | response |		response := each handleRequest: aZnRequest.		response isNotFound ifFalse: [ ^ response ] ].	^ ZnResponse notFound: aZnRequest uri! !!TeaCompositeRouter methodsFor: 'private' stamp: 'AttilaMagyar 9/22/2014 21:44'!exceptionOccurred: anException request: aZnRequest	| handler |	handler := errorhandlers 		detect: [ :each | each canHandleError: anException ]		ifNone: [ anException pass ].			^ handler handleError: anException request: (TeaRequest fromZnRequest: aZnRequest).	! !!TeaCompositeRouter methodsFor: 'zn delegate' stamp: 'AttilaMagyar 9/27/2014 22:21'!handleRequest: aZnRequest	| response |	^ [ self evaluateBeforeFilters: aZnRequest.	     response := self evaluateRouters: aZnRequest.	     self evaluateAfterFilters: aZnRequest response: response.	     response		   ] on: Exception 	     do: [ :ex | self exceptionOccurred: ex request: aZnRequest ]! !!TeaCompositeRouter methodsFor: 'initialization' stamp: 'AttilaMagyar 9/27/2014 19:50'!initialize	super initialize.	errorhandlers := OrderedCollection new.	beforeFilters := OrderedCollection new.	afterFilters := OrderedCollection new.! !!TeaCompositeRouter methodsFor: 'initialization' stamp: 'AttilaMagyar 8/3/2014 11:28'!setRouters: teaRouterCollection	routers := teaRouterCollection asArray.	^ self! !!TeaDynamicRouter methodsFor: 'route dispatcher' stamp: 'AttilaMagyar 7/31/2014 23:15'!addRoute: aRoute	^ routes add: aRoute.	! !!TeaDynamicRouter methodsFor: 'zn delegate' stamp: 'AttilaMagyar 8/16/2014 18:58'!handleRequest: aZnRequest	routes do: [ :each | | aZnResponse |		aZnResponse := each handleRequest: aZnRequest.		aZnResponse isNotFound ifFalse: [ ^ aZnResponse ] ].		^ ZnResponse notFound: aZnRequest uri! !!TeaDynamicRouter methodsFor: 'initialization' stamp: 'AttilaMagyar 7/31/2014 23:12'!initialize	super initialize.	routes := OrderedCollection new.! !!TeaDynamicRouter methodsFor: 'accessing' stamp: 'TorstenBergmann 10/12/2015 13:58'!routes	^routes! !!TeaRouter methodsFor: 'zn delegate' stamp: 'AttilaMagyar 8/2/2014 23:09'!handleRequest: aZnRequest	self subclassResponsibility ! !!TeaStaticRouter methodsFor: 'zn delegate' stamp: 'AttilaMagyar 8/2/2014 23:06'!handleRequest: aZnRequest	^ delegate 		ifNil: [ ZnResponse notFound: aZnRequest uri  ] 		ifNotNil: [ delegate handleRequest: aZnRequest ]! !!TeaStaticRouter methodsFor: 'acccessing' stamp: 'AttilaMagyar 8/2/2014 23:06'!urlPrefix: urlPrefixString path: pathString	delegate ifNil: [ delegate := ZnStaticFileServerDelegate new ].	delegate		prefixFromString: urlPrefixString;		directory: pathString asFileReference.! !!TeaGlobUrlPattern class methodsFor: 'private' stamp: 'AttilaMagyar 8/16/2014 18:36'!createSegment: aString atLast: aBoolean	aString = '*' 		ifTrue: [ ^ TeaWildcard atLast: aBoolean ].	(aString beginsWith: '<')		ifTrue: [ ^ TeaPlaceholder fromString: aString atLast: aBoolean ].	^ TeaLiteral fromString: aString atLast: aBoolean! !!TeaGlobUrlPattern class methodsFor: 'private' stamp: 'AttilaMagyar 8/16/2014 18:37'!parseSegments: aString	| tokens |	tokens := aString findTokens: '/'.	^ tokens collectWithIndex: [ :each :idx | 		self createSegment: each atLast: idx = tokens size ]! !!TeaGlobUrlPattern class methodsFor: 'instance creation' stamp: 'AttilaMagyar 7/26/2014 23:04'!parseString: aString	^ self new setSegments: (self parseSegments: aString)! !!TeaGlobUrlPattern methodsFor: 'url matcher' stamp: 'AttilaMagyar 7/30/2014 22:01'!matchesUrl: anUrl placeholders: aDictionary	| urlSegments |	urlSegments := self padUrlSegments: anUrl with: TeaPadding size: segments size.	segments isEmpty		ifTrue: [ ^ urlSegments isEmpty ].	^ segments first 		matches: urlSegments 		rest: segments allButFirst 		placeholders: aDictionary! !!TeaGlobUrlPattern methodsFor: 'private' stamp: 'AttilaMagyar 8/3/2014 18:36'!padUrlSegments: anUrl with: padding size: anInteger	| urlSegments |	urlSegments := anUrl segments isEmptyOrNil 		ifTrue: [ OrderedCollection new ]		ifFalse: [ self trimTrailingSlash: anUrl segments ].	urlSegments size < segments size		ifTrue: [ urlSegments := urlSegments forceTo: anInteger paddingWith: padding ].	^ urlSegments! !!TeaGlobUrlPattern methodsFor: 'printing' stamp: 'AttilaMagyar 10/26/2015 21:55'!printOn: aStream	aStream nextPut: $'.	segments 		do: [ :each | each printOn: aStream ]		separatedBy: [ aStream nextPut: $/ ].	aStream nextPut: $'.! !!TeaGlobUrlPattern methodsFor: 'initialization' stamp: 'AttilaMagyar 7/26/2014 23:23'!setSegments: anArray	segments := anArray.	^ self! !!TeaGlobUrlPattern methodsFor: 'private' stamp: 'AttilaMagyar 8/3/2014 18:29'!trimTrailingSlash: urlSegments 	^ (urlSegments isNotEmpty and: [ urlSegments last = '/' ])		ifTrue: [ urlSegments allButLast ]		ifFalse: [ urlSegments ]! !!TeaRxUrlPattern class methodsFor: 'instance creation' stamp: 'AttilaMagyar 8/14/2014 22:27'!fromRxMatcher: aRxMatcher 	^ self new initializeRxMatcher: aRxMatcher ! !!TeaRxUrlPattern methodsFor: 'private' stamp: 'AttilaMagyar 8/16/2014 19:21'!hasMatched: aZnUrl	"XXX RxMatcher has state. Consider something better"	^ lock critical: [ (regexp matches: aZnUrl path) or: [ regexp matches: '/', aZnUrl path ] ]! !!TeaRxUrlPattern methodsFor: 'initialization' stamp: 'AttilaMagyar 8/14/2014 22:27'!initializeRxMatcher: aRxMatcher 	regexp := aRxMatcher.	lock := Mutex new.	^ self! !!TeaRxUrlPattern methodsFor: 'url matcher' stamp: 'AttilaMagyar 8/14/2014 22:28'!matchesUrl: aZnUrl placeholders: aDictionary 	| match |	match := self hasMatched: aZnUrl.	match ifTrue:		[ 2 to: regexp subexpressionCount do: [ :i | 			aDictionary at: i - 1put: (regexp subexpression: i) ] ].	^ match! !!TeaRxUrlPattern methodsFor: 'printing' stamp: 'AttilaMagyar 10/26/2015 22:01'!printOn: aStream	aStream nextPutAll: '<regexp>'.! !!TeaUrlPattern methodsFor: 'url matcher' stamp: 'AttilaMagyar 8/14/2014 21:21'!matchesUrl: anUrl placeholders: aDictionary	self subclassResponsibility ! !!TeaUrlPatternSet class methodsFor: 'instance creation' stamp: 'AttilaMagyar 6/16/2015 18:27'!fromCollection: aCollection 	^ self new setPatterns: (aCollection collect: #asTeaUrlPattern)! !!TeaUrlPatternSet methodsFor: 'url matcher' stamp: 'AttilaMagyar 6/16/2015 18:45'!matchesUrl: anUrl placeholders: aDictionary	^ patterns anySatisfy: [ :each | each matchesUrl: anUrl placeholders: aDictionary ]! !!TeaUrlPatternSet methodsFor: 'printing' stamp: 'AttilaMagyar 6/16/2015 18:53'!printOn: aStream	aStream nextPut: ${.	patterns 		do: [ :each | each printOn: aStream ]		separatedBy: [ aStream nextPut: $. ].	aStream nextPut: $}.! !!TeaUrlPatternSet methodsFor: 'initialization' stamp: 'AttilaMagyar 6/16/2015 18:27'!setPatterns: aCollection 	patterns := aCollection.	^ self! !!Teapot class methodsFor: 'instance creation' stamp: 'AttilaMagyar 6/8/2016 22:24'!configure: optionsAssociations	"Create a new Teapot instance with optional properties. 	 - Teapot properties: #defaultOutput	 - ZnServer properties: See options protocol of ZnServer for specific usages.		Example: Teapot configure: { 		#defaultOutput -> #json. 		#bindAddress -> #[192 168 0 3].		#port -> 8080. 		#debugMode -> true 	}."		^ self new initializeOptions: optionsAssociations! !!Teapot class methodsFor: 'instance creation' stamp: 'AttilaMagyar 8/13/2014 21:09'!on	"Create Teapot with default properties."		^ self configure: { }! !!Teapot class methodsFor: 'controlling' stamp: 'AttilaMagyar 8/9/2014 17:11'!stopAll	self allInstancesDo: #stop! !!Teapot methodsFor: 'url mapping' stamp: 'AttilaMagyar 4/17/2015 23:48'!CONNECT: patternActionAssoc	self		addRouteMethod: (TeaMethodMatcher exactly: #CONNECT)		pattern: patternActionAssoc key		action: patternActionAssoc value! !!Teapot methodsFor: 'url mapping' stamp: 'AttilaMagyar 4/17/2015 23:48'!DELETE: patternActionAssoc	self		addRouteMethod: (TeaMethodMatcher exactly: #DELETE)		pattern: patternActionAssoc key		action: patternActionAssoc value! !!Teapot methodsFor: 'url mapping' stamp: 'AttilaMagyar 4/18/2015 00:09'!GET: patternActionAssoc	self 		addRouteMethod: (TeaMethodMatcher exactly: #GET) 		pattern: patternActionAssoc key 		action: patternActionAssoc value! !!Teapot methodsFor: 'url mapping' stamp: 'AttilaMagyar 4/17/2015 23:48'!HEAD: patternActionAssoc	self 		addRouteMethod: (TeaMethodMatcher exactly: #HEAD) 		pattern: patternActionAssoc key 		action: patternActionAssoc value! !!Teapot methodsFor: 'url mapping' stamp: 'AttilaMagyar 4/17/2015 23:48'!OPTIONS: patternActionAssoc	self		addRouteMethod: (TeaMethodMatcher exactly: #OPTIONS)		pattern: patternActionAssoc key		action: patternActionAssoc value! !!Teapot methodsFor: 'url mapping' stamp: 'AttilaMagyar 4/17/2015 23:48'!PATCH: patternActionAssoc	self		addRouteMethod: (TeaMethodMatcher exactly: #PATCH)		pattern: patternActionAssoc key		action: patternActionAssoc value! !!Teapot methodsFor: 'url mapping' stamp: 'AttilaMagyar 4/17/2015 23:48'!POST: patternActionAssoc	self 		addRouteMethod: (TeaMethodMatcher exactly: #POST) 		pattern: patternActionAssoc key 		action: patternActionAssoc value! !!Teapot methodsFor: 'url mapping' stamp: 'AttilaMagyar 4/17/2015 23:48'!PUT: patternActionAssoc	self 		addRouteMethod: (TeaMethodMatcher exactly: #PUT) 		pattern: patternActionAssoc key 		action: patternActionAssoc value! !!Teapot methodsFor: 'url mapping' stamp: 'AttilaMagyar 4/17/2015 23:48'!TRACE: patternActionAssoc	self		addRouteMethod: (TeaMethodMatcher exactly: #TRACE)		pattern: patternActionAssoc key		action: patternActionAssoc value! !!Teapot methodsFor: 'private' stamp: 'AttilaMagyar 11/8/2015 18:31'!addRouteMethod: aTeaMethodMatcher pattern: pattern action: aTeaAction	current := dynamicRouter addRoute:		(TeaRoute			matcher: (TeaRequestMatcher method: aTeaMethodMatcher url: pattern asTeaUrlPattern)			action: aTeaAction			transformer: defaultOutput			port: server port)! !!Teapot methodsFor: 'filters' stamp: 'AttilaMagyar 5/8/2015 19:17'!after: patternActionAssoc	current := compositeRouter addAfterFilter:				(TeaAfterFilter 			urlPattern: patternActionAssoc key asTeaUrlPattern 			action: patternActionAssoc value)! !!Teapot methodsFor: 'url mapping' stamp: 'AttilaMagyar 4/18/2015 00:02'!any: patternActionAssoc	self		addRouteMethod: TeaMethodMatcher any		pattern: patternActionAssoc key		action: patternActionAssoc value! !!Teapot methodsFor: 'filters' stamp: 'AttilaMagyar 5/8/2015 19:17'!before: patternActionAssoc	current := compositeRouter addBeforeFilter:				(TeaBeforeFilter 			urlPattern: patternActionAssoc key asTeaUrlPattern 			action: patternActionAssoc value)! !!Teapot methodsFor: 'url mapping' stamp: 'AttilaMagyar 5/8/2015 19:17'!exception: anExceptionSetActionAssoc	current := compositeRouter addErrorHandler:		(TeaErrorHandler			for: anExceptionSetActionAssoc key			action: anExceptionSetActionAssoc value			responseTransformer: defaultOutput)! !!Teapot methodsFor: 'initialization' stamp: 'AttilaMagyar 10/13/2014 20:41'!initializeOptions: optionsAssociations			dynamicRouter := TeaDynamicRouter new.	staticRouter := TeaStaticRouter new.	compositeRouter := TeaCompositeRouter routers: {dynamicRouter. staticRouter}.		defaultOutput := self responseTransformer: (optionsAssociations asDictionary at: #defaultOutput ifAbsent: #html).										self exception: TeaAbort -> [ :abort :req | abort response teaTransform: [ :same | same ] request: req].	server := ZnServer defaultServerClass new.	server delegate: compositeRouter.		optionsAssociations do: [ :each | server optionAt: each key put:  each value ].		^ self! !!Teapot methodsFor: 'url mapping' stamp: 'AttilaMagyar 5/8/2015 19:17'!output: transformerBlockOrSymbol	current responseTransformer: (self responseTransformer: transformerBlockOrSymbol)	! !!Teapot methodsFor: 'private' stamp: 'AttilaMagyar 8/13/2014 20:51'!responseTransformer: transformerBlockOrSymbol	^ transformerBlockOrSymbol isSymbol		ifTrue: [ TeaOutput perform: transformerBlockOrSymbol ]		ifFalse: [ transformerBlockOrSymbol ]! !!Teapot methodsFor: 'url mapping' stamp: 'AttilaMagyar 8/16/2014 18:38'!serveStatic: urlPrefixString from: pathString		staticRouter urlPrefix: urlPrefixString path: pathString! !!Teapot methodsFor: 'accessing' stamp: 'AttilaMagyar 8/2/2014 20:56'!server	^ server! !!Teapot methodsFor: 'controlling' stamp: 'AttilaMagyar 9/28/2014 18:14'!start	server start! !!Teapot methodsFor: 'controlling' stamp: 'AttilaMagyar 8/13/2014 20:24'!stop	server stop! !!Teapot methodsFor: 'filters' stamp: 'AttilaMagyar 5/8/2015 19:17'!when: aBlockClosure 	current whenClause: aBlockClosure	! !!Collection methodsFor: '*Teapot-Core' stamp: 'AttilaMagyar 6/16/2015 18:26'!asTeaUrlPattern	^ TeaUrlPatternSet fromCollection: self! !"Teapot-Core"!!TeaKeyValueList commentStamp: 'AttilaMagyar 10/31/2015 16:20' prior: 0!I'm built up from a dynamically extensible list of other components.!!Cupboard commentStamp: 'TorstenBergmann 10/8/2015 21:36' prior: 0!A cupboad for teapots!!TeaIconProvider commentStamp: 'TorstenBergmann 10/5/2016 21:57' prior: 0!An icon provider for tools icons with an icon cache!!TeaFormTab commentStamp: 'AttilaMagyar 10/30/2015 19:47' prior: 0!I'm built up from a dynamically extensible key value pair list (TeaKeyValueInput). I can represent POST parameters or HTTP headers for example.!!TeaKeyValueInput commentStamp: 'AttilaMagyar 10/30/2015 20:21' prior: 0!Two inputs and a remove button.!!TeaRequestBodyTabs commentStamp: 'AttilaMagyar 10/30/2015 20:17' prior: 0!I graphically represent a request body that can be viewed in multiple ways.!!Teaspoon commentStamp: 'AttilaMagyar 10/30/2015 19:33' prior: 0!I provide a graphical interface for quickly testing and excesising routes. Right click on a route in the inspector to open me.!!TeaKeyValueList class methodsFor: 'specs' stamp: 'AttilaMagyar 10/31/2015 14:28'!defaultSpec	^ SpecLayout composed! !!TeaKeyValueList methodsFor: 'protocol' stamp: 'AttilaMagyar 10/31/2015 19:45'!addKey: keyString value: valueString	self needFullRebuild: false.		self buildWithSpecLayout: 		(self dynamicLayout: 			(self asAssociations copyWith: keyString -> valueString))! !!TeaKeyValueList methodsFor: 'private' stamp: 'AttilaMagyar 10/31/2015 19:42'!asAssociations	^ models collect: #asAssociation! !!TeaKeyValueList methodsFor: 'private' stamp: 'AttilaMagyar 10/31/2015 19:52'!dynamicLayout: associations	self focusOrder removeAll.	models removeAll.	self widgets removeAll.	^ SpecLayout composed newColumn: [ :col |			associations doWithIndex: [:assoc :i | 				| inputName widget |				inputName := ('input', i asString) asSymbol.				self instantiateModels: {inputName.  #TeaKeyValueInput}.				widget := self perform: inputName.				widget					setKey: assoc key					value: assoc value					removeAction: [ :me | self remove: me ].				models add: widget.				self focusOrder add: widget.				col 					newRow: [ :row | row add: inputName ] ] ].		! !!TeaKeyValueList methodsFor: 'initialization' stamp: 'AttilaMagyar 10/31/2015 19:32'!initialize	super initialize.	models := OrderedCollection new.! !!TeaKeyValueList methodsFor: 'protocol' stamp: 'AttilaMagyar 10/31/2015 19:42'!items	^ self withoutDuplicatesAndBlanks: (self asAssociations asOrderedDictionary)! !!TeaKeyValueList methodsFor: 'protocol' stamp: 'AttilaMagyar 10/31/2015 19:39'!items: keyedCollection	self needFullRebuild: false.	self buildWithSpecLayout: 		(self dynamicLayout: 			(self withoutDuplicatesAndBlanks: keyedCollection))! !!TeaKeyValueList methodsFor: 'private' stamp: 'AttilaMagyar 10/31/2015 19:42'!remove: model	self needFullRebuild: false.	models remove: model.	self buildWithSpecLayout: (self dynamicLayout: self asAssociations)! !!TeaKeyValueList methodsFor: 'private' stamp: 'AttilaMagyar 10/31/2015 19:38'!withoutDuplicatesAndBlanks: keyedCollection	| keyset |	keyset := PluggableSet new		equalBlock: [ :a :b | a key = b key ];		hashBlock: [ :x | x key hash ];		yourself.					keyedCollection keysAndValuesDo: [ :key :value | 		keyset add: (key -> value) ].	^ keyset reject: [ :each | 		each key isEmptyOrNil or: [ each value isEmptyOrNil ] ]! !!Cupboard class methodsFor: 'accessing' stamp: 'TorstenBergmann 10/5/2016 21:56'!iconProvider	^TeaIconProvider! !!Cupboard class methodsFor: 'world menu' stamp: 'TorstenBergmann 10/5/2016 21:55'!menuCommandOn: aBuilder 	<worldMenu> 		(aBuilder item: #'Teapot')	 		help: 'Teatime'; 		parent: #'Tools' translated;		icon: self iconProvider teapotIcon;		action: [ self soleInstance inspect ].	 aBuilder withSeparatorAfter ! !!Cupboard class methodsFor: 'instance creation' stamp: 'TorstenBergmann 10/8/2015 21:37'!new	self error: 'Do not create new instances - access using #soleInstance'! !!Cupboard class methodsFor: 'private' stamp: 'TorstenBergmann 10/8/2015 21:38'!reset	<script>		soleInstance := nil.	 ! !!Cupboard class methodsFor: 'accessing' stamp: 'TorstenBergmann 10/8/2015 21:38'!soleInstance	<script: 'self soleInstance inspect'>		^ soleInstance ifNil: [ soleInstance := self basicNew initialize ]! !!Cupboard methodsFor: 'inspecting' stamp: 'TorstenBergmann 10/5/2016 22:05'!gtInspectorTeapotsIn: composite	<gtInspectorPresentationOrder: 0>  		^(composite list)		title: 'Teapots';		icon: [:each | self iconForTeapot: each ];		display: [ self teapots ]; 		format: [:each | self nameForTeapot: each ];		selectionAct:  [:each | each selection ifNotNil: [ each selection start ]. each update ] icon: self iconProvider teapotServerStartIcon entitled: 'Start';		selectionAct: [:each | each selection ifNotNil: [ each selection stop ]. each update ] icon: self iconProvider teapotServerStopIcon entitled: 'Stop';		act: [:each | self onNewServer. each update ] icon: self iconProvider teapotServerIcon entitled: 'New Teapot';		act: [:each | self onNewStaticServer. each update ] icon: self iconProvider teapotServerStaticIcon entitled: 'New Teapot (serving static)'		! !!Cupboard methodsFor: 'private' stamp: 'TorstenBergmann 10/5/2016 21:57'!iconForTeapot: aTeapot	^aTeapot server isRunning 			ifTrue: [ self iconProvider teapotServerStartIcon ] 			ifFalse: [ self iconProvider teapotServerStopIcon ]! !!Cupboard methodsFor: 'accessing' stamp: 'TorstenBergmann 10/5/2016 21:56'!iconProvider	^self class iconProvider! !!Cupboard methodsFor: 'private' stamp: 'TorstenBergmann 10/8/2015 21:39'!nameForTeapot: aTeapot	^String streamContents: [:stream |		stream nextPutAll: aTeapot server port asString.		stream nextPutAll: ' - '.		stream nextPutAll: (aTeapot server isRunning ifTrue: [ 'running' ] ifFalse: [ 'stopped' ]) ].! !!Cupboard methodsFor: 'actions' stamp: 'TorstenBergmann 10/5/2016 21:33'!onNewServer	|port pot |	port := UIManager default request: 'New server' initialAnswer: '80'.	port ifNil: [ ^self ].	pot := Teapot configure: { 		#port -> port asNumber	}.	pot start			! !!Cupboard methodsFor: 'actions' stamp: 'TorstenBergmann 10/5/2016 21:33'!onNewStaticServer	|port directory pot |	port := UIManager default request: 'New server' initialAnswer: '80'.	port ifNil: [ ^self ].	directory := UIManager default chooseDirectory: 'Serve directory'.	directory ifNil: [ ^self ].	pot := Teapot configure: { 		#port -> port asNumber	}.	pot serveStatic: '/' from: directory.	pot start			! !!Cupboard methodsFor: 'printing' stamp: 'TorstenBergmann 10/8/2015 21:39'!printOn: aStream	aStream nextPutAll: 'Cupboard'! !!Cupboard methodsFor: 'accessing' stamp: 'TorstenBergmann 10/12/2015 09:38'!teapots	^Teapot allInstances! !!TeaIconProvider class methodsFor: 'accessing' stamp: 'TorstenBergmann 10/5/2016 21:55'!icons	IconCache ifNil: [ IconCache := Dictionary new ].	^IconCache! !!TeaIconProvider class methodsFor: 'icons' stamp: 'TorstenBergmann 10/5/2016 21:52'!teapotIcon	^ self icons			at: #'teapotIcon'			ifAbsentPut: [ Form fromBinaryStream: (Base64MimeConverter mimeDecodeToBytes: self teapotIconContents readStream) ].! !!TeaIconProvider class methodsFor: 'private - icons' stamp: 'TorstenBergmann 10/5/2016 21:52'!teapotIconContents	^'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABhklEQVR42rWSPSxDURTHzzmvr8TyRBP00Y1BQiwiRD+YkKiPyWqTSDAZjUaj2SyS0lbEpNWPRCTEYBeNKrv4qN57nFYiPoqXNM7Nzcs799zf/Z//vQg1Bv4rIO4LdDCgF5FPwrn0s2PAdmsf1RkNvbK6KbMLGGaR4SCcTz19A0S8A3NkGo/TuexWORG1A/2MvE9EHuQ3PsuQeFFcWjXQtaEVjpHBzZLexj07cK4Je1jTKBn6khmzCNzyJo7h41dAD8z6FJEs+TuT1hijdnAICdJS8ShFRSlv/Ms4Zp6ZzKd2Y75gBqM+v9DoChgt587zsrtObRSLdFFpMm4Hk0AQcgpw89N6CdyHCnGtAthp93e6gI6l0yZ08DTEi1NibSmCpffqeFvILF+C3MD47/LFK8Y9MNRiOJe5+3RczDviYXpJisvdP+wXo2FCVCbC10dc9SHF7eF6QD2vUC8Qkkf0uiT9wFon5OSVqUL65oui6hGxBy3TMMsAU+Y9Ki5M3KZ1lZZqi5oBr2z5j75RN5raAAAAAElFTkSuQmCC'! !!TeaIconProvider class methodsFor: 'icons' stamp: 'TorstenBergmann 10/5/2016 21:52'!teapotServerIcon	^ self icons			at: #'teapotServerIcon'			ifAbsentPut: [ Form fromBinaryStream: (Base64MimeConverter mimeDecodeToBytes: self teapotServerIconContents readStream) ].! !!TeaIconProvider class methodsFor: 'private - icons' stamp: 'TorstenBergmann 10/5/2016 21:52'!teapotServerIconContents	^'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAC0UlEQVR4Xo2SbU+SURzG+RS2hDdufQBtM0e58GHa8o2W3mbWkjbLhzURTTNEHnwowNKG2oM6JUWF2+fHTJ2aJaFCPlAzJygGOMPM8qF8wqtbXli2rK7t2v7n7Fy/c8520fbk4nKEkZkpIUViKckXSEj9qBEjehNG3kxDILxLenoyCVdXVwbtMHl7s4hJ4ypsi1uUHbDad2Fz2kGtd2G2bWBIZ0Jz6wvLHtDL69RBIIvlS2hGFqEbW4FhcgWmuU0YzduYNu9QswOmDw7MWhwUaAe2Tw7M29dxIyGV3Af4+voR3X1mDAwuoLd/Hl09c9Q8D/34MgVcxYz1O+yft2Ff3sTYWxvKK/oRxU44CGhpe4/Orlm0tk+joWkS6toJ1KhHoax5jdLyPsgLn0GUrUZMnBTnw64jPj7lIEBNjqK+8R1U5DiU1XqUP9WitGwQfEEJMgRS5D8ohrJKjampKQhF9+HjG8j9BeBPlCk0qFDqUKbQ4knJSzwsom6Vd1N/lcJgMGBraxvf1jfw5es64mJvwfMEk9gHBAaeIeQFXXhcPIDCwl7k5z9HrqwDUkkL2Ox0aLXDWFvbwsLCMmZm7QgJYeNsUNBPgLu7B1MirUdeXidk0nbkZDdBLKqjXIuIiBS0tXXBal2C0bSEVxoTgoOjQGfQD/YiLU1MioQqZ1AoUEOQoYZISCI8PBnVNc2YMFiocpnR1jEM9lUO/lioa9FJZDqvygnYsxNwIQmKikYqbMGAZgbquh4kcsU4tJUyWYklg6/aBxDhXBQ9UkE3/hGDQzNIThUg5BxbcyjgKFVRHk9uEWSonIAwgoukm3eo0CW4uR1DQEAktRdN0v4md4/jTA4n17L3ipjYe2D5ROK0z0VcTuSBL6zElajYPNq/5OcfQGRlKZHAKaLal4/bPAXkBa3IypZr6HQ6g/Y/8vI6SVRW9qChUYPsnCJNaGgE9/czPwCyhvLlWzqQAwAAAABJRU5ErkJggg=='! !!TeaIconProvider class methodsFor: 'icons' stamp: 'TorstenBergmann 10/5/2016 21:52'!teapotServerStartIcon	^ self icons			at: #'teapotServerStartIcon'			ifAbsentPut: [ Form fromBinaryStream: (Base64MimeConverter mimeDecodeToBytes: self teapotServerStartIconContents readStream) ].! !!TeaIconProvider class methodsFor: 'private - icons' stamp: 'TorstenBergmann 10/5/2016 21:52'!teapotServerStartIconContents	^'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAADR0lEQVR4Xn2T71fTZRyG+S804RV56k3Hc6jciTpHICnNOnVYfCWhCZiiCAxGlEbbhCg2TjQdIYlCwWIIU0crDhAiiOA8xL6B4kFqG7+22QYRHCL5Nbia7ByOnNPpc859zvPmup7nOef+hDw5JzOydQWfaU0qtdYkDjro/9VJv2in8lKdVaMtNUkkksiQ/xtr3ygu3yqe6TU8U4+zHjgHM/FwmT5xFMtP3S71GY1JocjT7dgRGrZF0NH1O+LdBe7en8c+tohzfBXHmB/HhB/n5BpjrkA8fh4GLnB7/0aRm2/aImhpG6LH6qOz20N7xwQ3ezzYBv/i3vBCAF7CN7PK1NwyA0Muqr69wcmMj7cKmiw22q6P09xip8nyANPVIeobBqhv/IXq7zopK2+l4PNG0k5oiBfSSUxM1W0RNDRaMf8wTOOVe9TVi9QY+rhY1UthkQGlUsPZc5UYjSbsdgenPikmIkIibMK7JS9G5p0vIfF8Dqll+ZRUmKmouIlef52c3HOINhsrKys8+meZ2dkFUlKziY19LSiQ7JUIh5vep2SgmNbJFgy/1XC09SgHNXI0xRbSjmvo6uxiIQB7vbPYHX8glaYSFxcnhGx7altYglmgxl5Ns+tHFlcfMTI3TJ2zluzeLA4pPyLlSCENDddwu2dwOP+kq/tB4P/pbNwe/UGU7thtGbXOSuaX51hfX9+IdfoW+pESdpdHkpx6hksXjQzdn6TfNo7Z0kumXBUUPK/YZZKLR5ha9G7Cj+Nf82NxX+E5YziyFCXlFbXYRDc9t0epu9yCUlUaFLycJzEliq9TMfkF7TPmALyGb9nDhUkN6hE5uy4/TVLyp3xZWoU46KM30FZ5zile3SsNdkCaJdW9eecF0u1vUT+t3xC4lhx86BQ4OPgKMd/EIktWkZmlJu5dGeHhO9m3T4bscEZQEBoWGpbbeZwi1zF+nq8LvmBlgq+8uSTciiFNpSUzs4zomCT2RL9HUk4+6oLv2f/GO4rNDhx4+4CQcTXFVTRygralKmqnNMithyisLrBqtUYUiguB9p3ldH4N+q+bAxU+bfrPbYzaHyVsj9guPBv5jCB5Kbi6UXtiBIOhnWvmO3TcsBEfn6B4kvkXxV9YN+ClYBQAAAAASUVORK5CYII='! !!TeaIconProvider class methodsFor: 'icons' stamp: 'TorstenBergmann 10/5/2016 22:05'!teapotServerStaticIcon	^ self icons			at: #'teapotServerStaticIcon'			ifAbsentPut: [ Form fromBinaryStream: (Base64MimeConverter mimeDecodeToBytes: self teapotServerStaticIconContents readStream) ].! !!TeaIconProvider class methodsFor: 'private - icons' stamp: 'TorstenBergmann 10/5/2016 22:05'!teapotServerStaticIconContents	^'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAADIElEQVR42l2Ta0gUURTH/1fHWVNz2dLNIinQ0shAKCsSixIp7EMQ7VKbH8SICopo6UFaiBqZBm5R1Bc1i7ZwJw1DlzbQfKTr9rA+aGX2MFbbNsu21Np259Gdcczwwsw5c+85vzn/e+8hoCM0NHThjh07KySJQBAl5BcUGUSRAEREWWkh19Ls4H788DkFQRjCjEHkV0xMrKGj+70tWquRcZBBygIkGkEQDATg9Qyjr/f5kL2p3vmw5QHn831XgEpcbKze0GDvs7FhGmgoIyJCQyEhNJ0ghBDlNyGyCZEQpqFw0Y+8XBN3395gVAB6vd5grX1s07Dh4IMieD6I8FlhiIyaBZZlEDmbQVQEo0j6NPwVz3sGcL26nGtttU8DKqvbbSyrQTDIq08QoijQPfHD7/fj14Qfo76f8AwPYmTkHSbGPnMOx71pwKXLDhsTxirJPD8JoBoxOPiSKhjFnDk6KlWLtFWpuHW7EdVVl8xu96BFBcwznCu/a2MYdjo5QEECjzdve7BvbzaSkpKpPAEBXsDJE8WotVUaR0e/cQogLi7OkF9ww8Zq6B4EJgFysCjyePXahf37tyElJRXj4xP49TsI85HjcLkcRo/Hw5HVaQlRSUv0pdu3rj/IIAj30E/09Osxf8EKMAxDAY+Rk5OF1NSV8P8BPnt9OF9WjMamm/ECT48xL3fzoePmLSW6CEYLegISL6HD9RFdL3jodDqMfHEjOTke0XOTkLw8HV7vF9zhrKi5dlGpnpwpybHmH0s3EZ5+C/Tq8HRSkFQ7OQfqV9S+QtrGw/B8eg9nZycuWApVQNFua8HRDJMcJKnBRJj0CfX/Abh+rM06hPq6Gjx1PXO2tTWtUwAlhbsoYINJDpbUBKLCiJoszx04WwfHow9ITFyNsXEv1+1sNiqA4tNG6ynzRhNouUSYgkhqJdMS9pzhEIhbg8XaZXDYr1qePOkyK4CiUwbr6SOZJjJTgmqnAEevtGJRym709j50VlVeNE51Jtm0IcWcmbE0WxLpCdBWlgQRoFdY9sfG/PqYeQkr5IZqfzrg7n/nsQwM9Fv+b+e/lwaeIIipiHQAAAAASUVORK5CYII='! !!TeaIconProvider class methodsFor: 'icons' stamp: 'TorstenBergmann 10/5/2016 21:52'!teapotServerStopIcon	^ self icons			at: #'teapotServerStopIcon'			ifAbsentPut: [ Form fromBinaryStream: (Base64MimeConverter mimeDecodeToBytes: self teapotServerStopIconContents readStream) ].! !!TeaIconProvider class methodsFor: 'private - icons' stamp: 'TorstenBergmann 10/5/2016 21:52'!teapotServerStopIconContents	^'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAADO0lEQVR4Xn2T7U+TVxiH+xdsGfso0Q+Gbh+UBYFEsjeSzS6yKWDWdKyMurEXytDyVsfcKHRtFKdWRFyljxoiVbEoq3vxPVM2qKwd5XXZYK30BYotuEXWQaSUa8/GdDZLdidX7i/nvk7OOb8jebhK399uqtfvsdXqGmx9A15cbi9Ot4cWi9VRUrLNtGnTZrnk/6q710swHCM0vchkeInJyH3iTIQX+WHAj6vPw8e1u2ylpRrTunXpWQmCq9+M4h6KMjByl7HxOby+RTzjcbx+kcAStwJxxicWRVmc8K/3uHSlhwTB1xeH+c4R4XpXiCvXAlz/Nige4w6DI7/j8c8zNR1j5m6MUe805+xOzC32REGn3cXlq36+uuDh8/M/Yzs7zKn2fto7XAitN2g+chljQwea8kMoCspQKsscCYJT7T102n/iTMcQJ0+7aT3hRDjWw8HmC2zbvpP9piMcP96G0+nCaj1NXv5W24PhZLGExjO06Fux7LdjOdrNZ+YbHGy6hmFXO21tVhYWYszP32N2do69ew/xVrFmWaDKzatoK1IFbxoM/GhpoddoxKpS0/CBwO7dX1Dz4TGaD5uZm1sgEpklEJihvEJHdfVHNsnG7Gz5RaUSryA84NY/vXOLAl25mR07BOrqDExMzuAL/IZ78DbKwjLS0jLlEqtCERyqqmasvp5fHmJUZKSmhk8zXxJ3sqDV1jI8EqSv3ye+zCQvv1LIixtkcok9dS1Rv49YNCryR0JfiM5yMvNpqkSBpnwn/YMhurq99Nz0kpPzOiuSVyRLvpRKmQuFiC/F/0s8ztn09VRWmSlRa+l1BcWQ3WHPvhaKVGXLGegqKGAsO5tg7mZuFxYSURUxVfgGvtw8RmUyhLTnqKg0o3jtXd4s1iBNeZL1WTL0emFZ8Iw0Rf79Y0kEVq4kLBJZtYopsY+LOB55FJ2qXrwDgRc2bOXZ5xW8qq5AU3kYXd2Bf0O0JUVaMZiRQTQ3l/miImbz8xlIz0AoUTuamjqo1gq8856JKu1R9h04T2OjNZia+lTiR0p9Qppl3JhjM65ZYzPIZLa1q1f/vSAp6fHkE9ZLdJzrRv9Jk6P4bbXpr9Ddn/sTU0VgFvyaFxkAAAAASUVORK5CYII='! !!TeaIconProvider class methodsFor: 'icons' stamp: 'TorstenBergmann 10/5/2016 21:53'!teaspoonIcon	^ self icons			at: #'teaspoonIcon'			ifAbsentPut: [ Form fromBinaryStream: (Base64MimeConverter mimeDecodeToBytes: self teaspoonIconContents readStream) ].! !!TeaIconProvider class methodsFor: 'private - icons' stamp: 'TorstenBergmann 10/5/2016 21:51'!teaspoonIconContents	^'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABdklEQVR42mNkoBAwgoiJs6fLvHv/oe/d27cM6urqTxQVFfq8HV2fEG1AQ1f7qlevX4XCBDk5OBnExcWLynLy+4kyIK+idNWfv39C0SUNDQz7U6PjiggaMG3+3L4r164UokvycPMwdDU0MxI0YNfhgzK7du96/O37NwwFCfEJYWY6+qvxGgACPdMmF967f68PXYG8nHxYeW4BYQNAYM6yxX23bt0q/PL1C1xMVFRsdWNZZRhRBsDA8YtnQw8ePMTw8+fP0JevXoby8vCu7qxvCiPaAGRQ2dyw6uOnj6FArzzR09Oz9LR3ekKSASDQNWXi4wcPH8hwc3E/YefgsGyprHlCkgGgWNqzd89xYNjIMDMxP2FkZLSc1NH9hGgDQKCuo1Xm/fv3x//++yvDyMD4hIWV1XJiW+cTog0AAWCKlfn79+/x/wz/ZZiZmZ+oKCtbkmQACORXlcv8//fvODDpy0hJSh0n2QAQmDx3lsynT59W/fnz5wkA2dSUkQj2i7UAAAAASUVORK5CYII='! !!TeaMethodMatcher methodsFor: '*Teapot-Tools' stamp: 'AttilaMagyar 10/25/2015 18:06'!asString	^ name! !!TeaRoute methodsFor: '*Teapot-Tools' stamp: 'AttilaMagyar 11/8/2015 19:02'!gtInspectorRouteIn: composite	<gtInspectorPresentationOrder: 80>	| presentation |	presentation := composite morph.	presentation		title: 'Teaspoon';		display: 			[ | teaspoon |				teaspoon := Teaspoon new 					method: requestMatcher methodMatcher asString					url: requestMatcher urlPattern asTeaspoonPath					port: port.				teaspoon onHttpResultDo: [ :result | presentation selection: result ].				teaspoon buildWithSpec ]! !!TeaUrlPatternSet methodsFor: '*Teapot-Tools' stamp: 'AttilaMagyar 11/8/2015 18:25'!asRequestBuilderPath	^ patterns 		ifEmpty: [ '/' ]		ifNotEmpty: [ patterns first asTeaspoonPath ]! !!TeaUrlPatternSet methodsFor: '*Teapot-Tools' stamp: 'AttilaMagyar 11/8/2015 18:25'!asTeaspoonPath	^ patterns 		ifEmpty: [ '/' ]		ifNotEmpty: [ patterns first asTeaspoonPath ]! !!Teapot methodsFor: '*Teapot-Tools' stamp: 'TorstenBergmann 10/7/2016 23:02'!gtInspectorDynamicRoutesIn: composite	<gtInspectorPresentationOrder: 0>  		^(composite list)		title: ['Dynamic routes' translated];		 		display: [ dynamicRouter routes ]; 		format: [:each | each printString ];		selectionAct: [:p | p entity removeDynamicRoute: p selection. 			p pane browser update ] entitled: 'Remove route' translated;		selectionAct: [:p | p entity removeAllDynamicRoutes. 			p pane browser update ] entitled: 'Remove all' translated! !!Teapot methodsFor: '*Teapot-Tools' stamp: 'TorstenBergmann 10/7/2016 23:01'!removeAllDynamicRoutes 	dynamicRouter routes removeAll! !!Teapot methodsFor: '*Teapot-Tools' stamp: 'TorstenBergmann 10/5/2016 20:59'!removeDynamicRoute: aRoute	dynamicRouter routes remove: aRoute! !!TeaFormTab class methodsFor: 'specs' stamp: 'AttilaMagyar 10/26/2015 21:14'!defaultSpec	^ SpecLayout composed		newColumn: [ :col |			col 				add: #form;				add: #addButton height: self buttonHeight ]! !!TeaFormTab methodsFor: 'accessing' stamp: 'AttilaMagyar 10/26/2015 21:13'!addButton	^ addButton ! !!TeaFormTab methodsFor: 'accessing' stamp: 'AttilaMagyar 10/25/2015 20:16'!form	^ form! !!TeaFormTab methodsFor: 'initialization' stamp: 'AttilaMagyar 10/31/2015 19:45'!initializePresenter	addButton whenActionPerformedDo: [ form addKey: '' value: '' ]! !!TeaFormTab methodsFor: 'initialization' stamp: 'AttilaMagyar 10/31/2015 19:44'!initializeWidgets	addButton := self newButton label: 'Add parameter'; yourself.	form := self instantiate: TeaKeyValueList.	self focusOrder 		add: form;		add: addButton.! !!TeaFormTab methodsFor: 'protocol' stamp: 'AttilaMagyar 10/31/2015 16:30'!updateKeyValus: keyValueCollection	form items: keyValueCollection! !!TeaFormTab methodsFor: 'private' stamp: 'AttilaMagyar 10/31/2015 17:42'!urlEncoded	| url formParams |	url := '/' asZnUrl.	formParams := form items.	formParams ifEmpty: [ ^ '' ].	formParams do: [ :association | url := url withQuery: association ].	^ url asString allButFirst: 2	! !!TeaFormTab methodsFor: 'protocol' stamp: 'AttilaMagyar 11/1/2015 21:00'!writeUrlEncodedTo: aTextModel	self urlEncoded 		ifNotEmpty: [ aTextModel text: self urlEncoded ]! !!TeaKeyValueInput class methodsFor: 'specs' stamp: 'AttilaMagyar 10/25/2015 22:37'!defaultSpec	^ SpecLayout composed		newRow: [ :row |			row				add: #keyInput;				add: #valueInput;				add: #removeButton ]		 height: self height! !!TeaKeyValueInput class methodsFor: 'accessing' stamp: 'AttilaMagyar 10/25/2015 22:38'!height	^ self inputTextHeight max: self buttonHeight! !!TeaKeyValueInput class methodsFor: 'instance creation' stamp: 'AttilaMagyar 10/30/2015 20:34'!key: keyString value: valueString removeAction: aBlock	^ self new		setKey: keyString 		value: valueString		removeAction: aBlock! !!TeaKeyValueInput methodsFor: 'converting' stamp: 'AttilaMagyar 10/30/2015 20:23'!asAssociation	^ keyInput text -> valueInput text! !!TeaKeyValueInput methodsFor: 'initialization' stamp: 'AttilaMagyar 10/30/2015 23:52'!initializeWidgets		keyInput := self newTextInput autoAccept: true; ghostText: 'key'; yourself.	valueInput := self newTextInput autoAccept: true; ghostText: 'value'; yourself.	removeButton := self newButton label: 'Remove'; yourself.	self focusOrder		add: keyInput;		add: valueInput;		add: removeButton.		! !!TeaKeyValueInput methodsFor: 'accessing' stamp: 'AttilaMagyar 10/25/2015 20:13'!keyInput	^ keyInput! !!TeaKeyValueInput methodsFor: 'accessing' stamp: 'AttilaMagyar 10/25/2015 21:04'!removeButton	^ removeButton! !!TeaKeyValueInput methodsFor: 'initialization' stamp: 'AttilaMagyar 10/30/2015 20:39'!setKey: keyString value: valueString removeAction: aBlock	keyInput text: keyString.	valueInput text: valueString.	removeButton whenActionPerformedDo: [ aBlock value: self ].	^ self! !!TeaKeyValueInput methodsFor: 'accessing' stamp: 'AttilaMagyar 10/25/2015 20:13'!valueInput	^ valueInput! !!TeaRequestBodyTabs class methodsFor: 'specs' stamp: 'AttilaMagyar 10/30/2015 20:08'!defaultSpec	^ SpecLayout composed		newColumn: [ :col |			col 				add: #label height: self inputTextHeight;				add: #requestBody ]! !!TeaRequestBodyTabs methodsFor: 'private' stamp: 'AttilaMagyar 10/30/2015 22:22'!formTabTitle	^ 'Form'! !!TeaRequestBodyTabs methodsFor: 'initialization' stamp: 'AttilaMagyar 10/30/2015 20:08'!initializeWidgets	label := self newLabel label: 'Request body'; yourself.	requestBody := self newRequestBody.! !!TeaRequestBodyTabs methodsFor: 'accessing' stamp: 'AttilaMagyar 10/30/2015 20:08'!label	^ label! !!TeaRequestBodyTabs methodsFor: 'initialization' stamp: 'AttilaMagyar 11/1/2015 21:01'!newRequestBody	raw := self newText autoAccept: true; yourself.	form := TeaFormTab new.	^ self newTabManager			addTab: (self newTab				label: self rawTabTitle;				closeable: false;				model: raw);			addTab: (self newTab				label: self formTabTitle;				closeable: false;								model: form);			whenTabSelected: [:selected |				selected label = self formTabTitle					ifTrue: [ form updateKeyValus: ('?', raw text) asUrl query ] 					ifFalse: [ form writeUrlEncodedTo: raw ] ]! !!TeaRequestBodyTabs methodsFor: 'private' stamp: 'AttilaMagyar 10/30/2015 22:22'!rawTabTitle	^ 'Raw'! !!TeaRequestBodyTabs methodsFor: 'accessing' stamp: 'AttilaMagyar 10/30/2015 20:09'!requestBody	^ requestBody! !!TeaRequestBodyTabs methodsFor: 'protocol' stamp: 'AttilaMagyar 10/30/2015 22:22'!urlEncoded	requestBody selectedTab label = self formTabTitle		ifTrue: [ raw text: form urlEncoded ].	^ raw text! !!Teaspoon class methodsFor: 'specs' stamp: 'AttilaMagyar 10/30/2015 20:57'!defaultSpec	^ SpecLayout composed		newColumn: [ :col | 												col 				newRow: [ :row | 					row 						add: #methodDropList width: 90;						add: #urlInput ]				height: self inputTextHeight.			col				add: #requestBody;				add: #contentTypeLabel height: self inputTextHeight;				add: #contentTypeDropList height: self inputTextHeight.			col 				newRow: 					[ :row | row add: #execButton ] 				height: self buttonHeight						]! !!Teaspoon class methodsFor: 'private - accessing' stamp: 'TorstenBergmann 10/5/2016 21:59'!iconProvider	^TeaIconProvider ! !!Teaspoon class methodsFor: 'world menu' stamp: 'TorstenBergmann 10/5/2016 21:59'!menuCommandOn: aBuilder 	<worldMenu> 		(aBuilder item: #'Teaspoon')	 		help: 'Teaspoon'; 		parent: #'Tools' translated;		icon: self iconProvider teaspoonIcon;		action: [ self open ].! !!Teaspoon class methodsFor: 'interface' stamp: 'TorstenBergmann 10/5/2016 21:35'!open	<script>		(self new)		openWithSpec;		yourself! !!Teaspoon class methodsFor: 'specs' stamp: 'AttilaMagyar 10/30/2015 19:35'!title	^ 'Teaspoon client'! !!Teaspoon methodsFor: 'private' stamp: 'AttilaMagyar 10/30/2015 22:09'!client	^ ZnClient new		url: self urlInput text;		method: self methodDropList selectedItem;		entity: (ZnStreamingEntity 			readFrom: (ReadStream on: requestBody urlEncoded)			usingType: self contentTypeDropList selectedItem			andLength: requestBody urlEncoded size)		yourself! !!Teaspoon methodsFor: 'private' stamp: 'TorstenBergmann 10/5/2016 23:32'!consumer	^ consumer ifNil: [ consumer := [ :any | any inspect ] ]! !!Teaspoon methodsFor: 'accessing' stamp: 'AttilaMagyar 10/25/2015 17:24'!contentTypeDropList	^ contentTypeDropList! !!Teaspoon methodsFor: 'accessing' stamp: 'AttilaMagyar 10/25/2015 17:28'!contentTypeLabel	^ contentTypeLabel! !!Teaspoon methodsFor: 'accessing' stamp: 'AttilaMagyar 10/25/2015 18:27'!execButton	^ execButton! !!Teaspoon methodsFor: 'api' stamp: 'AttilaMagyar 10/25/2015 22:32'!initialExtent	^  580@420! !!Teaspoon methodsFor: 'initialization' stamp: 'TorstenBergmann 10/5/2016 23:31'!initializePresenter	execButton		whenActionPerformedDo: [ 			self urlInput text notEmpty				ifTrue: [ self consumer value: self client execute ]]! !!Teaspoon methodsFor: 'initialization' stamp: 'AttilaMagyar 10/30/2015 22:11'!initializeWidgets	methodDropList := self newMethodDropList.	urlInput := self newTextInput autoAccept: true; yourself.	requestBody := TeaRequestBodyTabs new.	contentTypeLabel := self newLabel label: 'Content Type'; yourself.	contentTypeDropList := self newContentTypeDropList.	execButton := self newButton label: 'Execute request'; yourself.! !!Teaspoon methodsFor: 'tea spoon' stamp: 'AttilaMagyar 11/8/2015 18:24'!method: methodString url: urlString port: portNumber	self populateMethod: methodString.	self populateUrl: urlString port: portNumber.! !!Teaspoon methodsFor: 'accessing' stamp: 'AttilaMagyar 10/25/2015 17:33'!methodDropList	^ methodDropList! !!Teaspoon methodsFor: 'initialization' stamp: 'AttilaMagyar 10/30/2015 22:29'!newContentTypeDropList	| dropList |	dropList := self newDropList.	#(		applicationFormUrlEncoded 		applicationJson 		applicationXml 		applicationSton 		applicationOctetStream 		text 		textHtml 		textPlain	) do: [ :each | dropList addItemLabeled: (each value: ZnMimeType) do: [] ].		^ dropList! !!Teaspoon methodsFor: 'initialization' stamp: 'AttilaMagyar 10/30/2015 21:03'!newMethodDropList	| dropList |	dropList := self newDropList.	ZnConstants knownHTTPMethods do: [ :each | 		dropList addItemLabeled: each do: [] ].	^ dropList! !!Teaspoon methodsFor: 'tea spoon' stamp: 'AttilaMagyar 11/8/2015 19:03'!onHttpResultDo: aBlock	consumer := aBlock! !!Teaspoon methodsFor: 'private' stamp: 'AttilaMagyar 11/8/2015 18:23'!populateMethod: methodString	| selected |	selected := methodDropList listItems		detect: [ :each | each = methodString ]		ifNone: [ methodDropList listItems first ].	methodDropList setSelectedItem: selected! !!Teaspoon methodsFor: 'private' stamp: 'AttilaMagyar 11/8/2015 18:24'!populateUrl: urlString port: portNumber	| pathSegment |	pathSegment := urlString.	(pathSegment beginsWith: '/') 		ifFalse: [ pathSegment := '/', pathSegment ].		urlInput text: ('http://localhost:', portNumber asString, pathSegment)! !!Teaspoon methodsFor: 'accessing' stamp: 'AttilaMagyar 10/30/2015 20:56'!requestBody	^ requestBody! !!Teaspoon methodsFor: 'accessing' stamp: 'AttilaMagyar 10/25/2015 17:22'!urlInput	^ urlInput! !!TeaRequestMatcher methodsFor: '*Teapot-Tools' stamp: 'AttilaMagyar 10/25/2015 18:02'!methodMatcher	^ methodMatcher! !!TeaRequestMatcher methodsFor: '*Teapot-Tools' stamp: 'AttilaMagyar 10/25/2015 18:03'!urlPattern	^ urlPattern! !!TeaGlobUrlPattern methodsFor: '*Teapot-Tools' stamp: 'AttilaMagyar 11/8/2015 18:25'!asTeaspoonPath	^ String streamContents: [ :aStream |			segments 				do: [ :each | each printOn: aStream ]				separatedBy: [ aStream nextPut: $/ ] ]! !!TeaRxUrlPattern methodsFor: '*Teapot-Tools' stamp: 'AttilaMagyar 11/8/2015 18:25'!asTeaspoonPath	^ '/'! !"Teapot-Tools"!!TeaTestClient commentStamp: 'AttilaMagyar 7/29/2014 22:38' prior: 0!Http client for testing.!!TeaUrlPatternTest methodsFor: 'private' stamp: 'AttilaMagyar 8/14/2014 21:22'!pattern: patternString matches: urlString	| placeholders |	placeholders := Dictionary new.	self assert: ((TeaGlobUrlPattern parseString: patternString) matchesUrl: urlString asUrl placeholders: placeholders).	^ placeholders! !!TeaUrlPatternTest methodsFor: 'private' stamp: 'AttilaMagyar 8/14/2014 21:22'!pattern: patternString noMatch: urlString	| placeholders |	placeholders := Dictionary new.	self deny: ((TeaGlobUrlPattern parseString: patternString) matchesUrl: urlString asUrl placeholders: placeholders).	^ placeholders! !!TeaUrlPatternTest methodsFor: 'tests' stamp: 'AttilaMagyar 7/29/2014 20:12'!testLongerPatternEndedPlaceholder	self pattern: '/a/b/<id>' noMatch: '/a/b'.! !!TeaUrlPatternTest methodsFor: 'tests' stamp: 'AttilaMagyar 7/26/2014 21:18'!testLongerPatternEndedWildcard	self pattern: '/a/b/c/*' matches: '/a/b/c'.	self pattern: '/1/2/3/*/*' matches: '/1/2/3'.		self pattern: '/a/b/c/*' noMatch: '/a/b'.! !!TeaUrlPatternTest methodsFor: 'tests' stamp: 'AttilaMagyar 7/26/2014 21:11'!testNoWildcard		self pattern: '/aa' matches: '/aa'.	self pattern: '/aa' noMatch: '/bb'.! !!TeaUrlPatternTest methodsFor: 'tests' stamp: 'AttilaMagyar 7/28/2014 22:29'!testPlaceholderSubstitute	| placeholders |		placeholders := self pattern: '/<id>/a/b' matches: '/123/a/b'.	self assert: (placeholders at: #id) equals: '123'.		placeholders := self pattern: '/a/<id>/b' matches: '/a/25/b'.	self assert: (placeholders at: #id) equals: '25'.		placeholders := self pattern: '/a/b/<id>' matches: '/a/b/xyz'.		self assert: (placeholders at: #id) equals: 'xyz'.		! !!TeaUrlPatternTest methodsFor: 'tests' stamp: 'AttilaMagyar 8/3/2014 17:25'!testPlaceholderTypeMatch	| placeholders |	placeholders := self pattern: '/<id:IsInteger>' matches: '/12'.	self assert: (placeholders at: #id) equals: 12.		placeholders := self pattern: '/<id:IsInteger>/abc' matches: '/-34/abc'.	self assert: (placeholders at: #id) equals: -34.		placeholders := self pattern: '/<float:IsNumber>/<int:IsNumber>' matches: '/3.14/3'.	self assert: (placeholders at: #float) equals: 3.14.	self assert: (placeholders at: #int) equals: 3.	! !!TeaUrlPatternTest methodsFor: 'tests' stamp: 'AttilaMagyar 8/3/2014 17:18'!testPlaceholderTypeNoMatch	self pattern: '/<id:IsInteger>' noMatch: '/foobar'.		self pattern: '/<id:IsNumber>' noMatch: '/foobar'.	self pattern: '/<id:IsInteger>' noMatch: '/12.3'.		! !!TeaUrlPatternTest methodsFor: 'tests' stamp: 'AttilaMagyar 7/28/2014 22:28'!testPlaceholders	self pattern: '/<id>/a/b' matches: '/1/a/b'.	self pattern: '/a/<id>/b' matches: '/a/2/b'.	self pattern: '/a/b/<id>' matches: '/a/b/1'.			self pattern: '/<id>/a/b' noMatch: '/1/a/c'.	self pattern: '/a/<id>/b' noMatch: '/a/2/c'.	self pattern: '/a/b/<id>' noMatch: '/a/c/1'.! !!TeaUrlPatternTest methodsFor: 'tests' stamp: 'AttilaMagyar 8/3/2014 18:36'!testRoot	self pattern: '/' matches: '/'.		self pattern: '/' noMatch: '/a'.		self pattern: '/a' noMatch: '/'.	self pattern: '/a/b' noMatch: '/'.	! !!TeaUrlPatternTest methodsFor: 'tests' stamp: 'AttilaMagyar 7/29/2014 20:12'!testShorterPatternEndedPlaceholder	self pattern: '/a/b/<id>' noMatch: '/a/b/1/2'.	! !!TeaUrlPatternTest methodsFor: 'tests' stamp: 'AttilaMagyar 7/27/2014 11:39'!testShorterPatternEndedWildcard	 	self pattern: '/a/*' matches: '/a/b/c'.	self pattern: '/*' matches: '/1/2/3'.	 	self pattern: '/a/*' noMatch: '/b/b/c'.	self pattern: '/a/b' noMatch: '/a/b/c'.	! !!TeaUrlPatternTest methodsFor: 'tests' stamp: 'AttilaMagyar 7/27/2014 15:33'!testTralingSlash	self pattern: '/a/b' matches: '/a/b/'.! !!TeaUrlPatternTest methodsFor: 'tests' stamp: 'AttilaMagyar 7/26/2014 21:09'!testWildcards	self pattern: '/*/1/2' matches: '/0/1/2'.	self pattern: '/a/b/*' matches: '/a/b/c'.	self pattern: '/x/*/z' matches: '/x/y/z'.		self pattern: '/*/1/2' noMatch: '/a/1/z'.		self pattern: '/a/b/*' noMatch: '/a/1/z'.		self pattern: '/x/*/z' noMatch: '/a/1/z'.						! !!TeapotAbortTest methodsFor: 'running' stamp: 'AttilaNamed 3/1/2015 20:08'!setUp	server := Teapot on		GET: 'badrequest' -> [ :req | req abort: (ZnResponse badRequest: req) ];		GET: 'unauthorized' -> [ :req | req abort: TeaResponse unauthorized ];		GET: 'abortstring' -> [ :req | req abort: 'abort test' ];				start.! !!TeapotAbortTest methodsFor: 'running' stamp: 'AttilaMagyar 8/9/2014 22:15'!tearDown	server stop! !!TeapotAbortTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testAbortSupportsAnyObject	self assert: (TeaTestClient httpGetString: '/abortstring') equals: 'abort test'.! !!TeapotAbortTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testErrorCodes	self assert: (TeaTestClient httpGet: '/badrequest') code equals: 400.	self assert: (TeaTestClient httpGet: '/unauthorized') code equals: 401.! !!TeapotAfterTest methodsFor: 'running' stamp: 'AttilaMagyar 9/27/2014 22:24'!setUp	server := Teapot on		after: '/after/<param>' -> [ :req :resp | resp headers at: 'header-key' put: (req at: #param) ];		GET: '/after/*' -> 'after-return';				start		! !!TeapotAfterTest methodsFor: 'running' stamp: 'AttilaMagyar 9/22/2014 21:12'!tearDown	server stop! !!TeapotAfterTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testAfterFilterCanModifyResponse	| response |		response := TeaTestClient httpGet: '/after/header-value'.	self assert: response entity string equals: 'after-return'.	self assert: (response headers at: 'header-key') equals: 'header-value'.		response := TeaTestClient httpPost: '/after/notfound'.	self assert: response code equals: 404.	self assert: (response headers at: 'header-key') equals: 'notfound'.! !!TeapotBeforeTest methodsFor: 'private' stamp: 'AttilaMagyar 8/17/2014 19:35'!forbidden	^ ZnResponse new		statusLine: ZnStatusLine forbidden;		headers: ZnHeaders defaultResponseHeaders;		yourself! !!TeapotBeforeTest methodsFor: 'private' stamp: 'AttilaMagyar 8/11/2014 21:45'!logRequest: aTeaRequest	log add: (aTeaRequest at: #user)! !!TeapotBeforeTest methodsFor: 'running' stamp: 'AttilaMagyar 8/24/2014 18:04'!setUp	log := OrderedCollection new.	server := Teapot on		before: '/secure/*' -> [ :req | ((req at: #user) = 'admin' and: [ (req at: #pass) = '****' ]) 			ifFalse: [ req abort: self forbidden ] ];		before: '*' -> (Send message: #logRequest: to: self);		before: '*' -> 'any';		GET: '/secure' -> 'protected';		GET: '/secure/1/2/3' -> 'protected';		POST: '/public' -> 'public';		start		! !!TeapotBeforeTest methodsFor: 'running' stamp: 'AttilaMagyar 8/11/2014 21:26'!tearDown	server stop! !!TeapotBeforeTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testAuthentication	self assert: (TeaTestClient httpGetString: '/secure?user=admin&pass=****') equals: 'protected'.	self assert: (TeaTestClient httpGetString: '/secure/1/2/3?user=admin&pass=****') equals: 'protected'.			self assert: (TeaTestClient httpGet: '/secure?user=user01&pass=****') code equals: 403.	self assert: (TeaTestClient httpGet: '/secure/1/2/3?user=user02&pass=****') code equals: 403.			self assert: (TeaTestClient httpPostString: '/public?user=any') equals: 'public'.! !!TeapotBeforeTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testMultipleBeforeHandlers	TeaTestClient httpGet: '/secure?user=admin&pass=****'.	TeaTestClient httpGet: '/secure/1/2/3?user=admin&pass=****'.		TeaTestClient httpGet: '/secure?user=user01&pass=****'. "403 before second filter"	TeaTestClient httpPost: '/public?user=pubuser'.					self assert: log asArray equals: #(admin admin pubuser).! !!TeapotDefaultFormatTest methodsFor: 'running' stamp: 'AttilaMagyar 8/13/2014 20:50'!setUp	server := (Teapot configure: { #defaultOutput -> #text })		GET: 'default' -> 'any';		GET: 'html' -> 'any'; output: #html;		start		! !!TeapotDefaultFormatTest methodsFor: 'running' stamp: 'AttilaMagyar 8/5/2014 20:51'!tearDown	server stop! !!TeapotDefaultFormatTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testDefault	self 		assert: (TeaTestClient httpGet: '/default') contentType 		equals: ZnMimeType textPlain! !!TeapotDefaultFormatTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testOverride	self 		assert: (TeaTestClient httpGet: '/html') contentType 		equals: ZnMimeType textHtml! !!TeapotEncodingTest methodsFor: 'running' stamp: 'AttilaMagyar 5/9/2015 18:15'!setUp	server := Teapot on		GET: 'enc' -> (TeaResponse ok 								body: 'rvztr tkrfrgp'; 								charSet: 'iso-8859-2');		start! !!TeapotEncodingTest methodsFor: 'running' stamp: 'AttilaMagyar 5/9/2015 18:11'!tearDown	server stop! !!TeapotEncodingTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testUserSpecifiedEncoding	| response |	response := TeaTestClient httpGet: '/enc'.	self 		assert: response entity string		equals: 'rvztr tkrfrgp'.			self 		assert: response contentType charSet		equals: 'iso-8859-2'! !!TeapotErrorHandlingTest methodsFor: 'private' stamp: 'AttilaMagyar 8/12/2014 21:40'!handleError: ex request: req	self assert: (ex isKindOf: Exception).	self assert: (req isKindOf: TeaRequest).	^ ZnResponse ok: (ZnStringEntity text: 'outofbounds/domainerror handled')! !!TeapotErrorHandlingTest methodsFor: 'running' stamp: 'AttilaMagyar 9/28/2014 18:54'!setUp	server := Teapot on		GET: '/zerodiv' -> [ 1 / 0 ];		GET: '/sub' -> [ #() at: 123 ];					GET: '/domain' -> [ -2 sqrt ];		GET: '/nonbool' -> [ NotYetImplemented signal ];		GET: '/keynotfound' -> [ KeyNotFound signal ];		exception: ZeroDivide -> [ :ex :req | 'zerodiv handled' ];		exception: SubscriptOutOfBounds, DomainError -> (Send message: #handleError:request: to: self);		exception: NotYetImplemented -> (ZnResponse ok: (ZnStringEntity text: 'nonbool handled'));		exception: KeyNotFound -> 42;		output: [ :resp :req | ZnResponse ok: (ZnStringEntity text: resp body printStringRoman) ];		start		! !!TeapotErrorHandlingTest methodsFor: 'running' stamp: 'AttilaMagyar 8/4/2014 13:05'!tearDown	server stop! !!TeapotErrorHandlingTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testHandlesExceptionSet	self assert: (TeaTestClient httpGetString: '/sub') equals: 'outofbounds/domainerror handled'.		self assert: (TeaTestClient httpGetString: '/domain') equals: 'outofbounds/domainerror handled'.		! !!TeapotErrorHandlingTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testHandlesOneException	self assert: (TeaTestClient httpGetString: '/zerodiv') equals: 'zerodiv handled'.	! !!TeapotErrorHandlingTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testTransformingErroHandlerResponse	self assert: (TeaTestClient httpGetString: '/keynotfound') equals: 'XLII'.! !!TeapotErrorHandlingTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testValueAsExceptionHandler	self assert: (TeaTestClient httpGetString: '/nonbool') equals: 'nonbool handled'.	! !!TeapotFormParamsTest methodsFor: 'running' stamp: 'AttilaMagyar 11/16/2014 17:07'!setUp	server := Teapot on		POST: '/form' -> [ :req | (req at: #foo), '-', (req at: #bar) ];		exception: TeaNoSuchParam -> 'no such param';		start.! !!TeapotFormParamsTest methodsFor: 'running' stamp: 'AttilaMagyar 7/29/2014 22:34'!tearDown	server stop! !!TeapotFormParamsTest methodsFor: 'tests' stamp: 'AttilaMagyar 8/13/2014 21:01'!testFormParams	| result |	result := ZnEasy post: 'http://localhost:1701/form' data: (ZnApplicationFormUrlEncodedEntity new 		at: 'foo' put: 'abc'; 		at: 'bar' put: '123'; 		yourself).	self assert: result entity string equals: 'abc-123'.! !!TeapotFormParamsTest methodsFor: 'tests' stamp: 'AttilaMagyar 11/16/2014 17:07'!testFormParamsNotFound	| result |	result := ZnEasy post: 'http://localhost:1701/form' data: (ZnApplicationFormUrlEncodedEntity new 		at: 'invalid1' put: 'abc'; 		at: 'invalid2' put: '123'; 		yourself).	self assert: result entity string equals: 'no such param'! !!TeapotFormatTest methodsFor: 'running' stamp: 'AttilaMagyar 10/16/2014 20:45'!setUp	server := Teapot on		GET: '/a' -> [ 4 ]; output: [ :resp :req | ZnResponse ok: (ZnStringEntity text: resp body printStringRoman) ];		GET: 'default' -> 'any';		GET: '/plain' -> 'any'; output: #text;		GET: 'xml' -> 'any'; output: (TeaOutput stringWithContentType: ZnMimeType applicationXml);		start		! !!TeapotFormatTest methodsFor: 'running' stamp: 'AttilaMagyar 7/29/2014 22:37'!tearDown	server stop! !!TeapotFormatTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testArbitraryContentType	self 		assert: (TeaTestClient httpGet: '/xml') contentType 		equals: (ZnMimeType applicationXml charSet: 'utf-8'; yourself)! !!TeapotFormatTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testConverting	self assert: (TeaTestClient httpGetString: '/a') equals: 'IV'.	! !!TeapotFormatTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testDefaultContentTypeIsHtml	self 		assert: (TeaTestClient httpGet: '/default') contentType 		equals: ZnMimeType textHtml! !!TeapotFormatTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testSetsContentType	self 		assert: (TeaTestClient httpGet: '/plain') contentType 		equals: ZnMimeType textPlain! !!TeapotMessageSendTest methodsFor: 'web controller' stamp: 'AttilaMagyar 8/2/2014 19:32'!msg1	^ 'msg1 result'! !!TeapotMessageSendTest methodsFor: 'web controller' stamp: 'AttilaMagyar 8/10/2014 20:56'!msg2Req: req nil: resp	self assert: resp isNil.	^ 'msg2 ', (req at: #param)! !!TeapotMessageSendTest methodsFor: 'web controller' stamp: 'AttilaMagyar 8/2/2014 19:44'!msg3Req: req	^ 'msg3 ', (req at: #param)! !!TeapotMessageSendTest methodsFor: 'running' stamp: 'AttilaMagyar 8/10/2014 20:55'!setUp	server := Teapot on		GET: '/msg1' -> (Send message: #msg1 to: self);		GET: '/msg2/<param>' -> (Send message: #msg2Req:nil: to: self);				GET: '/msg3/<param>' -> (Send message: #msg3Req: to: self);							start.		! !!TeapotMessageSendTest methodsFor: 'running' stamp: 'AttilaMagyar 8/2/2014 19:30'!tearDown	server stop! !!TeapotMessageSendTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testReceivingOneArgKeywordMessage	self assert: (TeaTestClient httpGetString: '/msg3/bar') equals: 'msg3 bar'.! !!TeapotMessageSendTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testReceivingTwoArgsKeywordMessage	self assert: (TeaTestClient httpGetString: '/msg2/foo') equals: 'msg2 foo'.! !!TeapotMessageSendTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testReceivingUnaryMessage	self assert: (TeaTestClient httpGetString: '/msg1') equals: 'msg1 result'.! !!TeapotPathParamTest methodsFor: 'running' stamp: 'AttilaMagyar 8/10/2014 20:15'!setUp	server := Teapot on		GET: '/user/<id>' -> [ :req | '1-', (req at: #id) ];		GET: '/user/<id>/create' -> [ :req | '2-', (req at: #id) ];		GET: '/<id>/<user>' -> [ :req | '3-', (req at: #id) ];						POST: '/user/<id>/create' -> [ :req | '4-', (req at: #id) ];		start.		! !!TeapotPathParamTest methodsFor: 'running' stamp: 'AttilaMagyar 7/29/2014 22:04'!tearDown	server stop! !!TeapotPathParamTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testPlaceholderAtLast	self assert: (TeaTestClient httpGetString: 'user/12') equals: '1-12'	! !!TeapotPathParamTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testPlaceholderFirst	self assert: (TeaTestClient httpGetString: '54/user') equals: '3-54'.	! !!TeapotPathParamTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testPlaceholderInside	self assert: (TeaTestClient httpGetString: 'user/34/create') equals: '2-34'.		! !!TeapotPathParamTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testPlaceholderPost	self assert: (TeaTestClient httpPostString: '/user/789/create') equals: '4-789'.		! !!TeapotQueryParamsTest methodsFor: 'running' stamp: 'AttilaMagyar 8/10/2014 20:15'!setUp	server := Teapot on		GET: '/query' -> [ :req | req at: #foo ];		GET: '/queryopt' -> [ :req | req at: #foo ifAbsent: [ 'default' ] ];				start! !!TeapotQueryParamsTest methodsFor: 'running' stamp: 'AttilaMagyar 7/26/2014 22:56'!tearDown	server stop! !!TeapotQueryParamsTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testDefaultQueryParam	self assert: (TeaTestClient httpGetString: '/queryopt') equals: 'default'.	! !!TeapotQueryParamsTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testQueryParam	self assert: (TeaTestClient httpGetString: '/query?foo=bar') equals: 'bar'.	self assert: (TeaTestClient httpGetString: '/queryopt?foo=baz') equals: 'baz'.! !!TeapotRegexpTest methodsFor: 'running' stamp: 'AttilaMagyar 8/14/2014 21:16'!setUp	server := Teapot on		GET: '/./' asRegex -> [ 'regexp' ];		GET: '\w+(\d)/\d/xxx' asRegex -> [ :req | req at: 1 ];		GET: '/(\d)/([abc]+)/\d/(.*)' asRegex -> [ :req | (req at: 1), (req at: 2), (req at: 3) ];				start! !!TeapotRegexpTest methodsFor: 'running' stamp: 'AttilaMagyar 8/14/2014 20:18'!tearDown	server stop! !!TeapotRegexpTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testCollectingSubexpressions	self assert: (TeaTestClient httpGetString: '/abc3/4/xxx') equals: '3'.		self assert: (TeaTestClient httpGetString: '/1/aabbcc/2/foobar') equals: '1aabbccfoobar'.! !!TeapotRegexpTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testIgnoresQueryParam	self assert: (TeaTestClient httpGetString: '/k/?param=value') equals: 'regexp'.	! !!TeapotRegexpTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testRegexpMatch	self assert: (TeaTestClient httpGetString: 'k/') equals: 'regexp'.	! !!TeapotResponseTest methodsFor: 'running' stamp: 'AttilaNamed 2/28/2015 23:27'!setUp	server := Teapot on		GET: '/test400' -> [ 			TeaResponse badRequest				body: 'malformed input';				headers: { 'my-header' -> 'my-value' } ];		start! !!TeapotResponseTest methodsFor: 'running' stamp: 'AttilaMagyar 9/28/2014 18:27'!tearDown	server stop! !!TeapotResponseTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testReturnsCustomCodeBodyAndHeaders	| response |	response := TeaTestClient httpGet: '/test400'.	self assert: response entity string equals: 'malformed input'.	self assert: response code equals: 400.	self assert: (response headers at: 'my-header') equals: 'my-value'.! !!TeapotReturnResponseTest methodsFor: 'running' stamp: 'AttilaMagyar 8/10/2014 22:05'!setUp	| stream |	stream := ZnStreamingEntity		readFrom: 'direct stream' readStream		usingType: ZnMimeType textHtml		andLength: 'direct stream' size.			server := Teapot on		GET: '/resp1' -> [ :req | ZnResponse ok: (ZnStringEntity text: 'direct response') ];		GET: '/resp2' -> (ZnResponse ok: stream);		GET: '/redirect' -> (ZnResponse redirect: '/redirect_location');		GET: '/redirect_location' -> 'redirected here';		start! !!TeapotReturnResponseTest methodsFor: 'running' stamp: 'AttilaMagyar 8/10/2014 20:39'!tearDown	server stop! !!TeapotReturnResponseTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testDirectStreamResponse	self assert: (TeaTestClient httpGetString: '/resp2') equals: 'direct stream'.	! !!TeapotReturnResponseTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testDirectStringResponse	self assert: (TeaTestClient httpGetString: '/resp1') equals: 'direct response'.	! !!TeapotReturnResponseTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testRedirect	self assert: (TeaTestClient httpGetString: '/redirect') equals: 'redirected here'.	! !!TeapotRouteSetTest methodsFor: 'running' stamp: 'AttilaMagyar 6/16/2015 18:43'!setUp	server := Teapot on		before: { '/secure/*' . '/protected/*' } -> [ :req | req abort: TeaResponse unauthorized ];			GET: {'/a'. '/b'. '/c'} -> 'abc';		POST: { '/x/<param>'. '/y/<param>' } -> [ :req | req at: #param ];		after: { '/a'. '/b' } -> [ :req :resp | resp headers at: 'test' put: 'ab' ];		start.! !!TeapotRouteSetTest methodsFor: 'running' stamp: 'AttilaMagyar 6/16/2015 18:21'!tearDown	server stop! !!TeapotRouteSetTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testMatchesAnyRouteInAfterFilter	| response |	response := TeaTestClient httpGet: '/a'.	self assert: (response headers at: 'test') equals: 'ab'.		response := TeaTestClient httpGet: '/b'.	self assert: (response headers at: 'test') equals: 'ab'.			response := TeaTestClient httpGet: '/c'.	self assert: (response headers at: 'test' ifAbsent: nil) equals: nil.! !!TeapotRouteSetTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testMatchesAnyRouteInBeforeFilter	| response |	response := TeaTestClient httpGet: '/secure/123'.	self assert: response code equals: 401.		response := TeaTestClient httpGet: '/protected/123'.	self assert: response code equals: 401.! !!TeapotRouteSetTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testMatchesAnyRouteInSet	self assert: (TeaTestClient httpGetString: '/a') equals: 'abc'.	self assert: (TeaTestClient httpGetString: '/b') equals: 'abc'.	self assert: (TeaTestClient httpGetString: '/c') equals: 'abc'.! !!TeapotRouteSetTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testMatchesAnyRouteInSetWithParams	self assert: (TeaTestClient httpPostString: '/x/value1') equals: 'value1'.	self assert: (TeaTestClient httpPostString: '/y/value2') equals: 'value2'.	! !!TeapotRoutingTest methodsFor: 'running' stamp: 'AttilaMagyar 4/18/2015 00:09'!setUp	server := Teapot on		GET: '/' -> '1';		GET: '/a' -> '2';		GET: '/a/*/b' -> [ '3' ];		GET: '/*/c' -> [ '4' ];			GET: '/x/y/*' -> [ '5' ];		GET: '/x/*/*/z/*' -> [ '6' ];		any: 'any' -> 'any';		start.		! !!TeapotRoutingTest methodsFor: 'running' stamp: 'AttilaMagyar 7/29/2014 21:59'!tearDown	server stop! !!TeapotRoutingTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!test404 	self assert: (TeaTestClient httpGet: '1/2/3/4') code equals: 404! !!TeapotRoutingTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testAnyMatchesToAnyHttpMethod 	self assert: (TeaTestClient httpGetString: 'any') equals: 'any'. 	self assert: (TeaTestClient httpPostString: 'any') equals: 'any'. 	self assert: (TeaTestClient httpPutString: 'any') equals: 'any'.	 	self assert: (TeaTestClient httpDeleteString: 'any') equals: 'any'.! !!TeapotRoutingTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testMultipleWildcard	self assert: (TeaTestClient httpGetString: 'x/foo/bar/z/baz') equals: '6'.	self assert: (TeaTestClient httpGetString: 'x/foo/bar/z/baz/123') equals: '6'.	! !!TeapotRoutingTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testNoWildcard	self assert: (TeaTestClient httpGetString: '') equals: '1'.	self assert: (TeaTestClient httpGetString: '/a') equals: '2'.		! !!TeapotRoutingTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testWildcardEnd	self assert: (TeaTestClient httpGetString: '/x/y/foo') equals: '5'.		! !!TeapotRoutingTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testWildcardFirst	self assert: (TeaTestClient httpGetString: 'foo/c') equals: '4'	! !!TeapotRoutingTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testWildcardInside	self assert: (TeaTestClient httpGetString: 'a/bar/b') equals: '3'	! !!TeapotStaticFilesTest methodsFor: 'private' stamp: 'AttilaMagyar 8/3/2014 11:14'!createTempHtdocs	| tmpHtdocs |	tmpHtdocs := FileLocator temp asFileReference / 'test_htdocs'.	tmpHtdocs createDirectory.	tmpHtdocs / 'index.html' writeStreamDo: [ :stream | stream nextPutAll: 'static index' ].	tmpHtdocs / 'a.txt' writeStreamDo: [ :stream | stream nextPutAll: 'a' ].	tmpHtdocs / 'b.txt' writeStreamDo: [ :stream | stream nextPutAll: 'static' ].	^ tmpHtdocs! !!TeapotStaticFilesTest methodsFor: 'running' stamp: 'AttilaMagyar 8/3/2014 11:19'!setUp	htdocs := self createTempHtdocs.	server := Teapot on		GET: 'here/are/statics/b.txt' -> 'dynamic';		serveStatic: 'here/are/statics' from: htdocs;		start! !!TeapotStaticFilesTest methodsFor: 'running' stamp: 'AttilaMagyar 8/3/2014 11:16'!tearDown	htdocs deleteAll.	server stop.! !!TeapotStaticFilesTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testDynamicContentServedBeforeStatic	self assert: (TeaTestClient httpGetString: 'here/are/statics/b.txt') equals: 'dynamic'.	! !!TeapotStaticFilesTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testStaticFile	self assert: (TeaTestClient httpGetString: 'here/are/statics/a.txt') equals: 'a'.	! !!TeapotStaticFilesTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testStaticIndexHtml	self assert: (TeaTestClient httpGetString: 'here/are/statics') equals: 'static index'.	! !!TeapotStaticFilesTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testStaticNotFound	self assert: (TeaTestClient httpGet: 'here/are/statics/notfound.txt') code equals: 404.	! !!TeapotStreamingTest methodsFor: 'private' stamp: 'AttilaMagyar 8/8/2014 20:16'!content	^ (ByteArray new: 4096 withAll: 65) asString! !!TeapotStreamingTest methodsFor: 'private' stamp: 'AttilaMagyar 8/8/2014 20:14'!createDownloadableFile	| file |	file := FileLocator temp asFileReference / 'download.file'.	file writeStreamDo: [ :stream | stream nextPutAll: self content ].	^ file! !!TeapotStreamingTest methodsFor: 'private' stamp: 'AttilaMagyar 8/8/2014 20:12'!deleteDownloadableFile	downloadFile delete! !!TeapotStreamingTest methodsFor: 'running' stamp: 'AttilaMagyar 8/10/2014 20:29'!setUp	downloadFile := self createDownloadableFile.	server := Teapot on		GET: '/stream' -> downloadFile readStream;		output: #stream;		start! !!TeapotStreamingTest methodsFor: 'running' stamp: 'AttilaMagyar 8/8/2014 20:11'!tearDown	self deleteDownloadableFile.	server stop.! !!TeapotStreamingTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testStreamingContent	self 		assert: (TeaTestClient httpGet: '/stream') contents asString 		equals: self content	! !!TeapotTeaResponseTest methodsFor: 'running' stamp: 'AttilaNamed 3/1/2015 00:03'!setUp	server := Teapot on		GET: '/ok' -> (TeaResponse ok body: 'tested ok');		GET: '/badrequest' -> [:req | TeaResponse badRequest body: 'Bad Request'];		GET: '/created' -> [:req | TeaResponse created body: 'Created'; location: req url];		GET: '/notallowed' -> [:req | TeaResponse methodNotAllowed ];		GET: '/notfound' -> [:req | TeaResponse notFound ];		GET: '/notmodified' -> [:req | TeaResponse notModified ];		GET: '/redirect' -> (TeaResponse redirect location: '/target');		GET: '/servererror' -> (TeaResponse serverError body: 'tested server error');		GET: '/unauthorized' -> (TeaResponse unauthorized body: 'Unauthorized'; headerName: 'WWW-Authenticate' value: 'tested unauthorized');		start! !!TeapotTeaResponseTest methodsFor: 'running' stamp: 'AttilaMagyar 10/13/2014 19:35'!tearDown	server stop.! !!TeapotTeaResponseTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testBadRequest	| response |	response := TeaTestClient httpGet: '/badrequest'.	self assert: response code equals: 400.	self assert: response entity string equals: 'Bad Request'! !!TeapotTeaResponseTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testCreated	| response |	response := TeaTestClient httpGet: '/created'.	self assert: response code equals: 201.	self assert: response entity string equals: 'Created'.	self assert: (response headers at: 'Location') equals: '/created'.! !!TeapotTeaResponseTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testMethodNotAllowed	| response |	response := TeaTestClient httpGet: '/notallowed'.	self assert: response code equals: 405.! !!TeapotTeaResponseTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testNotFound	| response |	response := TeaTestClient httpGet: '/notfound'.	self assert: response code equals: 404.! !!TeapotTeaResponseTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testNotModified	| response |	response := TeaTestClient httpGet: '/notmodified'.	self assert: response code equals: 304.! !!TeapotTeaResponseTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testOk	| response |	response := TeaTestClient httpGet: '/ok'.	self assert: response code equals: 200.	self assert: response entity string equals: 'tested ok'.! !!TeapotTeaResponseTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testRedirect	| response |	response := TeaTestClient httpGetNoRedirect: '/redirect'.	self assert: response code equals: 302.	self assert: (response headers at: 'Location') equals: '/target'.! !!TeapotTeaResponseTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testServerError	| response |	response := TeaTestClient httpGet: '/servererror'.	self assert: response code equals: 500.	self assert: response entity string equals: 'tested server error'! !!TeapotTeaResponseTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testUnauthorized	| response |	response := TeaTestClient httpGet: '/unauthorized'.	self assert: response code equals: 401.	self assert: response entity string equals: 'Unauthorized'.	self assert: (response headers at: 'WWW-Authenticate') equals: 'tested unauthorized'.! !!TeapotWhenClauseTest methodsFor: 'running' stamp: 'AttilaMagyar 5/8/2015 20:01'!setUp	server := Teapot on		any: '/when' -> 'get'; when: [:req | req method = 'GET'];		any: '/when' -> 'post'; when: [:req | req method = 'POST'];		any: '/when/<p>' -> 'param-dispatch'; when: [:req | (req at: #p) = 'pval'];		any: '/when' -> 'unfiltered';		any: '/never' -> 'never match'; when: [ false ];		before: '/*' -> [:req | 			req abort: (TeaResponse ok body: 'before') ]; 			when: [:req | req relativeUrl path = 'beforeurl' ];		after: '/*' -> [:req :resp | 			resp statusLine: ZnStatusLine ok. 			resp entity: (ZnStringEntity text: 'after') ]; 			when: [:req | req relativeUrl path = 'afterurl' ];		start! !!TeapotWhenClauseTest methodsFor: 'running' stamp: 'AttilaMagyar 5/4/2015 21:23'!tearDown	server stop! !!TeapotWhenClauseTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testDispatchesOnMethodInWhenFilter	self 		assert: (TeaTestClient httpGetString: '/when') 		equals: 'get'.		self 		assert: (TeaTestClient httpPutString: '/when/pval') 		equals: 'param-dispatch'.	self 		assert: (TeaTestClient httpPostString: '/when') 		equals: 'post'.	self 		assert: (TeaTestClient httpDeleteString: '/when') 		equals: 'unfiltered'.			self assert: (TeaTestClient httpGet: '/never') isNotFound.! !!TeapotWhenClauseTest methodsFor: 'tests' stamp: 'AttilaMagyar 10/25/2015 17:07'!testWhenClauseWithBeforeAfterFilter	self 		assert: (TeaTestClient httpGetString: 'beforeurl') 		equals: 'before'.	self 		assert: (TeaTestClient httpGetString: 'afterurl') 		equals: 'after'.! !!TeaTestClient class methodsFor: 'private' stamp: 'AttilaMagyar 4/18/2015 00:06'!httpDeleteString: aString	^ ZnClient new		url: 'http://localhost:1701/', aString;		delete	! !!TeaTestClient class methodsFor: 'private' stamp: 'AttilaMagyar 8/13/2014 21:00'!httpGet: aString	^ ZnEasy get: 'http://localhost:1701/', aString	! !!TeaTestClient class methodsFor: 'private' stamp: 'AttilaMagyar 10/13/2014 19:52'!httpGetNoRedirect: aString	^ ZnClient new		followRedirects: false;		get: 'http://localhost:1701/', aString;				response	! !!TeaTestClient class methodsFor: 'private' stamp: 'AttilaMagyar 7/29/2014 22:07'!httpGetString: aString	^ (self httpGet: aString) entity string	! !!TeaTestClient class methodsFor: 'private' stamp: 'AttilaMagyar 8/13/2014 21:00'!httpPost: aString	^ ZnEasy post: 'http://localhost:1701/', aString data: (ZnEntity text: 'any')	! !!TeaTestClient class methodsFor: 'private' stamp: 'AttilaMagyar 7/29/2014 22:26'!httpPostString: aString	^ (self httpPost: aString) entity string	! !!TeaTestClient class methodsFor: 'private' stamp: 'AttilaMagyar 4/18/2015 00:03'!httpPut: aString	^ ZnEasy put: 'http://localhost:1701/', aString data: (ZnEntity text: 'any')	! !!TeaTestClient class methodsFor: 'private' stamp: 'AttilaMagyar 4/18/2015 00:03'!httpPutString: aString	^ (self httpPut: aString) entity string	! !"Teapot-Tests"!!ConfigurationOfGarage class methodsFor: 'development support' stamp: 'GuillermoPolito 4/16/2015 13:56'!DevelopmentSupport"See the methods in the 'development support' category on the class-side of MetacelloBaseConfiguration. Decide what development support methods you would like to use and copy them the the class-side of your configuration."	<apiDocumentation>! !!ConfigurationOfGarage class methodsFor: 'private' stamp: 'GuillermoPolito 4/16/2015 13:56'!baseConfigurationClassIfAbsent: aBlock	^Smalltalk		at: #MetacelloBaseConfiguration		ifAbsent: [ 			self ensureMetacelloBaseConfiguration.			Smalltalk at: #MetacelloBaseConfiguration ifAbsent: aBlock ].! !!ConfigurationOfGarage class methodsFor: 'catalog' stamp: 'EstebanMaringolo 5/2/2016 22:34'!catalogChangeLog	^ 'v0.5.0 [01.05.2016]: Temporarly drop support for SQLite due to changes in the FFI in Pharo 5.0'! !!ConfigurationOfGarage class methodsFor: 'catalog' stamp: 'EstebanMaringolo 4/29/2016 12:42'!catalogContactInfo	^ 'Guillermo Polito'! !!ConfigurationOfGarage class methodsFor: 'catalog' stamp: 'EstebanMaringolo 4/29/2016 12:40'!catalogDescription	^ 'Garage is the relational database driver for Pharo. Garage provides a common API to connect with several database servers in a coherent way (JDBC like). Along with Garage, we provide implementations of several database drivers.'! !!ConfigurationOfGarage class methodsFor: 'catalog' stamp: 'EstebanMaringolo 5/2/2016 21:59'!catalogKeyClassesAndExample	^ '1. Getting a ConnectionThe Garage database driver supports the creation of a connection through connection strings.connection := GADriver fromConnectionString:	''mysql://localhost:5432/sodbxtest?&user=sodbxtest&password=sodbxtest''.Connection strings are URL styled:    the schema (http, ftp, etc.) is the database driver id (we will talk about it later). In this example our schema is mysql.    host, port and database are the address of your database server    the query-string allows us to put additional information such as connection credentials. the key user is followed by the database user to login and the key password by its password.driver://host:port/database?key=value&key2=value2Which are the drivers I have? To know which are the available drivers you have, you can ask it to the driver class using the #availableDrivers message.2. Establishing connectionInitially and to avoid surprises, a database connection is not connected to the database. You can check if a connection is connected at any time during the life of the connection using the isConnected message.connection isConnected.	" => true/false"To activate the connection, we can send the connect message to it. If everything is allright (the database is available, username and passwords are correct) and the connection succedded we will receive no error. Instead, if a failure happened while trying to stablish the connection, it will raise an exception. Stablising manually the connection is useful to those users that want to parametrize the connection between its creation and its connection to the database. We will talk in more detail about connection settings later.connection connect.However, for those users that do not need to set manually parameters, he can use a shortcut that creates the connection and connects it in only one step.connection := GADriver connectToConnectionString: 	''mysql://localhost:3306/sodbxtest?user=sodbxtest&password=sodbxtest''.3. Sending a QueryOnce a connection is available, we can send queries and statements to it for their execution. Here we will only see a simple query, using the execute message. We will describe in details how queries and their results are managed later.connection execute: ''CREATE TABLE CATS (	name varchar(50),	owner varchar(50))''.connection execute: ''SELECT * FROM CATS''.Executing a correct query will return an according result: a select query will answer a result with rows, other statements will return a result with a summary of the action they did (e.g., an insert or update will return the amount of modified rows). Executing a wrong query will throw an exception explaining the problem. For example, a query with incorrect syntax will fail and tell us where is the syntax problem; querying an unexistent table will throw an error saying so. We will dive later into the expected kind of results.4. Closing the connectionDatabase servers allow a limited number of simultaneous connections. If too many connections are open the server will start refusing new connections. To avoid these problems we have to close unused connections. Closing an unused connection will free used resources both in our Pharo image and in the database server. We can close manually a database connection by sending it the close message.connection close.Garage provides also the automatic closure of connections on garbage collection. That is, when a database connection object is being garbage collected, the connection will be automatically closed. To allow a database connection to be automatically collected, we must release all references to it. We must not keep references to a connection from any of our objects.'! !!ConfigurationOfGarage class methodsFor: 'catalog' stamp: 'EstebanMaringolo 4/29/2016 12:39'!catalogKeywords	^ #(database drivers api)! !!ConfigurationOfGarage class methodsFor: 'private' stamp: 'GuillermoPolito 4/16/2015 13:56'!ensureMetacello	(self baseConfigurationClassIfAbsent: []) ensureMetacello! !!ConfigurationOfGarage class methodsFor: 'private' stamp: 'GuillermoPolito 4/16/2015 13:56'!ensureMetacelloBaseConfiguration	Smalltalk		at: #MetacelloBaseConfiguration		ifAbsent: [ 			| repository version |			repository := MCHttpRepository location: 'http://seaside.gemstone.com/ss/metacello' user: '' password: ''.			repository				versionReaderForFileNamed: 'Metacello-Base-DaleHenrichs.2.mcz'				do: [ :reader | 					version := reader version.					version load.					version workingCopy repositoryGroup addRepository: repository ] ]! !!ConfigurationOfGarage class methodsFor: 'metacello tool support' stamp: 'GuillermoPolito 4/16/2015 13:56'!isMetacelloConfig	"Answer true and the Metacello tools will operate on you"		^true! !!ConfigurationOfGarage class methodsFor: 'loading' stamp: 'GuillermoPolito 4/16/2015 13:56'!load	"Load the #stable version defined for this platform. The #stable version is the version that is recommended to be used on this platform."	"self load"	<apiDocumentation>	^(self project version: #stable) load! !!ConfigurationOfGarage class methodsFor: 'loading' stamp: 'GuillermoPolito 4/16/2015 13:56'!loadBleedingEdge	"Load the latest versions of the mcz files defined for this project. It is not likely that the #bleedingEdge has been tested."	"self loadBleedingEdge"	<apiDocumentation>	^(self project version: #bleedingEdge) load! !!ConfigurationOfGarage class methodsFor: 'loading' stamp: 'GuillermoPolito 4/16/2015 13:56'!loadDevelopment	"Load the #development version defined for this platform. The #development version will change over time and is not expected to be stable."	"self loadDevelopment"	<apiDocumentation>	^(self project version: #development) load! !!ConfigurationOfGarage class methodsFor: 'accessing' stamp: 'GuillermoPolito 4/16/2015 13:56'!project	^self new project! !!ConfigurationOfGarage class methodsFor: 'development support' stamp: 'GuillermoPolito 4/16/2015 13:56'!validate	"Check the configuration for Errors, Critical Warnings, and Warnings (see class comment for MetacelloMCVersionValidator for more information). 	Errors identify specification issues that will result in unexpected behaviour when you load the configuration. 	Critical Warnings identify specification issues that may result in unexpected behavior when you load the configuration.	Warnings identify specification issues that are technically correct, but are worth take a look at."	"self validate"	<apiDocumentation>	self ensureMetacello.	^ ((Smalltalk at: #MetacelloToolBox) validateConfiguration: self debug: #() recurse: false) explore! !!ConfigurationOfGarage methodsFor: 'baselines' stamp: 'GuillermoPolito 5/7/2015 11:19'!baseline01: spec	<version: '0.1-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec repository: 'http://www.smalltalkhub.com/mc/DBXTalk/Garage/main'.		spec 			project: 'TalkFFIRuntime' with: [				spec					className: #ConfigurationOfTalkFFI;					versionString: '1.3.1';					loads: #('Runtime' );					repository: 'http://www.smalltalkhub.com/mc/CipT/TalkFFI/main' ];			project: 'Postgres' with: [				spec					className: #ConfigurationOfPostgresV2;					versionString: #'bleedingEdge';					repository: 'http://smalltalkhub.com/mc/DBXTalk/PostgresV2Driver/main/' ].		spec 			package: 'Garage';			package: 'Garage-OpenDBX' with: [				spec requires: #('TalkFFIRuntime' 'Garage' ). ];			package: 'Garage-Mysql' with: [				spec requires: #('Garage' ). ];			package: 'Garage-Postgres' with: [				spec requires: #('Postgres' 'Garage' ). ];			package: 'Garage-Sqlite3' with: [				spec requires: #('Garage' ). ].		spec 			group: 'default' with: #('ALL' );			group: 'opendbx' with: #('Garage-OpenDBX' );			group: 'mysql' with: #('Garage-Mysql' );			group: 'postgres' with: #('Garage-Postgres' );			group: 'pgsqlV2' with: #('Garage-Postgres' );			group: 'postgresV2' with: #('Garage-Postgres' ). ].! !!ConfigurationOfGarage methodsFor: 'baselines' stamp: 'GuillermoPolito 5/13/2015 13:47'!baseline02: spec	<version: '0.2-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec repository: 'http://www.smalltalkhub.com/mc/DBXTalk/Garage/main'.		spec 			project: 'TalkFFIRuntime' with: [				spec					className: #ConfigurationOfTalkFFI;					versionString: '1.3.1';					loads: #('Runtime' );					repository: 'http://www.smalltalkhub.com/mc/CipT/TalkFFI/main' ];			project: 'JSON' with: [				spec					className: #ConfigurationOfJSON;					versionString: '1.1';					repository: 'http://smalltalkhub.com/mc/PharoExtras/JSON/main/' ].		spec 			package: 'Garage';			package: 'Garage-OpenDBX' with: [				spec requires: #('TalkFFIRuntime' 'Garage' ). ];			package: 'Garage-Mysql' with: [				spec requires: #('Garage' ). ];			package: 'Garage-Postgres' with: [				spec requires: #('Garage' 'JSON' ). ];			package: 'Garage-Sqlite3' with: [				spec requires: #('Garage' ). ].		spec 			group: 'default' with: #('ALL' );			group: 'opendbx' with: #('Garage-OpenDBX' );			group: 'mysql' with: #('Garage-Mysql' );			group: 'sqlite3' with: #('Garage-Sqlite3' );			group: 'pgsqlV2' with: #('Garage-Postgres' );			group: 'postgresV2' with: #('Garage-Postgres' ). ].! !!ConfigurationOfGarage methodsFor: 'baselines' stamp: 'EstebanMaringolo 5/3/2016 22:26'!baseline03: spec	<version: '0.3-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec repository: 'http://www.smalltalkhub.com/mc/DBXTalk/Garage/main'.		spec 			project: 'JSON' with: [				spec					className: #ConfigurationOfJSON;					versionString: '1.1';					repository: 'http://smalltalkhub.com/mc/PharoExtras/JSON/main/' ].		spec 			package: 'Garage';			package: 'Garage-Mysql' with: [ spec requires: #('Garage' ) ];			package: 'Garage-Sqlite3' with: [spec requires: #('Garage' )];			package: 'Garage-Postgres' with: [spec requires: #('Garage' 'JSON' )].		spec 			group: 'default' with: #('ALL' );			group: 'mysql' with: #('Garage-Mysql' );			group: 'sqlite3' with: #('Garage-Sqlite3' );						group: 'pgsqlV2' with: #('Garage-Postgres' );			group: 'postgresV2' with: #('Garage-Postgres' ) ].! !!ConfigurationOfGarage methodsFor: 'accessing' stamp: 'GuillermoPolito 4/16/2015 13:56'!customProjectAttributes	 "Edit to return a collection of any custom attributes e.g. for conditional loading: Array with: #'Condition1' with: #'Condition2.	For more information see: http://code.google.com/p/metacello/wiki/CustomProjectAttrributes"	^ #().! !!ConfigurationOfGarage methodsFor: 'symbolic versions' stamp: 'VincentBlondeau 11/25/2016 11:50'!development: spec	<symbolicVersion: #'development'>	spec for: #'pharo4.x' version: '0.2-baseline'.	spec for: #'pharo5.x' version: '0.3-baseline'.		spec for: #'common' version: '0.3-baseline'.	! !!ConfigurationOfGarage methodsFor: 'accessing' stamp: 'GuillermoPolito 4/16/2015 13:56'!project	^ project ifNil: [ 		"Bootstrap Metacello if it is not already loaded"		(self class baseConfigurationClassIfAbsent: []) ensureMetacello.		"Construct Metacello project"		project := MetacelloMCProject new projectAttributes: self customProjectAttributes. 		(Smalltalk at: #MetacelloVersionConstructor) on: self project: project.		project loadType: #linear. "change to #atomic if desired"		project ]! !!ConfigurationOfGarage methodsFor: 'symbolic versions' stamp: 'EstebanMaringolo 5/3/2016 23:04'!release1: spec	<symbolicVersion: #'release1'>	spec for: #'common' version: '0.2'.! !!ConfigurationOfGarage methodsFor: 'symbolic versions' stamp: 'EstebanMaringolo 5/3/2016 23:05'!release2: spec	<symbolicVersion: #'release2'>	spec for: #'common' version: '0.5'.! !!ConfigurationOfGarage methodsFor: 'symbolic versions' stamp: 'EstebanMaringolo 5/3/2016 23:05'!stable: spec	<symbolicVersion: #'stable'>	spec for: #'pharo4.x' version: #'release1'.	spec for: #'pharo5.x' version: #'release2'.! !!ConfigurationOfGarage methodsFor: 'versions' stamp: 'GuillermoPolito 5/7/2015 10:50'!version01: spec	<version: '0.1' imports: #('0.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.1First alpha version: - connection - transactions  - statements - basic encoding - lots of testsSupported drivers - postgresql v2 - mysql - opendbx - sqlite3'.		spec author: 'GuillermoPolito'.		spec timestamp: '5/7/2015 10:47'.		spec 			project: 'TalkFFIRuntime' with: '1.3.1';			project: 'Postgres' with: '2.5'.		spec 			package: 'Garage' with: 'Garage-GuillermoPolito.44';			package: 'Garage-OpenDBX' with: 'Garage-OpenDBX-GuillermoPolito.14';			package: 'Garage-Mysql' with: 'Garage-Mysql-GuillermoPolito.22';			package: 'Garage-Postgres' with: 'Garage-Postgres-GuillermoPolito.14';			package: 'Garage-Sqlite3' with: 'Garage-Sqlite3-GuillermoPolito.17'. ].! !!ConfigurationOfGarage methodsFor: 'versions' stamp: 'GuillermoPolito 5/14/2015 20:32'!version02: spec	<version: '0.2' imports: #('0.2-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.2Version for GarageGlorp - added row abstraction - isResultSet testing method - new connection string url parser to handle unix and windows like paths (sqlite)'.		spec author: 'GuillermoPolito'.		spec timestamp: '5/14/2015 20:31'.		spec 			project: 'TalkFFIRuntime' with: '1.3.1';			project: 'JSON' with: '1.1'.		spec 			package: 'Garage' with: 'Garage-GuillermoPolito.50';			package: 'Garage-OpenDBX' with: 'Garage-OpenDBX-GuillermoPolito.20';			package: 'Garage-Mysql' with: 'Garage-Mysql-GuillermoPolito.24';			package: 'Garage-Postgres' with: 'Garage-Postgres-GuillermoPolito.18';			package: 'Garage-Sqlite3' with: 'Garage-Sqlite3-GuillermoPolito.21'. ].! !!ConfigurationOfGarage methodsFor: 'versions' stamp: 'EstebanMaringolo 12/10/2015 11:07'!version03: spec	<version: '0.3' imports: #('0.2-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.3'.		spec author: 'EstebanMaringolo'.		spec timestamp: '12/10/2015 11:03'.		spec 			project: 'TalkFFIRuntime' with: '1.3.1';			project: 'JSON' with: '1.1'.		spec 			package: 'Garage' with: 'Garage-GuillermoPolito.50';			package: 'Garage-OpenDBX' with: 'Garage-OpenDBX-EstebanMaringolo.23';			package: 'Garage-Mysql' with: 'Garage-Mysql-GuillermoPolito.24';			package: 'Garage-Postgres' with: 'Garage-Postgres-GuillermoPolito.18';			package: 'Garage-Sqlite3' with: 'Garage-Sqlite3-GuillermoPolito.21'. ].	! !!ConfigurationOfGarage methodsFor: 'versions' stamp: 'usmanbhatti 2/26/2016 13:26'!version04: spec	<version: '0.4' imports: #('0.2-baseline')>	spec		for: #common		do:			[ spec blessing: #stable.			spec description: 'version 0.4'.			spec author: 'EstebanMaringolo'.			spec timestamp: '12/10/2015 16:52'.			spec				project: 'TalkFFIRuntime' with: '1.3.1';				project: 'JSON' with: '1.1'.			spec				package: 'Garage' with: 'Garage-GuillermoPolito.51';				package: 'Garage-OpenDBX' with: 'Garage-OpenDBX-VincentBlondeau.24';				package: 'Garage-Mysql' with: 'Garage-Mysql-GuillermoPolito.24';				package: 'Garage-Postgres' with: 'Garage-Postgres-EstebanMaringolo.19';				package: 'Garage-Sqlite3' with: 'Garage-Sqlite3-EstebanMaringolo.23' ]! !!ConfigurationOfGarage methodsFor: 'versions' stamp: 'EstebanMaringolo 5/4/2016 00:47'!version05: spec	<version: '0.5' imports: #('0.3-baseline')>	spec		for: #common		do:			[ spec blessing: #stable.			spec description: 'version 0.5, drops support for untested FFI Drivers'.			spec author: 'EstebanMaringolo'.			spec timestamp: '05/01/2016 12:00'.			spec				project: 'JSON' with: '1.1'.			spec				package: 'Garage' with: 'Garage-VincentBlondeau.52';				package: 'Garage-Mysql' with: 'Garage-Mysql-GuillermoPolito.24';				package: 'Garage-Postgres' with: 'Garage-Postgres-VincentBlondeau.22';				package: 'Garage-Sqlite3' with: 'Garage-Sqlite3-GuillermoPolito.26' ]! !"ConfigurationOfGarage"!----QUIT----2017-04-30T16:13:49.17144+02:00 Pharo5.0.image priorSource: 469968!!ConfigurationOfPostgresV2 commentStamp: 'SvenVanCaekenberghe 8/31/2014 12:02' prior: 0!I am ConfigurationOfPostgresV2, the Metacello configuration of the PostgreSQL database driver.PostgresV2 implements version 2 of the PG wire protocol over TCP.!!ConfigurationOfPostgresV2 class methodsFor: 'private' stamp: 'LT 2/18/2011 13:23'!bootstrapPackage: aString from: aPath 	| repository version |	repository := MCHttpRepository				location: aPath				user: ''				password: ''.	repository		versionReaderForFileNamed: aString , '.mcz'		do: [:reader | 			version := reader version.			version load.			version workingCopy repositoryGroup addRepository: repository]! !!ConfigurationOfPostgresV2 class methodsFor: 'private' stamp: 'LT 2/18/2011 13:23'!ensureMetacello	"Bootstrap Gofer (if necessary), load latest mcz file for ConfigurationOfMetacello (using old 	 Gofer API), then load the latest version of Metacello itself."	Smalltalk at: #MetacelloProject ifAbsent: [ | error |		"list of repositories to try, in case primary repository is not accessible"		(Array 			with: 'http://www.squeaksource.com/MetacelloRepository' 			with: 'http://seaside.gemstone.com/ss/metacello') do: [:repositoryUrl |				([					Smalltalk at: #Gofer ifAbsent: [					"Current version of Gofer from which to bootstrap - as of 1.0-beta.21"						self bootstrapPackage: 'Gofer-Core-lr.115' from: repositoryUrl ].					Smalltalk at: #Gofer ifPresent: [:goferClass | | gofer |						gofer := goferClass new							url: repositoryUrl;							yourself.						[ gofer addPackage: 'ConfigurationOfMetacello' ] on: Warning do: [:ex | ex resume ].						gofer load ]]							on: Error							do: [ :ex |								error := ex.								Transcript 									cr; 									show: 'failed ensureMetacello: ';									show: ex description printString;									show: '...retrying'.								"try again"								ex return: nil ]) ~~ nil					ifTrue: [						"load 'default' group of Metacello"						(Smalltalk at: #ConfigurationOfMetacello) perform: #load.						^self ]].		"shouldn't get here unless the load failed ... throw an error"		self error: 'retry with alternate repository failed: ', error description printString ]! !!ConfigurationOfPostgresV2 class methodsFor: 'metacello tool support' stamp: 'LT 2/18/2011 13:24'!isMetacelloConfig	"Answer true and the Metacello tools will operate on you"		^true! !!ConfigurationOfPostgresV2 class methodsFor: 'metacello tool support' stamp: 'LT 2/18/2011 13:24'!lastMetacelloVersionLoad	"Answer the last version loaded and the list of packages loaded for that version."	LastVersionLoad == nil ifTrue: [ LastVersionLoad := nil -> 'default' ].	^LastVersionLoad! !!ConfigurationOfPostgresV2 class methodsFor: 'loading' stamp: 'LT 2/18/2011 13:14'!load	"self load"	^self project latestVersion load! !!ConfigurationOfPostgresV2 class methodsFor: 'metacello tool support' stamp: 'LT 2/18/2011 13:24'!metacelloVersion: versionString loads: anArrayOrString	"Stash the last version loaded and the list of packages loaded for that version. The list	 of packages will be used by the tools when doing 'Load Package Version'"	LastVersionLoad := versionString -> anArrayOrString! !!ConfigurationOfPostgresV2 class methodsFor: 'accessing' stamp: 'LT 2/18/2011 13:14'!project	^self new project! !!ConfigurationOfPostgresV2 methodsFor: 'baselines' stamp: 'MarianoMartinezPeck 11/9/2011 11:05'!baseline10: spec 	<version: '1.0-baseline'>        	spec for: #squeakCommon do: [		spec 			blessing: #baseline;               	description: '1.0 baseline for PostgresV2';			repository: 'http://www.squeaksource.com/PostgresV2'.		spec package: 'PostgresV2'.		].		spec for: #squeak do: [		spec package: 'Cryptography' with: 				[ spec repository: 'http://www.squeaksource.com/Cryptography' ]		]! !!ConfigurationOfPostgresV2 methodsFor: 'baselines' stamp: 'MarianoMartinezPeck 6/10/2013 13:05'!baseline20: spec 	<version: '2.0-baseline'>        	spec for: #squeakCommon do: [		spec 			blessing: #baseline;               	description: '2.0 baseline for PostgresV2 in the new SmalltalkHub repository';			repository: 'http://smalltalkhub.com/mc/PharoExtras/PostgresV2/main'.		spec package: 'PostgresV2'.		].		spec for: #squeak do: [		spec package: 'Cryptography' with: 				[ spec repository: 'http://www.squeaksource.com/Cryptography' ]		]! !!ConfigurationOfPostgresV2 methodsFor: 'baselines' stamp: 'EstebanMaringolo 9/4/2014 16:17'!baseline24: spec 	<version: '2.4-baseline'> 	spec for: #pharo do: [ 		spec project: 'JSON' with: [ 			spec 				className: #ConfigurationOfJSON;				repository: 'http://smalltalkhub.com/mc/PharoExtras/JSON/main';				versionString: #stable.		 ].			spec package: #PostgresV2 with: [ spec requires: #('JSON') ].	].       	spec for: #squeakCommon do: [		spec 			blessing: #baseline;               	description: '2.0 baseline for PostgresV2 in the new SmalltalkHub repository';			repository: 'http://smalltalkhub.com/mc/PharoExtras/PostgresV2/main'.		spec package: 'PostgresV2'.		].		spec for: #squeak do: [		spec package: 'Cryptography' with: 				[ spec repository: 'http://www.squeaksource.com/Cryptography' ]		]! !!ConfigurationOfPostgresV2 methodsFor: 'symbolic versions' stamp: 'EstebanMaringolo 9/4/2014 16:21'!development: spec 	<symbolicVersion: #development>		spec for: #'pharo3.0.x' version: '2.4'.! !!ConfigurationOfPostgresV2 methodsFor: 'accessing' stamp: 'LT 2/18/2011 13:00'!project	^ project ifNil: [ | constructor |		"Bootstrap Metacello if it is not already loaded"		self class ensureMetacello.		"Construct Metacello project"		constructor := (Smalltalk at: #MetacelloVersionConstructor) on: self.		project := constructor project.		project loadType: #linear. "change to #atomic if desired"		project ]! !!ConfigurationOfPostgresV2 methodsFor: 'symbolic versions' stamp: 'SvenVanCaekenberghe 8/31/2014 12:01'!stable: spec 	<symbolicVersion: #stable>		spec for: #'pharo3.0.x' version: '2.3'.! !!ConfigurationOfPostgresV2 methodsFor: 'versions' stamp: 'MarianoMartinezPeck 11/9/2011 11:19'!version10: spec	<version: '1.0' imports: #('1.0-baseline')>		spec for: #common do: [		spec blessing: #release.		spec package: 'PostgresV2' with: 'PostgresV2-YanniChiu.25'.	].	spec for:  #squeak do: [		spec package: 'Cryptography' with: 'Cryptography-mtf.36'.		]! !!ConfigurationOfPostgresV2 methodsFor: 'versions' stamp: 'MarianoMartinezPeck 5/27/2013 12:04'!version11: spec	<version: '1.1' imports: #('1.0-baseline')>		spec for: #common do: [		spec blessing: #release.		spec package: 'PostgresV2' with: 'PostgresV2-SvenVanCaekenberghe.28'.	].	spec for:  #squeak do: [		spec package: 'Cryptography' with: 'Cryptography-mtf.36'.		]! !!ConfigurationOfPostgresV2 methodsFor: 'versions' stamp: 'MarianoMartinezPeck 6/10/2013 13:06'!version21: spec	<version: '2.1' imports: #('2.0-baseline')>		spec for: #common do: [		spec blessing: #release.		spec package: 'PostgresV2' with: 'PostgresV2-SvenVanCaekenberghe.28'.	].	spec for:  #squeak do: [		spec package: 'Cryptography' with: 'Cryptography-mtf.36'.		]! !!ConfigurationOfPostgresV2 methodsFor: 'versions' stamp: 'vb 1/19/2015 15:01'!version22: spec	<version: '2.2' imports: #('2.0-baseline')>		spec for: #common do: [		spec blessing: #release.		spec package: 'PostgresV2' with: 'PostgresV2-GuillermoPolito.31'.	].	spec for:  #squeak do: [		spec package: 'Cryptography' with: 'Cryptography-mtf.36'.		]! !!ConfigurationOfPostgresV2 methodsFor: 'versions' stamp: 'EstebanMaringolo 5/19/2014 13:07'!version23: spec	<version: '2.3' imports: #('2.0-baseline')>		spec for: #common do: [		spec blessing: #release.		spec package: 'PostgresV2' with: 'PostgresV2-EstebanMaringolo.32'.	].	spec for:  #squeak do: [		spec package: 'Cryptography' with: 'Cryptography-mtf.36'.		]! !!ConfigurationOfPostgresV2 methodsFor: 'versions' stamp: 'vb 1/19/2015 15:15'!version24: spec	<version: '2.4' imports: #('2.4-baseline')>		spec for: #common do: [		spec description: 'Adds support to JSON native datatype available from PostgreSQL 9.2'.		spec author: 'EstebanMaringolo'.		spec blessing: #development.		spec project:  'JSON' with: '1.0'.		spec package: 'PostgresV2' with: 'PostgresV2-EstebanMaringolo.33'.	].	spec for:  #squeak do: [		spec package: 'Cryptography' with: 'Cryptography-mtf.36'.		]! !!ConfigurationOfPostgresV2 methodsFor: 'versions' stamp: 'GuillermoPolito 5/7/2015 10:50'!version25: spec	<version: '2.5' imports: #('2.4-baseline')>		spec for: #common do: [		spec description: 'Adds support to JSON native datatype available from PostgreSQL 9.2'.		spec author: 'EstebanMaringolo'.		spec blessing: #development.		spec project:  'JSON' with: '1.1'.		spec package: 'PostgresV2' with: 'PostgresV2-EstebanMaringolo.33'.	].	spec for:  #squeak do: [		spec package: 'Cryptography' with: 'Cryptography-mtf.36'.		]! !"ConfigurationOfPostgresV2"!!ConfigurationOfTalkFFI class methodsFor: 'development support' stamp: 'CiprianTeodorov 12/27/2012 14:25'!DevelopmentSupport"See the methods in the 'development support' category on the class-side of MetacelloBaseConfiguration. Decide what development support methods you would like to use and copy them the the class-side of your configuration."	<apiDocumentation>! !!ConfigurationOfTalkFFI class methodsFor: 'private' stamp: 'CiprianTeodorov 12/27/2012 14:25'!baseConfigurationClassIfAbsent: aBlock	^Smalltalk		at: #MetacelloBaseConfiguration		ifAbsent: [ 			self ensureMetacelloBaseConfiguration.			Smalltalk at: #MetacelloBaseConfiguration ifAbsent: aBlock ].! !!ConfigurationOfTalkFFI class methodsFor: 'private' stamp: 'CiprianTeodorov 12/27/2012 14:25'!ensureMetacello	(self baseConfigurationClassIfAbsent: []) ensureMetacello! !!ConfigurationOfTalkFFI class methodsFor: 'private' stamp: 'CiprianTeodorov 12/27/2012 14:25'!ensureMetacelloBaseConfiguration	Smalltalk		at: #MetacelloBaseConfiguration		ifAbsent: [ 			| repository version |			repository := MCHttpRepository location: 'http://seaside.gemstone.com/ss/metacello' user: '' password: ''.			repository				versionReaderForFileNamed: 'Metacello-Base-DaleHenrichs.2.mcz'				do: [ :reader | 					version := reader version.					version load.					version workingCopy repositoryGroup addRepository: repository ] ]! !!ConfigurationOfTalkFFI class methodsFor: 'metacello tool support' stamp: 'CiprianTeodorov 12/27/2012 14:25'!isMetacelloConfig	"Answer true and the Metacello tools will operate on you"		^true! !!ConfigurationOfTalkFFI class methodsFor: 'loading' stamp: 'CiprianTeodorov 12/27/2012 14:25'!load	"Load the #stable version defined for this platform. The #stable version is the version that is recommended to be used on this platform."	"self load"	<apiDocumentation>	^(self project version: #stable) load! !!ConfigurationOfTalkFFI class methodsFor: 'loading' stamp: 'CiprianTeodorov 12/27/2012 14:25'!loadBleedingEdge	"Load the latest versions of the mcz files defined for this project. It is not likely that the #bleedingEdge has been tested."	"self loadBleedingEdge"	<apiDocumentation>	^(self project version: #bleedingEdge) load! !!ConfigurationOfTalkFFI class methodsFor: 'loading' stamp: 'CiprianTeodorov 12/27/2012 14:25'!loadDevelopment	"Load the #development version defined for this platform. The #development version will change over time and is not expected to be stable."	"self loadDevelopment"	<apiDocumentation>	^(self project version: #development) load! !!ConfigurationOfTalkFFI class methodsFor: 'accessing' stamp: 'CiprianTeodorov 12/27/2012 14:25'!project	^self new project! !!ConfigurationOfTalkFFI class methodsFor: 'development support' stamp: 'CiprianTeodorov 12/27/2012 14:25'!validate	"Check the configuration for Errors, Critical Warnings, and Warnings (see class comment for MetacelloMCVersionValidator for more information). 	Errors identify specification issues that will result in unexpected behaviour when you load the configuration. 	Critical Warnings identify specification issues that may result in unexpected behavior when you load the configuration.	Warnings identify specification issues that are technically correct, but are worth take a look at."	"self validate"	<apiDocumentation>	self ensureMetacello.	^ ((Smalltalk at: #MetacelloToolBox) validateConfiguration: self debug: #() recurse: false) explore! !!ConfigurationOfTalkFFI methodsFor: 'baselines' stamp: 'CiprianTeodorov 1/6/2013 14:13'!baseline10: spec	<version: '1.0-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec repository: 'http://smalltalkhub.com/mc/CipT/TalkFFI/main'.		spec 			project: 'NativeBoost' with: [				spec					className: 'ConfigurationOfNativeBoost';					versionString: #'1.9';					repository: 'http://www.squeaksource.com/NativeBoost' ];			project: 'LibClang' with: [				spec					className: 'ConfigurationOfLibClang';					versionString: #'bleedingEdge';					repository: 'http://smalltalkhub.com/mc/CipT/LibClang/main' ].		spec 			package: 'TalkFFI-Runtime' with: [				spec requires: #('NativeBoost' ). ];			package: 'TalkFFI-AST-Core';			package: 'TalkFFI-AST-Generation' with: [				spec requires: #('LibClang' 'TalkFFI-AST-Core' );				postLoadDoIt: #postloadForASTGeneration ];			package: 'TalkFFI-SmalltalkBinding' with: [				spec requires: #('TalkFFI-AST-Core' ). ];			package: 'TalkFFI-NativeBoostBinding' with: [				spec requires: #('NativeBoost' 'TalkFFI-SmalltalkBinding' ). ].		spec 			group: 'default' with: #('Core' );			group: 'Core' with: #('TalkFFI-Runtime' 'TalkFFI-AST-Core' 'TalkFFI-AST-Generation' 'TalkFFI-SmalltalkBinding' 'TalkFFI-NativeBoostBinding' );			group: 'Runtime' with: #('TalkFFI-Runtime' ). ].! !!ConfigurationOfTalkFFI methodsFor: 'baselines' stamp: 'CiprianTeodorov 1/31/2013 19:55'!baseline11: spec	<version: '1.1-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec repository: 'http://smalltalkhub.com/mc/CipT/TalkFFI/main'.		spec 			project: 'NativeBoost' with: [				spec					className: 'ConfigurationOfNativeBoost';					versionString: #'2.0';					repository: 'http://www.smalltalkhub.com/mc/Pharo/NativeBoost/main' ];			project: 'LibClang' with: [				spec					className: 'ConfigurationOfLibClang';					versionString: #'bleedingEdge';					repository: 'http://smalltalkhub.com/mc/CipT/LibClang/main' ].		spec 			package: 'TalkFFI-Runtime' with: [				spec requires: #('NativeBoost' ). ];			package: 'TalkFFI-AST-Core';			package: 'TalkFFI-AST-Generation' with: [				spec requires: #('LibClang' 'TalkFFI-AST-Core' );				postLoadDoIt: #postloadForASTGeneration ];			package: 'TalkFFI-SmalltalkBinding' with: [				spec requires: #('TalkFFI-AST-Core' ). ];			package: 'TalkFFI-NativeBoostBinding' with: [				spec requires: #('NativeBoost' 'TalkFFI-SmalltalkBinding' ). ];			package: 'TalkFFI-Examples' with: [				spec requires: #('TalkFFI-NativeBoostBinding')];			package: 'TalkFFI-Tests' with: [				spec requires: #('TalkFFI-NativeBoostBinding')].		spec 			group: 'default' with: #('Core' );			group: 'Core' with: #('TalkFFI-Runtime' 'TalkFFI-AST-Core' 'TalkFFI-AST-Generation' 'TalkFFI-SmalltalkBinding' 'TalkFFI-NativeBoostBinding' 'TalkFFI-Examples' );			group: 'Runtime' with: #('TalkFFI-Runtime' );			group: 'Tests' with: #('TalkFFI-Tests'). ].! !!ConfigurationOfTalkFFI methodsFor: 'baselines' stamp: 'CiprianTeodorov 4/7/2013 17:32'!baseline12: spec	<version: '1.2-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec repository: 'http://smalltalkhub.com/mc/CipT/TalkFFI/main'.		spec 			project: 'NativeBoost' with: [				spec					className: 'ConfigurationOfNativeBoost';					versionString: #'2.0';					repository: 'http://www.smalltalkhub.com/mc/Pharo/NativeBoost/main' ];			project: 'LibClang' with: [				spec					className: 'ConfigurationOfLibClang';					versionString: #'bleedingEdge';					repository: 'http://smalltalkhub.com/mc/CipT/LibClang/main' ].		spec 			package: 'TalkFFI-Runtime' with: [				spec requires: #('NativeBoost' ). ];			package: 'TalkFFI-Announcements';			package: 'TalkFFI-AST-Core';			package: 'TalkFFI-AST-Generation' with: [				spec requires: #('LibClang' 'TalkFFI-AST-Core' );				postLoadDoIt: #postloadForASTGeneration ];			package: 'TalkFFI-SmalltalkBinding' with: [				spec requires: #('TalkFFI-AST-Core' ). ];			package: 'TalkFFI-NativeBoostBinding' with: [				spec requires: #('NativeBoost' 'TalkFFI-SmalltalkBinding' ). ];			package: 'TalkFFI-Examples' with: [				spec requires: #('TalkFFI-NativeBoostBinding')];			package: 'TalkFFI-Tests' with: [				spec requires: #('TalkFFI-NativeBoostBinding')].		spec 			group: 'default' with: #('Core' );			group: 'Core' with: #('TalkFFI-Runtime' 'TalkFFI-Announcements' 'TalkFFI-AST-Core' 'TalkFFI-AST-Generation' 'TalkFFI-SmalltalkBinding' 'TalkFFI-NativeBoostBinding' 'TalkFFI-Examples' );			group: 'Runtime' with: #('TalkFFI-Runtime' );			group: 'Tests' with: #('TalkFFI-Tests'). ].! !!ConfigurationOfTalkFFI methodsFor: 'baselines' stamp: 'CiprianTeodorov 3/16/2014 22:20'!baseline13: spec	<version: '1.3-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec repository: 'http://smalltalkhub.com/mc/CipT/TalkFFI/main'.		spec 			project: 'LibClang' with: [				spec					className: 'ConfigurationOfLibClang';					versionString: #'bleedingEdge';					repository: 'http://smalltalkhub.com/mc/CipT/LibClang/main' ].		spec 			package: 'TalkFFI-Runtime';			package: 'TalkFFI-Announcements';			package: 'TalkFFI-AST-Core';			package: 'TalkFFI-AST-Generation' with: [				spec requires: #('LibClang' 'TalkFFI-AST-Core' );				postLoadDoIt: #postloadForASTGeneration ];			package: 'TalkFFI-SmalltalkBinding' with: [				spec requires: #('TalkFFI-AST-Core' ). ];			package: 'TalkFFI-NativeBoostBinding' with: [				spec requires: #('TalkFFI-SmalltalkBinding' ). ];			package: 'TalkFFI-Examples' with: [				spec requires: #('TalkFFI-NativeBoostBinding')];			package: 'TalkFFI-Tests' with: [				spec requires: #('TalkFFI-NativeBoostBinding')].		spec 			group: 'default' with: #('Core' );			group: 'Core' with: #('TalkFFI-Runtime' 'TalkFFI-Announcements' 'TalkFFI-AST-Core' 'TalkFFI-AST-Generation' 'TalkFFI-SmalltalkBinding' 'TalkFFI-NativeBoostBinding' 'TalkFFI-Examples' );			group: 'Runtime' with: #('TalkFFI-Runtime' );			group: 'Tests' with: #('TalkFFI-Tests'). ].! !!ConfigurationOfTalkFFI methodsFor: 'baselines' stamp: 'CiprianTeodorov 5/19/2015 23:10'!baseline14: spec	<version: '1.4-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec repository: 'http://smalltalkhub.com/mc/CipT/TalkFFI/main'.		spec 			project: 'LibClang' with: [				spec					className: 'ConfigurationOfLibClang';					versionString: #'developement';					repository: 'http://smalltalkhub.com/mc/CipT/LibClang/main' ].		spec 			package: 'TalkFFI-Runtime';			package: 'TalkFFI-Announcements';			package: 'TalkFFI-AST-Core';			package: 'TalkFFI-AST-Generation' with: [				spec requires: #('LibClang' 'TalkFFI-AST-Core' );				postLoadDoIt: #postloadForASTGeneration ];			package: 'TalkFFI-SmalltalkBinding' with: [				spec requires: #('TalkFFI-AST-Core' ). ];			package: 'TalkFFI-NativeBoostBinding' with: [				spec requires: #('TalkFFI-SmalltalkBinding' ). ];			package: 'TalkFFI-Examples' with: [				spec requires: #('TalkFFI-NativeBoostBinding')];			package: 'TalkFFI-Tests' with: [				spec requires: #('TalkFFI-NativeBoostBinding')].		spec 			group: 'default' with: #('Core' );			group: 'Core' with: #('TalkFFI-Runtime' 'TalkFFI-Announcements' 'TalkFFI-AST-Core' 'TalkFFI-AST-Generation' 'TalkFFI-SmalltalkBinding' 'TalkFFI-NativeBoostBinding' 'TalkFFI-Examples' );			group: 'Runtime' with: #('TalkFFI-Runtime' );			group: 'Tests' with: #('TalkFFI-Tests'). ].! !!ConfigurationOfTalkFFI methodsFor: 'symbolic versions' stamp: 'CiprianTeodorov 5/19/2015 23:10'!development: spec	<symbolicVersion: #'development'>	spec for: #'common' version: '1.4-baseline'.	spec for: #'pharo2.x' version: '1.4'.	spec for: #'pharo3.x' version: '1.5'! !!ConfigurationOfTalkFFI methodsFor: 'post load' stamp: 'CiprianTeodorov 3/3/2013 13:27'!postloadForASTGeneration	(Smalltalk at: #CLPrimaryBinding) initialize.! !!ConfigurationOfTalkFFI methodsFor: 'accessing' stamp: 'CiprianTeodorov 12/27/2012 14:25'!project	^ project ifNil: [ | constructor |		"Bootstrap Metacello if it is not already loaded"		(self class baseConfigurationClassIfAbsent: []) ensureMetacello.		"Construct Metacello project"		constructor := (Smalltalk at: #MetacelloVersionConstructor) on: self.		project := constructor project.		project loadType: #linear. "change to #atomic if desired"		project ]! !!ConfigurationOfTalkFFI methodsFor: 'symbolic versions' stamp: 'GuillermoPolito 9/1/2013 12:53'!stable: spec	<symbolicVersion: #'stable'>	spec for: #'common' version: '1.0'.	spec for: #'pharo2.x' version: '1.3.1'.! !!ConfigurationOfTalkFFI methodsFor: 'versions' stamp: 'CiprianTeodorov 1/6/2013 15:37'!version10: spec	<version: '1.0' imports: #('1.0-baseline' )>	spec for: #'common' do: [		spec blessing: #'development'.		spec description: 'initial version'.		spec author: 'CiprianTeodorov'.		spec timestamp: '12/27/2012 14:26'.		spec 			project: 'NativeBoost' with: '1.9';			project: 'LibClang' with: '1.0'.		spec 			package: 'TalkFFI-Runtime' with: 'TalkFFI-Runtime-CiprianTeodorov.1';			package: 'TalkFFI-AST-Core' with: 'TalkFFI-AST-Core-CiprianTeodorov.1';			package: 'TalkFFI-AST-Generation' with: 'TalkFFI-AST-Generation-CiprianTeodorov.1';			package: 'TalkFFI-SmalltalkBinding' with: 'TalkFFI-SmalltalkBinding-CiprianTeodorov.1';			package: 'TalkFFI-NativeBoostBinding' with: 'TalkFFI-NativeBoostBinding-CiprianTeodorov.4'. ].! !!ConfigurationOfTalkFFI methodsFor: 'versions' stamp: 'CiprianTeodorov 1/6/2013 18:15'!version11: spec	<version: '1.1' imports: #('1.0-baseline' )>	spec for: #'common' do: [		spec blessing: #'development'.		spec description: 'initial pharo 2.0 version'.		spec author: 'CiprianTeodorov'.		spec timestamp: '01/06/2013 15:20'.		spec 			project: 'NativeBoost' with: '1.9';			project: 'LibClang' with: '1.0'.		spec 			package: 'TalkFFI-Runtime' with: 'TalkFFI-Runtime-CiprianTeodorov.1';			package: 'TalkFFI-AST-Core' with: 'TalkFFI-AST-Core-CiprianTeodorov.1';			package: 'TalkFFI-AST-Generation' with: 'TalkFFI-AST-Generation-CiprianTeodorov.1';			package: 'TalkFFI-SmalltalkBinding' with: 'TalkFFI-SmalltalkBinding-CiprianTeodorov.3';			package: 'TalkFFI-NativeBoostBinding' with: 'TalkFFI-NativeBoostBinding-CiprianTeodorov.6'. ].! !!ConfigurationOfTalkFFI methodsFor: 'versions' stamp: 'CiprianTeodorov 1/28/2013 23:03'!version12: spec	<version: '1.2' imports: #('1.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'development'.		spec description: 'development version'.		spec author: 'CiprianTeodorov'.		spec timestamp: '01/06/2013 15:20'.		spec 			project: 'NativeBoost' with: '1.9';			project: 'LibClang' with: '1.1'.		spec 			package: 'TalkFFI-Runtime' with: 'TalkFFI-Runtime-CiprianTeodorov.3';			package: 'TalkFFI-AST-Core' with: 'TalkFFI-AST-Core-CiprianTeodorov.3';			package: 'TalkFFI-AST-Generation' with: 'TalkFFI-AST-Generation-CiprianTeodorov.4';			package: 'TalkFFI-SmalltalkBinding' with: 'TalkFFI-SmalltalkBinding-CiprianTeodorov.8';			package: 'TalkFFI-NativeBoostBinding' with: 'TalkFFI-NativeBoostBinding-CiprianTeodorov.11';			package: 'TalkFFI-Examples' with: 'TalkFFI-Examples-CiprianTeodorov.3'. ].! !!ConfigurationOfTalkFFI methodsFor: 'versions' stamp: 'GuillermoPolito 9/3/2013 09:36'!version131: spec	<version: '1.3.1' imports: #('1.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'development'.		spec description: 'development version'.		spec author: 'CiprianTeodorov'.		spec timestamp: '06/02/2013'.		spec 			project: 'NativeBoost' with: '2.1';			project: 'LibClang' with: '1.2'.		spec 			package: 'TalkFFI-Runtime' with: 'TalkFFI-Runtime-CiprianTeodorov.7';			package: 'TalkFFI-AST-Core' with: 'TalkFFI-AST-Core-CiprianTeodorov.6';			package: 'TalkFFI-AST-Generation' with: 'TalkFFI-AST-Generation-CiprianTeodorov.7';			package: 'TalkFFI-SmalltalkBinding' with: 'TalkFFI-SmalltalkBinding-CiprianTeodorov.12';			package: 'TalkFFI-NativeBoostBinding' with: 'TalkFFI-NativeBoostBinding-CiprianTeodorov.16';			package: 'TalkFFI-Examples' with: 'TalkFFI-Examples-CiprianTeodorov.7'. ].! !!ConfigurationOfTalkFFI methodsFor: 'versions' stamp: 'CiprianTeodorov 3/3/2013 13:23'!version13: spec	<version: '1.3' imports: #('1.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'development'.		spec description: 'development version'.		spec author: 'CiprianTeodorov'.		spec timestamp: '06/02/2013'.		spec 			project: 'NativeBoost' with: '2.1';			project: 'LibClang' with: '1.2'.		spec 			package: 'TalkFFI-Runtime' with: 'TalkFFI-Runtime-CiprianTeodorov.5';			package: 'TalkFFI-AST-Core' with: 'TalkFFI-AST-Core-CiprianTeodorov.6';			package: 'TalkFFI-AST-Generation' with: 'TalkFFI-AST-Generation-CiprianTeodorov.7';			package: 'TalkFFI-SmalltalkBinding' with: 'TalkFFI-SmalltalkBinding-CiprianTeodorov.12';			package: 'TalkFFI-NativeBoostBinding' with: 'TalkFFI-NativeBoostBinding-CiprianTeodorov.16';			package: 'TalkFFI-Examples' with: 'TalkFFI-Examples-CiprianTeodorov.7'. ].! !!ConfigurationOfTalkFFI methodsFor: 'versions' stamp: 'CiprianTeodorov 4/7/2013 17:48'!version14: spec	<version: '1.4' imports: #('1.2-baseline' )>	spec for: #'common' do: [		spec blessing: #'development'.		spec description: 'development version'.		spec author: 'CiprianTeodorov'.		spec timestamp: '07/04/2013'.		spec 			project: 'NativeBoost' with: '2.1';			project: 'LibClang' with: '1.2'.		spec 			package: 'TalkFFI-Runtime' with: 'TalkFFI-Runtime-CiprianTeodorov.7';			package: 'TalkFFI-Announcements' with: 'TalkFFI-Announcements-CiprianTeodorov.1';			package: 'TalkFFI-AST-Core' with: 'TalkFFI-AST-Core-CiprianTeodorov.6';			package: 'TalkFFI-AST-Generation' with: 'TalkFFI-AST-Generation-CiprianTeodorov.9';			package: 'TalkFFI-SmalltalkBinding' with: 'TalkFFI-SmalltalkBinding-CiprianTeodorov.16';			package: 'TalkFFI-NativeBoostBinding' with: 'TalkFFI-NativeBoostBinding-CiprianTeodorov.23';			package: 'TalkFFI-Examples' with: 'TalkFFI-Examples-CiprianTeodorov.16'. ].! !!ConfigurationOfTalkFFI methodsFor: 'versions' stamp: 'CiprianTeodorov 3/16/2014 22:25'!version15: spec	<version: '1.5' imports: #('1.3-baseline' )>	spec for: #'common' do: [		spec blessing: #'development'.		spec description: 'development version'.		spec author: 'CiprianTeodorov'.		spec timestamp: '03/16/2014'.		spec 			project: 'LibClang' with: '1.4'.		spec 			package: 'TalkFFI-Runtime' with: 'TalkFFI-Runtime-CiprianTeodorov.7';			package: 'TalkFFI-Announcements' with: 'TalkFFI-Announcements-CiprianTeodorov.1';			package: 'TalkFFI-AST-Core' with: 'TalkFFI-AST-Core-CiprianTeodorov.6';			package: 'TalkFFI-AST-Generation' with: 'TalkFFI-AST-Generation-CiprianTeodorov.9';			package: 'TalkFFI-SmalltalkBinding' with: 'TalkFFI-SmalltalkBinding-CiprianTeodorov.16';			package: 'TalkFFI-NativeBoostBinding' with: 'TalkFFI-NativeBoostBinding-CiprianTeodorov.24';			package: 'TalkFFI-Examples' with: 'TalkFFI-Examples-CiprianTeodorov.17'. ].! !"ConfigurationOfTalkFFI"!!ConfigurationOfNativeBoost commentStamp: '<historical>' prior: 0!Loading latest stable version:ConfigurationOfNativeBoost loadStable.Loading latest development version:ConfigurationOfNativeBoost loadDevelopment.For loading a user code, use:NBInstaller install.This will install the latest version of NativeBoost. Includes: Core, all platforms, tests and examples.You can use groups to install only necessary parts:"install only core and platforms code"ConfigurationOfNativeBoost project lastVersion load: 'Core-AllPlatforms'( you could also use Core-Win32 , Core-Unix and Core-Mac for installing code support only for your platform)To load plugin (need VMMaker already loaded), use:NBInstaller installPluginwhich is equivalent to:ConfigurationOfNativeBoost project lastVersion load: 'Plugin'------MetacelloToolBox updateToLatestPackageVersionsIn: ConfigurationOfNativeBoost description: 'update 2012-1-20'----- to load a specific version, use(ConfigurationOfNativeBoost project version: '1.8') load!!ConfigurationOfNativeBoost class methodsFor: 'development support' stamp: 'CamilloBruni 8/21/2012 18:32'!DevelopmentProcess"DEVELOPMENT Process	- load current version:	  	(self project version: #stable) load: 'ALL'.	- open new version for development:		self createNewDevelopmentVersion	- do development and periodically save mcz files and configuration until ready for release		self saveModifiedPackagesAndConfiguration: '- fixed a bug'	- update the the development version to match mcz file versions		self updateToLatestPackageVersions: '- fixed a bug'	- save configuration		self saveConfiguration: '- checkpoint configuration'RELEASE Process	- mark development version as release:		self releaseDevelopmentVersion: '- release'"	<apiDocumentation>! !!ConfigurationOfNativeBoost class methodsFor: 'development support'!DevelopmentSupport"See the methods in the 'development support' category on the class-side of MetacelloBaseConfiguration. Decide what development support methods you would like to use and copy them the the class-side of your configuration."	<apiDocumentation>! !!ConfigurationOfNativeBoost class methodsFor: 'private'!baseConfigurationClassIfAbsent: aBlock	^Smalltalk		at: #MetacelloBaseConfiguration		ifAbsent: [ 			self ensureMetacelloBaseConfiguration.			Smalltalk at: #MetacelloBaseConfiguration ifAbsent: aBlock ].! !!ConfigurationOfNativeBoost class methodsFor: 'development support' stamp: 'CamilloBruni 8/21/2012 18:33'!commit: commitMessage	"Release #development version: set version blessing to #release, update the #development and #stable symbolic version methods and save the configuration."	"self releaseDevelopmentVersion: '- release version 1.0.2'"	<apiDocumentation>	self ensureMetacello.	self updateConfiguration.		self createNewDevelopmentVersion.	self saveModifiedPackagesAndConfiguration: commitMessage.	(Smalltalk at: #MetacelloToolBox) updateToLatestPackageVersionsIn: self description: commitMessage.		self loadDevelopment.	self saveConfiguration: commitMessage.! !!ConfigurationOfNativeBoost class methodsFor: 'development support' stamp: 'CamilloBruni 8/21/2012 18:32'!compareVersions	"Compare the #stable version to #development version"	"self compareVersions"	<apiDocumentation>	self ensureMetacello.	((Smalltalk at: #MetacelloToolBox) compareVersionsIn: self) inspect! !!ConfigurationOfNativeBoost class methodsFor: 'development support' stamp: 'CamilloBruni 8/21/2012 18:32'!createNewBaselineVersion	"Create a new baseline version based upon the #stable version's baseline.	 A new baseline should be created if new packages have been added or package dependencies have changed."	"self createNewDevelopmentVersion"	<apiDocumentation>	self ensureMetacello.	(Smalltalk at: #MetacelloToolBox) createNewBaselineVersionIn: self description: ''! !!ConfigurationOfNativeBoost class methodsFor: 'development support' stamp: 'CamilloBruni 8/21/2012 18:32'!createNewDevelopmentVersion	"Create a new development version using the #stable version as model."	"self createNewDevelopmentVersion"	<apiDocumentation>	self ensureMetacello.	(Smalltalk at: #MetacelloToolBox) createNewDevelopmentVersionIn: self description: ''! !!ConfigurationOfNativeBoost class methodsFor: 'private'!ensureMetacello	(self baseConfigurationClassIfAbsent: []) ensureMetacello! !!ConfigurationOfNativeBoost class methodsFor: 'private'!ensureMetacelloBaseConfiguration	Smalltalk		at: #MetacelloBaseConfiguration		ifAbsent: [ 			| repository version |			repository := MCHttpRepository location: 'http://seaside.gemstone.com/ss/metacello' user: '' password: ''.			repository				versionReaderForFileNamed: 'Metacello-Base-DaleHenrichs.2.mcz'				do: [ :reader | 					version := reader version.					version load.					version workingCopy repositoryGroup addRepository: repository ] ]! !!ConfigurationOfNativeBoost class methodsFor: 'loading' stamp: 'CamilloBruni 4/4/2012 18:56'!installPlugin	Smalltalk at: #VMMaker ifAbsent: [ self error: 'Thou shall install Cog VMMaker first' ].		ConfigurationOfNativeBoost project lastVersion load: 'Plugin'! !!ConfigurationOfNativeBoost class methodsFor: 'metacello tool support'!isMetacelloConfig	"Answer true and the Metacello tools will operate on you"		^true! !!ConfigurationOfNativeBoost class methodsFor: 'loading'!load	"Load the #stable version defined for this platform. The #stable version is the version that is recommended to be used on this platform."	"self load"	<apiDocumentation>	^(self project version: #stable) load! !!ConfigurationOfNativeBoost class methodsFor: 'loading'!loadBleedingEdge	"Load the latest versions of the mcz files defined for this project. It is not likely that the #bleedingEdge has been tested."	"self loadBleedingEdge"	<apiDocumentation>	^(self project version: #bleedingEdge) load! !!ConfigurationOfNativeBoost class methodsFor: 'loading' stamp: 'IgorStasenko 12/28/2012 15:14'!loadDevelopment	"Load the #development version defined for this platform. The #development version will change over time and is not expected to be stable."	"self loadDevelopment"	<apiDocumentation>	^(self project latestVersion: #development) load! !!ConfigurationOfNativeBoost class methodsFor: 'loading' stamp: 'IgorStasenko 12/28/2012 15:13'!loadStable	"Load the #stable version defined for this platform. The #development version will change over time and is not expected to be stable."	"self loadStable"	<apiDocumentation>	^(self project latestVersion: #stable) load! !!ConfigurationOfNativeBoost class methodsFor: 'accessing'!project	^self new project! !!ConfigurationOfNativeBoost class methodsFor: 'development support' stamp: 'CamilloBruni 8/21/2012 18:32'!releaseDevelopmentVersion: commitMessage	"Release #development version: set version blessing to #release, update the #development and #stable symbolic version methods and save the configuration."	"self releaseDevelopmentVersion: '- release version 1.0.2'"	<apiDocumentation>	self ensureMetacello.	(Smalltalk at: #MetacelloToolBox) releaseDevelopmentVersionIn: self description: commitMessage! !!ConfigurationOfNativeBoost class methodsFor: 'development support' stamp: 'CamilloBruni 8/21/2012 18:32'!saveConfiguration: commitMessage	"Save mcz file that contains the configuration to it's repository."	"self saveConfiguration: '- fixed bug'"	<apiDocumentation>	self ensureMetacello.	(Smalltalk at: #MetacelloToolBox) saveConfigurationPackageFor: self name asString description: commitMessage! !!ConfigurationOfNativeBoost class methodsFor: 'development support' stamp: 'CamilloBruni 8/21/2012 18:32'!saveModifiedPackagesAndConfiguration: commitMessage	"Save modified mcz files, update the #development version and then save the configuration."	"self saveModifiedPackagesAndConfiguration: '- fixed bug'"	<apiDocumentation>	self ensureMetacello.	(Smalltalk at: #MetacelloToolBox) saveModifiedPackagesAndConfigurationIn: self description: commitMessage! !!ConfigurationOfNativeBoost class methodsFor: 'development support' stamp: 'CamilloBruni 8/21/2012 17:42'!updateConfiguration	[[ 		(Smalltalk at: #Gofer) new			package: self name;			merge 		] on: (Smalltalk at: #MCMergeOrLoadWarning ifAbsent: [ nil ]) do: [ :e| e resume: false ]	] on: (Smalltalk at: #MCNoChangesException ifAbsent: [ nil ]) do: [ :e| e resume].! !!ConfigurationOfNativeBoost class methodsFor: 'development support' stamp: 'CamilloBruni 8/21/2012 18:32'!updateToLatestPackageVersions: descriptionString	"Update the #development version to match currently loaded mcz files."	"self updateToLatestPackageVersions: '- fixed a bug'"	<apiDocumentation>	self ensureMetacello.	((Smalltalk at: #MetacelloToolBox) updateToLatestPackageVersionsIn: self description: descriptionString) isEmpty		ifTrue: [ self inform: 'All specs up to date' ]! !!ConfigurationOfNativeBoost class methodsFor: 'development support'!validate	"Check the configuration for Errors, Critical Warnings, and Warnings (see class comment for MetacelloMCVersionValidator for more information). 	Errors identify specification issues that will result in unexpected behaviour when you load the configuration. 	Critical Warnings identify specification issues that may result in unexpected behavior when you load the configuration.	Warnings identify specification issues that are technically correct, but are worth take a look at."	"self validate"	<apiDocumentation>	self ensureMetacello.	^ ((Smalltalk at: #MetacelloToolBox) validateConfiguration: self debug: #() recurse: false) explore! !!ConfigurationOfNativeBoost methodsFor: 'external projects' stamp: 'CamilloBruni 9/10/2013 14:11'!asmJit: spec	spec project: 'AsmJit' with: [	   spec 	 	  repository: 'http://smalltalkhub.com/mc/Pharo/AsmJit/main';		  className: 'ConfigurationOfAsmJit']! !!ConfigurationOfNativeBoost methodsFor: 'baselines' stamp: 'CamilloBruni 8/21/2012 17:24'!baseline10: spec 	<version: '1.0-baseline'>		spec for: #common do: [		spec 			blessing: #baseline;			preLoadDoIt: #installPrerequisites;			repository: 'http://www.squeaksource.com/NativeBoost';							package: 'AsmJit' with: [				spec repository: 'http://www.squeaksource.com/AsmJit' ];						package: 'NativeBoost-Pools';			package: 'NativeBoost-Core' with: [				spec requires: #('AsmJit' 'NativeBoost-Pools') ];						package: 'NativeBoost-Unix' with: [				spec requires: #('NativeBoost-Core') ];						package: 'NativeBoost-Mac' with: [				spec requires: #('NativeBoost-Unix') ];						package: 'NativeBoost-Win32'  with: [				spec requires: #('NativeBoost-Core') ];						package: 'NativeBoost-Tests'  with: [				spec requires: #('NativeBoost-Core') ];						package: 'NativeBoost-Examples' with: [				spec requires: #('NativeBoost-Core') ];									package: 'NativeBoost-CogPlugin' with: [				spec requires: #('NativeBoost-Pools') ].	"image-side groups"	spec 		group: 'Core' with: #('NativeBoost-Core');		group: 'Core-Win32' with: #('Core' 'NativeBoost-Win32');		group: 'Core-Unix' with: #('Core' 'NativeBoost-Unix');		group: 'Core-Mac' with: #('Core' 'NativeBoost-Mac');		group: 'Core-AllPlatforms' with: #('Core' 'NativeBoost-Win32' 'NativeBoost-Unix' 'NativeBoost-Mac');		group: 'Tests' with: #('Core-AllPlatforms' 'NativeBoost-Tests');		group: 'Examples' with: #('Core-AllPlatforms' 'NativeBoost-Examples');						group: 'All' with: #('Core-AllPlatforms' 'Tests' 'Examples');		group: 'default' with: #('All');	"group for building plugin with VMMaker"		group: 'Plugin' with: #('NativeBoost-CogPlugin').	].! !!ConfigurationOfNativeBoost methodsFor: 'baselines' stamp: 'CamilloBruni 8/23/2012 17:29'!baseline11: spec 	<version: '1.1-baseline'>		spec for: #common do: [		spec 			blessing: #baseline;			preLoadDoIt: #installPrerequisites;			repository: 'http://www.squeaksource.com/NativeBoost';							project: 'AsmJit' with: [				spec					className: 'ConfigurationOfAsmJit';					repository: 'http://www.squeaksource.com/AsmJit' ];						package: 'NativeBoost-Pools';			package: 'NativeBoost-Core' with: [				spec requires: #('AsmJit' 'NativeBoost-Pools') ];						package: 'NativeBoost-Unix' with: [				spec requires: #('NativeBoost-Core') ];						package: 'NativeBoost-Mac' with: [				spec requires: #('NativeBoost-Unix') ];						package: 'NativeBoost-Win32'  with: [				spec requires: #('NativeBoost-Core') ];						package: 'NativeBoost-Tests'  with: [				spec requires: #('NativeBoost-Core') ];						package: 'NativeBoost-Examples' with: [				spec requires: #('NativeBoost-Core') ];									package: 'NativeBoost-CogPlugin' with: [				spec requires: #('NativeBoost-Pools') ].	"image-side groups"	spec 		group: 'Core' with: #('NativeBoost-Core');		group: 'Core-Win32' with: #('Core' 'NativeBoost-Win32');		group: 'Core-Unix' with: #('Core' 'NativeBoost-Unix');		group: 'Core-Mac' with: #('Core' 'NativeBoost-Mac');		group: 'Core-AllPlatforms' with: #('Core' 'NativeBoost-Win32' 'NativeBoost-Unix' 'NativeBoost-Mac');		group: 'Tests' with: #('Core-AllPlatforms' 'NativeBoost-Tests');		group: 'Examples' with: #('Core-AllPlatforms' 'NativeBoost-Examples');						group: 'All' with: #('Core-AllPlatforms' 'Tests' 'Examples');		group: 'default' with: #('All');	"group for building plugin with VMMaker"		group: 'Plugin' with: #('NativeBoost-CogPlugin').	].! !!ConfigurationOfNativeBoost methodsFor: 'baselines' stamp: 'CamilloBruni 9/10/2013 14:12'!baseline12: spec 	<version: '1.2-baseline'>		spec for: #common do: [		spec 			blessing: #baseline;			preLoadDoIt: #installPrerequisites;			repository: 'http://www.squeaksource.com/NativeBoost';							project: 'AsmJit' with: [				spec					className: 'ConfigurationOfAsmJit';					repository: 'http://www.squeaksource.com/AsmJit' ];						package: 'NativeBoost-Pools';			package: 'NativeBoost-Core' with: [				spec 					requires: #('AsmJit' 'NativeBoost-Pools');					postLoadDoIt: #postLoadForCore ];						package: 'NativeBoost-Unix' with: [				spec requires: #('NativeBoost-Core') ];						package: 'NativeBoost-Mac' with: [				spec requires: #('NativeBoost-Unix') ];						package: 'NativeBoost-Win32'  with: [				spec requires: #('NativeBoost-Core') ];						package: 'NativeBoost-Tests'  with: [				spec requires: #('NativeBoost-Core') ];						package: 'NativeBoost-Examples' with: [				spec requires: #('NativeBoost-Core') ];									package: 'NativeBoost-CogPlugin' with: [				spec requires: #('NativeBoost-Pools') ].	"image-side groups"	spec 		group: 'Core' with: #('NativeBoost-Core');		group: 'Core-Win32' with: #('Core' 'NativeBoost-Win32');		group: 'Core-Unix' with: #('Core' 'NativeBoost-Unix');		group: 'Core-Mac' with: #('Core' 'NativeBoost-Mac');		group: 'Core-AllPlatforms' with: #('Core' 'NativeBoost-Win32' 'NativeBoost-Unix' 'NativeBoost-Mac');		group: 'Tests' with: #('Core-AllPlatforms' 'NativeBoost-Tests');		group: 'Examples' with: #('Core-AllPlatforms' 'NativeBoost-Examples');						group: 'All' with: #('Core-AllPlatforms' 'Tests' 'Examples');		group: 'default' with: #('All');	"group for building plugin with VMMaker"		group: 'Plugin' with: #('NativeBoost-CogPlugin').	].! !!ConfigurationOfNativeBoost methodsFor: 'baselines' stamp: 'CamilloBruni 9/10/2013 14:12'!baseline13: spec 	<version: '1.3-baseline'>		spec for: #common do: [		spec 			blessing: #baseline;			preLoadDoIt: #installPrerequisites;			repository: 'http://www.smalltalkhub.com/mc/Pharo/NativeBoost/main';							project: 'AsmJit' with: [				spec					className: 'ConfigurationOfAsmJit';					repository: 'http://www.smalltalkhub.com/mc/Pharo/AsmJit/main' ];						package: 'NativeBoost-Pools';			package: 'NativeBoost-Core' with: [				spec 					requires: #('AsmJit' 'NativeBoost-Pools');					postLoadDoIt: #postLoadForCore ];						package: 'NativeBoost-Unix' with: [				spec requires: #('NativeBoost-Core') ];						package: 'NativeBoost-Mac' with: [				spec requires: #('NativeBoost-Unix') ];						package: 'NativeBoost-Win32'  with: [				spec requires: #('NativeBoost-Core') ];						package: 'NativeBoost-Tests'  with: [				spec requires: #('NativeBoost-Core') ];						package: 'NativeBoost-Examples' with: [				spec requires: #('NativeBoost-Core') ];									package: 'NativeBoost-CogPlugin' with: [				spec requires: #('NativeBoost-Pools') ].	"image-side groups"	spec 		group: 'Core' with: #('NativeBoost-Core');		group: 'Core-Win32' with: #('Core' 'NativeBoost-Win32');		group: 'Core-Unix' with: #('Core' 'NativeBoost-Unix');		group: 'Core-Mac' with: #('Core' 'NativeBoost-Mac');		group: 'Core-AllPlatforms' with: #('Core' 'NativeBoost-Win32' 'NativeBoost-Unix' 'NativeBoost-Mac');		group: 'Tests' with: #('Core-AllPlatforms' 'NativeBoost-Tests');		group: 'Examples' with: #('Core-AllPlatforms' 'NativeBoost-Examples');						group: 'All' with: #('Core-AllPlatforms' 'Tests' 'Examples');		group: 'default' with: #('All');	"group for building plugin with VMMaker"		group: 'Plugin' with: #('NativeBoost-CogPlugin').	].! !!ConfigurationOfNativeBoost methodsFor: 'baselines' stamp: 'CamilloBruni 9/10/2013 14:21'!baselineDEV: spec 	<version: 'dev-baseline'>		spec for: #common do: [		spec 			blessing: #baseline;			preLoadDoIt: #installPrerequisites;			repository: 'http://www.smalltalkhub.com/mc/Pharo/NativeBoost/main'.				self asmJit: spec.				spec 			project: 'AsmJit'		with: #bleedingEdge.				spec			package: 'NativeBoost-Pools';			package: 'NativeBoost-Core' with: [				spec 					requires: #('AsmJit' 'NativeBoost-Pools');					postLoadDoIt: #postLoadForCore ];						package: 'NativeBoost-Unix' with: [				spec requires: #('NativeBoost-Core') ];						package: 'NativeBoost-Mac' with: [				spec requires: #('NativeBoost-Unix') ];						package: 'NativeBoost-Win32'  with: [				spec requires: #('NativeBoost-Core') ];						package: 'NativeBoost-Tests'  with: [				spec requires: #('NativeBoost-Core') ];						package: 'NativeBoost-Examples' with: [				spec requires: #('NativeBoost-Core') ];									package: 'NativeBoost-CogPlugin' with: [				spec requires: #('NativeBoost-Pools') ].	"image-side groups"	spec 		group: 'Core' with: #('NativeBoost-Core');		group: 'Core-Win32' with: #('Core' 'NativeBoost-Win32');		group: 'Core-Unix' with: #('Core' 'NativeBoost-Unix');		group: 'Core-Mac' with: #('Core' 'NativeBoost-Mac');		group: 'Core-AllPlatforms' with: #('Core' 'NativeBoost-Win32' 'NativeBoost-Unix' 'NativeBoost-Mac');		group: 'Tests' with: #('Core-AllPlatforms' 'NativeBoost-Tests');		group: 'Examples' with: #('Core-AllPlatforms' 'NativeBoost-Examples');						group: 'All' with: #('Core-AllPlatforms' 'Tests' 'Examples');		group: 'default' with: #('All');		"group for building plugin with VMMaker"		group: 'Plugin' with: #('NativeBoost-CogPlugin').	].! !!ConfigurationOfNativeBoost methodsFor: 'symbolic versions' stamp: 'CamilloBruni 9/10/2013 14:08'!bleedingEdge: spec	<symbolicVersion: #'bleedingEdge'>	spec for: #'common' version: 'dev-baseline'.! !!ConfigurationOfNativeBoost methodsFor: 'symbolic versions' stamp: 'IgorStasenko 6/27/2013 15:56'!development: spec	<symbolicVersion: #development>		spec for: #'common' version: '2.2'! !!ConfigurationOfNativeBoost methodsFor: 'preinstall' stamp: 'CamilloBruni 4/4/2012 18:51'!fileInUrl: anUrl intoChangeset: changesetName	ChangeSet 	newChangesFromStream: (self readUrl: anUrl) named: changesetName! !!ConfigurationOfNativeBoost methodsFor: 'preinstall' stamp: 'CamilloBruni 9/10/2013 14:13'!installPrerequisites		(CompiledMethodTrailer trailerKinds includes: #NativeCodeTrailer) ifFalse: [		self 			fileInUrl: 'http://nativeboost.googlecode.com/files/000-NativeCodeTrailers.cs'			intoChangeset: 'NativeCodeTrailer' 	].	"Make sure the image has this crucial fix "	(Object>>#perform:withArguments: ) frameSize > CompiledMethod smallFrameSize ifFalse: [		self 			fileInUrl: 'http://nativeboost.googlecode.com/files/001-perform-framesize.cs'			intoChangeset: 'Perform-framesize-fix' 	].! !!ConfigurationOfNativeBoost methodsFor: 'post load' stamp: 'CamilloBruni 9/10/2013 14:12'!postLoadForCore	NBFFICallout initialize.! !!ConfigurationOfNativeBoost methodsFor: 'accessing'!project	^ project ifNil: [ | constructor |		"Bootstrap Metacello if it is not already loaded"		(self class baseConfigurationClassIfAbsent: []) ensureMetacello.		"Construct Metacello project"		constructor := (Smalltalk at: #MetacelloVersionConstructor) on: self.		project := constructor project.		project loadType: #linear. "change to #atomic if desired"		project ]! !!ConfigurationOfNativeBoost methodsFor: 'preinstall' stamp: 'CamilloBruni 10/9/2012 19:44'!readUrl: anUrl	^ ZnClient new		url: anUrl;		streaming: true;		get! !!ConfigurationOfNativeBoost methodsFor: 'symbolic versions' stamp: 'IgorStasenko 12/28/2012 15:02'!stable: spec	<symbolicVersion: #'stable'>	 	spec for: #'common' version: '1.8'! !!ConfigurationOfNativeBoost methodsFor: 'versions'!version101: spec 	<version: '1.0.1' imports: #('1.0-baseline') >		spec for: #common do: [				spec blessing: #release.		spec author: 'IgorStasenko'.		spec timestamp: '8/5/2011 19:13'.				spec 			package: 'AsmJit' with: 'AsmJit-IgorStasenko.13';			package: 'NativeBoost-Pools' with: 'NativeBoost-Pools-Igor.Stasenko.5';			package: 'NativeBoost-Core' with: 'NativeBoost-Core-IgorStasenko.32';			package: 'NativeBoost-Unix' with: 'NativeBoost-Unix-IgorStasenko.7';			package: 'NativeBoost-Mac' with: 'NativeBoost-Mac-IgorStasenko.3';			package: 'NativeBoost-Win32'  with: 'NativeBoost-Win32-IgorStasenko.12';			package: 'NativeBoost-Tests'  with: 'NativeBoost-Tests-IgorStasenko.16';			package: 'NativeBoost-Examples' with: 'NativeBoost-Examples-IgorStasenko.5';			package: 'NativeBoost-CogPlugin' with: 'NativeBoost-CogPlugin-IgorStasenko.8'	].! !!ConfigurationOfNativeBoost methodsFor: 'versions'!version102: spec 	<version: '1.0.2' imports: #('1.0-baseline') >		spec for: #common do: [				spec blessing: #release.		spec author: 'IgorStasenko'.		spec timestamp: '8/5/2011 19:13'.				spec 			package: 'AsmJit' with: 'AsmJit-IgorStasenko.13';			package: 'NativeBoost-Pools' with: 'NativeBoost-Pools-IgorStasenko.7';			package: 'NativeBoost-Core' with: 'NativeBoost-Core-IgorStasenko.33';			package: 'NativeBoost-Unix' with: 'NativeBoost-Unix-IgorStasenko.7';			package: 'NativeBoost-Mac' with: 'NativeBoost-Mac-IgorStasenko.3';			package: 'NativeBoost-Win32'  with: 'NativeBoost-Win32-IgorStasenko.12';			package: 'NativeBoost-Tests'  with: 'NativeBoost-Tests-IgorStasenko.17';			package: 'NativeBoost-Examples' with: 'NativeBoost-Examples-IgorStasenko.6';			package: 'NativeBoost-CogPlugin' with: 'NativeBoost-CogPlugin-IgorStasenko.8'	].! !!ConfigurationOfNativeBoost methodsFor: 'versions'!version103: spec 	<version: '1.0.3' imports: #('1.0-baseline') >		spec for: #common do: [				spec blessing: #release.		spec author: 'IgorStasenko'.		spec timestamp: '8/10/2011 2:41'.				spec 			package: 'AsmJit' with: 'AsmJit-IgorStasenko.14';			package: 'NativeBoost-Pools' with: 'NativeBoost-Pools-IgorStasenko.7';			package: 'NativeBoost-Core' with: 'NativeBoost-Core-IgorStasenko.34';			package: 'NativeBoost-Unix' with: 'NativeBoost-Unix-IgorStasenko.7';			package: 'NativeBoost-Mac' with: 'NativeBoost-Mac-IgorStasenko.3';			package: 'NativeBoost-Win32'  with: 'NativeBoost-Win32-IgorStasenko.12';			package: 'NativeBoost-Tests'  with: 'NativeBoost-Tests-IgorStasenko.18';			package: 'NativeBoost-Examples' with: 'NativeBoost-Examples-IgorStasenko.6';			package: 'NativeBoost-CogPlugin' with: 'NativeBoost-CogPlugin-IgorStasenko.8'	].! !!ConfigurationOfNativeBoost methodsFor: 'versions'!version104: spec 	<version: '1.0.4' imports: #('1.0-baseline') >		spec for: #common do: [				spec blessing: #development.		spec author: 'IgorStasenko'.		spec timestamp: '8/10/2011 16:08'.				spec 			package: 'AsmJit' with: 'AsmJit-IgorStasenko.15';			package: 'NativeBoost-Pools' with: 'NativeBoost-Pools-IgorStasenko.7';			package: 'NativeBoost-Core' with: 'NativeBoost-Core-IgorStasenko.36';			package: 'NativeBoost-Unix' with: 'NativeBoost-Unix-IgorStasenko.7';			package: 'NativeBoost-Mac' with: 'NativeBoost-Mac-IgorStasenko.3';			package: 'NativeBoost-Win32'  with: 'NativeBoost-Win32-IgorStasenko.12';			package: 'NativeBoost-Tests'  with: 'NativeBoost-Tests-IgorStasenko.18';			package: 'NativeBoost-Examples' with: 'NativeBoost-Examples-IgorStasenko.6';			package: 'NativeBoost-CogPlugin' with: 'NativeBoost-CogPlugin-IgorStasenko.8'	].! !!ConfigurationOfNativeBoost methodsFor: 'versions'!version105: spec 	<version: '1.0.5' imports: #('1.0-baseline') >		spec for: #common do: [				spec blessing: #development.		spec author: 'IgorStasenko'.		spec timestamp: '23/11/2011 10:40'.				spec 			package: 'AsmJit' with: 'AsmJit-HenrikSperreJohansen.18';			package: 'NativeBoost-Pools' with: 'NativeBoost-Pools-IgorStasenko.7';			package: 'NativeBoost-Core' with: 'NativeBoost-Core-IgorStasenko.43';			package: 'NativeBoost-Unix' with: 'NativeBoost-Unix-IgorStasenko.7';			package: 'NativeBoost-Mac' with: 'NativeBoost-Mac-IgorStasenko.3';			package: 'NativeBoost-Win32'  with: 'NativeBoost-Win32-IgorStasenko.12';			package: 'NativeBoost-Tests'  with: 'NativeBoost-Tests-IgorStasenko.21';			package: 'NativeBoost-Examples' with: 'NativeBoost-Examples-IgorStasenko.6';			package: 'NativeBoost-CogPlugin' with: 'NativeBoost-CogPlugin-IgorStasenko.8'	].! !!ConfigurationOfNativeBoost methodsFor: 'versions'!version106: spec	<version: '1.0.6' imports: #('1.0-baseline' )>	spec for: #'common' do: [		spec blessing: #'development'.		spec description: 'update 2012-1-20'.		spec author: 'IgorStasenko'.		spec timestamp: '1/20/2012 17:23'.		spec 			package: 'AsmJit' with: 'AsmJit-IgorStasenko.20';			package: 'NativeBoost-Pools' with: 'NativeBoost-Pools-IgorStasenko.8';			package: 'NativeBoost-Core' with: 'NativeBoost-Core-IgorStasenko.48';			package: 'NativeBoost-Unix' with: 'NativeBoost-Unix-IgorStasenko.8';			package: 'NativeBoost-Mac' with: 'NativeBoost-Mac-IgorStasenko.3';			package: 'NativeBoost-Win32' with: 'NativeBoost-Win32-IgorStasenko.12';			package: 'NativeBoost-Tests' with: 'NativeBoost-Tests-IgorStasenko.23';			package: 'NativeBoost-Examples' with: 'NativeBoost-Examples-IgorStasenko.6';			package: 'NativeBoost-CogPlugin' with: 'NativeBoost-CogPlugin-IgorStasenko.8'. ].! !!ConfigurationOfNativeBoost methodsFor: 'versions'!version107: spec	<version: '1.0.7' imports: #('1.0-baseline' )>	spec for: #'common' do: [		spec blessing: #'development'.		spec description: 'Update of 2012-2-09'.		spec author: 'IgorStasenko'.		spec timestamp: '2012-2-09'.		spec 			package: 'AsmJit' with: 'AsmJit-IgorStasenko.21';			package: 'NativeBoost-Pools' with: 'NativeBoost-Pools-IgorStasenko.8';			package: 'NativeBoost-Core' with: 'NativeBoost-Core-IgorStasenko.50';			package: 'NativeBoost-Unix' with: 'NativeBoost-Unix-IgorStasenko.10';			package: 'NativeBoost-Mac' with: 'NativeBoost-Mac-IgorStasenko.4';			package: 'NativeBoost-Win32' with: 'NativeBoost-Win32-IgorStasenko.12';			package: 'NativeBoost-Tests' with: 'NativeBoost-Tests-IgorStasenko.24';			package: 'NativeBoost-Examples' with: 'NativeBoost-Examples-IgorStasenko.6';			package: 'NativeBoost-CogPlugin' with: 'NativeBoost-CogPlugin-IgorStasenko.9'. ].! !!ConfigurationOfNativeBoost methodsFor: 'versions' stamp: 'CamilloBruni 8/21/2012 17:38'!version108: spec	<version: '1.0.8' imports: #('1.0-baseline' )>	spec for: #'common' do: [		spec blessing: #'development'.		spec description: 'Update of 2012-2-09'.		spec author: 'IgorStasenko'.		spec timestamp: '2012-2-09'.		spec 			package: 'AsmJit' with: 'AsmJit-IgorStasenko.21';			package: 'NativeBoost-Pools' with: 'NativeBoost-Pools-IgorStasenko.8';			package: 'NativeBoost-Core' with: 'NativeBoost-Core-IgorStasenko.52';			package: 'NativeBoost-Unix' with: 'NativeBoost-Unix-IgorStasenko.10';			package: 'NativeBoost-Mac' with: 'NativeBoost-Mac-IgorStasenko.4';			package: 'NativeBoost-Win32' with: 'NativeBoost-Win32-IgorStasenko.12';			package: 'NativeBoost-Tests' with: 'NativeBoost-Tests-IgorStasenko.24';			package: 'NativeBoost-Examples' with: 'NativeBoost-Examples-IgorStasenko.6';			package: 'NativeBoost-CogPlugin' with: 'NativeBoost-CogPlugin-IgorStasenko.9'. ].! !!ConfigurationOfNativeBoost methodsFor: 'versions' stamp: 'CamilloBruni 8/21/2012 17:38'!version109: spec	<version: '1.0.9' imports: #('1.0-baseline' )>	spec for: #'common' do: [		spec blessing: #'development'.		spec description: 'Restore debugger support due to changes in 1.4 (past version #14402) '.		spec author: 'IgorStasenko'.		spec timestamp: '2012-3-20'.		spec 			package: 'AsmJit' with: 'AsmJit-CamilloBruni.35';			package: 'NativeBoost-Pools' with: 'NativeBoost-Pools-IgorStasenko.9';			package: 'NativeBoost-Core' with: 'NativeBoost-Core-IgorStasenko.54';			package: 'NativeBoost-Unix' with: 'NativeBoost-Unix-IgorStasenko.10';			package: 'NativeBoost-Mac' with: 'NativeBoost-Mac-IgorStasenko.5';			package: 'NativeBoost-Win32' with: 'NativeBoost-Win32-IgorStasenko.12';			package: 'NativeBoost-Tests' with: 'NativeBoost-Tests-IgorStasenko.25';			package: 'NativeBoost-Examples' with: 'NativeBoost-Examples-IgorStasenko.6';			package: 'NativeBoost-CogPlugin' with: 'NativeBoost-CogPlugin-IgorStasenko.9'. ].! !!ConfigurationOfNativeBoost methodsFor: 'versions'!version10: spec 	<version: '1.0' imports: #('1.0-baseline') >		spec for: #common do: [				spec blessing: #release.		spec author: 'IgorStasenko'.		spec timestamp: '8/5/2011 11:49'.				spec 			package: 'AsmJit' with: 'AsmJit-IgorStasenko.12';			package: 'NativeBoost-Pools' with: 'NativeBoost-Pools-Igor.Stasenko.5';			package: 'NativeBoost-Core' with: 'NativeBoost-Core-IgorStasenko.31';			package: 'NativeBoost-Unix' with: 'NativeBoost-Unix-IgorStasenko.7';			package: 'NativeBoost-Mac' with: 'NativeBoost-Mac-IgorStasenko.3';			package: 'NativeBoost-Win32'  with: 'NativeBoost-Win32-IgorStasenko.12';			package: 'NativeBoost-Tests'  with: 'NativeBoost-Tests-IgorStasenko.15';			package: 'NativeBoost-Examples' with: 'NativeBoost-Examples-IgorStasenko.5';			package: 'NativeBoost-CogPlugin' with: 'NativeBoost-CogPlugin-IgorStasenko.8'	].! !!ConfigurationOfNativeBoost methodsFor: 'versions' stamp: 'CamilloBruni 8/21/2012 17:37'!version110: spec	<version: '1.1.0' imports: #('1.0-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.		spec description: 'added resource manager. some fixes'.		spec author: 'IgorStasenko'.		spec timestamp: '2012-3-30'.		spec 			package: 'AsmJit' with: 'AsmJit-CamilloBruni.42';			package: 'NativeBoost-Pools' with: 'NativeBoost-Pools-IgorStasenko.9';			package: 'NativeBoost-Core' with: 'NativeBoost-Core-IgorStasenko.56';			package: 'NativeBoost-Unix' with: 'NativeBoost-Unix-IgorStasenko.10';			package: 'NativeBoost-Mac' with: 'NativeBoost-Mac-IgorStasenko.5';			package: 'NativeBoost-Win32' with: 'NativeBoost-Win32-IgorStasenko.12';			package: 'NativeBoost-Tests' with: 'NativeBoost-Tests-IgorStasenko.27';			package: 'NativeBoost-Examples' with: 'NativeBoost-Examples-IgorStasenko.6';			package: 'NativeBoost-CogPlugin' with: 'NativeBoost-CogPlugin-IgorStasenko.9'. ].! !!ConfigurationOfNativeBoost methodsFor: 'versions' stamp: 'IgorStasenko 4/6/2012 14:15'!version111: spec	<version: '1.1.1' imports: #('1.0-baseline' )>	spec for: #'common' do: [		spec blessing: #release.		spec description: 'added resource manager. some fixes'.		spec author: 'IgorStasenko'.		spec timestamp: '2012-3-30'.		spec 			package: 'AsmJit' with: 'AsmJit-IgorStasenko.50';			package: 'NativeBoost-Pools' with: 'NativeBoost-Pools-IgorStasenko.9';			package: 'NativeBoost-Core' with: 'NativeBoost-Core-IgorStasenko.56';			package: 'NativeBoost-Unix' with: 'NativeBoost-Unix-IgorStasenko.10';			package: 'NativeBoost-Mac' with: 'NativeBoost-Mac-IgorStasenko.5';			package: 'NativeBoost-Win32' with: 'NativeBoost-Win32-IgorStasenko.13';			package: 'NativeBoost-Tests' with: 'NativeBoost-Tests-sig.27';			package: 'NativeBoost-Examples' with: 'NativeBoost-Examples-IgorStasenko.6';			package: 'NativeBoost-CogPlugin' with: 'NativeBoost-CogPlugin-IgorStasenko.9'. ].! !!ConfigurationOfNativeBoost methodsFor: 'versions' stamp: 'CamilloBruni 4/10/2012 18:17'!version112: spec	<version: '1.1.2' imports: #('1.0-baseline' )>	spec for: #'common' do: [		spec blessing: #release.		spec description: 'updated to latest asmjit version'.		spec author: 'CamilloBruni'.		spec timestamp: '4/10/2012 16:50'.		spec 			package: 'AsmJit' with: 'AsmJit-CamilloBruni.51';			package: 'NativeBoost-Pools' with: 'NativeBoost-Pools-IgorStasenko.9';			package: 'NativeBoost-Core' with: 'NativeBoost-Core-IgorStasenko.56';			package: 'NativeBoost-Unix' with: 'NativeBoost-Unix-IgorStasenko.10';			package: 'NativeBoost-Mac' with: 'NativeBoost-Mac-IgorStasenko.5';			package: 'NativeBoost-Win32' with: 'NativeBoost-Win32-IgorStasenko.13';			package: 'NativeBoost-Tests' with: 'NativeBoost-Tests-sig.27';			package: 'NativeBoost-Examples' with: 'NativeBoost-Examples-IgorStasenko.6';			package: 'NativeBoost-CogPlugin' with: 'NativeBoost-CogPlugin-IgorStasenko.9'. ].! !!ConfigurationOfNativeBoost methodsFor: 'versions' stamp: 'IgorStasenko 7/5/2012 09:50'!version121: spec         <version: '1.2.1' imports: #('1.0-baseline')>        spec for: #common do: [                spec blessing: #release.			spec package: 'AsmJit' with: 'AsmJit-IgorStasenko.66'.			spec package: 'NativeBoost-Pools' with: 'NativeBoost-Pools-IgorStasenko.9'.			spec package: 'NativeBoost-Core' with: 'NativeBoost-Core-IgorStasenko.62'.			spec package: 'NativeBoost-Unix' with: 'NativeBoost-Unix-IgorStasenko.11'.			spec package: 'NativeBoost-Mac' with: 'NativeBoost-Mac-IgorStasenko.6'.			spec package: 'NativeBoost-Win32' with: 'NativeBoost-Win32-IgorStasenko.14'.			spec package: 'NativeBoost-Tests' with: 'NativeBoost-Tests-IgorStasenko.30'.			spec package: 'NativeBoost-Examples' with: 'NativeBoost-Examples-IgorStasenko.8'.                ].! !!ConfigurationOfNativeBoost methodsFor: 'versions' stamp: 'CamilloBruni 8/21/2012 17:36'!version122: spec 	<version: '1.2.2' imports: #('1.0-baseline')>	spec for: #common do: [		spec blessing: #development.		spec author: 'Camillo Bruni'.		spec timestamp: '2012-08-21'.				spec package: 'AsmJit' with: 'AsmJit-CamilloBruni.76'.				spec package: 'NativeBoost-Core' with: 'NativeBoost-Core-CamilloBruni.71'.		spec package: 'NativeBoost-Examples' with: 'NativeBoost-Examples-CamilloBruni.12'.		spec package: 'NativeBoost-Mac' with: 'NativeBoost-Mac-IgorStasenko.6'.		spec package: 'NativeBoost-Pools' with: 'NativeBoost-Pools-IgorStasenko.9'.		spec package: 'NativeBoost-Tests' with: 'NativeBoost-Tests-IgorStasenko.30'.		spec package: 'NativeBoost-Unix' with: 'NativeBoost-Unix-IgorStasenko.11'.		spec package: 'NativeBoost-Win32' with: 'NativeBoost-Win32-CamilloBruni.16'.	].! !!ConfigurationOfNativeBoost methodsFor: 'versions' stamp: 'CamilloBruni 10/16/2012 14:51'!version123: spec 	<version: '1.2.3' imports: #('1.0-baseline')>	spec for: #common do: [		spec blessing: #development.		spec author: 'Camillo Bruni'.		spec timestamp: '2012-10-16'.				spec package: 'AsmJit' with: 'AsmJit-CamilloBruni.76'.				spec package: 'NativeBoost-Core' with: 'NativeBoost-Core-CamilloBruni.80'.		spec package: 'NativeBoost-Examples' with: 'NativeBoost-Examples-IgorStasenko.14'.		spec package: 'NativeBoost-Mac' with: 'NativeBoost-Mac-IgorStasenko.6'.		spec package: 'NativeBoost-Pools' with: 'NativeBoost-Pools-IgorStasenko.12'.		spec package: 'NativeBoost-Tests' with: 'NativeBoost-Tests-IgorStasenko.33'.		spec package: 'NativeBoost-Unix' with: 'NativeBoost-Unix-IgorStasenko.11'.		spec package: 'NativeBoost-Win32' with: 'NativeBoost-Win32-CamilloBruni.17'.	].! !!ConfigurationOfNativeBoost methodsFor: 'versions' stamp: 'IgorStasenko 6/2/2012 15:25'!version12: spec         <version: '1.2' imports: #('1.0-baseline')>        spec for: #common do: [			spec blessing: #release.			spec package: 'AsmJit' with: 'AsmJit-IgorStasenko.66'.			spec package: 'NativeBoost-Pools' with: 'NativeBoost-Pools-IgorStasenko.9'.			spec package: 'NativeBoost-Core' with: 'NativeBoost-Core-IgorStasenko.61'.			spec package: 'NativeBoost-Unix' with: 'NativeBoost-Unix-IgorStasenko.11'.			spec package: 'NativeBoost-Mac' with: 'NativeBoost-Mac-IgorStasenko.6'.			spec package: 'NativeBoost-Win32' with: 'NativeBoost-Win32-IgorStasenko.14'.			spec package: 'NativeBoost-Tests' with: 'NativeBoost-Tests-IgorStasenko.30'.			spec package: 'NativeBoost-Examples' with: 'NativeBoost-Examples-IgorStasenko.7'.	].! !!ConfigurationOfNativeBoost methodsFor: 'versions' stamp: 'IgorStasenko 8/30/2012 18:51'!version13: spec 	<version: '1.3' imports: #('1.1-baseline')>	spec for: #common do: [		spec blessing: #development.		spec author: 'Camillo Bruni'.		spec timestamp: '2012-08-23 17:30'.				spec project: 'AsmJit' with: '1.0'.				spec package: 'NativeBoost-Core' with: 'NativeBoost-Core-IgorStasenko.74'.		spec package: 'NativeBoost-Examples' with: 'NativeBoost-Examples-CamilloBruni.12'.		spec package: 'NativeBoost-Mac' with: 'NativeBoost-Mac-IgorStasenko.6'.		spec package: 'NativeBoost-Pools' with: 'NativeBoost-Pools-IgorStasenko.9'.		spec package: 'NativeBoost-Tests' with: 'NativeBoost-Tests-IgorStasenko.31'.		spec package: 'NativeBoost-Unix' with: 'NativeBoost-Unix-IgorStasenko.11'.		spec package: 'NativeBoost-Win32' with: 'NativeBoost-Win32-CamilloBruni.16'.	].! !!ConfigurationOfNativeBoost methodsFor: 'versions' stamp: 'CamilloBruni 9/10/2013 14:12'!version14: spec         <version: '1.4' imports: #('1.1-baseline')>        spec for: #common do: [		spec blessing: #development.		spec author: 'Igor Stasenko'.		spec timestamp: '2012-Sep-03 3:08'.				spec project: 'AsmJit' with: '1.0'.		spec package: 'NativeBoost-Pools' with: 'NativeBoost-Pools-IgorStasenko.9'.		spec package: 'NativeBoost-Core' with: [ 			spec				file: 'NativeBoost-Core-IgorStasenko.75';				postLoadDoIt: #postLoadForCore ].		spec package: 'NativeBoost-Unix' with: 'NativeBoost-Unix-IgorStasenko.11'.		spec package: 'NativeBoost-Mac' with: 'NativeBoost-Mac-IgorStasenko.6'.		spec package: 'NativeBoost-Win32' with: 'NativeBoost-Win32-CamilloBruni.16'.		spec package: 'NativeBoost-Tests' with: 'NativeBoost-Tests-IgorStasenko.32'.		spec package: 'NativeBoost-Examples' with: 'NativeBoost-Examples-IgorStasenko.14'.		spec package: 'NativeBoost-CogPlugin' with: 'NativeBoost-CogPlugin-IgorStasenko.11'. 	].! !!ConfigurationOfNativeBoost methodsFor: 'versions' stamp: 'CamilloBruni 10/16/2012 14:54'!version15: spec 	<version: '1.5' imports: #('1.2-baseline')>	spec for: #common do: [		spec blessing: #development.		spec author: 'Igor Stasenko'.		spec timestamp: '2012-Sep-18 12:45'.				spec project: 'AsmJit' with: '1.0'.				spec package: 'NativeBoost-Pools' with: 'NativeBoost-Pools-IgorStasenko.10'.		spec package: 'NativeBoost-Core' with: 'NativeBoost-Core-IgorStasenko.76'.		spec package: 'NativeBoost-Unix' with: 'NativeBoost-Unix-IgorStasenko.11'.		spec package: 'NativeBoost-Mac' with: 'NativeBoost-Mac-IgorStasenko.6'.		spec package: 'NativeBoost-Win32' with: 'NativeBoost-Win32-IgorStasenko.17'.		spec package: 'NativeBoost-Tests' with: 'NativeBoost-Tests-IgorStasenko.33'.		spec package: 'NativeBoost-Examples' with: 'NativeBoost-Examples-IgorStasenko.14'.		spec package: 'NativeBoost-CogPlugin' with: 'NativeBoost-CogPlugin-IgorStasenko.12'. 	].! !!ConfigurationOfNativeBoost methodsFor: 'versions' stamp: 'tbn 11/29/2012 08:12'!version16: spec 	<version: '1.6' imports: #('1.2-baseline')>	spec for: #common do: [		spec blessing: #release.		spec author: 'Camillo Bruni'.		spec timestamp: '2012-10-16'.				spec project: 'AsmJit' with: '1.1'.				spec package: 'NativeBoost-Core' with: 'NativeBoost-Core-CamilloBruni.80'.		spec package: 'NativeBoost-CogPlugin' with: 'NativeBoost-CogPlugin-IgorStasenko.15'. 		spec package: 'NativeBoost-Examples' with: 'NativeBoost-Examples-IgorStasenko.14'.		spec package: 'NativeBoost-Mac' with: 'NativeBoost-Mac-IgorStasenko.6'.		spec package: 'NativeBoost-Pools' with: 'NativeBoost-Pools-IgorStasenko.12'.		spec package: 'NativeBoost-Tests' with: 'NativeBoost-Tests-IgorStasenko.33'.		spec package: 'NativeBoost-Unix' with: 'NativeBoost-Unix-IgorStasenko.11'.		spec package: 'NativeBoost-Win32' with: 'NativeBoost-Win32-tbn.28'.	].! !!ConfigurationOfNativeBoost methodsFor: 'versions' stamp: 'tbn 11/29/2012 08:13'!version17: spec 	<version: '1.7' imports: #('1.2-baseline')>	spec for: #common do: [		spec blessing: #stable.		spec author: 'Igor Stasenko'.		spec timestamp: '2012-11-26'.				spec project: 'AsmJit' with: '1.1'.				spec package: 'NativeBoost-Core' with: 'NativeBoost-Core-IgorStasenko.90'.		spec package: 'NativeBoost-CogPlugin' with: 'NativeBoost-CogPlugin-IgorStasenko.15'. 		spec package: 'NativeBoost-Examples' with: 'NativeBoost-Examples-IgorStasenko.15'.		spec package: 'NativeBoost-Mac' with: 'NativeBoost-Mac-IgorStasenko.8'.		spec package: 'NativeBoost-Pools' with: 'NativeBoost-Pools-IgorStasenko.12'.		spec package: 'NativeBoost-Tests' with: 'NativeBoost-Tests-IgorStasenko.38'.		spec package: 'NativeBoost-Unix' with: 'NativeBoost-Unix-IgorStasenko.12'.		spec package: 'NativeBoost-Win32' with: 'NativeBoost-Win32-IgorStasenko.30'.	].! !!ConfigurationOfNativeBoost methodsFor: 'versions' stamp: 'IgorStasenko 12/28/2012 15:13'!version18: spec 	<version: '1.8' imports: #('1.2-baseline')>	spec for: #common do: [		spec blessing: #stable.		spec author: 'Igor Stasenko'.		spec timestamp: '2012-12-07'.				spec project: 'AsmJit' with: '1.2'.				spec package: 'NativeBoost-Core' with: 'NativeBoost-Core-IgorStasenko.94'.		spec package: 'NativeBoost-CogPlugin' with: 'NativeBoost-CogPlugin-IgorStasenko.15'. 		spec package: 'NativeBoost-Examples' with: 'NativeBoost-Examples-IgorStasenko.15'.		spec package: 'NativeBoost-Mac' with: 'NativeBoost-Mac-IgorStasenko.8'.		spec package: 'NativeBoost-Pools' with: 'NativeBoost-Pools-IgorStasenko.12'.		spec package: 'NativeBoost-Tests' with: 'NativeBoost-Tests-IgorStasenko.43'.		spec package: 'NativeBoost-Unix' with: 'NativeBoost-Unix-IgorStasenko.12'.		spec package: 'NativeBoost-Win32' with: 'NativeBoost-Win32-IgorStasenko.31'.	].! !!ConfigurationOfNativeBoost methodsFor: 'versions' stamp: 'CiprianTeodorov 1/28/2013 21:03'!version19: spec	<version: '1.9' imports: #('1.2-baseline' )>	spec for: #'common' do: [		spec blessing: #'development'.		spec description: 'included enumerations'.		spec author: 'CiprianTeodorov'.		spec timestamp: '12/27/2012 14:38'.		spec project: 'AsmJit' with: '1.2'.		spec			package: 'NativeBoost-Core' with: 'NativeBoost-Core-CiprianTeodorov.106'; 			package: 'NativeBoost-CogPlugin' with: 'NativeBoost-CogPlugin';			package: 'NativeBoost-Examples' with: 'NativeBoost-Examples-IgorStasenko.15';			package: 'NativeBoost-Mac' with: 'NativeBoost-Mac-IgorStasenko.8';			package: 'NativeBoost-Pools' with: 'NativeBoost-Pools-IgorStasenko.12';			package: 'NativeBoost-Tests' with: 'NativeBoost-Tests-CiprianTeodorov.47';			package: 'NativeBoost-Unix' with: 'NativeBoost-Unix-IgorStasenko.12';			package: 'NativeBoost-Win32' with: 'NativeBoost-Win32-IgorStasenko.31'.	].! !!ConfigurationOfNativeBoost methodsFor: 'versions' stamp: 'CamilloBruni 5/7/2013 17:57'!version20: spec	<version: '2.0' imports: #('1.3-baseline' )>	spec for: #'common' do: [		spec blessing: #'development'.		spec description: 'included enumerations'.		spec author: 'IgorStasenko'.		spec timestamp: '31/01/2013'.		spec project: 'AsmJit' with: '1.2'.		spec			package: 'NativeBoost-Core' with: 'NativeBoost-Core-CiprianTeodorov.106'; 			package: 'NativeBoost-CogPlugin' with: 'NativeBoost-CogPlugin';			package: 'NativeBoost-Examples' with: 'NativeBoost-Examples-IgorStasenko.15';			package: 'NativeBoost-Mac' with: 'NativeBoost-Mac-IgorStasenko.8';			package: 'NativeBoost-Pools' with: 'NativeBoost-Pools-IgorStasenko.12';			package: 'NativeBoost-Tests' with: 'NativeBoost-Tests-CiprianTeodorov.47';			package: 'NativeBoost-Unix' with: 'NativeBoost-Unix-IgorStasenko.12';			package: 'NativeBoost-Win32' with: 'NativeBoost-Win32-IgorStasenko.31'.	].! !!ConfigurationOfNativeBoost methodsFor: 'versions' stamp: 'GuillermoPolito 5/31/2013 13:30'!version21: spec	<version: '2.1' imports: #('1.3-baseline' )>	spec for: #'common' do: [		spec blessing: #'development'.		spec description: 'included enumerations'.		spec author: 'CiprianTeodorov'.		spec timestamp: '06/02/2013'.		spec project: 'AsmJit' with: '1.2'.		spec			package: 'NativeBoost-Core' with: 'NativeBoost-Core-EstebanLorenzano.110'; 			package: 'NativeBoost-CogPlugin' with: 'NativeBoost-CogPlugin-GuillermoPolito.19';			package: 'NativeBoost-Examples' with: 'NativeBoost-Examples-IgorStasenko.15';			package: 'NativeBoost-Mac' with: 'NativeBoost-Mac-IgorStasenko.8';			package: 'NativeBoost-Pools' with: 'NativeBoost-Pools-IgorStasenko.12';			package: 'NativeBoost-Tests' with: 'NativeBoost-Tests-IgorStasenko.49';			package: 'NativeBoost-Unix' with: 'NativeBoost-Unix-IgorStasenko.12';			package: 'NativeBoost-Win32' with: 'NativeBoost-Win32-IgorStasenko.34'.	].! !!ConfigurationOfNativeBoost methodsFor: 'versions' stamp: 'StephaneDucasse 8/13/2013 17:44'!version22: spec	<version: '2.2' imports: #('1.3-baseline' )>	spec for: #'common' do: [		spec blessing: #'development'.		spec description: 'more fixes and cleanups'.		spec author: 'IgorStasenko'.		spec timestamp: '13/08/2013'.		spec project: 'AsmJit' with: '1.2'.		spec			package: 'NativeBoost-Core' with: 'NativeBoost-Core-StephaneDucasse.133'; 			package: 'NativeBoost-CogPlugin' with: 'NativeBoost-CogPlugin-EstebanLorenzano.18';			package: 'NativeBoost-Examples' with: 'NativeBoost-Examples-CamilloBruni.16';			package: 'NativeBoost-Mac' with: 'NativeBoost-Mac-CamilloBruni.9';			package: 'NativeBoost-Pools' with: 'NativeBoost-Pools-CamilloBruni.13';			package: 'NativeBoost-Tests' with: 'NativeBoost-Tests-IgorStasenko.63';			package: 'NativeBoost-Unix' with: 'NativeBoost-Unix-CamilloBruni.13';			package: 'NativeBoost-Win32' with: 'NativeBoost-Win32-EstebanLorenzano.38'.	].! !!ConfigurationOfNativeBoost methodsFor: 'versions' stamp: 'IgorStasenko 1/17/2014 20:51'!version23: spec	<version: '2.3' imports: #('1.3-baseline' )>	spec for: #'common' do: [		spec blessing: #'development'.		spec description: 'fixing issue #12478'.		spec author: 'IgorStasenko'.		spec timestamp: '16/01/2014'.		spec project: 'AsmJit' with: '1.2'.		spec			package: 'NativeBoost-Core' with: 'NativeBoost-Core-IgorStasenko.145'; 			package: 'NativeBoost-CogPlugin' with: 'NativeBoost-CogPlugin-EstebanLorenzano.18';			package: 'NativeBoost-Examples' with: 'NativeBoost-Examples-CamilloBruni.16';			package: 'NativeBoost-Mac' with: 'NativeBoost-Mac-CamilloBruni.9';			package: 'NativeBoost-Pools' with: 'NativeBoost-Pools-CamilloBruni.13';			package: 'NativeBoost-Tests' with: 'NativeBoost-Tests-IgorStasenko.81';			package: 'NativeBoost-Unix' with: 'NativeBoost-Unix-IgorStasenko.14';			package: 'NativeBoost-Win32' with: 'NativeBoost-Win32-TorstenBergmann.45'.	].! !!ConfigurationOfNativeBoost methodsFor: 'versions' stamp: 'IgorStasenko 4/1/2014 17:59'!version24: spec	<version: '2.4' imports: #('1.3-baseline' )>	spec for: #'common' do: [		spec blessing: #'development'.		spec description: 'fixing issue #13150'.		spec author: 'IgorStasenko'.		spec timestamp: '1/04/2014'.		spec project: 'AsmJit' with: '1.2'.		spec			package: 'NativeBoost-Core' with: 'NativeBoost-Core-IgorStasenko.149'; 			package: 'NativeBoost-CogPlugin' with: 'NativeBoost-CogPlugin-GuillermoPolito.19';			package: 'NativeBoost-Examples' with: 'NativeBoost-Examples-CamilloBruni.16';			package: 'NativeBoost-Mac' with: 'NativeBoost-Mac-CamilloBruni.9';			package: 'NativeBoost-Pools' with: 'NativeBoost-Pools-CamilloBruni.13';			package: 'NativeBoost-Tests' with: 'NativeBoost-Tests-IgorStasenko.81';			package: 'NativeBoost-Unix' with: 'NativeBoost-Unix-IgorStasenko.14';			package: 'NativeBoost-Win32' with: 'NativeBoost-Win32-TorstenBergmann.45'.	].! !!ConfigurationOfNativeBoost methodsFor: 'versions' stamp: 'CamilloBruni 9/10/2013 14:10'!versionDEV: spec 	<version: 'dev' imports: #('dev-baseline')>	spec for: #common do: [		spec blessing: #development.		spec author: 'Camillo Bruni'.		spec timestamp: '2012-10-16'.				spec package: 'NativeBoost-Core'		with: 'NativeBoost-Core-CamilloBruni.80'.		spec package: 'NativeBoost-Examples'	with: 'NativeBoost-Examples-IgorStasenko.14'.		spec package: 'NativeBoost-Mac'		with: 'NativeBoost-Mac-IgorStasenko.6'.		spec package: 'NativeBoost-Pools'		with: 'NativeBoost-Pools-IgorStasenko.12'.		spec package: 'NativeBoost-Tests'		with: 'NativeBoost-Tests-IgorStasenko.33'.		spec package: 'NativeBoost-Unix'		with: 'NativeBoost-Unix-IgorStasenko.11'.		spec package: 'NativeBoost-Win32'		with: 'NativeBoost-Win32-CamilloBruni.17'.	].! !"ConfigurationOfNativeBoost"!!ConfigurationOfAsmJit class methodsFor: 'development support' stamp: 'CamilloBruni 8/23/2012 16:07'!DevelopmentProcess"DEVELOPMENT Process	- load current version:	  	(self project version: #stable) load: 'ALL'.	- open new version for development:		self createNewDevelopmentVersion	- do development and periodically save mcz files and configuration until ready for release		self saveModifiedPackagesAndConfiguration: '- fixed a bug'	- update the the development version to match mcz file versions		self updateToLatestPackageVersions: '- fixed a bug'	- save configuration		self saveConfiguration: '- checkpoint configuration'RELEASE Process	- mark development version as release:		self releaseDevelopmentVersion: '- release'"	<apiDocumentation>! !!ConfigurationOfAsmJit class methodsFor: 'development support' stamp: 'CamilloBruni 8/23/2012 16:05'!DevelopmentSupport"See the methods in the 'development support' category on the class-side of MetacelloBaseConfiguration. Decide what development support methods you would like to use and copy them the the class-side of your configuration."	<apiDocumentation>! !!ConfigurationOfAsmJit class methodsFor: 'private' stamp: 'CamilloBruni 8/23/2012 16:05'!baseConfigurationClassIfAbsent: aBlock	^Smalltalk		at: #MetacelloBaseConfiguration		ifAbsent: [ 			self ensureMetacelloBaseConfiguration.			Smalltalk at: #MetacelloBaseConfiguration ifAbsent: aBlock ].! !!ConfigurationOfAsmJit class methodsFor: 'development support' stamp: 'CamilloBruni 8/23/2012 16:07'!commit: commitMessage	"Release #development version: set version blessing to #release, update the #development and #stable symbolic version methods and save the configuration."	"self releaseDevelopmentVersion: '- release version 1.0.2'"	<apiDocumentation>	self ensureMetacello.	self updateConfiguration.		self createNewDevelopmentVersion.	self saveModifiedPackagesAndConfiguration: commitMessage.	(Smalltalk at: #MetacelloToolBox) updateToLatestPackageVersionsIn: self description: commitMessage.		self loadDevelopment.	self saveConfiguration: commitMessage.! !!ConfigurationOfAsmJit class methodsFor: 'development support' stamp: 'CamilloBruni 8/23/2012 16:07'!compareVersions	"Compare the #stable version to #development version"	"self compareVersions"	<apiDocumentation>	self ensureMetacello.	((Smalltalk at: #MetacelloToolBox) compareVersionsIn: self) inspect! !!ConfigurationOfAsmJit class methodsFor: 'development support' stamp: 'CamilloBruni 8/23/2012 16:07'!createNewBaselineVersion	"Create a new baseline version based upon the #stable version's baseline.	 A new baseline should be created if new packages have been added or package dependencies have changed."	"self createNewDevelopmentVersion"	<apiDocumentation>	self ensureMetacello.	(Smalltalk at: #MetacelloToolBox) createNewBaselineVersionIn: self description: ''! !!ConfigurationOfAsmJit class methodsFor: 'development support' stamp: 'CamilloBruni 8/23/2012 16:07'!createNewDevelopmentVersion	"Create a new development version using the #stable version as model."	"self createNewDevelopmentVersion"	<apiDocumentation>	self ensureMetacello.	(Smalltalk at: #MetacelloToolBox) createNewDevelopmentVersionIn: self description: ''! !!ConfigurationOfAsmJit class methodsFor: 'private' stamp: 'CamilloBruni 8/23/2012 16:05'!ensureMetacello	(self baseConfigurationClassIfAbsent: []) ensureMetacello! !!ConfigurationOfAsmJit class methodsFor: 'private' stamp: 'CamilloBruni 8/23/2012 16:05'!ensureMetacelloBaseConfiguration	Smalltalk		at: #MetacelloBaseConfiguration		ifAbsent: [ 			| repository version |			repository := MCHttpRepository location: 'http://seaside.gemstone.com/ss/metacello' user: '' password: ''.			repository				versionReaderForFileNamed: 'Metacello-Base-DaleHenrichs.2.mcz'				do: [ :reader | 					version := reader version.					version load.					version workingCopy repositoryGroup addRepository: repository ] ]! !!ConfigurationOfAsmJit class methodsFor: 'metacello tool support' stamp: 'CamilloBruni 8/23/2012 16:05'!isMetacelloConfig	"Answer true and the Metacello tools will operate on you"		^true! !!ConfigurationOfAsmJit class methodsFor: 'loading' stamp: 'CamilloBruni 8/23/2012 16:05'!load	"Load the #stable version defined for this platform. The #stable version is the version that is recommended to be used on this platform."	"self load"	<apiDocumentation>	^(self project version: #stable) load! !!ConfigurationOfAsmJit class methodsFor: 'loading' stamp: 'CamilloBruni 8/23/2012 16:05'!loadBleedingEdge	"Load the latest versions of the mcz files defined for this project. It is not likely that the #bleedingEdge has been tested."	"self loadBleedingEdge"	<apiDocumentation>	^(self project version: #bleedingEdge) load! !!ConfigurationOfAsmJit class methodsFor: 'loading' stamp: 'CamilloBruni 8/23/2012 16:05'!loadDevelopment	"Load the #development version defined for this platform. The #development version will change over time and is not expected to be stable."	"self loadDevelopment"	<apiDocumentation>	^(self project version: #development) load! !!ConfigurationOfAsmJit class methodsFor: 'accessing' stamp: 'CamilloBruni 8/23/2012 16:05'!project	^self new project! !!ConfigurationOfAsmJit class methodsFor: 'development support' stamp: 'CamilloBruni 8/23/2012 16:07'!releaseDevelopmentVersion: commitMessage	"Release #development version: set version blessing to #release, update the #development and #stable symbolic version methods and save the configuration."	"self releaseDevelopmentVersion: '- release version 1.0.2'"	<apiDocumentation>	self ensureMetacello.	(Smalltalk at: #MetacelloToolBox) releaseDevelopmentVersionIn: self description: commitMessage! !!ConfigurationOfAsmJit class methodsFor: 'development support' stamp: 'CamilloBruni 8/23/2012 16:07'!saveConfiguration: commitMessage	"Save mcz file that contains the configuration to it's repository."	"self saveConfiguration: '- fixed bug'"	<apiDocumentation>	self ensureMetacello.	(Smalltalk at: #MetacelloToolBox) saveConfigurationPackageFor: self name asString description: commitMessage! !!ConfigurationOfAsmJit class methodsFor: 'development support' stamp: 'CamilloBruni 8/23/2012 16:07'!saveModifiedPackagesAndConfiguration: commitMessage	"Save modified mcz files, update the #development version and then save the configuration."	"self saveModifiedPackagesAndConfiguration: '- fixed bug'"	<apiDocumentation>	self ensureMetacello.	(Smalltalk at: #MetacelloToolBox) saveModifiedPackagesAndConfigurationIn: self description: commitMessage! !!ConfigurationOfAsmJit class methodsFor: 'development support' stamp: 'CamilloBruni 8/23/2012 16:07'!updateConfiguration	[[ 		(Smalltalk at: #Gofer) new			package: self name;			merge 		] on: (Smalltalk at: #MCMergeOrLoadWarning ifAbsent: [ nil ]) do: [ :e| e resume: false ]	] on: (Smalltalk at: #MCNoChangesException ifAbsent: [ nil ]) do: [ :e| e resume].! !!ConfigurationOfAsmJit class methodsFor: 'development support' stamp: 'CamilloBruni 8/23/2012 16:07'!updateToLatestPackageVersions: descriptionString	"Update the #development version to match currently loaded mcz files."	"self updateToLatestPackageVersions: '- fixed a bug'"	<apiDocumentation>	self ensureMetacello.	((Smalltalk at: #MetacelloToolBox) updateToLatestPackageVersionsIn: self description: descriptionString) isEmpty		ifTrue: [ self inform: 'All specs up to date' ]! !!ConfigurationOfAsmJit class methodsFor: 'development support' stamp: 'CamilloBruni 8/23/2012 16:05'!validate	"Check the configuration for Errors, Critical Warnings, and Warnings (see class comment for MetacelloMCVersionValidator for more information). 	Errors identify specification issues that will result in unexpected behaviour when you load the configuration. 	Critical Warnings identify specification issues that may result in unexpected behavior when you load the configuration.	Warnings identify specification issues that are technically correct, but are worth take a look at."	"self validate"	<apiDocumentation>	self ensureMetacello.	^ ((Smalltalk at: #MetacelloToolBox) validateConfiguration: self debug: #() recurse: false) explore! !!ConfigurationOfAsmJit methodsFor: 'baseline' stamp: 'CamilloBruni 7/16/2013 17:58'!baseline10: spec 	<version: '1.0-baseline'>		spec for: #common do: [				spec			blessing: #baseline;			repository: 'http://www.smalltalkhub.com/mc/Pharo/AsmJit/main';						package: 'AsmJit-Core';						package: 'AsmJit-Compiler' with: [				spec requires: #('AsmJit-Core')];			package: 'AsmJit-Extension' with: [				spec requires: #( 'AsmJit-Operands')];			package: 'AsmJit-Instructions' with: [				spec requires: #('AsmJit-Core')];			package: 'AsmJit-Operands' with: [				spec requires: #('AsmJit-Core')];			package: 'AsmJit-Reference' with: [				spec requires: #('AsmJit-x86' 'Soup' 'OSProcess')];			package: 'AsmJit-StackManagement' with: [				spec requires: #('AsmJit-Instructions')];			package: 'AsmJit-Tests' with: [				spec requires: #('AsmJit-x86')];			package: 'AsmJit-x86' with: [				spec requires: #( 'AsmJit-Extension' 'AsmJit-Instructions' 									 'AsmJit-Operands' 'AsmJit-StackManagement')].				self 			soup: spec;			osProcess: spec.						spec 			group: 'default' with: #('x86' 'Test');			group: 'x86' with: #('AsmJit-x86');			"To make the CI service s bit happier"			group: 'ARM' with: #();			group: 'Test' with: #('x86' 'AsmJit-Tests');			group: 'Dev' with: #('Test' 'AsmJit-Reference')].! !!ConfigurationOfAsmJit methodsFor: 'baseline' stamp: 'CamilloBruni 9/4/2013 15:01'!baseline12: spec 	<version: '1.2-baseline'>		spec for: #common do: [				spec 			blessing: #baseline;			repository: 'http://www.smalltalkhub.com/mc/Pharo/AsmJit/main';						package: 'AsmJit-Core';						package: 'AsmJit-Compiler' with: [				spec requires: #('AsmJit-Core')];			package: 'AsmJit-Extension' with: [				spec requires: #( 'AsmJit-Operands')];			package: 'AsmJit-Instructions' with: [				spec requires: #('AsmJit-Core')];			package: 'AsmJit-Operands' with: [				spec requires: #('AsmJit-Core')];			package: 'AsmJit-Reference' with: [				spec requires: #('AsmJit-x86' 'Soup' 'OSProcess')];			package: 'AsmJit-StackManagement' with: [				spec requires: #('AsmJit-Instructions')];			package: 'AsmJit-Tests' with: [				spec requires: #('AsmJit-x86')];			package: 'AsmJit-x86' with: [				spec 					requires: #( 'AsmJit-Extension' 'AsmJit-Instructions' 									 'AsmJit-Operands' 'AsmJit-StackManagement');					postLoadDoIt: #postLoadAsmJitx86DEV].				self 			soup: spec;			osProcess: spec.						spec 			group: 'default' with: #('x86' 'Test');			group: 'x86' with: #('AsmJit-x86');			group: 'Test' with: #('AsmJit-Tests');			group: 'Dev' with: #('Test' 'AsmJit-Reference')].			spec		for: #'pharo1.4.x'		do: [ 			spec 				package: 'AsmJit-Legacy';				package: 'AsmJit-Extension' with: [ spec requires: 'AsmJit-Legacy' ]]! !!ConfigurationOfAsmJit methodsFor: 'baseline' stamp: 'CamilloBruni 11/28/2013 17:02'!baseline20: spec 	<version: '2.0-baseline'>		spec for: #common do: [				spec 			blessing: #baseline;			repository: 'http://www.smalltalkhub.com/mc/Pharo/AsmJit/main';						package: 'AsmJit-Core';			package: 'AsmJit-Compiler' with: [				spec requires: #('AsmJit-Core')];			package: 'AsmJit-Extension' with: [				spec requires: #( 'AsmJit-Operands')];			package: 'AsmJit-Instructions' with: [				spec requires: #('AsmJit-Core')];			package: 'AsmJit-Operands' with: [				spec requires: #('AsmJit-Core')];			package: 'AsmJit-Reference' with: [				spec requires: #('AsmJit-x86' 'Soup' 'OSProcess')];			package: 'AsmJit-StackManagement' with: [				spec requires: #('AsmJit-Instructions')];			package: 'AsmJit-Tests' with: [				spec requires: #('AsmJit-x86')];			package: 'AsmJit-x86' with: [				spec 					requires: #( 'AsmJit-Extension' 'AsmJit-Instructions' 									 'AsmJit-Operands' 'AsmJit-StackManagement');					postLoadDoIt: #postLoadAsmJitx86DEV ];			package: 'AsmJit-ARM' with: [				spec requires: #( 'AsmJit-Operands' )].				self 			soup: spec;			osProcess: spec.					spec			project: 'Soup' with: '1.2'.						spec 			group: 'default'     with: #('x86' 'Test');			group: 'x86'         with: #('AsmJit-x86');			group: 'ARM'         with: #('AsmJit-ARM');			group: 'Core'        with: #('x86' 'ARM');			group: 'Test'        with: #('AsmJit-Tests');			group: 'Dev'         with: #('Test' 'AsmJit-Reference')	].! !!ConfigurationOfAsmJit methodsFor: 'baseline' stamp: 'CamilloBruni 9/17/2013 22:35'!baselineDEV: spec 	<version: '999-dev-baseline'>		spec for: #common do: [				spec 			blessing: #baseline;			repository: 'http://www.smalltalkhub.com/mc/Pharo/AsmJit/main';						package: 'AsmJit-Core';			package: 'AsmJit-Compiler' with: [				spec requires: #('AsmJit-Core')];			package: 'AsmJit-Extension' with: [				spec requires: #( 'AsmJit-Operands')];			package: 'AsmJit-Instructions' with: [				spec requires: #('AsmJit-Core')];			package: 'AsmJit-Operands' with: [				spec requires: #('AsmJit-Core')];			package: 'AsmJit-Reference' with: [				spec requires: #('AsmJit-x86' 'Soup' 'OSProcess')];			package: 'AsmJit-StackManagement' with: [				spec requires: #('AsmJit-Instructions')];			package: 'AsmJit-Tests' with: [				spec requires: #('AsmJit-x86')];			package: 'AsmJit-x86' with: [				spec 					requires: #( 'AsmJit-Extension' 'AsmJit-Instructions' 									 'AsmJit-Operands' 'AsmJit-StackManagement');					postLoadDoIt: #postLoadAsmJitx86DEV ];			package: 'AsmJit-ARM' with: [				spec requires: #( 'AsmJit-Operands' )].				self 			soup: spec;			osProcess: spec.					spec			project: 'Soup' with: '1.2'.						spec 			group: 'default'     with: #('x86' 'Test');			group: 'x86'         with: #('AsmJit-x86');			group: 'ARM'         with: #('AsmJit-ARM');			group: 'Core'        with: #('x86' 'ARM');			group: 'Test'        with: #('AsmJit-Tests');			group: 'Dev'         with: #('Test' 'AsmJit-Reference')	].! !!ConfigurationOfAsmJit methodsFor: 'symbolic versions' stamp: 'CamilloBruni 9/12/2013 19:37'!bleedingEdge: spec	<symbolicVersion: #'bleedingEdge'>	spec for: #'common' version: '999-dev-baseline'.! !!ConfigurationOfAsmJit methodsFor: 'symbolic versions' stamp: 'CamilloBruni 9/12/2013 19:36'!development: spec	<symbolicVersion: #'development'>	spec for: #'common' version: '999-dev'.! !!ConfigurationOfAsmJit methodsFor: 'external projects' stamp: 'CamilloBruni 7/16/2013 18:08'!osProcess: spec	spec project: 'OSProcess' with: [		spec			repository: 'http://squeaksource.com/MetacelloRepository';			className: 'ConfigurationOfOSProcess';			versionString: #stable ].! !!ConfigurationOfAsmJit methodsFor: 'post load' stamp: 'CamilloBruni 9/17/2013 22:33'!postLoadAsmJitx86DEV	(Smalltalk at: #AJx86Registers) initialize.! !!ConfigurationOfAsmJit methodsFor: 'accessing' stamp: 'CamilloBruni 8/23/2012 16:05'!project	^ project ifNil: [ | constructor |		"Bootstrap Metacello if it is not already loaded"		(self class baseConfigurationClassIfAbsent: []) ensureMetacello.		"Construct Metacello project"		constructor := (Smalltalk at: #MetacelloVersionConstructor) on: self.		project := constructor project.		project loadType: #linear. "change to #atomic if desired"		project ]! !!ConfigurationOfAsmJit methodsFor: 'external projects' stamp: 'CamilloBruni 7/16/2013 17:57'!soup: spec		spec project: 'Soup' with: [		spec			className: 'ConfigurationOfSoup';			repository: 'http://squeaksource.com/Soup' ].! !!ConfigurationOfAsmJit methodsFor: 'symbolic versions' stamp: 'GuillermoPolito 6/17/2013 14:27'!stable: spec	<symbolicVersion: #'stable'>	spec for: #'common' version: '1.2'.! !!ConfigurationOfAsmJit methodsFor: 'versions' stamp: 'CamilloBruni 5/21/2013 17:13'!version10: spec	<version: '1.0' imports: #('1.0-baseline' )>	spec for: #'common' do: [		spec blessing: #'development'.		spec description: ''.		spec author: 'CamilloBruni'.		spec timestamp: '8/23/2012 17:15'.		spec project: 'Soup' with: '1.2'.		spec 			package: 'AsmJit-Compiler' with: 'AsmJit-Compiler-CamilloBruni.1';			package: 'AsmJit-Core' with: 'AsmJit-Core-CamilloBruni.2';			package: 'AsmJit-Extension' with: 'AsmJit-Extension-IgorStasenko.3';			package: 'AsmJit-Instructions' with: 'AsmJit-Instructions-CamilloBruni.1';			package: 'AsmJit-Operands' with: 'AsmJit-Operands-CamilloBruni.1';			package: 'AsmJit-Reference' with: 'AsmJit-Reference-CamilloBruni.1';			package: 'AsmJit-StackManagement' with: 'AsmJit-StackManagement-CamilloBruni.1';			package: 'AsmJit-Tests' with: 'AsmJit-Tests-CamilloBruni.1';			package: 'AsmJit-x86' with: 'AsmJit-x86-CamilloBruni.2'. ].! !!ConfigurationOfAsmJit methodsFor: 'versions' stamp: 'CamilloBruni 5/21/2013 17:13'!version11: spec	<version: '1.1' imports: #('1.0-baseline' )>	spec for: #'common' do: [		spec blessing: #'development'.		spec description: ''.		spec author: 'CamilloBruni'.		spec timestamp: '8/23/2012 17:15'.		spec project: 'Soup' with: '1.2'.		spec 			package: 'AsmJit-Compiler' with: 'AsmJit-Compiler-CamilloBruni.1';			package: 'AsmJit-Core' with: 'AsmJit-Core-CamilloBruni.2';			package: 'AsmJit-Extension' with: 'AsmJit-Extension-IgorStasenko.3';			package: 'AsmJit-Instructions' with: 'AsmJit-Instructions-CamilloBruni.3';			package: 'AsmJit-Operands' with: 'AsmJit-Operands-CamilloBruni.3';			package: 'AsmJit-Reference' with: 'AsmJit-Reference-CamilloBruni.1';			package: 'AsmJit-StackManagement' with: 'AsmJit-StackManagement-CamilloBruni.2';			package: 'AsmJit-Tests' with: 'AsmJit-Tests-CamilloBruni.1';			package: 'AsmJit-x86' with: 'AsmJit-x86-IgorStasenko.3'. ].! !!ConfigurationOfAsmJit methodsFor: 'versions' stamp: 'CamilloBruni 9/12/2013 19:00'!version12: spec	<version: '1.2' imports: #('1.2-baseline' )>"Please note, this version is used by NativeBoost (versions 1.8 + ).So if you change it, please make sure all NB tests are passed and green,before committing. For further development, which may not be compatible with NB yet, please create a new version (1.3)or use dev version.Igor Stasenko"	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: ''.		spec author: 'IgorStasenko'.		spec timestamp: '23/12/2012 14:37'.		spec project: 'Soup' with: '1.2'.		spec 			package: 'AsmJit-Compiler'			with: 'AsmJit-Compiler-CamilloBruni.1';			package: 'AsmJit-Core'				with: 'AsmJit-Core-MartinMcClure.3';			package: 'AsmJit-Extension'		with: 'AsmJit-Extension-MartinMcClure.6';			package: 'AsmJit-Instructions'		with: 'AsmJit-Instructions-MartinMcClure.6';			package: 'AsmJit-Operands'			with: 'AsmJit-Operands-CamilloBruni.11';			package: 'AsmJit-Reference'		with: 'AsmJit-Reference-CamilloBruni.2';			package: 'AsmJit-StackManagement'	with: 'AsmJit-StackManagement-IgorStasenko.6';			package: 'AsmJit-Tests'				with: 'AsmJit-Tests-MartinMcClure.13';			package: 'AsmJit-x86'				with: 'AsmJit-x86-IgorStasenko.26' ].	spec for: #'pharo1.4.x' do: [ 		spec package: 'AsmJit-Legacy' with: 'AsmJit-Legacy-IgorStasenko.2'.	]! !!ConfigurationOfAsmJit methodsFor: 'versions' stamp: 'CamilloBruni 11/28/2013 17:02'!version20: spec	<version: '2.0' imports: #('2.0-baseline' )>		spec for: #'common' do: [		spec blessing: #'development'.		spec author: 'CamilloBruni'.		spec timestamp: '2013-11-28T17:02:24.382712+01:00'.		"Authors: CamilloBruni ClementBera DamienPollet GuillermoPolito IgorStasenko GuidoChari"		spec 			package: 'AsmJit-ARM'             with: 'AsmJit-ARM-DamienPollet.38';			package: 'AsmJit-Compiler'        with: 'AsmJit-Compiler-CamilloBruni.1';			package: 'AsmJit-Core'            with: 'AsmJit-Core-CamilloBruni.10';			package: 'AsmJit-Extension'       with: 'AsmJit-Extension-GuidoChari.9';			package: 'AsmJit-Instructions'    with: 'AsmJit-Instructions-GuidoChari.33';			package: 'AsmJit-Operands'        with: 'AsmJit-Operands-CamilloBruni.52';			package: 'AsmJit-StackManagement' with: 'AsmJit-StackManagement-CamilloBruni.12';			package: 'AsmJit-Tests'           with: 'AsmJit-Tests-CamilloBruni.56';			package: 'AsmJit-x86'             with: 'AsmJit-x86-CamilloBruni.130';			package: 'AsmJit-Deprecation'     with: 'AsmJit-Deprecation-CamilloBruni.2'].! !!ConfigurationOfAsmJit methodsFor: 'versions' stamp: 'CamilloBruni 11/28/2013 17:01'!versionDEV: spec	<version: '999-dev' imports: #('999-dev-baseline' )>	spec for: #'common' do: [		spec blessing: #'development'.		spec author: 'GuillermoPolito'.		spec timestamp: '2013-06-17T14:29:35.695+02:00'.		"Authors: CamilloBruni ClementBera DamienPollet GuillermoPolito IgorStasenko GuidoChari"		spec 			package: 'AsmJit-ARM'             with: 'AsmJit-ARM-DamienPollet.38';			package: 'AsmJit-Compiler'        with: 'AsmJit-Compiler-CamilloBruni.1';			package: 'AsmJit-Core'            with: 'AsmJit-Core-CamilloBruni.10';			package: 'AsmJit-Extension'       with: 'AsmJit-Extension-GuidoChari.9';			package: 'AsmJit-Instructions'    with: 'AsmJit-Instructions-GuidoChari.33';			package: 'AsmJit-Operands'        with: 'AsmJit-Operands-CamilloBruni.52';			package: 'AsmJit-StackManagement' with: 'AsmJit-StackManagement-CamilloBruni.12';			package: 'AsmJit-Tests'           with: 'AsmJit-Tests-CamilloBruni.56';			package: 'AsmJit-x86'             with: 'AsmJit-x86-CamilloBruni.130';			package: 'AsmJit-Deprecation'     with: 'AsmJit-Deprecation-CamilloBruni.2'].! !"ConfigurationOfAsmJit"!!ConfigurationOfJSON class methodsFor: 'development support' stamp: 'StephaneDucasse 8/31/2013 14:51'!DevelopmentSupport"See the methods in the 'development support' category on the class-side of MetacelloBaseConfiguration. Decide what development support methods you would like to use and copy them the the class-side of your configuration."	<apiDocumentation>! !!ConfigurationOfJSON class methodsFor: 'private' stamp: 'StephaneDucasse 8/31/2013 14:51'!baseConfigurationClassIfAbsent: aBlock	^Smalltalk		at: #MetacelloBaseConfiguration		ifAbsent: [ 			self ensureMetacelloBaseConfiguration.			Smalltalk at: #MetacelloBaseConfiguration ifAbsent: aBlock ].! !!ConfigurationOfJSON class methodsFor: 'catalog' stamp: 'StephaneDucasse 8/31/2013 15:01'!catalogChangeLog^ '- 2013-08-30 Version 1: moved to SmalltalkHub and first configuration.[ [ [ 	(ConfigurationOfJSON project version: ''1.0'') load] ] ]'! !!ConfigurationOfJSON class methodsFor: 'catalog' stamp: 'StephaneDucasse 8/31/2013 14:57'!catalogDescription	^ 'JSON is an implementation of the JSON syntax. This package was the first implemented. Now NeoJSON proposes another approach covered by tests. JSON was originally hosted on http://www.squeaksource.com/JSON. If you want to maintain this package just ask in the Pharo mailing-list.'! !!ConfigurationOfJSON class methodsFor: 'catalog' stamp: 'StephaneDucasse 8/31/2013 14:58'!catalogKeywords	^ #(JSON object-format text web)! !!ConfigurationOfJSON class methodsFor: 'private' stamp: 'StephaneDucasse 8/31/2013 14:51'!ensureMetacello	(self baseConfigurationClassIfAbsent: []) ensureMetacello! !!ConfigurationOfJSON class methodsFor: 'private' stamp: 'StephaneDucasse 8/31/2013 14:51'!ensureMetacelloBaseConfiguration	Smalltalk		at: #MetacelloBaseConfiguration		ifAbsent: [ 			| repository version |			repository := MCHttpRepository location: 'http://seaside.gemstone.com/ss/metacello' user: '' password: ''.			repository				versionReaderForFileNamed: 'Metacello-Base-DaleHenrichs.2.mcz'				do: [ :reader | 					version := reader version.					version load.					version workingCopy repositoryGroup addRepository: repository ] ]! !!ConfigurationOfJSON class methodsFor: 'metacello tool support' stamp: 'StephaneDucasse 8/31/2013 14:51'!isMetacelloConfig	"Answer true and the Metacello tools will operate on you"		^true! !!ConfigurationOfJSON class methodsFor: 'catalog' stamp: 'StephaneDucasse 8/31/2013 15:04'!keyClassesAndExample^ '- ==Json== reads and write JSON objects.- ==JsonObject== represents JSON objects. '! !!ConfigurationOfJSON class methodsFor: 'loading' stamp: 'StephaneDucasse 8/31/2013 14:51'!load	"Load the #stable version defined for this platform. The #stable version is the version that is recommended to be used on this platform."	"self load"	<apiDocumentation>	^(self project version: #stable) load! !!ConfigurationOfJSON class methodsFor: 'loading' stamp: 'StephaneDucasse 8/31/2013 14:51'!loadBleedingEdge	"Load the latest versions of the mcz files defined for this project. It is not likely that the #bleedingEdge has been tested."	"self loadBleedingEdge"	<apiDocumentation>	^(self project version: #bleedingEdge) load! !!ConfigurationOfJSON class methodsFor: 'loading' stamp: 'StephaneDucasse 8/31/2013 14:51'!loadDevelopment	"Load the #development version defined for this platform. The #development version will change over time and is not expected to be stable."	"self loadDevelopment"	<apiDocumentation>	^(self project version: #development) load! !!ConfigurationOfJSON class methodsFor: 'accessing' stamp: 'StephaneDucasse 8/31/2013 14:51'!project	^self new project! !!ConfigurationOfJSON class methodsFor: 'development support' stamp: 'StephaneDucasse 8/31/2013 14:51'!validate	"Check the configuration for Errors, Critical Warnings, and Warnings (see class comment for MetacelloMCVersionValidator for more information). 	Errors identify specification issues that will result in unexpected behaviour when you load the configuration. 	Critical Warnings identify specification issues that may result in unexpected behavior when you load the configuration.	Warnings identify specification issues that are technically correct, but are worth take a look at."	"self validate"	<apiDocumentation>	self ensureMetacello.	^ ((Smalltalk at: #MetacelloToolBox) validateConfiguration: self debug: #() recurse: false) explore! !!ConfigurationOfJSON methodsFor: 'baselines' stamp: 'PaulDeBruicker 10/24/2013 10:34'!baseline10: spec	<version: '1.0-baseline'>	spec		for: #common		do: [ 			spec repository: 'http://smalltalkhub.com/mc/PharoExtras/JSON/main'.			spec blessing: #baseline.			spec package: 'JSON'.			spec group: 'default' with: #('JSON') ].	spec for: #gemstone do: [ spec repository: 'http://www.smalltalkhub.com/mc/pdebruic/JSONg/main' ]! !!ConfigurationOfJSON methodsFor: 'symbolic versions' stamp: 'StephanEggermont 1/13/2016 16:46'!development: spec	<symbolicVersion: #'development'>		spec for: #common version: '1.2'! !!ConfigurationOfJSON methodsFor: 'accessing' stamp: 'PaulDeBruicker 10/7/2013 16:01'!project	^ project ifNil: [ | constructor |		"Bootstrap Metacello if it is not already loaded"		(self class baseConfigurationClassIfAbsent: []) ensureMetacello.		"Construct Metacello project"		constructor := (Smalltalk at: #MetacelloVersionConstructor) on: self.		project := constructor project.		project loadType: #linear. "change to #atomic if desired"		project ]! !!ConfigurationOfJSON methodsFor: 'symbolic versions' stamp: 'PaulDeBruicker 12/30/2015 18:40'!stable: spec	<symbolicVersion: #stable>	spec for: #common version: '1.2'! !!ConfigurationOfJSON methodsFor: 'versions' stamp: 'PaulDeBruicker 10/7/2013 16:02'!version10: spec	<version: '1.0' imports: #('1.0-baseline')>	spec		for: #common		do: [ 			spec blessing: #development.			spec description: 'life is easier with metacello'.			spec author: 'PaulDeBruicker'.			spec timestamp: '9/7/2013 12:45' ].	spec for: #squeakCommon do: [ spec package: 'JSON' with: 'JSON-ul.35' ].	spec for: #gemstone do: [ spec package: 'JSON' with: 'JSON-PaulDeBruicker.40' ]! !!ConfigurationOfJSON methodsFor: 'versions' stamp: 'TommasoDalSasso 3/17/2015 09:53'!version11: spec	<version: '1.1' imports: #('1.0-baseline')>	spec		for: #common		do: [ 			spec blessing: #release.			spec author: 'TommasoDalSasso' ].	spec for: #squeakCommon do: [ spec package: 'JSON' with: 'JSON-TommasoDalSasso.38' ].	spec for: #gemstone do: [ spec package: 'JSON' with: 'JSON-PaulDeBruicker.40' ]! !!ConfigurationOfJSON methodsFor: 'versions' stamp: 'PaulDeBruicker 12/30/2015 18:40'!version12: spec	<version: '1.2' imports: #('1.0-baseline')>	spec		for: #common		do: [ 			spec blessing: #release.			spec author: 'TommasoDalSasso' ].	spec for: #squeakCommon do: [ spec package: 'JSON' with: 'JSON-PaulDeBruicker.39' ].	spec for: #gemstone do: [ spec package: 'JSON' with: 'JSON-PaulDeBruicker.40' ]! !"ConfigurationOfJSON"!!AJGeneratedCode class methodsFor: 'instance creation' stamp: 'CamilloBruni 7/25/2012 12:44'!fromInstructions: instructions	^ self new fromInstructions: instructions! !!AJGeneratedCode methodsFor: 'accessing'!bytes	^ bytes! !!AJGeneratedCode methodsFor: 'accessing'!bytes: aBytes 	bytes := aBytes	! !!AJGeneratedCode methodsFor: 'output'!dumpWithLabels	"dump the native code , interspersed with labels"		| offsets i str |		offsets := OrderedCollection new.	labels keysAndValuesDo: [ :name :offset |		offsets add: (offset -> name)	].	offsets := offsets sort: [:a :b | a key < b key ].		str := String new writeStream.	i := 0.		offsets do: [:offset |		i to: offset key -1 do: [:x | str nextPutAll: ((bytes at: i+1) printStringBase: 16 nDigits: 2) ; space. i:=i+1. ].		str cr; nextPutAll: offset value; cr.	].	i to: bytes size-1 do: [:x | str nextPutAll: ((bytes at: i+1) printStringBase: 16 nDigits: 2) ; space. i := i + 1] .	^ str contents! !!AJGeneratedCode methodsFor: 'initialize-release' stamp: 'CamilloBruni 4/4/2012 16:30'!fromInstructions: instructions		bytes := ByteArray new: 100 streamContents: [:stream|		instructions do: [ :each |			each extractLabels: [:name :pos | labels at: name put: pos ].			each storeOn: stream ]].! !!AJGeneratedCode methodsFor: 'initialize-release'!initialize	labels := Dictionary new.	! !!AJGeneratedCode methodsFor: 'accessing'!labels: aLabels	"turn labels into a simple name->offset pairs"	aLabels keysAndValuesDo: [:name :lbl |		labels at: name put: lbl paddedOffset ].		! !!AJGeneratedCode methodsFor: 'accessing'!offsetAt: aLabelName	^ labels at: aLabelName! !!AJGeneratedCode methodsFor: 'printing'!printOn: aStream	bytes notNil ifTrue: [		aStream nextPutAll: self dumpWithLabels				]! !!AJGeneratedCode methodsFor: 'output'!saveToFile	self saveToFile: 'asm.bin'! !!AJGeneratedCode methodsFor: 'output'!saveToFile: fileName	(FileStream forceNewFileNamed: fileName)  		nextPutAll: bytes;		close  ! !!AJConstants class methodsFor: 'initialization' stamp: 'CamilloBruni 3/29/2012 13:49'!initOpCodes  " x86 "  OG8          := 16r01.  OG16         := 16r02.  OG32         := 16r04.  OG64         := 16r08.  OMEM         := 16r40.  OIMM         := 16r80.  O64Only      := 16r100.  OG8163264    := OG64  + OG32  + OG16  + OG8.  OG163264     := OG64  + OG32  + OG16.  OG3264       := OG64  + OG32.  " x87"  OFM1        := 16r01.  OFM2        := 16r02.  OFM4        := 16r04.  OFM8        := 16r08.  OFM10       := 16r10.  OFM24       := OFM2 + OFM4.  OFM248      := OFM2 + OFM4 + OFM8.  OFM48       := OFM4 + OFM8.  OFM4810     := OFM4 + OFM8 + OFM10.  " mm|xmm"  ONOREX      := 16r01. " Used by MMX/SSE instructions. OG8 is never used for them "  OMM         := 16r10.  OXMM        := 16r20.  OMMMEM      := OMM   + OMEM.  OXMMMEM     := OXMM  + OMEM.  OMMXMM      := OMM   + OXMM.  OMMXMMMEM   := OMM   + OXMM  + OMEM.! !!AJConstants class methodsFor: 'initialization' stamp: 'MartinMcClure 1/27/2013 15:13'!initialize	"AJConstants initialize"		"Operand is none, used only internally."	OpNONE := 0.	"Operand is register"	OpREG := 1.	"Operand is memory"	OpMem := 2.	"Operand is immediate."	OpImm := 3.	"Operand is label. "	OpLabel := 4.	RegTypeMask := 16rF0.	RegCodeMask := 16r0F.	RegRequiresRexMask := 16r100.	RegProhibitsRexMask := 16r200.	RegHighByteMask := 2r111100.		"1 byte size."	SizeByte := 1.	"2 bytes size."	SizeWord := 2.	"4 bytes size."	SizeDWord := 4.	"8 bytes size."	SizeQWord := 8.	"10 bytes size."	SizeTWord := 10.	"16 bytes size."	SizeDQWord := 16.	"ID for AX/EAX/RAX registers."	RIDEAX := 0.	"ID for CX/ECX/RCX registers."	RIDECX := 1.	"ID for DX/EDX/RDX registers."	RIDEDX := 2.	"ID for BX/EBX/RBX registers."	RIDEBX := 3.	"ID for SP/ESP/RSP registers."	RIDESP := 4.	"ID for BP/EBP/RBP registers."	RIDEBP := 5.	"ID for SI/ESI/RSI registers."	RIDESI := 6.	"ID for DI/EDI/RDI registers."	RIDEDI := 7.	"8 bit general purpose register type."	RegGPB := 16r00.	"16 bit general purpose register type."	RegGPW := 16r10.	"32 bit general purpose register type."	RegGPD := 16r20.	"64 bit general purpose register type. "	RegGPQ := 16r30.	"X87 (FPU) register type. "	RegX87 := 16r50.	"64 bit mmx register type."	RegMM := 16r60.	"128 bit sse register type."	RegXMM := 16r70.	"Segment override prefixes."		"No segment override prefix."	SegmentNONE := 0.	"Use 'cs' segment override prefix."	SegmentCS := 1.	"Use 'ss' segment override prefix."	SegmentSS := 2.	"Use 'ds' segment override prefix."	SegmentDS := 3.	"Use 'es' segment override prefix."	SegmentES := 4.	"Use 'fs' segment override prefix."	SegmentFS := 5.	"Use 'gs' segment override prefix."	SegmentGS := 6.  	self initializePrefetchHints.	self initializeConditionCodes.	self initOpCodes.	! !!AJConstants class methodsFor: 'initialization'!initializeConditionCodes	"Condition codes."	"No condition code."	CcNOCONDITION  := -1.	"Condition codes from processor manuals."	CcA             := 16r7.	CcAE            := 16r3.	CcB             := 16r2.	CcBE            := 16r6.	CcC             := 16r2.	CcE             := 16r4.	CcG             := 16rF.	CcGE            := 16rD.	CcL             := 16rC.	CcLE            := 16rE.	CcNA            := 16r6.	CcNAE           := 16r2.	CcNB            := 16r3.	CcNBE           := 16r7.	CcNC            := 16r3.	CcNE            := 16r5.	CcNG            := 16rE.	CcNGE           := 16rC.	CcNL            := 16rD.	CcNLE           := 16rF.	CcNO            := 16r1.	CcNP            := 16rB.	CcNS            := 16r9.	CcNZ            := 16r5.	CcO             := 16r0.	CcP             := 16rA.	CcPE            := 16rA.	CcPO            := 16rB.	CcS             := 16r8.	CcZ             := 16r4.	" Simplified condition codes"	CcOVERFLOW      := 16r0.	CcNOOVERFLOW   := 16r1.	CcBELOW         := 16r2.	CcABOVEEQUAL   := 16r3.	CcEQUAL         := 16r4.	CcNOTEQUAL     := 16r5.	CcBELOWEQUAL   := 16r6.	CcABOVE         := 16r7.	CcSIGN          := 16r8.	CcNOTSIGN      := 16r9.	CcPARITYEVEN   := 16rA.	CcPARITYODD    := 16rB.	CcLESS          := 16rC.	CcGREATEREQUAL := 16rD.	CcLESSEQUAL    := 16rE.	CcGREATER       := 16rF.	"aliases"	CcZERO          := 16r4.	CcNOTZERO      := 16r5.	CcNEGATIVE      := 16r8.	CcPOSITIVE      := 16r9.	"x87 floating point only"	CcFPUNORDERED  := 16.	CcFPNOTUNORDERED := 17.! !!AJConstants class methodsFor: 'initialization'!initializePrefetchHints	"Prefetch hints."	"Prefetch to L0 cache."	PrefetchT0 := 1.	"Prefetch to L1 cache."	PrefetchT1 := 2.	"Prefetch to L2 cache."	PrefetchT2  := 3.	"Prefetch using NT hint."	PrefetchNTA := 0.! !"AsmJit-Core"!!AJAlignmentInstruction commentStamp: '<historical>' prior: 0!I am a pseudo instruction used to align the following instruction to a multiple of a given byte number.Example:	asm := AJx64Assembler noStackFrame.		"align the following instruction to a word (2bytes)"	asm alignWord.	asm inc: asm RAX.		"align the following instruction to a double (4bytes)"	asm alignDouble.	asm inc: asm RAX.		"align the following instruction to a QuadWord (8bytes)"	asm alignQuad.	asm inc: asm RAX.		"align the following instruction to a multiple of an arbirary count"	asm align: 64.	asm inc: asm RAX.!!AJData commentStamp: '<historical>' prior: 0!I represent a pure data section in an assembly instruction stream.Example:	asm := AJx64Assembler noStackFrame.		"add a raw byte"	asm db: 16rFF.		"add a raw word"	asm dw: #[16r34 16r12].		"add a raw double"	asm dw: #[16r78 16r56 16r34 16r12].		"add a arbitrary sized data section with a byteArray"	asm data: #[1 2 3 4 5 6 7 8 9 10 11 12 ].!!AJRoutinePrologue commentStamp: 'IgorStasenko 5/11/2011 00:32' prior: 0!This is a pseudo-instruction to indicate a place in native code for routine prologue.It is later replaced by real instructions which contain code for initializing stack frame & extra stack space required by routine.!!AJAlignmentInstruction class methodsFor: 'instance creation' stamp: 'CamilloBruni 4/12/2012 13:50'!align: byteSize	^ self new align: byteSize! !!AJAlignmentInstruction class methodsFor: 'instance creation'!alignDouble	^ self new alignDouble! !!AJAlignmentInstruction class methodsFor: 'instance creation'!alignQuad	^ self new alignQuad! !!AJAlignmentInstruction class methodsFor: 'instance creation'!alignWord	^ self new alignWord! !!AJAlignmentInstruction methodsFor: 'visitor' stamp: 'CamilloBruni 4/12/2012 13:38'!accept: anObject	self shouldBeImplemented ! !!AJAlignmentInstruction methodsFor: 'accessing'!align	^ alignTo! !!AJAlignmentInstruction methodsFor: 'accessing'!align: bytesSize	"align the data to the given byte count"	alignTo := bytesSize! !!AJAlignmentInstruction methodsFor: 'alignment' stamp: 'CamilloBruni 4/12/2012 13:50'!alignByte	self align: 1! !!AJAlignmentInstruction methodsFor: 'alignment' stamp: 'CamilloBruni 4/12/2012 13:50'!alignDouble	self align: 4! !!AJAlignmentInstruction methodsFor: 'alignment' stamp: 'CamilloBruni 4/12/2012 13:50'!alignQuad	self align: 8! !!AJAlignmentInstruction methodsFor: 'alignment' stamp: 'CamilloBruni 4/12/2012 13:50'!alignWord	self align: 2! !!AJAlignmentInstruction methodsFor: 'emitting code' stamp: 'CamilloBruni 4/12/2012 13:44'!emitCode: asm	| padding |		padding := self paddingForPosition: position.		"new machine code: | padding |"	machineCode := ByteArray new: padding .! !!AJAlignmentInstruction methodsFor: 'initialize-release'!initialize 	super initialize.	self alignByte.! !!AJAlignmentInstruction methodsFor: 'accessing' stamp: 'CamilloBruni 4/12/2012 13:56'!name	^ String streamContents: [ :s|		self printSelfOn: s]! !!AJAlignmentInstruction methodsFor: 'emitting code' stamp: 'CamilloBruni 4/12/2012 13:50'!paddingForPosition: aPositionNumber	| padding |		padding := aPositionNumber \\ self align.	padding = 0 		ifFalse: [ padding := self align - padding ].			^ padding! !!AJAlignmentInstruction methodsFor: 'accessing' stamp: 'CamilloBruni 4/12/2012 13:55'!printSelfOn: aStream  	self align <= 1 ifTrue: [ ^ self ].		aStream nextPut: $|.	self align <= 8 		ifTrue: [			self align timesRepeat: [				aStream nextPutAll: '----|']]		ifFalse: [			aStream 				nextPutAll: (self align asString padded: #left to: 4 with: $ );				nextPut: $|]! !!AJData class methodsFor: 'instance creation'!byte: aByteValue	^ self data: (ByteArray with: aByteValue)! !!AJData class methodsFor: 'instance creation'!data: aDataByteArray	^ self new		data: aDataByteArray;		yourself! !!AJData class methodsFor: 'instance creation'!label: aLabel data: aDataByteArray	^ self new		label: aLabel;		data: aDataByteArray;		yourself! !!AJData methodsFor: 'visitor'!accept: anObject	anObject instructionData: self! !!AJData methodsFor: 'accessing' stamp: 'CamilloBruni 4/12/2012 14:22'!data	^ machineCode! !!AJData methodsFor: 'accessing' stamp: 'CamilloBruni 4/12/2012 14:22'!data: aByteArray	"the will be put in the executable."	machineCode := aByteArray! !!AJData methodsFor: 'emitting code' stamp: 'CamilloBruni 4/12/2012 14:22'!emitCode: asm	machineCode ifNil: [ machineCode := #[] ]! !!AJData methodsFor: 'testing'!is16	^ self size = 2! !!AJData methodsFor: 'testing'!is32	^ self size = 4! !!AJData methodsFor: 'testing'!is64	^ self size = 8! !!AJData methodsFor: 'testing'!is8	^ self size = 1! !!AJData methodsFor: 'accessing'!name	name ifNotNil: [ ^ name ].		"standard data sections"	self is8 ifTrue: [ ^ 'db' ].	self is16 ifTrue: [ ^ 'dw' ].	self is32 ifTrue: [ ^ 'dd' ].! !!AJData methodsFor: 'accessing'!size	^ self data size! !!AJInstruction methodsFor: 'visitor'!accept: anObject	self subclassResponsibility! !!AJInstruction methodsFor: 'accessing'!annotation	^ annotation! !!AJInstruction methodsFor: 'accessing'!annotation: anObject	annotation := anObject! !!AJInstruction methodsFor: 'helpers' stamp: 'MartinMcClure 1/27/2013 17:40'!checkOperandsForConflict	"Subclasses may signal an error here."! !!AJInstruction methodsFor: 'iterating'!do: aBlock	"evaluate all instructions for the list"	| nn |	nn := self.	[ nn notNil ] whileTrue: [		aBlock value: nn.		nn := nn next.	].! !!AJInstruction methodsFor: 'emitting code'!emitCode: asm	machineCode := #[]! !!AJInstruction methodsFor: 'emitting code'!emitCodeAtOffset: offset assembler: asm	position := offset.	self emitCode: asm.	next ifNotNil: [ next emitCodeAtOffset: offset + self machineCodeSize assembler: asm ].! !!AJInstruction methodsFor: 'accessing'!extractLabels: aBlock	operands ifNotNil: [ operands do: [:each | each extractLabels: aBlock ]]! !!AJInstruction methodsFor: 'helpers'!find: aByteString 	self shouldBeImplemented.! !!AJInstruction methodsFor: 'testing'!hasLabel	self shouldBeImplemented.! !!AJInstruction methodsFor: 'accessing'!increaseLevel: num	level := level + num! !!AJInstruction methodsFor: 'initialize-release'!initialize	level := 0! !!AJInstruction methodsFor: 'accessing'!insert: anInstructions	| n |	self halt.	n := next.	next := anInstructions.	anInstructions do: [:each | each increaseLevel: level ].	anInstructions last next: n! !!AJInstruction methodsFor: 'manipulating'!insert: newInstruction before: anInstruction		"replace a single instruction with one or more other instructions"	| instr  anext |		anInstruction == self ifTrue: [		newInstruction last next: self.		^ newInstruction ].		instr := self.	[ (anext := instr next) notNil and: [ anext ~~ anInstruction ]] whileTrue: [ instr := anext ].	instr next ifNotNil: [		newInstruction do: [:each | 			each increaseLevel: instr level  			].		newInstruction last next: instr next.		instr next: newInstruction ].  ! !!AJInstruction methodsFor: 'accessing'!instructionName 	^ name! !!AJInstruction methodsFor: 'testing'!isLabelUsed: anAJJumpLabel	^ false! !!AJInstruction methodsFor: 'iterating'!last	"answer the last instruction in the list"	| nn l |	nn := self.	[ (l := nn next) notNil ] whileTrue: [ nn := l ].	^ nn! !!AJInstruction methodsFor: 'accessing'!level	^ level! !!AJInstruction methodsFor: 'accessing'!level: aLevel	level := aLevel ! !!AJInstruction methodsFor: 'accessing'!machineCodeSize	^ machineCode ifNil: [ 0 ] ifNotNil: [ machineCode size ]! !!AJInstruction methodsFor: 'accessing'!name	^ name		ifNil: ['undefined']! !!AJInstruction methodsFor: 'accessing'!name: anObject	name := anObject! !!AJInstruction methodsFor: 'accessing'!next	^ next! !!AJInstruction methodsFor: 'accessing'!next: anObject	next := anObject! !!AJInstruction methodsFor: 'accessing'!operands	^ operands! !!AJInstruction methodsFor: 'accessing' stamp: 'MartinMcClure 2/9/2013 14:30'!operands: anObject	operands := anObject! !!AJInstruction methodsFor: 'accessing'!position	^ position! !!AJInstruction methodsFor: 'accessing'!position: anObject	position := anObject! !!AJInstruction methodsFor: 'function calls'!prepareCallAlignments	"do nothing"! !!AJInstruction methodsFor: 'printing' stamp: 'CamilloBruni 7/16/2012 15:33'!printAnnotationOn: aStream 	annotation		ifNil: [^ self].	aStream nextPut: $";		 nextPutAll: annotation asString;		 nextPut: $";		 cr.	self printIndentOn: aStream! !!AJInstruction methodsFor: 'printing' stamp: 'CamilloBruni 7/23/2012 16:44'!printIndentOn: aStream 	level ifNil: [ ^ self ].	level timesRepeat: [ aStream nextPutAll: '|   ']! !!AJInstruction methodsFor: 'printing' stamp: 'CamilloBruni 7/16/2012 15:27'!printListOn: aStream		self printIndentOn: aStream.	self printSelfOn: aStream.		next ifNotNil: [		aStream cr.		next printListOn: aStream 		]! !!AJInstruction methodsFor: 'printing' stamp: 'CamilloBruni 10/12/2012 11:40'!printMachineCodeOn: aStream 	(machineCode isNil			or: [machineCode isEmpty])		ifTrue: [^ self].	aStream padColumn: 65;		 nextPutAll: '#['.	machineCode 		do: [ :byte | 			byte printOn: aStream base: 16 length: 2 padded: true ]		separatedBy: [ aStream space ].	aStream nextPut: $]! !!AJInstruction methodsFor: 'printing' stamp: 'CamilloBruni 7/16/2012 15:24'!printOn: aStream  "[ ^self ] value."	self printListOn: aStream asLineStream! !!AJInstruction methodsFor: 'printing' stamp: 'CamilloBruni 7/16/2012 15:29'!printOperandsOn: aStream 	(operands notNil			and: [operands isEmpty not])		ifTrue: [aStream space; nextPut: $(.			operands				do: [ :operand | operand printAsOperandOn: aStream]				separatedBy: [aStream space].			aStream nextPut: $)]! !!AJInstruction methodsFor: 'printing' stamp: 'MartinMcClure 11/26/2012 18:54'!printSelfOn: aStream 	self printAnnotationOn: aStream.	aStream nextPutAll: (self name ). "padRightTo: 4)."	self printOperandsOn: aStream.	self printMachineCodeOn: aStream! !!AJInstruction methodsFor: 'printing'!printStringLimitedTo: aNumber	^ String streamContents: [:s | self printOn: s] ! !!AJInstruction methodsFor: 'visitor'!processTempsWith: anObject	"do nothing"! !!AJInstruction methodsFor: 'manipulating'!replace: anInstruction with: otherInstructions		"replace a single instruction with one or more other instructions"	| instr |		anInstruction == self ifTrue: [		otherInstructions last next: self next.		^ otherInstructions ].		instr := self.	[ instr notNil and: [instr next ~~ anInstruction ]] whileTrue: [ instr := instr next ].	instr notNil ifTrue: [		otherInstructions last next: instr next next.		instr next: otherInstructions 		].  ! !!AJInstruction methodsFor: 'visitor'!setPrologue: anInstrucitons	"do nothing"! !!AJInstruction methodsFor: 'printing'!storeOn: aStream	"store machine code to binary stream"	machineCode ifNotNil: [		aStream nextPutAll: machineCode   		]! !!AJInstructionDecoration methodsFor: 'visitor'!accept: anObject	anObject instructionDecoration: self! !!AJInstructionDecoration methodsFor: 'accessing'!end	end := true! !!AJInstructionDecoration methodsFor: 'printing' stamp: 'CamilloBruni 7/23/2012 16:43'!printIndentOn: aStream 	end ifFalse: [ 		super printIndentOn: aStream.		aStream cr ].	^ super printIndentOn: aStream! !!AJInstructionDecoration methodsFor: 'printing' stamp: 'CamilloBruni 7/23/2012 16:42'!printSelfOn: aStream  	end 		ifFalse: [ aStream nextPutAll: '/ "' ]		ifTrue: [	aStream nextPutAll: '\ "end ' ].	aStream  nextPutAll: annotation; nextPut: $".	! !!AJInstructionDecoration methodsFor: 'accessing'!start	end := false! !!AJJumpInstruction methodsFor: 'visitor'!accept: anObject	^ anObject jumpInstruction: self! !!AJJumpInstruction methodsFor: 'accessing'!codeSize	^ machineCode size! !!AJJumpInstruction methodsFor: 'accessing' stamp: 'CamilloBruni 4/17/2012 17:54'!description	^ description! !!AJJumpInstruction methodsFor: 'accessing' stamp: 'CamilloBruni 4/17/2012 17:55'!description: anInstructionDescription	description := anInstructionDescription! !!AJJumpInstruction methodsFor: 'testing'!isLabelUsed: anAJJumpLabel	^ label = anAJJumpLabel ! !!AJJumpInstruction methodsFor: 'accessing'!label	^ label! !!AJJumpInstruction methodsFor: 'accessing'!label: anObject	label := anObject! !!AJJumpInstruction methodsFor: 'printing'!printSelfOn: aStream  	aStream nextPutAll: name; space.	label printSelfOn: aStream.			machineCode ifNotNil: [		aStream space; nextPut: $[ .		machineCode do: [:byte | aStream nextPutAll: (byte printStringBase: 16)] separatedBy: [ aStream space ].		aStream nextPut: $].		].! !!AJJumpLabel methodsFor: 'visitor'!accept: anObject	anObject jumpLabel: self! !!AJJumpLabel methodsFor: 'emitting code'!emitCode: asm	! !!AJJumpLabel methodsFor: 'accessing'!extractLabels: aBlock	aBlock value: name value: position! !!AJJumpLabel methodsFor: 'testing' stamp: 'CamilloBruni 8/22/2012 16:43'!isLabel	^ true! !!AJJumpLabel methodsFor: 'accessing'!isSet	^ isSet == true! !!AJJumpLabel methodsFor: 'accessing'!isSet: anObject	isSet := anObject! !!AJJumpLabel methodsFor: 'printing'!printAsOperandOn: aStream		aStream nextPutAll: '@@';		nextPutAll: name asString ! !!AJJumpLabel methodsFor: 'printing'!printOn: aStream		aStream nextPutAll: '@@';		nextPutAll: name asString ! !!AJJumpLabel methodsFor: 'printing' stamp: 'CamilloBruni 7/17/2012 14:48'!printSelfOn: aStream	aStream nextPutAll: '@@';		nextPutAll: name asString ! !!AJRoutinePrologue methodsFor: 'visitor'!accept: anObject	^ anObject visitRoutinePrologue: self! !!AJRoutinePrologue methodsFor: 'emitting code'!emitCode: asm	machineCode := #[]! !!AJRoutinePrologue methodsFor: 'accessing'!name	^ 'prologue' ! !!AJRoutinePrologue methodsFor: 'visitor' stamp: 'CamilloBruni 10/4/2012 18:54'!setPrologue: anInstructions	"do nothing"	| old |	old := next.	next := anInstructions.	anInstructions last next: old ! !"AsmJit-Instructions"!!AJOperand commentStamp: '<historical>' prior: 0!I am a generic operand used in the ASMJit assembler.I define the interface for setting the final instruction code and annotations.!!AJBaseReg commentStamp: 'MartinMcClure 1/27/2013 09:59' prior: 0!AJBaseReg  -- abstract superclass of all register operands.Instance Variables:	size	<Number>  Width in bytes (1, 2, 4, 8...)	code	<Integer>  Non-negative integer, encoding varies with subclass. For AJx86GPRegisters, ten bits: xyttttnnnn						where nnnn is the register number 0-15, tttt is the "type", which encodes size as a power of 2. 						Higher types are used in other subclasses.						If y is 1, REX prefix is required to encode this register.						If x is 1, this register cannot be used when any REX prefix is present in the instruction.	name	<Symbol>  Name by which this register may be referenced in instructions!!AJRegister commentStamp: '<historical>' prior: 0!I am an abstract superclass for the standard x86 registers.!!AJImmediate commentStamp: '<historical>' prior: 0!I am an immediate (constant integer) operand used by the assembler.Example:	"create an immediate from an integer"	1 asImm.	"implicitely use an immediate in an assembly instrution"	asm := AJx64Assembler new.	asm add: 1 to: asm RAX.	!!AJMem commentStamp: '<historical>' prior: 0!I am memory operand used in assembly instructions. I can be created from an immedate or a register.Memory operands are used to read values indirectly from memory using certain offsets.Example:	asm := AJx86Assembler new.		"create an memory operand on the address 1234"	1234 asImm ptr		"create a simple memory operand with RAX as base"	asm RAX ptr.		"the same with a 8 byte offset"	asm RAX ptr + 8!!AJBaseReg class methodsFor: 'instance creation'!code: aRegisterCode name: aSymbol	^ self basicNew initializeWithCode: aRegisterCode name: aSymbol! !!AJBaseReg methodsFor: 'comparing'!= otherReg	^ (self class == otherReg class) and: [ code = otherReg code ]! !!AJBaseReg methodsFor: 'accessing' stamp: 'CamilloBruni 10/17/2012 15:54'!annotation: anObject	"registers gereally are used as single instances, hence putting	an annotation on the default register will change the annotation	for all the users. To avoid that, the receiver is copied first"	^ self copy		basicAnnotation: anObject;		yourself! !!AJBaseReg methodsFor: 'private' stamp: 'CamilloBruni 10/17/2012 15:54'!basicAnnotation: anObject	"private setter"	annotation := anObject! !!AJBaseReg methodsFor: 'accessing'!code	"Answer the value of code"	^ code! !!AJBaseReg methodsFor: 'accessing'!code: anObject	"Set the value of code"	code := anObject! !!AJBaseReg methodsFor: 'accessing' stamp: 'CamilloBruni 7/17/2012 11:07'!description	^ String streamContents: [ :s | self descriptionOn: s ].! !!AJBaseReg methodsFor: 'printing' stamp: 'CamilloBruni 7/17/2012 11:07'!descriptionOn: aStream	self subclassResponsibility! !!AJBaseReg methodsFor: 'comparing'!hash	^ code hash! !!AJBaseReg methodsFor: 'accessing'!index	^ code bitAnd: RegCodeMask! !!AJBaseReg methodsFor: 'accessing' stamp: 'CamilloBruni 7/17/2012 11:24'!influencingRegisters	^ #()! !!AJBaseReg methodsFor: 'initialize-release' stamp: 'MartinMcClure 1/27/2013 09:35'!initializeWithCode: aRegisterCode name: aSymbol	super initialize.	self code: aRegisterCode.	"Also sets size"	name := aSymbol! !!AJBaseReg methodsFor: 'testing'!isGeneralPurpose	self subclassResponsibility ! !!AJBaseReg methodsFor: 'testing'!isUpperBank	"Used for emitting the REX Prefix Byte on 64bit machines"	^ self index > 7! !!AJBaseReg methodsFor: 'testing' stamp: 'MartinMcClure 1/27/2013 15:34'!isX86	self subclassResponsibility! !!AJBaseReg methodsFor: 'accessing'!name	^ name! !!AJBaseReg methodsFor: 'testing' stamp: 'MartinMcClure 1/27/2013 16:04'!prohibitsRex	"Answer true if this register cannot be used in any instruction that has a REX prefix.	Of the general-purpose registers, this is true only of SPL, BPL, SIL, DIL."	^ (code & RegProhibitsRexMask) ~~ 0! !!AJBaseReg methodsFor: 'testing' stamp: 'MartinMcClure 1/27/2013 16:04'!requiresRex 	"Answer true if use of this register requires that the instruction have a REX prefix.	This can be because the register cannot be accessed except with REX (high bank or 64-only low byte)	or because the register is 64-bits wide"		^(code & RegRequiresRexMask) ~~ 0! !!AJBaseReg methodsFor: 'accessing'!size	^ size! !!AJBaseReg methodsFor: 'accessing' stamp: 'CamilloBruni 4/17/2012 17:59'!type	^ code bitAnd: RegTypeMask! !!AJRegister methodsFor: 'accessing'!code: aCode	code := aCode.	size :=  1 << (( code bitAnd: RegTypeMask ) >> 4).! !!AJRegister methodsFor: 'accessing' stamp: 'CamilloBruni 7/17/2012 12:43'!influencingRegisters	self is8		ifFalse: [ ^ self as8 influencingRegisters ].	^ { self as8. self as16. self as32. self as64}! !!AJRegister methodsFor: 'testing'!isGeneralPurpose	^ false! !!AJRegister methodsFor: 'testing'!isReg	^ true! !!AJRegister methodsFor: 'testing' stamp: 'MartinMcClure 1/30/2013 20:52'!isX86	"Return whether this register is available in the standard x86 instruction set"	^ self requiresRex not & (self index < 8)! !!AJRegister methodsFor: 'accessing'!size	^ 1 << (( code bitAnd: RegTypeMask ) >> 4).! !!AJImmediate class methodsFor: 'as yet unclassified'!ivalue: aValue	^ self new		ivalue: aValue! !!AJImmediate methodsFor: 'converting'!asByte	"answer the byte representing a value"	(self fitsInSize: 1)		ifFalse: [ Error signal: self asString, ' exceeds byte (8bit) range' ].	(self isSigned and: [ value < 0 ]) ifTrue: [ ^ (1<<8) + value ].		^ value! !!AJImmediate methodsFor: 'converting' stamp: 'CamilloBruni 4/4/2012 16:52'!asDWord	"answer the 32bit word representing a value"	(self fitsInSize: 4)		ifFalse: [ Error signal: self asString, ' exceeds doubleword (32bit) range' ].	(self isSigned and: [ value < 0 ]) ifTrue: [ ^ (1<<32) + value ].		^ value! !!AJImmediate methodsFor: 'converting' stamp: 'CamilloBruni 4/4/2012 16:52'!asQWord	"answer the 64bit word representing a value"	(self fitsInSize: 8)		ifFalse: [ Error signal: self asString, ' exceeds quadword (64bit) range' ].	(self isSigned and: [ value < 0 ]) ifTrue: [ ^ (1<<64) + value ].		^ value! !!AJImmediate methodsFor: 'converting'!asWord	"answer the 16bit word representing a value"	(self fitsInSize: 2)		ifFalse: [ Error signal: self asString, ' value exceeds word (16bit) range' ].	(self isSigned and: [ value < 0 ]) ifTrue: [ ^ (1<<16) + value ].		^ value! !!AJImmediate methodsFor: 'emitting code' stamp: 'CamilloBruni 4/4/2012 16:53'!emitUsing: emitter size: aSize	label ifNotNil: [		"this will set the label offset"		emitter setLabelPosition: label. 	].	aSize = 1 ifTrue: [ ^ emitter emitByte: self asByte ].	aSize = 2 ifTrue: [ ^ emitter emitWord: self asWord ].	aSize = 4 ifTrue: [ ^ emitter emitDWord: self asDWord ].	aSize = 8 ifTrue: [ ^ emitter emitQWord: self asQWord ].		self error: aSize asString, 'bytes is an invalid immediate value size'! !!AJImmediate methodsFor: 'accessing'!extractLabels: aBlock	label ifNotNil: [ label extractLabels: aBlock ]    ! !!AJImmediate methodsFor: 'testing' stamp: 'CamilloBruni 4/4/2012 16:54'!fitsInSize: aSize	| maxSize |	maxSize := 1 << (aSize * 8).	self isUnsigned 		ifTrue: [ ^ maxSize > value ].	value < 0 		ifTrue: [ ^ 0 - value <= (maxSize >> 1) ].			^ value < (maxSize>>1)! !!AJImmediate methodsFor: 'initialize-release'!initialize	value := 0.	isUnsigned := false.! !!AJImmediate methodsFor: 'testing'!isImm	^ true! !!AJImmediate methodsFor: 'testing' stamp: 'CamilloBruni 4/4/2012 16:54'!isInt32	  ^ value >= -2147483648 and: [ value <= 2147483647 ]! !!AJImmediate methodsFor: 'testing'!isInt8	^ size ifNil:  [ self fitsInSize: 1 ]		ifNotNil: [ size = 1 ]! !!AJImmediate methodsFor: 'testing'!isSigned 	^ isUnsigned not! !!AJImmediate methodsFor: 'testing'!isUnsigned 	^ isUnsigned! !!AJImmediate methodsFor: 'testing'!isZero	^ value = 0! !!AJImmediate methodsFor: 'accessing'!ivalue: aValue	"signed integer value"	value := aValue.	isUnsigned := false.! !!AJImmediate methodsFor: 'accessing'!label: aLabelName	label := aLabelName! !!AJImmediate methodsFor: 'printing' stamp: 'CamilloBruni 10/5/2012 14:39'!printOn: aStream	aStream nextPut: $(.	self printAnnotationOn: aStream.	  	value > 1000000 		ifTrue: [ aStream nextPutAll: value hex]		ifFalse: [ aStream print: value].	aStream space.			aStream nextPut: (		self isSigned ifTrue: [ $i ] ifFalse: [ $u ]).	size ifNotNil: [ aStream print: size].		aStream nextPut: $).	! !!AJImmediate methodsFor: 'testing' stamp: 'MartinMcClure 1/27/2013 17:49'!prohibitsRex 	"Answer true if use of this operand requires that the instruction *not* have a REX prefix."	^ false! !!AJImmediate methodsFor: 'converting' stamp: 'IgorStasenko 5/28/2012 01:54'!ptr	"turn receiver into a memory operand with absolute address == receiver"		^ AJMem new displacement: self! !!AJImmediate methodsFor: 'accessing'!relocMode	^ relocMode ifNil: [#RelocNone ]! !!AJImmediate methodsFor: 'testing' stamp: 'MartinMcClure 1/27/2013 15:53'!requiresRex	"Answer true if use of this operand requires that the instruction have a REX prefix."	^ false! !!AJImmediate methodsFor: 'accessing'!size	^ size! !!AJImmediate methodsFor: 'accessing'!size: aSize	size := aSize! !!AJImmediate methodsFor: 'accessing'!sizeFor: anOperand	"Check if I am a valid size to be used together with anOperand	If so, I will use as much size as it"	self assert: (self fitsInSize: anOperand size).	^anOperand size! !!AJImmediate methodsFor: 'accessing'!uvalue: aValue	"unsigned value"	self assert: (aValue >=0).	value := aValue.	isUnsigned := true.! !!AJImmediate methodsFor: 'accessing'!value	^ value! !!AJMem methodsFor: 'accessing'!* aScale	self scale: aScale! !!AJMem methodsFor: 'accessing' stamp: 'CamilloBruni 4/4/2012 16:45'!+ displacementOrIndex	displacementOrIndex isInteger 		ifTrue: [ 			self displacement: (AJImmediate new ivalue: displacementOrIndex).			^ self ].		displacementOrIndex isGeneralPurpose 		ifTrue: [ 			index := displacementOrIndex. 			^ self ].		 self error: 'Expected integer or general purpose register for memory displacement but got ', displacementOrIndex class name, '.'.! !!AJMem methodsFor: 'accessing' stamp: 'CamilloBruni 4/4/2012 16:40'!- aDisplacement	aDisplacement isInteger 		ifFalse: [ self error: 'Expected integer for memory displacement but got ', aDisplacement class name, '.' ].	self displacement: (AJImmediate new ivalue: aDisplacement negated).	^ self! !!AJMem methodsFor: 'accessing'!base	"Answer the value of base"	^ base! !!AJMem methodsFor: 'accessing'!base: anObject	"Set the value of base"	base := anObject! !!AJMem methodsFor: 'accessing'!displacement	"Answer the value of displacement"	^ displacement! !!AJMem methodsFor: 'accessing'!displacement: anImm	"Set the value of displacement"	self assert: anImm isImm.	displacement := anImm! !!AJMem methodsFor: 'emitting'!emit32BitAbsoluteDisplacementModRM: emitter code: rCode	self hasIndex		ifTrue: [ 			self assert: index index ~= RIDESP.	" ESP/RSP"			emitter emitMod: 0 reg: rCode rm: 4.			emitter emitScale: shift index: index index base: 5 ]		ifFalse: [ emitter emitMod: 0 reg: rCode rm: 5 ].			self hasLabel		ifTrue: [ 			"X86 uses absolute addressing model, all relative addresses will be			 relocated to absolute ones."			"target is label"			target				addRelocationAt: emitter offset				displacement: displacement				absolute: true				size: 4.			emitter emitInt32: 0 ]		ifFalse: [ 			" Absolute address"			displacement emitUsing: emitter size: 4 ]! !!AJMem methodsFor: 'emitting'!emitBaseDisplacementModRM: emitter code: rCode	| mod |		self base isRip		ifTrue: [ 			emitter emitMod: 0 reg: rCode rm: 2r101.			displacement emitUsing: emitter size: 4.			^ self ]. 			mod := 0.	displacement isZero		ifFalse: [ 			mod := displacement isInt8 ifTrue: [ 1 ] ifFalse: [ 2 ]].			self base index == RIDESP		ifTrue: [ 			"ESP/RSP/R12"			emitter emitMod: mod reg: rCode rm: RIDESP.			emitter emitScale: 0 index: RIDESP base: RIDESP ]		ifFalse: [ 			(self base index ~= RIDEBP and: [ displacement isZero ])				ifTrue: [ 					"just base, and not EBP/RBP/R13 "					^ emitter emitMod: 0 reg: rCode rm: base index ].			"force emitting displacement"			mod = 0ifTrue: [ mod := 1 ].			emitter emitMod: mod reg: rCode rm: base index ].				mod = 1 ifTrue: [ displacement emitUsing: emitter size: 1 ].	mod = 2 ifTrue: [ displacement emitUsing: emitter size: 4 ].! !!AJMem methodsFor: 'emitting' stamp: 'MartinMcClure 1/4/2013 22:22'!emitModRM: emitter code: rCode immSize: immSize	"Receiver is memory location. rCode is a register number"	"[base + displacement]"	(self hasBase and: [ self hasIndex not ])		ifTrue: [ ^ self emitBaseDisplacementModRM: emitter code: rCode ].			"[base + index * scale + displacement]"	(self hasBase and: [ self hasIndex ])		ifTrue: [ ^ self emitScaledBaseDisplacementModRM: emitter code: rCode ].			" Address                       | 32-bit mode | 64-bit mode   ------------------------------+-------------+---------------   [displacement]                |   ABSOLUTE  | RELATIVE (RIP)   [index * scale + displacemnt] |   ABSOLUTE  | ABSOLUTE (ZERO EXTENDED)   In 32 bit mode is used absolute addressing model.   In 64 bit mode is used relative addressing model together with absolute   addressing one. The main problem is that if the instruction contains a SIB byte   then relative addressing (RIP) is not possible. "	emitter is32BitMode		ifTrue: [ ^ self emit32BitAbsoluteDisplacementModRM: emitter code: rCode ].				emitter is64BitMode		ifTrue: [ self shouldBeImplemented ].			self invalidInstruction! !!AJMem methodsFor: 'emitting'!emitScaledBaseDisplacementModRM: emitter code: rCode	self assert: index index ~= RIDESP.	(base index ~= RIDEBP and: [ displacement isZero ])		ifTrue: [ 			emitter emitMod: 0 reg: rCode rm: 4.			^ emitter emitScale: shift index: index index base: base index ].			displacement isInt8		ifTrue: [ 			emitter emitMod: 1 reg: rCode rm: 4.			emitter emitScale: shift index: index index base: base index.			displacement emitUsing: emitter size: 1 ]		ifFalse: [ 			emitter emitMod: 2 reg: rCode rm: 4.			emitter emitScale: shift index: index index base: base index.			displacement emitUsing: emitter size: 4 ].	^ self! !!AJMem methodsFor: 'testing'!hasBase	^ base notNil! !!AJMem methodsFor: 'testing'!hasIndex	^ index notNil! !!AJMem methodsFor: 'accessing'!hasLabel	"Answer the value of hasLabel"	^ false! !!AJMem methodsFor: 'accessing'!hasLabel: anObject	"Set the value of hasLabel"	hasLabel := anObject! !!AJMem methodsFor: 'testing'!hasSegmentPrefix	^ segmentPrefix notNil! !!AJMem methodsFor: 'testing' stamp: 'MartinMcClure 1/4/2013 22:14'!hasUpperBankIndex	"True iff I have an index register, and it is one of r8-r15"	^ self hasIndex and: [ self index isUpperBank ]! !!AJMem methodsFor: 'accessing'!index	"Answer the value of index"	^ index! !!AJMem methodsFor: 'accessing'!index: anIndex	"Set the value of index, must be a general purpose register"	self assert: (anIndex isGeneralPurpose).	index := anIndex! !!AJMem methodsFor: 'initialize-release'!initialize	displacement := AJImmediate new.	shift := 0.! !!AJMem methodsFor: 'testing'!isMem	^ true! !!AJMem methodsFor: 'testing'!isRip	^ self base isRip! !!AJMem methodsFor: 'testing'!isUpperBank	"see `AJBaseReg >> #isUpperBank` "	^ self base isUpperBank! !!AJMem methodsFor: 'printing' stamp: 'MartinMcClure 1/25/2013 22:21'!printOn: aStream	self printAnnotationOn: aStream.	aStream nextPutAll: 'mem['.	base		ifNotNil: [ 			base printAsMemBaseOn: aStream.			(index isNil and: [ displacement isNil ])				ifFalse: [ aStream nextPutAll: ' + ' ] ].	index		ifNotNil: [ 			aStream nextPutAll: index registerName.			self printScaleOn: aStream.			displacement ifNotNil: [ aStream nextPutAll: ' + ' ] ].	displacement ifNotNil: [ aStream print: displacement ].	aStream nextPut: $]! !!AJMem methodsFor: 'printing' stamp: 'MartinMcClure 1/25/2013 22:22'!printScaleOn: aStream	aStream nextPutAll: ' * '.	(2 raisedToInteger: shift) printOn: aStream! !!AJMem methodsFor: 'testing' stamp: 'MartinMcClure 1/27/2013 17:49'!prohibitsRex 	"Answer true if use of this operand requires that the instruction *not* have a REX prefix."	^ false! !!AJMem methodsFor: 'testing' stamp: 'MartinMcClure 1/27/2013 16:16'!requiresRex	"Answer true if use of this operand requires that the instruction have a REX prefix.	For a memory reference, this is true if width of the transfer is 64, 	or if either the base or index register is in the upper bank -- the	use of a 64-bit base or index register is not enough by itself."	^ self is64 or: [ (self hasBase and: [ base isUpperBank ]) or: [ self hasIndex and: [ index isUpperBank ] ] ]! !!AJMem methodsFor: 'accessing' stamp: 'MartinMcClure 1/3/2013 21:15'!scale: aScale	"a valid scale values is 1 , 2 , 4 and 8"	aScale = 1 ifTrue: [  shift := 0. ^ self ].		aScale = 2 ifTrue: [  shift := 1. ^ self ].		aScale = 4 ifTrue: [  shift := 2. ^ self ].		aScale = 8 ifTrue: [  shift := 3. ^ self ].				self error: 'invalid scale value'! !!AJMem methodsFor: 'accessing'!segmentPrefix	"Answer the value of segmentPrefix"	^ segmentPrefix! !!AJMem methodsFor: 'accessing'!segmentPrefix: anObject	"Set the value of segmentPrefix"	segmentPrefix := anObject! !!AJMem methodsFor: 'accessing'!shift	"Answer the value of shift"	^ shift! !!AJMem methodsFor: 'accessing'!shift: value	"Set the value of shift"	self assert: (value >=0 and: [ value < 4 ]).	shift := value! !!AJMem methodsFor: 'accessing' stamp: 'MartinMcClure 1/27/2013 16:23'!size	^ size! !!AJMem methodsFor: 'accessing'!size: anObject	"Set the value of size"	size := anObject! !!AJOperand methodsFor: 'accessing'!annotation	^ annotation! !!AJOperand methodsFor: 'accessing'!annotation: anObject	annotation := anObject! !!AJOperand methodsFor: 'converting'!asAJOperand	"receiver is already an operand. no nothing"! !!AJOperand methodsFor: 'accessing'!clearId	operandId := 0.! !!AJOperand methodsFor: 'accessing'!compilerData	^ compilerData! !!AJOperand methodsFor: 'code generation'!emitPushOnStack: asm	asm push: self! !!AJOperand methodsFor: 'labels'!extractLabels: aBlockClosure	" do nothing"! !!AJOperand methodsFor: 'testing' stamp: 'MartinMcClure 1/4/2013 22:15'!hasUpperBankIndex	"True iff I have an index register, and it is one of r8-r15"	^ false	"Only can be true for memory references."! !!AJOperand methodsFor: 'testing'!is16	^ self size == 2! !!AJOperand methodsFor: 'testing'!is32	^ self size == 4! !!AJOperand methodsFor: 'testing'!is64	^ self size == 8! !!AJOperand methodsFor: 'testing'!is8	^ self size == 1! !!AJOperand methodsFor: 'testing'!isImm	^ false ! !!AJOperand methodsFor: 'testing'!isLabel	^ false! !!AJOperand methodsFor: 'testing'!isMem	^ false! !!AJOperand methodsFor: 'testing'!isNone	"Return true if operand is none (OP_NONE)."	self shouldBeImplemented ! !!AJOperand methodsFor: 'testing'!isReg	^ false! !!AJOperand methodsFor: 'testing'!isRegCode: aRegCode	self shouldBeImplemented ! !!AJOperand methodsFor: 'testing'!isRegIndex: aRegIndex	^ self isReg and: [ self index == (aRegIndex bitAnd: RegCodeMask ) ]! !!AJOperand methodsFor: 'testing'!isRegMem	^ self isReg or: [ self isMem ]! !!AJOperand methodsFor: 'testing'!isRegMem: aRegType	self shouldBeImplemented ! !!AJOperand methodsFor: 'testing'!isRegType: aRegType	^ self isReg and: [self type == aRegType]! !!AJOperand methodsFor: 'testing'!isRegTypeGPB	^ self isRegType: RegGPB! !!AJOperand methodsFor: 'testing'!isRegTypeGPD	^ self isRegType: RegGPD! !!AJOperand methodsFor: 'testing'!isRegTypeGPQ	^ self isRegType: RegGPQ! !!AJOperand methodsFor: 'testing'!isRegTypeGPW	^ self isRegType: RegGPW! !!AJOperand methodsFor: 'testing'!isRegTypeMM	^ false! !!AJOperand methodsFor: 'testing'!isRegTypeX87	^ false! !!AJOperand methodsFor: 'testing'!isRegTypeXMM	^ false! !!AJOperand methodsFor: 'testing'!isRip	^ false! !!AJOperand methodsFor: 'accessing'!operandId	^ operandId! !!AJOperand methodsFor: 'printing' stamp: 'CamilloBruni 8/24/2012 13:56'!printAnnotationOn: aStream	annotation ifNil: [ ^ self ].	aStream 		nextPut: $" ; 		nextPutAll: annotation asString; 		nextPut: $";  space.! !!AJOperand methodsFor: 'printing' stamp: 'CamilloBruni 10/17/2012 15:57'!printAsOperandOn: aStream	self printAnnotationOn: aStream.	^ self printOn: aStream ! !!AJOperand methodsFor: 'testing' stamp: 'MartinMcClure 1/27/2013 17:48'!prohibitsRex	"Answer true if use of this operand requires that the instruction *not* have a REX prefix."	self subclassResponsibility! !!AJOperand methodsFor: 'converting' stamp: 'IgorStasenko 5/28/2012 01:52'!ptr	"turn receiver into a memory operand "		self subclassResponsibility ! !!AJOperand methodsFor: 'converting' stamp: 'IgorStasenko 5/28/2012 01:51'!ptr16	"turn receiver into a memory operand with receiver as base,	with 2 bytes size"		^ self ptr size: 2! !!AJOperand methodsFor: 'converting' stamp: 'IgorStasenko 5/28/2012 01:52'!ptr32	"turn receiver into a memory operand with receiver as base,	with 4 bytes size"		^ self ptr size: 4! !!AJOperand methodsFor: 'converting' stamp: 'IgorStasenko 5/28/2012 01:52'!ptr64	"turn receiver into a memory operand with receiver as base,	with 8 bytes size"		^ self ptr size: 8! !!AJOperand methodsFor: 'converting' stamp: 'IgorStasenko 5/28/2012 01:52'!ptr8	"turn receiver into a memory operand with receiver as base,	with 1 byte size"		^ self ptr size: 1! !!AJOperand methodsFor: 'testing' stamp: 'MartinMcClure 1/27/2013 15:54'!requiresRex	"Answer true if use of this operand requires that the instruction have a REX prefix."	self subclassResponsibility! !!AJOperand methodsFor: 'accessing'!size	"Return size of operand in bytes."		self shouldBeImplemented ! !!AJOperand methodsFor: 'accessing'!size16	^ self size: 2! !!AJOperand methodsFor: 'accessing'!size32	^ self size: 4! !!AJOperand methodsFor: 'accessing'!size64	^ self size: 8! !!AJOperand methodsFor: 'accessing'!size8	^ self size: 1! !!AJOperand methodsFor: 'accessing'!stackSize	^ self size! !"AsmJit-Operands"!!WriteStream methodsFor: '*AsmJit-Extension' stamp: 'CamilloBruni 8/23/2012 15:55'!asLineStream	^ AJLineStream on: self! !!AJLineStream class methodsFor: 'instance creation' stamp: 'CamilloBruni 7/16/2012 15:33'!on: aWriteStream 	^ self new 		writeStream: aWriteStream;		yourself! !!AJLineStream methodsFor: 'writing'!cr	self updateLineStart.	writeStream cr! !!AJLineStream methodsFor: 'writing'!crlf	self updateLineStart.	writeStream crlf! !!AJLineStream methodsFor: 'error handling' stamp: 'CamilloBruni 7/16/2012 14:59'!doesNotUnderstand: aMessage	writeStream 		perform: aMessage selector 		withArguments: aMessage arguments! !!AJLineStream methodsFor: 'writing'!lf	self updateLineStart.	writeStream lf! !!AJLineStream methodsFor: 'writing' stamp: 'CamilloBruni 7/16/2012 15:00'!on: aStream 	^ self new 		writeStream: aStream;		yourself! !!AJLineStream methodsFor: 'writing' stamp: 'CamilloBruni 7/16/2012 15:23'!padColumn: maxCharacterPosition	"pad the current line up to maxCharacterPosition with spaces"	[writeStream position - lineStart < maxCharacterPosition]		whileTrue: [writeStream space]! !!AJLineStream methodsFor: 'writing'!updateLineStart	lineStart := writeStream position! !!AJLineStream methodsFor: 'writing' stamp: 'CamilloBruni 7/16/2012 15:22'!writeStream: aWriteStream 	writeStream := aWriteStream.	self updateLineStart! !!Integer methodsFor: '*AsmJit-Extension'!asAJOperand	"Convert receiver into operand: a signed immediate"	^ AJImmediate new ivalue: self! !!Integer methodsFor: '*AsmJit-Extension'!asByte	^ self asTwosComplement: 16rFF! !!Integer methodsFor: '*AsmJit-Extension'!asDoubleWord	^ self asTwosComplement: 16rFFFFFFFF! !!Integer methodsFor: '*AsmJit-Extension'!asImm	"Convert integer value into a signed immediate operand"	^ AJImmediate new ivalue: self! !!Integer methodsFor: '*AsmJit-Extension'!asImm16	"Convert integer value into a signed immediate word operand "	^ AJImmediate new ivalue: self; size: 2! !!Integer methodsFor: '*AsmJit-Extension'!asImm32	"Convert integer value into a signed immediate operand"	^ AJImmediate new ivalue: self; size: 4! !!Integer methodsFor: '*AsmJit-Extension'!asImm8	"Convert integer value into a signed immediate operand"	^ AJImmediate new ivalue: self; size: 1! !!Integer methodsFor: '*AsmJit-Extension'!asQuadWord	^ self asTwosComplement: 16rFFFFFFFFFFFFFFFF! !!Integer methodsFor: '*AsmJit-Extension'!asTwosComplement: mask	"return the two's completemented cropped version.	Example for a byte value:		-5 asTwosComplement: 16rFF "	| bound |	bound := (mask + 1).		self * 2 >= bound 		ifTrue: [Error signal: self printString , ' too big for signed ', mask highBit printString,  'bit value'].		 	(self >= 0)		ifTrue: [ ^ self bitAnd: mask ].			self * 2 < bound negated 		ifTrue: [Error signal: self printString , ' too small for signed ', mask highBit printString, 'bit value'].			^ (self + mask + 1) bitAnd: mask! !!Integer methodsFor: '*AsmJit-Extension'!asUImm	"Convert integer value into an unsigned immediate operand"	^ AJImmediate new uvalue: self! !!Integer methodsFor: '*AsmJit-Extension'!asUImm16	"Convert integer value into an unsigned immediate operand"	^ AJImmediate new uvalue: self; size: 2! !!Integer methodsFor: '*AsmJit-Extension'!asUImm32	"Convert integer value into an unsigned immediate operand"	^ AJImmediate new uvalue: self; size: 4! !!Integer methodsFor: '*AsmJit-Extension'!asUImm8	"Convert integer value into an unsigned immediate operand"	^ AJImmediate new uvalue: self; size: 1! !!Integer methodsFor: '*AsmJit-Extension'!asWord	^ self asTwosComplement: 16rFFFF! !!Integer methodsFor: '*AsmJit-Extension' stamp: 'CamilloBruni 5/14/2012 17:18'!bin	"Print the receiver as hex, prefixed with 2r."	^self storeStringBase: 2! !!Integer methodsFor: '*AsmJit-Extension'!isByte	^ self >= 0 and: [ self <= 255 ]! !!Integer methodsFor: '*AsmJit-Extension'!printAsOperandOn: aStream	aStream print: self.! !"AsmJit-Extension"!!AJStdCallCallInfo commentStamp: 'IgorStasenko 8/5/2011 06:17' prior: 0!stdcall calling convention.Used on windows. No need for stack cleanup after call. No need to align stack before making call.!!AJReserveTemp commentStamp: 'IgorStasenko 1/18/2012 13:09' prior: 0!note: assembler should set size even before realizing a temp into stack location reference!!AJCallInfo methodsFor: 'accessing'!alignment: aStackAlignment	stackAlignment := aStackAlignment! !!AJCallInfo methodsFor: 'accessing'!alignmentInsertionPoint: instruction	alignInsertionPoint := instruction! !!AJCallInfo methodsFor: 'accessing'!asm: assembler	asm := assembler! !!AJCallInfo methodsFor: 'accessing'!callCleanup: aCallCleanup	self assert: callCleanup isNil.		callCleanup := aCallCleanup ! !!AJCallInfo methodsFor: 'accessing'!defaultArgumentSize	self subclassResponsibility ! !!AJCallInfo methodsFor: 'accessing'!disableCleanup 	noCleanup := true! !!AJCallInfo methodsFor: 'initialize-release'!initialize	arguments := OrderedCollection new.	stackSize := 0.	stackAlignment := 1.	noCleanup := false.! !!AJCallInfo methodsFor: 'accessing'!name	^ 'call info' ! !!AJCallInfo methodsFor: 'testing'!needsAlignment	^ stackAlignment > 1! !!AJCallInfo methodsFor: 'accessing'!noCleanup 	^ noCleanup ! !!AJCallInfo methodsFor: 'accessing'!noticeArgument: aCallArgument	arguments add: aCallArgument.	stackSize := stackSize + aCallArgument size.! !!AJCallInfo methodsFor: 'pushing args'!push: anArgument		asm pushArgument: anArgument forCall: self.! !!AJCallInfo methodsFor: 'accessing'!stackSize	^ stackSize! !!AJCallInfo methodsFor: 'accessing'!stackSize: anObject	stackSize := anObject! !!AJCdeclCallInfo methodsFor: 'emitting code' stamp: 'CamilloBruni 3/29/2012 14:01'!alignedCleanup	asm		mov: savedSP to: asm ESP.			asm releaseTemps: 1 "release our temp afterwards"  ! !!AJCdeclCallInfo methodsFor: 'accessing'!defaultArgumentSize	^ 4! !!AJCdeclCallInfo methodsFor: 'emitting code' stamp: 'CamilloBruni 7/23/2012 13:29'!emitAlignment	| instructions |		instructions := asm		instructionsFor: [ 			asm				decorateWith: 'align stack'				during: [ 					savedSP := asm reserveTemp annotation: 'saved SP'.					asm mov: asm ESP to: savedSP.					stackSize > 0						ifTrue: [ asm sub: asm ESP with: (stackSize asUImm annotation: 'stack size') ].					asm						and: asm ESP with: stackAlignment - 1;						neg: asm ESP;						add: asm ESP with: savedSP ] ].		asm insert: instructions after: alignInsertionPoint.	self emitCleanup! !!AJCdeclCallInfo methodsFor: 'emitting code' stamp: 'CamilloBruni 4/4/2012 16:57'!emitAlignmentIfNeeded	| alignment |		self needsAlignment		ifTrue: [ ^ self emitAlignment ].			self emitCleanup! !!AJCdeclCallInfo methodsFor: 'emitting code'!emitCleanup	noCleanup ifTrue: [ ^ self ].		asm insert: 	(			asm instructionsFor: [			self needsAlignment 				ifTrue: [ self alignedCleanup ]				ifFalse: [ self normalCleanup ]  					]	) after: callCleanup! !!AJCdeclCallInfo methodsFor: 'emitting code'!normalCleanup 	stackSize > 0 ifTrue: [		asm			add: asm ESP with: stackSize 	]! !!AJStdCallCallInfo methodsFor: 'emitting code'!emitAlignment	"do nothing"		"stdcall calling convention requires no stack alignment, no stack cleanup after call"! !!AJStdCallCallInfo methodsFor: 'emitting code'!emitAlignmentIfNeeded	"do nothing"		"stdcall calling convention requires no stack alignment, no stack cleanup after call"! !!AJRoutineStackManager methodsFor: 'as yet unclassified' stamp: 'CamilloBruni 4/4/2012 16:33'!analyzeInstructions: anInstructions assembler: asm		instructions := anInstructions.	assembler := asm.		instructions do: #prepareCallAlignments.			calls do: [:callInfo |		callInfo asm: assembler.		callInfo emitAlignmentIfNeeded ].	instructions do: [:each | each processTempsWith: self].	self emitPrologue.	^ instructions ! !!AJRoutineStackManager methodsFor: 'as yet unclassified'!emitEpilogue: popExtraBytes assembler: asm	asm leave.		popExtraBytes > 0 ifTrue: [		asm ret: popExtraBytes asUImm		]	ifFalse: [		asm ret.		].! !!AJRoutineStackManager methodsFor: 'emitting'!emitPrologue	noStackFrame == true ifTrue: [ ^self ]. 	instructions do: [:each |		each setPrologue: (assembler instructionsFor: [ | numBytes |			assembler 				push: assembler EBP;				mov: assembler ESP to: assembler EBP.							numBytes := extraStackBytes.			numBytes := numBytes + (maxTemps * assembler wordSize ).			 			numBytes > 0 ifTrue: [				(assembler 					sub: assembler ESP with: numBytes) annotation:						extraStackBytes asString , ' extra bytes + ' ,						maxTemps asString , ' temps'				]						]).		]! !!AJRoutineStackManager methodsFor: 'initialize-release'!initialize	self reset.	noStackFrame := false.! !!AJRoutineStackManager methodsFor: 'as yet unclassified'!newCdeclCall 	self stackFrameCheck.	^ calls add: (AJCdeclCallInfo new)! !!AJRoutineStackManager methodsFor: 'as yet unclassified'!newStdCall	self stackFrameCheck.	^ calls add: (AJStdCallCallInfo new)! !!AJRoutineStackManager methodsFor: 'as yet unclassified'!noStackFrame	noStackFrame := true.! !!AJRoutineStackManager methodsFor: 'as yet unclassified'!releaseTemps: count	temps := temps - count! !!AJRoutineStackManager methodsFor: 'as yet unclassified'!reserveExtraBytesOnStack: numBytes		self stackFrameCheck.		extraStackBytes := numBytes ! !!AJRoutineStackManager methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 8/7/2013 19:06'!reserveTemp: anAJReserveTemp	self stackFrameCheck.	temps := temps + 1.	maxTemps := maxTemps max: temps .		anAJReserveTemp operand: (assembler stackFrameValueAtOffset: extraStackBytes + (temps * assembler wordSize )).! !!AJRoutineStackManager methodsFor: 'initialize-release'!reset	instructions := nil.	assembler := nil.	calls := OrderedCollection new.	temps := maxTemps := extraStackBytes := 0.! !!AJRoutineStackManager methodsFor: 'as yet unclassified'!stackFrameCheck	noStackFrame ifTrue: [		self error: 'Operation requires stack frame management to be enabled for generated code'		].! !!AJReleaseTemps methodsFor: 'visitor'!accept: anObject	anObject visitReleaseTemps: self   ! !!AJReleaseTemps methodsFor: 'accessing'!count	^ count! !!AJReleaseTemps methodsFor: 'accessing'!count: anObject	count := anObject! !!AJReleaseTemps methodsFor: 'printing'!printOn: aStream	^ self printSelfOn: aStream  ! !!AJReleaseTemps methodsFor: 'printing'!printSelfOn: aStream	aStream nextPutAll: 'Release temps: ';	print: count   ! !!AJReleaseTemps methodsFor: 'visitor'!processTempsWith: anObject	anObject releaseTemps: count! !!AJReserveTemp methodsFor: 'visitor'!accept: anObject	^ anObject reserveTemp: self! !!AJReserveTemp methodsFor: 'converting'!asAJOperand		^ operands first! !!AJReserveTemp methodsFor: 'emitting code'!emitPushOnStack: asm	^ asm push: self! !!AJReserveTemp methodsFor: 'testing'!isMem	^ true! !!AJReserveTemp methodsFor: 'accessing' stamp: 'CamilloBruni 8/24/2012 13:32'!name	^ name ifNil: [ 'Reserve temp' ]! !!AJReserveTemp methodsFor: 'accessing'!operand	^ operands first! !!AJReserveTemp methodsFor: 'accessing'!operand: anObject	anObject annotation: annotation.  	operands := Array with: anObject ! !!AJReserveTemp methodsFor: 'printing' stamp: 'CamilloBruni 7/20/2012 13:29'!printAsOperandOn: aStream		annotation ifNotNil: [		aStream nextPut: $"; nextPutAll: annotation asString; nextPut: $"; space	].	operands 		ifNil: [ ^ aStream nextPutAll: 'aStackTEMP' ].	self operand printAsOperandOn: aStream.! !!AJReserveTemp methodsFor: 'printing'!printOn: aStream	^ self printSelfOn: aStream  ! !!AJReserveTemp methodsFor: 'visitor'!processTempsWith: anObject	anObject reserveTemp: self  ! !!AJReserveTemp methodsFor: 'testing' stamp: 'IgorStasenko 8/13/2013 13:45'!prohibitsRex"This test is used to validate if operand(s) is valid.. but reserve temp could not have an operand assigned yet and validation can be only performed at instruction analyzis stage (right before emitting the code), but not at instruction creation time"	self flag: #todo. 	^ false! !!AJReserveTemp methodsFor: 'accessing'!size	^ size! !!AJReserveTemp methodsFor: 'accessing'!size: number	size := number! !!AJReserveTemp methodsFor: 'accessing'!stackSize	^ self size! !!AJCallArgument methodsFor: 'visitor'!accept: anObject	^ anObject visitCallArgument: self  ! !!AJCallArgument methodsFor: 'accessing'!instructionName	^ #push! !!AJCallArgument methodsFor: 'accessing'!name	^ 'argument push:'! !!AJCallArgument methodsFor: 'function calls'!prepareCallAlignments	callInfo noticeArgument: self! !!AJCallArgument methodsFor: 'accessing'!size	^ size ! !!AJCallArgument methodsFor: 'accessing'!size: aSmallInteger 	size := aSmallInteger! !!AJCallArgument methodsFor: 'accessing'!stackOffset: anOffset	stackOffset := anOffset ! !!AJCallCleanup methodsFor: 'visitor'!accept: anObject	^ anObject visitCallCleanup: self! !!AJCallCleanup methodsFor: 'accessing'!name	^ 'call cleanup'! !!AJCallCleanup methodsFor: 'function calls'!prepareCallAlignments	callInfo callCleanup: self! !!AJStackInstruction methodsFor: 'accessing'!callInfo	^ callInfo! !!AJStackInstruction methodsFor: 'accessing'!callInfo: anObject	callInfo := anObject! !"AsmJit-StackManagement"!!AJMMRegister commentStamp: '<historical>' prior: 0!I am register used for the MMX integer instructions on IA-32 processors.MMX registers are 64Bit wide, depending on the instructions used the register is used either as 1 x 64bit value, 2 x 32bit values, 4 x 16bit values or 8 x 8bit values.Note that the MMX register overlap with the floating point register and only use the lower 64bits of the 80bits FPU registers.!!AJx87Register commentStamp: '<historical>' prior: 0!I am an x87 Floating Point register (ST0 - ST7) used in the FPU stack. The lower 64bit of the floating point ST registers are shared with the MMX registers.!!AJxMMRegister commentStamp: '<historical>' prior: 0!I am a register used by the SSE (Streaming SIMD Extensions) for the x86 instruction set. The independent XMM registers are 128bit wide and do not overlap with any other existing registers.Depending on the instructions used the XMM registers represent different data types:	SSE:  4 x 32bit single precision floats	SSE2: 2 x 64bit double prexision floats	      2 x 64bit integers	      4 x 32bit integers	      8 x 16bit short integers	      16 x 8bit bytes/characters!!AJx86Registers commentStamp: '<historical>' prior: 0!I am a SHaredPool which initializes all the registers needed by the Assmbler.!!AJx86Assembler commentStamp: '<historical>' prior: 0!I am an Assmbler for the Intel x86 (32Bit) architecture.Example:	asm := AJx64Assembler new.	"by default the assembler will set up a stack frame"	asm noStackFrame.	"load the constant 16r12 into the RAX register"	asm mov: 16r12 to: asm RAX.	"output the bytes for this instruction"	asm bytes !!AJx64Assembler commentStamp: '<historical>' prior: 0!I am an assembler for the Intel x86-64 architecture.!!AJx86GPRegister commentStamp: 'sig 12/7/2009 03:22' prior: 0!A general purpose x86 & x64 registers!!AJx64RipRegister commentStamp: '<historical>' prior: 0!Virtual registers used for relative instruction pointer addressing in 64Bit modeIn IA-32 architecture and compatibility mode, addressing relative to the instruction pointer is available only with control-transfer instructions. In 64-bit mode, instruc- tions that use ModR/M addressing can use RIP-relative addressing. Without RIP-rela- tive addressing, all ModR/M instruction modes address memory relative to zero.!!AJx86InstructionDescription commentStamp: 'sig 12/7/2009 10:36' prior: 0!name:		an instruction mnemonic	group:		an instruction encoding group	o1Flags:		operand1 flags	o2Flags:		operand2 flags	opCode1:		opcode 1	opCode2:		opcode 2	opCodeR:		code for inlining in MR field as registerOperand flags:bit:	 9   |  8   |  7    |   6  |  5    |   4    |  3  |  2   |  1  | 0 |______________________________________________      *86| *64 | XMM | MM | IMM | MEM | 64 | 32 | 16 | 8|	- *64 , set on o1Flags, meaning that instruction available only for x64 processor mode- *86 , set on o1Flags, meaning that instruction available only for x86 processor mode!!AJx64Instruction methodsFor: 'accessing'!instructionDesciptions	^ AJx64InstructionDescription instructions! !!AJx64Instruction methodsFor: 'testing'!is32BitMode	^ false! !!AJx64Instruction methodsFor: 'testing'!is64BitMode	^ true! !!AJx64Instruction methodsFor: 'testing' stamp: 'MartinMcClure 1/30/2013 20:59'!requiresRex	"Answer true if I absolutely must have a REX prefix."	^ (operands		detect: [ :rawOp | 			| op |			op := rawOp asAJOperand.			op requiresRex | op is64 ]		ifNone: [ #none ]) ~~ #none! !!AJx86Instruction methodsFor: 'visitor'!accept: anObject	"generic instruction"	^ anObject visitInstruction: self	! !!AJx86Instruction methodsFor: 'consistency' stamp: 'MartinMcClure 2/9/2013 14:15'!checkOperandsForConflict	"Signal an error if the given operands cannot be used together. Must be sent after operands are set."	| prohibited required |	required := self requiresRex.	prohibited := false.	operands		do: [ :op | 			(op isInteger not and: [ op prohibitsRex ])				ifTrue: [ prohibited := true ] ].	prohibited & required		ifTrue: [ self error: 'Mix of operands that require and prohibit a REX prefix' ]! !!AJx86Instruction methodsFor: 'accessing' stamp: 'CamilloBruni 4/17/2012 17:55'!description	^ description! !!AJx86Instruction methodsFor: 'accessing' stamp: 'CamilloBruni 4/17/2012 17:55'!description: anInstructionDescription	description := anInstructionDescription! !!AJx86Instruction methodsFor: 'code generation' stamp: 'CamilloBruni 3/29/2012 13:54'!emitByte: byte	self assert: byte isByte.	machineCode nextPut: byte ! !!AJx86Instruction methodsFor: 'code generation' stamp: 'CamilloBruni 4/17/2012 17:56'!emitCode: asm	"do not generate machine code if it is already there"	machineCode ifNotNil: [ ^ self ].		"make sure all operands are converted"	operands ifNotNil: [ operands := operands collect: #asAJOperand ].		machineCode := WriteStream on: (ByteArray new: 16).			description emitUsing: self operands: operands.	machineCode := machineCode contents.! !!AJx86Instruction methodsFor: 'code generation'!emitDWord: dword 	"Emit dword (4 bytes) in little-endian order (since our target it x86 anyways)"		self 		emitByte: (dword bitAnd: 255);		emitByte: (dword>>8 bitAnd: 255);				emitByte: (dword>>16 bitAnd: 255);		emitByte: (dword>>24 bitAnd: 255)		! !!AJx86Instruction methodsFor: 'code generation'!emitImmediate: imm size: size	^ imm emitUsing: self size: size! !!AJx86Instruction methodsFor: 'code generation' stamp: 'CamilloBruni 3/28/2012 15:59'!emitMod: mod reg: reg rm: rm	"Emit MODR/M byte.	mmrrrxxx		mm = mod	rrr = REG (r8/r16/r32/mm/xmm	xxx = r/m	"		^ self emitByte: (mod & 3) << 3 + (reg & 7) << 3 + (rm & 7)	! !!AJx86Instruction methodsFor: 'code generation'!emitOpCode: opCode	| byte |	"instruction prefix"	(byte := (opCode bitAnd: 16rFF000000)) = 0 ifFalse: [		self emitByte: byte >> 24 ].	(byte := (opCode bitAnd: 16r00FF0000)) = 0 ifFalse: [		self emitByte: byte >> 16 ].	(byte := (opCode bitAnd: 16r0000FF00)) = 0 ifFalse: [		self emitByte: byte >> 8 ].	self emitByte: (opCode bitAnd: 16rFF).	! !!AJx86Instruction methodsFor: 'code generation - prefixes' stamp: 'CamilloBruni 3/30/2012 17:07'!emitOperandSizeOverridePrefix: anOperand	"If creating 64bit code, this must be called last of the prefix-generators, as the 64-bit prefixes are required to precede the opcode"	"Switch to 16-bit operand mode for the next opcode if necessary"	anOperand is16 ifTrue: [ self emitByte: 16r66].	self emitRexRM: anOperand is64 regCode: 0 rm: anOperand		! !!AJx86Instruction methodsFor: 'code generation'!emitQWord: dword 	"Emit a qword (8 bytes) in little-endian order (since our target it x86 anyways)"		self 		emitByte: (dword bitAnd: 255);		emitByte: (dword>>8 bitAnd: 255);				emitByte: (dword>>16 bitAnd: 255);		emitByte: (dword>>24 bitAnd: 255);				emitByte: (dword>>32 bitAnd: 255);		emitByte: (dword>>40 bitAnd: 255);				emitByte: (dword>>48 bitAnd: 255);		emitByte: (dword>>56 bitAnd: 255)		! !!AJx86Instruction methodsFor: 'code generation'!emitRexForInteger: anInt op2: op2		self emitRexPrefixW: op2 is64 R: false X: false  B:  op2 isUpperBank.! !!AJx86Instruction methodsFor: 'code generation' stamp: 'MartinMcClure 1/4/2013 22:14'!emitRexForOp1: op1 op2: op2	"op1 is the general-purpose register argument (or a register number).	op2 is the reg/mem argument.		In 64-bit mode, the instruction's default operation size is 32 bits. 	Use of the REX.W prefix promotes operation to 64 bits. 	Use of the REX.R prefix permits access to additional registers (R8-R15) for the op1 (reg) register. 	Use of the REX.B prefix permits access to additional registers (R8-R15) for the op2 (r/m) register, or the base register of op2 if register indirect. 	Use of the REX.X prefix permits access to additional registers (R8-R15) for the index register of op2, if indexed.	See the summary chart at the beginning of this section for encoding data and limits."	| requires64Bit |	"no-op in 32 bit mode"	self is32BitMode		ifTrue: [ ^ self ].	op1 isInteger		ifTrue: [ ^ self emitRexForInteger: op1 op2: op2 ].	requires64Bit := op1 is64 or: [ op2 isReg and: [ op2 is64 ] ].	self		emitRexPrefixW: requires64Bit		R: op1 isUpperBank		X: op2 hasUpperBankIndex		B: op2 isUpperBank! !!AJx86Instruction methodsFor: 'code generation'!emitRexForSingleOperand: op	"In 64-bit mode, the instructions default operation size is 32 bits. 	Use of the REX.W prefix promotes operation to 64 bits. 	Use of the REX.B prefix permits access to additional registers (R8-R15). 	See the summary chart at the beginning of this section for encoding data and limits."	 	self emitRexPrefixW: op is64 R: false X: false B: op isUpperBank .! !!AJx86Instruction methodsFor: 'code generation' stamp: 'MartinMcClure 1/27/2013 16:24'!emitRexPrefixW: w R: r X: x B: b	"	field  bit   def	-      7-4   2r0100 REX prefix identifier	W      3     0 = Operand size determined by CS.D	             1 = 64 Bit Operand Size	R      2     Extension of the ModR/M reg field	X      1     Extension of the SIB index field	B      0     Extension of the ModR/M r/m field. SIB base field, or Opcode reg field	"	self requiresRex		ifTrue: [ 			self is32BitMode				ifTrue: [ self error: 'Attempt to use a 64-bit-specific instruction or operand in 32-bit mode' ]				ifFalse: [ self emitByte: 2r0100 << 4 | (w asBit << 3) | (r asBit << 2) | (x asBit << 1) | b asBit ] ]! !!AJx86Instruction methodsFor: 'code generation'!emitRexR: w opReg: opReg regCode: regCode	"no-op in 32 bit mode"	! !!AJx86Instruction methodsFor: 'code generation' stamp: 'CamilloBruni 4/4/2012 17:10'!emitRexRM: opRequires64Bit regCode: regCode rm: rm		self emitRexPrefixW: opRequires64Bit R: (regCode > 7) X: false B: rm isUpperBank	! !!AJx86Instruction methodsFor: 'code generation' stamp: 'MartinMcClure 1/4/2013 22:27'!emitScale: shift index: indexCode base: baseCode	self emitByte: ((shift << 3) + (indexCode bitAnd: 7) << 3) + (baseCode bitAnd: 7)! !!AJx86Instruction methodsFor: 'code generation'!emitSegmentPrefix: aMem	(aMem isMem and: [ aMem hasSegmentPrefix ]) ifTrue: [		self emitByte: aMem segmentPrefixCode.	]! !!AJx86Instruction methodsFor: 'emitting code'!emitWord: aWord 	"little-endian"		self 		emitByte: (aWord bitAnd: 255);		emitByte: ((aWord >> 8) bitAnd: 255)	! !!AJx86Instruction methodsFor: 'code generation' stamp: 'CamilloBruni 3/30/2012 17:10'!emitX86Inl: opCode reg: reg	"Emit instruction where register is inlined to opcode."	^ self emitX86Inl: opCode reg: reg withRex: true! !!AJx86Instruction methodsFor: 'code generation'!emitX86Inl: opCode reg: reg withRex: useREX	"Emit instruction where register is inlined to opcode."	| byte |	"16 bit prefix"	reg size == 2 		ifTrue: [ self emitByte: 16r66 ].		"instruction prefix"	(byte := (opCode bitAnd: 16rFF000000)) = 0 ifFalse: [		self emitByte: byte >> 24 ].		useREX ifTrue: [ self emitRexForSingleOperand: reg ].		(byte := (opCode bitAnd: 16r00FF0000)) = 0 ifFalse: [		self emitByte: byte >> 16 ].	(byte := (opCode bitAnd: 16r0000FF00)) = 0 ifFalse: [		self emitByte: byte >> 8 ].	self emitByte: (opCode bitAnd: 16rFF) + (reg code bitAnd: 7).! !!AJx86Instruction methodsFor: 'code generation'!emitX86RM: opCode size: aSize regOrCode: regOrCode rm: regOrMem "Emit instruction with reg/memory operand."		^ self emitX86RM: opCode size: aSize regOrCode: regOrCode rm: regOrMem immSize: 0! !!AJx86Instruction methodsFor: 'code generation' stamp: 'CamilloBruni 3/30/2012 16:50'!emitX86RM: opCode size: aSize regOrCode: regOrCode rm: regOrMem immSize: immSize	"Emit instruction with reg/memory operand."		| byte code |	code := regOrCode isInteger ifTrue: [ regOrCode ] ifFalse: [ regOrCode code ].	"16 bit prefix"	aSize == 2 ifTrue: [ self emitByte: 16r66 ].		"segment prefix"	self emitSegmentPrefix: regOrMem.	"instruction prefix"	(byte := (opCode bitAnd: 16rFF000000)) = 0 ifFalse: [		self emitByte: byte >> 24 ].		self emitRexForOp1: regOrCode op2: regOrMem.		(byte := (opCode bitAnd: 16r00FF0000)) = 0 ifFalse: [		self emitByte: byte >> 16 ].	(byte := (opCode bitAnd: 16r0000FF00)) = 0 ifFalse: [		self emitByte: byte >> 8 ].	self emitByte: (opCode bitAnd: 16rFF).	"ModR/M"	^ regOrMem emitModRM: self code: code immSize: immSize! !!AJx86Instruction methodsFor: 'accessing' stamp: 'CamilloBruni 8/23/2012 16:01'!instructionDesciptions	^ AJx86InstructionDescription instructions! !!AJx86Instruction methodsFor: 'testing'!is32BitMode	^ true! !!AJx86Instruction methodsFor: 'testing'!is64BitMode	^ false! !!AJx86Instruction methodsFor: 'testing'!isGPNRegister: reg	"answer true if given register is native general purpose register,	matching the target native size i.e. 32 bits for x86 or 64 bits for x64"	^ reg isGeneralPurpose and: [ reg size = 4 ]! !!AJx86Instruction methodsFor: 'testing' stamp: 'MartinMcClure 1/27/2013 15:47'!requiresRex	^false! !!AJx86Instruction methodsFor: 'code generation'!setLabelPosition: label	"set label position for immediate operand(s), if any"	label position: self position + machineCode size.  ! !!AJx64JumpInstruction methodsFor: 'accessing'!instructionDesciptions	^ AJx64InstructionDescription instructions! !!AJx86JumpInstruction methodsFor: 'accessing'!codeSize 	machineCode ifNil: [  ^ 2 ].	^ machineCode size! !!AJx86JumpInstruction methodsFor: 'emitting code' stamp: 'CamilloBruni 8/22/2012 14:34'!emitCode: asm	"generate opcodes"	| delta code nextInstruction target desc |		target := label position.	target ifNil: [ ^ machineCode := nil ].		nextInstruction := position + 2.	delta := (target - nextInstruction) asImm.	desc := self instructionDesciptions at: name.	"can we use 8bit offset?"	machineCode := delta isInt8		ifTrue: [ 	self emitShortJump: desc offset: delta ]		ifFalse: [ self emitLongJump: desc target: target ]! !!AJx86JumpInstruction methodsFor: 'emitting code' stamp: 'CamilloBruni 8/22/2012 18:07'!emitCodeAtOffset: offset assembler: asm		position := offset.	[ | labelPos | 		labelPos := label position.		labelPos ifNotNil: [ self emitCode: asm ].		next ifNotNil: [ 			next emitCodeAtOffset: offset + self machineCodeSize assembler: asm ].		label position ~= labelPos ] whileTrue.		label position ifNil: [ self errorUndefinedLabel: label  ]! !!AJx86JumpInstruction methodsFor: 'emitting code'!emitConditionalJump: addr to: desc	^ {16r0F.	(16r80 + desc opCode1).	(addr bitAnd: 255).	(addr >> 8 bitAnd: 255).	(addr >> 16 bitAnd: 255).	(addr >> 24 bitAnd: 255)} asByteArray! !!AJx86JumpInstruction methodsFor: 'emitting code'!emitLongJump: desc target: target	| addr sz nextInstruction |		sz := self isConditional		ifTrue: [ 2 ]		ifFalse: [ 1 ].			nextInstruction := position + 4 + sz.	addr := (AJImmediate ivalue: target - nextInstruction) asDWord.		^ self isConditional		ifFalse: [ self emitUnconditionalJumpTo: addr ]		ifTrue: [ 	self emitConditionalJump: addr to: desc ]! !!AJx86JumpInstruction methodsFor: 'emitting code'!emitShortJump: desc offset: delta	"short jump"	^ self isConditional		ifTrue: [ {(16r70 + desc opCode1). (delta asByte)} asByteArray ]		ifFalse: [ {16rEB. (delta asByte)} asByteArray ]! !!AJx86JumpInstruction methodsFor: 'emitting code'!emitUnconditionalJumpTo: addr	^ {	16rE9.	(addr bitAnd: 255).	(addr >> 8 bitAnd: 255).	(addr >> 16 bitAnd: 255).	(addr >> 24 bitAnd: 255)} asByteArray! !!AJx86JumpInstruction methodsFor: 'convenience' stamp: 'CamilloBruni 8/22/2012 18:07'!errorUndefinedLabel: aLabel 	^ self error: 'undefined label: ', aLabel name! !!AJx86JumpInstruction methodsFor: 'accessing' stamp: 'CamilloBruni 8/23/2012 16:01'!instructionDesciptions	^ AJx86InstructionDescription instructions! !!AJx86JumpInstruction methodsFor: 'testing'!isConditional	^ name ~~ #jmp! !!AJx86JumpInstruction methodsFor: 'accessing'!machineCodeSize	machineCode ifNil: [ ^ 2 ].		^ machineCode size! !!AJMMRegister methodsFor: 'accessing'!code: aCode	code := aCode.	size := 8.! !!AJMMRegister methodsFor: 'printing' stamp: 'CamilloBruni 7/17/2012 11:13'!descriptionOn: s		s nextPutAll: 'An MMX register'.! !!AJMMRegister methodsFor: 'accessing' stamp: 'CamilloBruni 5/7/2013 11:32'!influencingRegisters	"MMX registers overlap with the ST register"	self shouldBeImplemented.! !!AJMMRegister methodsFor: 'testing'!isGeneralPurpose	^ false! !!AJMMRegister methodsFor: 'testing'!isRegTypeMM	^ true! !!AJMMRegister methodsFor: 'testing' stamp: 'MartinMcClure 1/27/2013 15:28'!isX86	^ true! !!AJx87Register methodsFor: 'accessing'!code: aCode	code := aCode bitOr: RegX87.	size := 10.! !!AJx87Register methodsFor: 'printing' stamp: 'CamilloBruni 7/17/2012 11:12'!descriptionOn: s	s nextPutAll: 'A floating point register'.! !!AJx87Register methodsFor: 'accessing' stamp: 'CamilloBruni 5/7/2013 11:32'!influencingRegisters	"ST registers overlap with the MMX register"	self shouldBeImplemented.! !!AJx87Register methodsFor: 'testing'!isGeneralPurpose	^ false! !!AJx87Register methodsFor: 'testing'!isRegTypeX87	^ true! !!AJx87Register methodsFor: 'testing' stamp: 'MartinMcClure 1/27/2013 15:31'!isX86	^ true! !!AJxMMRegister methodsFor: 'accessing'!code: aCode	code := aCode.	size := 16! !!AJxMMRegister methodsFor: 'printing' stamp: 'CamilloBruni 7/17/2012 11:15'!descriptionOn: s		s nextPutAll: 'An SSE register'.! !!AJxMMRegister methodsFor: 'testing'!isGeneralPurpose	^ false! !!AJxMMRegister methodsFor: 'testing'!isRegTypeXMM	^ true! !!AJxMMRegister methodsFor: 'testing' stamp: 'MartinMcClure 1/27/2013 15:33'!isX86	^ self index < 8! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'MartinMcClure 1/27/2013 20:55'!BPL	^ BPL! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'MartinMcClure 1/27/2013 20:55'!DIL	^ DIL! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!EIP	"A 32bit instruction pointer register	This register overlaps with IP, EIP, RIP"	^ EIP! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!IP	"A 16bit instruction pointer register	This register overlaps with IP, EIP, RIP"	^ IP! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!R10	"A 64bit general purpose register	This register overlaps with R10B, R10W, R10D, R10"	^ R10! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!R10B	"A 8bit general purpose register	This register overlaps with R10B, R10W, R10D, R10"	^ R10B! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!R10D	"A 32bit general purpose register	This register overlaps with R10B, R10W, R10D, R10"	^ R10D! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!R10W	"A 16bit general purpose register	This register overlaps with R10B, R10W, R10D, R10"	^ R10W! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!R11	"A 64bit general purpose register	This register overlaps with R11B, R11W, R11D, R11"	^ R11! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!R11B	"A 8bit general purpose register	This register overlaps with R11B, R11W, R11D, R11"	^ R11B! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!R11D	"A 32bit general purpose register	This register overlaps with R11B, R11W, R11D, R11"	^ R11D! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!R11W	"A 16bit general purpose register	This register overlaps with R11B, R11W, R11D, R11"	^ R11W! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!R12	"A 64bit general purpose register	This register overlaps with R12B, R12W, R12D, R12"	^ R12! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!R12B	"A 8bit general purpose register	This register overlaps with R12B, R12W, R12D, R12"	^ R12B! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!R12D	"A 32bit general purpose register	This register overlaps with R12B, R12W, R12D, R12"	^ R12D! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!R12W	"A 16bit general purpose register	This register overlaps with R12B, R12W, R12D, R12"	^ R12W! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!R13	"A 64bit general purpose register	This register overlaps with R13B, R13W, R13D, R13"	^ R13! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!R13B	"A 8bit general purpose register	This register overlaps with R13B, R13W, R13D, R13"	^ R13B! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!R13D	"A 32bit general purpose register	This register overlaps with R13B, R13W, R13D, R13"	^ R13D! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!R13W	"A 16bit general purpose register	This register overlaps with R13B, R13W, R13D, R13"	^ R13W! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!R14	"A 64bit general purpose register	This register overlaps with R14B, R14W, R14D, R14"	^ R14! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!R14B	"A 8bit general purpose register	This register overlaps with R14B, R14W, R14D, R14"	^ R14B! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!R14D	"A 32bit general purpose register	This register overlaps with R14B, R14W, R14D, R14"	^ R14D! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!R14W	"A 16bit general purpose register	This register overlaps with R14B, R14W, R14D, R14"	^ R14W! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!R15	"A 64bit general purpose register	This register overlaps with R15B, R15W, R15D, R15"	^ R15! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!R15B	"A 8bit general purpose register	This register overlaps with R15B, R15W, R15D, R15"	^ R15B! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!R15D	"A 32bit general purpose register	This register overlaps with R15B, R15W, R15D, R15"	^ R15D! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!R15W	"A 16bit general purpose register	This register overlaps with R15B, R15W, R15D, R15"	^ R15W! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!R8	"A 64bit general purpose register	This register overlaps with R8B, R8W, R8D, R8"	^ R8! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!R8B	"A 8bit general purpose register	This register overlaps with R8B, R8W, R8D, R8"	^ R8B! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!R8D	"A 32bit general purpose register	This register overlaps with R8B, R8W, R8D, R8"	^ R8D! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!R8W	"A 16bit general purpose register	This register overlaps with R8B, R8W, R8D, R8"	^ R8W! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!R9	"A 64bit general purpose register	This register overlaps with R9B, R9W, R9D, R9"	^ R9! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!R9B	"A 8bit general purpose register	This register overlaps with R9B, R9W, R9D, R9"	^ R9B! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!R9D	"A 32bit general purpose register	This register overlaps with R9B, R9W, R9D, R9"	^ R9D! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!R9W	"A 16bit general purpose register	This register overlaps with R9B, R9W, R9D, R9"	^ R9W! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!RAX	"A 64bit general purpose register	This register overlaps with AL, AX, EAX, RAX"	^ RAX! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!RBP	"A 64bit general purpose register	This register overlaps with CH, CX, ECX, RCX"	^ RBP! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!RBX	"A 64bit general purpose register	This register overlaps with BL, BX, EBX, RBX"	^ RBX! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!RCX	"A 64bit general purpose register	This register overlaps with CL, CX, ECX, RCX"	^ RCX! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!RDI	"A 64bit general purpose register	This register overlaps with BH, BX, EBX, RBX"	^ RDI! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!RDX	"A 64bit general purpose register	This register overlaps with DL, DX, EDX, RDX"	^ RDX! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!RIP	"A 64bit instruction pointer register	This register overlaps with IP, EIP, RIP"	^ RIP! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!RSI	"A 64bit general purpose register	This register overlaps with DH, DX, EDX, RDX"	^ RSI! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!RSP	"A 64bit general purpose register	This register overlaps with AH, AX, EAX, RAX"	^ RSP! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'MartinMcClure 1/27/2013 20:55'!SIL	^ SIL! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'MartinMcClure 1/27/2013 20:54'!SPL	^ SPL! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!XMM10	"An SSE register"	^ XMM10! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!XMM11	"An SSE register"	^ XMM11! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!XMM12	"An SSE register"	^ XMM12! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!XMM13	"An SSE register"	^ XMM13! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!XMM14	"An SSE register"	^ XMM14! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!XMM15	"An SSE register"	^ XMM15! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!XMM8	"An SSE register"	^ XMM8! !!AJx64Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!XMM9	"An SSE register"	^ XMM9! !!AJx64Assembler methodsFor: 'register'!accumulator	^ RAX! !!AJx64Assembler methodsFor: 'register'!basePointer	^ RBP ! !!AJx64Assembler methodsFor: 'register'!counter	^ RCX! !!AJx64Assembler methodsFor: 'register'!data	^ RDX! !!AJx64Assembler methodsFor: 'register'!destinationIndex	^ RDI! !!AJx64Assembler methodsFor: 'initialize-release' stamp: 'CamilloBruni 4/17/2012 18:16'!initialize	super initialize.	is64 := true.! !!AJx64Assembler methodsFor: 'accessing' stamp: 'CamilloBruni 4/17/2012 18:17'!instructionDesciptions	^ AJx64InstructionDescription instructions! !!AJx64Assembler methodsFor: 'register'!instructionPointer	^ RIP! !!AJx64Assembler methodsFor: 'testing'!is32	^ false! !!AJx64Assembler methodsFor: 'accessing' stamp: 'CamilloBruni 4/18/2012 15:25'!newInstruction	^ AJx64Instruction new! !!AJx64Assembler methodsFor: 'accessing' stamp: 'CamilloBruni 4/18/2012 15:24'!newJumpInstruction	^ AJx64JumpInstruction new! !!AJx64Assembler methodsFor: 'accessing'!numGPRegisters	^ 16! !!AJx64Assembler methodsFor: 'accessing'!pointerSize	"see AJx86Assembler >> #pointerSize"	^ 8! !!AJx64Assembler methodsFor: 'register'!sourceIndex	^ RSI! !!AJx64Assembler methodsFor: 'register'!stackPointer	^ RSP! !!AJx86Assembler class methodsFor: 'debugging'!gccDisassemble: bytesArray	"compile the given bytes to a C binary and disassemble it using gdb"	^ self new gccDisassemble: bytesArray! !!AJx86Assembler class methodsFor: 'instance creation' stamp: 'CamilloBruni 4/19/2012 11:46'!noStackFrame	^ self new noStackFrame! !!AJx86Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!AH	"A 8bit general purpose register	This register overlaps with AH, AX, EAX, RAX"	^ AH! !!AJx86Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!AL	"A 8bit general purpose register	This register overlaps with AL, AX, EAX, RAX"	^ AL! !!AJx86Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!AX	"A 16bit general purpose register	This register overlaps with AL, AX, EAX, RAX"	^ AX! !!AJx86Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!BH	"A 8bit general purpose register	This register overlaps with BH, BX, EBX, RBX"	^ BH! !!AJx86Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!BL	"A 8bit general purpose register	This register overlaps with BL, BX, EBX, RBX"	^ BL! !!AJx86Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!BP	"A 16bit general purpose register	This register overlaps with CH, CX, ECX, RCX"	^ BP! !!AJx86Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!BX	"A 16bit general purpose register	This register overlaps with BL, BX, EBX, RBX"	^ BX! !!AJx86Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!CH	"A 8bit general purpose register	This register overlaps with CH, CX, ECX, RCX"	^ CH! !!AJx86Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!CL	"A 8bit general purpose register	This register overlaps with CL, CX, ECX, RCX"	^ CL! !!AJx86Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!CX	"A 16bit general purpose register	This register overlaps with CL, CX, ECX, RCX"	^ CX! !!AJx86Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!DH	"A 8bit general purpose register	This register overlaps with DH, DX, EDX, RDX"	^ DH! !!AJx86Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!DI	"A 16bit general purpose register	This register overlaps with BH, BX, EBX, RBX"	^ DI! !!AJx86Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!DL	"A 8bit general purpose register	This register overlaps with DL, DX, EDX, RDX"	^ DL! !!AJx86Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!DX	"A 16bit general purpose register	This register overlaps with DL, DX, EDX, RDX"	^ DX! !!AJx86Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!EAX	"A 32bit general purpose register	This register overlaps with AL, AX, EAX, RAX"	^ EAX! !!AJx86Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!EBP	"A 32bit general purpose register	This register overlaps with CH, CX, ECX, RCX"	^ EBP! !!AJx86Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!EBX	"A 32bit general purpose register	This register overlaps with BL, BX, EBX, RBX"	^ EBX! !!AJx86Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!ECX	"A 32bit general purpose register	This register overlaps with CL, CX, ECX, RCX"	^ ECX! !!AJx86Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!EDI	"A 32bit general purpose register	This register overlaps with BH, BX, EBX, RBX"	^ EDI! !!AJx86Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!EDX	"A 32bit general purpose register	This register overlaps with DL, DX, EDX, RDX"	^ EDX! !!AJx86Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!ESI	"A 32bit general purpose register	This register overlaps with DH, DX, EDX, RDX"	^ ESI! !!AJx86Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!ESP	"A 32bit general purpose register	This register overlaps with AH, AX, EAX, RAX"	^ ESP! !!AJx86Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!MM0	"An MMX register"	^ MM0! !!AJx86Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!MM1	"An MMX register"	^ MM1! !!AJx86Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!MM2	"An MMX register"	^ MM2! !!AJx86Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!MM3	"An MMX register"	^ MM3! !!AJx86Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!MM4	"An MMX register"	^ MM4! !!AJx86Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!MM5	"An MMX register"	^ MM5! !!AJx86Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!MM6	"An MMX register"	^ MM6! !!AJx86Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!MM7	"An MMX register"	^ MM7! !!AJx86Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!SI	"A 16bit general purpose register	This register overlaps with DH, DX, EDX, RDX"	^ SI! !!AJx86Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!SP	"A 16bit general purpose register	This register overlaps with AH, AX, EAX, RAX"	^ SP! !!AJx86Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!ST0	"A floating point register"	^ ST0! !!AJx86Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!ST1	"A floating point register"	^ ST1! !!AJx86Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!ST2	"A floating point register"	^ ST2! !!AJx86Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!ST3	"A floating point register"	^ ST3! !!AJx86Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!ST4	"A floating point register"	^ ST4! !!AJx86Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!ST5	"A floating point register"	^ ST5! !!AJx86Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!ST6	"A floating point register"	^ ST6! !!AJx86Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!ST7	"A floating point register"	^ ST7! !!AJx86Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!XMM0	"An SSE register"	^ XMM0! !!AJx86Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!XMM1	"An SSE register"	^ XMM1! !!AJx86Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!XMM2	"An SSE register"	^ XMM2! !!AJx86Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!XMM3	"An SSE register"	^ XMM3! !!AJx86Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!XMM4	"An SSE register"	^ XMM4! !!AJx86Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!XMM5	"An SSE register"	^ XMM5! !!AJx86Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!XMM6	"An SSE register"	^ XMM6! !!AJx86Assembler methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!XMM7	"An SSE register"	^ XMM7! !!AJx86Assembler methodsFor: 'register'!accumulator	^ self is32BitMode ifTrue: [ EAX ] ifFalse: [ AX ]! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!adc: aRegisterOrMemoryOperand with: aSource	"Add with Carry	"	^ self 		addInstruction: #adc		operands: { aRegisterOrMemoryOperand . aSource }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!add: aRegisterOrMemoryOperand with: aSource	"Add	Pseudo Code-----------DEST = DEST + SRC;Description-----------Adds the destination operand (first operand) and the source operand(second operand) and then stores the result in the destination operand.The destination operand can be a register or a memory location; thesource operand can be an immediate, a register, or a memory location.(However, two memory operands cannot be used in one instruction.) Whenan immediate value is used as an operand, it is sign-extended to thelength of the destination operand format.The ADD instruction performs integer addition. It evaluates the resultfor both signed and unsigned integer operands and sets the OF and CFflags to indicate a carry (overflow) in the signed or unsigned result,respectively. The SF flag indicates the sign of the signed result.This instruction can be used with a LOCK prefix to allow the instructionto be executed atomically.In 64-bit mode, the instruction's default operation size is 32 bits.Using a REX prefix in the form of REX.R permits access to additionalregisters (R8-R15). Using a REX a REX prefix in the form of REX.Wpromotes operation to 64 bits. See the summary chart at the beginning ofthis section for encoding data and limits."	^ self 		addInstruction: #add		operands: { aRegisterOrMemoryOperand . aSource }! !!AJx86Assembler methodsFor: 'instruction list'!addInstruction: anInstruction	"add one or multiple instructions to the tail"	instructions ifNil: [		instructions := anInstruction.		]	ifNotNil: [		last := last last next: anInstruction.		].	anInstruction level: level.	last := anInstruction last.	^ anInstruction ! !!AJx86Assembler methodsFor: 'instruction list' stamp: 'CamilloBruni 4/17/2012 17:51'!addInstruction: sel description: description operands: operands	^ self addInstruction: (self newInstruction: sel description: description operands: operands)! !!AJx86Assembler methodsFor: 'instruction list' stamp: 'CamilloBruni 4/25/2012 14:23'!addInstruction: sel operands: operands	^ self 		addInstruction: sel 		description: (self instructionDesciptions at: sel)		operands: operands ! !!AJx86Assembler methodsFor: 'alignment' stamp: 'CamilloBruni 4/12/2012 13:52'!align: aByteSize	self addInstruction: (AJAlignmentInstruction align: aByteSize)! !!AJx86Assembler methodsFor: 'alignment'!alignDouble	self addInstruction: AJAlignmentInstruction alignDouble! !!AJx86Assembler methodsFor: 'alignment'!alignQuad	self addInstruction: AJAlignmentInstruction alignQuad! !!AJx86Assembler methodsFor: 'alignment'!alignWord	self addInstruction: AJAlignmentInstruction alignWord! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!amdprefetch: aMemoryOperand	"	"	^ self 		addInstruction: #amdprefetch		operands: { aMemoryOperand }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!amdprefetchw: aMemoryOperand	"	"	^ self 		addInstruction: #amdprefetchw		operands: { aMemoryOperand }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!and: aRegisterOrMemoryOperand with: aSource	"Logical AND	"	^ self 		addInstruction: #and		operands: { aRegisterOrMemoryOperand . aSource }! !!AJx86Assembler methodsFor: 'register'!basePointer	^ self is32BitMode ifTrue: [ EBP ] ifFalse: [ BP ]! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!bsf: aRegister with: aSourceRegisterOrMemory	"Bit Scan Forward	Description-----------Searches the source operand (second operand) for the least significantset bit (1 bit). If a least significant 1 bit is found, its bit index isstored in the destination operand (first operand). The source operandcan be a register or a memory location; the destination operand is aregister. The bit index is an unsigned offset from bit 0 of the sourceoperand. If the content of the source operand is 0, the content of thedestination operand is undefined.In 64-bit mode, the instruction's default operation size is 32 bits.Using a REX prefix in the form of REX.R permits access to additionalregisters (R8-R15). Using a REX prefix in the form of REX.W promotesoperation to 64 bits. See the summary chart at the beginning of thissection for encoding data and limits."	^ self 		addInstruction: #bsf		operands: { aRegister . aSourceRegisterOrMemory }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!bsr: aRegister with: aSourceRegisterOrMemory	"Bit Scan Reverse	Description-----------Searches the source operand (second operand) for the most significantset bit (1 bit). If a most significant 1 bit is found, its bit index isstored in the destination operand (first operand). The source operandcan be a register or a memory location; the destination operand is aregister. The bit index is an unsigned offset from bit 0 of the sourceoperand. If the content source operand is 0, the content of thedestination operand is undefined.In 64-bit mode, the instruction's default operation size is 32 bits.Using a REX prefix in the form of REX.R permits access to additionalregisters (R8-R15). Using a REX prefix in the form of REX.W promotesoperation to 64 bits. See the summary chart at the beginning of thissection for encoding data and limits."	^ self 		addInstruction: #bsr		operands: { aRegister . aSourceRegisterOrMemory }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!bswap: aDestinationRegister	"Byte Swap	Description-----------Reverses the byte order of a 32-bit or 64-bit (destination) register.This instruction is provided for converting little-endian values tobig-endian format and vice versa. To swap bytes in a word value (16-bitregister), use the XCHG instruction. When the BSWAP instructionreferences a 16-bit register, the result is undefined.In 64-bit mode, the instruction's default operation size is 32 bits.Using a REX prefix in the form of REX.R permits access to additionalregisters (R8-R15). Using a REX prefix in the form of REX.W promotesoperation to 64 bits. See the summary chart at the beginning of thissection for encoding data and limits.IA-32 Architecture Legacy CompatibilityThe BSWAP instruction is not supported on IA-32 processors earlier thanthe Intel486 processor family. For compatibility with this instruction,software should include functionally equivalent code for execution onIntel processors earlier than the Intel486 processor family."	^ self 		addInstruction: #bswap		operands: { aDestinationRegister }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!bt: aDestinationRegisterOrMemory with: aSourceRegisterOrImmediate	"Bit Test	Pseudo Code-----------CF = Bit(BitBase, BitOffset);Description-----------Selects the bit in a bit string (specified with the first operand,called the bit base) at the bit-position designated by the bit offset(specified by the second operand) and stores the value of the bit in theCF flag. The bit base operand can be a register or a memory location;the bit offset operand can be a register or an immediate value:-   If the bit base operand specifies a register, the instruction takes    the modulo 16, 32, or 64 of the bit offset operand (modulo size    depends on the mode and register size; 64-bit operands are available    only in 64-bit mode).-   If the bit base operand specifies a memory location, the operand    represents the address of the byte in memory that contains the bit    base (bit 0 of the specified byte) of the bit string. The range of    the bit position that can be referenced by the offset operand    depends on the operand size.See also: Bit(BitBase, BitOffset) on page 3-11.Some assemblers support immediate bit offsets larger than 31 by usingthe immediate bit offset field in combination with the displacementfield of the memory operand. In this case, the low-order 3 or 5 bits (3for 16-bit operands, 5 for 32-bit operands) of the immediate bit offsetare stored in the immediate bit offset field, and the high-order bitsare shifted and combined with the byte displacement in the addressingmode by the assembler. The processor will ignore the high order bits ifthey are not zero.When accessing a bit in memory, the processor may access 4 bytesstarting from the memory address for a 32-bit operand size, using by thefollowing relationship:Effective Address + (4 \* (BitOffset DIV 32))Or, it may access 2 bytes starting from the memory address for a 16-bitoperand, using this relationship:Effective Address + (2 \* (BitOffset DIV 16))It may do so even when only a single byte needs to be accessed to reachthe given bit. When using this bit addressing mechanism, software shouldavoid referencing areas of memory close to address space holes. Inparticular, it should avoid references to memory-mapped I/O registers.Instead, software should use the MOV instructions to load from or storeto these addresses, and use the register form of these instructions tomanipulate the data.In 64-bit mode, the instruction's default operation size is 32 bits.Using a REX prefix in the form of REX.R permits access to additionalregisters (R8-R15). Using a REX prefix in the form of REX.W promotesoperation to 64 bit operands. See the summary chart at the beginning ofthis section for encoding data and limits."	^ self 		addInstruction: #bt		operands: { aDestinationRegisterOrMemory . aSourceRegisterOrImmediate }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!btc: aDestinationRegisterOrMemory with: aSourceRegisterOrImmediate	"Bit Test and Complement	Pseudo Code-----------CF = Bit(BitBase, BitOffset);Bit(BitBase, BitOffset) = NOT Bit(BitBase, BitOffset);Description-----------Selects the bit in a bit string (specified with the first operand,called the bit base) at the bit-position designated by the bit offsetoperand (second operand), stores the value of the bit in the CF flag,and complements the selected bit in the bit string. The bit base operandcan be a register or a memory location; the bit offset operand can be aregister or an immediate value:-   If the bit base operand specifies a register, the instruction takes    the modulo 16, 32, or 64 of the bit offset operand (modulo size    depends on the mode and register size; 64-bit operands are available    only in 64-bit mode). This allows any bit position to be selected.-   If the bit base operand specifies a memory location, the operand    represents the address of the byte in memory that contains the bit    base (bit 0 of the specified byte) of the bit string. The range of    the bit position that can be referenced by the offset operand    depends on the operand size.See also: Bit(BitBase, BitOffset) on page 3-11.Some assemblers support immediate bit offsets larger than 31 by usingthe immediate bit offset field in combination with the displacementfield of the memory operand. See 'BTBit Test' in this chapter for moreinformation on this addressingmechanism.This instruction can be used with a LOCK prefix to allow the instructionto be executed atomically.In 64-bit mode, the instruction's default operation size is 32 bits.Using a REX prefix in the form of REX.R permits access to additionalregisters (R8-R15). Using a REX prefix in the form of REX.W promotesoperation to 64 bits. See the summary chart at the beginning of thissection for encoding data and limits."	^ self 		addInstruction: #btc		operands: { aDestinationRegisterOrMemory . aSourceRegisterOrImmediate }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!btr: aDestinationRegisterOrMemory with: aSourceRegisterOrImmediate	"Bit Test and Reset	Pseudo Code-----------CF = Bit(BitBase, BitOffset);Bit(BitBase, BitOffset) = 0;Description-----------Selects the bit in a bit string (specified with the first operand,called the bit base) at the bit-position designated by the bit offsetoperand (second operand), stores the value of the bit in the CF flag,and clears the selected bit in the bit string to 0. The bit base operandcan be a register or a memory location; the bit offset operand can be aregister or an immediate value:-   If the bit base operand specifies a register, the instruction takes    the modulo 16, 32, or 64 of the bit offset operand (modulo size    depends on the mode and register size; 64-bit operands are available    only in 64-bit mode). This allows any bit position to be selected.-   If the bit base operand specifies a memory location, the operand    represents the address of the byte in memory that contains the bit    base (bit 0 of the specified byte) of the bit string. The range of    the bit position that can be referenced by the offset operand    depends on the operand size.See also: Bit(BitBase, BitOffset) on page 3-11.Some assemblers support immediate bit offsets larger than 31 by usingthe immediate bit offset field in combination with the displacementfield of the memory operand. See 'BTBit Test' in this chapter for moreinformation on this addressingmechanism.This instruction can be used with a LOCK prefix to allow the instructionto be executed atomically.In 64-bit mode, the instruction's default operation size is 32 bits.Using a REX prefix in the form of REX.R permits access to additionalregisters (R8-R15). Using a REX prefix in the form of REX.W promotesoperation to 64 bits. See the summary chart at the beginning of thissection for encoding data and limits."	^ self 		addInstruction: #btr		operands: { aDestinationRegisterOrMemory . aSourceRegisterOrImmediate }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!bts: aDestinationRegisterOrMemory with: aSourceRegisterOrImmediate	"Bit Test and Set	Pseudo Code-----------CF = Bit(BitBase, BitOffset);Bit(BitBase, BitOffset) = 1;Description-----------Selects the bit in a bit string (specified with the first operand,called the bit base) at the bit-position designated by the bit offsetoperand (second operand), stores the value of the bit in the CF flag,and sets the selected bit in the bit string to 1. The bit base operandcan be a register or a memory location; the bit offset operand can be aregister or an immediate value:-   If the bit base operand specifies a register, the instruction takes    the modulo 16, 32, or 64 of the bit offset operand (modulo size    depends on the mode and register size; 64-bit operands are available    only in 64-bit mode). This allows any bit position to be selected.-   If the bit base operand specifies a memory location, the operand    represents the address of the byte in memory that contains the bit    base (bit 0 of the specified byte) of the bit string. The range of    the bit position that can be referenced by the offset operand    depends on the operand size.See also: Bit(BitBase, BitOffset) on page 3-11.Some assemblers support immediate bit offsets larger than 31 by usingthe immediate bit offset field in combination with the displacementfield of the memory operand. See 'BTBit Test' in this chapter for moreinformation on this addressingmechanism.This instruction can be used with a LOCK prefix to allow the instructionto be executed atomically.In 64-bit mode, the instruction's default operation size is 32 bits.Using a REX prefix in the form of REX.R permits access to additionalregisters (R8-R15). Using a REX prefix in the form of REX.W promotesoperation to 64 bits. See the summary chart at the beginning of thissection for encoding data and limits."	^ self 		addInstruction: #bts		operands: { aDestinationRegisterOrMemory . aSourceRegisterOrImmediate }! !!AJx86Assembler methodsFor: 'code generation'!bytes	^ self generatedCode bytes.! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!call: anAddressSource	"Call Procedure	Description-----------Saves procedure linking information on the stack and branches to thecalled procedure specified using the target operand. The target operandspecifies the address of the first instruction in the called procedure.The operand can be an immediate value, a general-purpose register, or amemory location.This instruction can be used to execute four types of calls:-   Near Call  A call to a procedure in the current code segment (the    segment currently pointed to by the CS register), sometimes referred    to as an intrasegment call.-   Far Call  A call to a procedure located in a different segment than    the current code segment, sometimes referred to as an inter-segment    call.-   Inter-privilege-level far call  A far call to a procedure in a    segment at a different privilege level than that of the currently    executing program or procedure.-   Task switch  A call to a procedure located in a different task.The latter two call types (inter-privilege-level call and task switch)can only be executed in protected mode. See 'Calling Procedures UsingCall and RET' in Chapter6 of the Intel64 and IA-32 ArchitecturesSoftware Developer's Manual, Volume 1, for additional information onnear, far, and inter-privilege-level calls. See Chapter 7,'TaskManagement,' in theIntel 64 and IA-32 Architectures SoftwareDeveloper'sManual, Volume 3A, for information on performing taskswitches with the CALL instruction.Near Call. When executing a near call, the processor pushes the value ofthe EIP register (which contains the offset of the instruction followingthe CALL instruction) on the stack (for use later as areturn-instruction pointer). The processor then branches to the addressin the current code segment specified by the target operand. The targetoperand specifies either an absolute offset in the code segment (anoffset from the base of the code segment) or a relative offset (a signeddisplacement relative to the current value of the instruction pointer inthe EIP register; this value points to the instruction following theCALL instruction). The CS register is not changed on near calls.For a near call absolute, an absolute offset is specified indirectly ina general-purpose register or a memory location (r/m16, r/m32, orr/m64). The operand-size attribute determines the size of the targetoperand (16, 32 or 64 bits). When in 64-bit mode, the operand size fornear call (and all near branches) is forced to 64-bits. Absolute offsetsare loaded directly into the EIP(RIP) register. If the operand sizeattribute is 16, the upper two bytes of the EIP register are cleared,resulting in a maximum instruction pointer size of 16 bits. Whenaccessing an absolute offset indirectly using the stack pointer [ESP] asthe base register, the base value used is the value of the ESP beforethe instruction executes.A relative offset (rel16 or rel32) is generally specified as a label inassembly code. But at the machine code level, it is encoded as a signed,16- or 32-bit immediate value. This value is added to the value in theEIP(RIP) register. In 64-bit mode the relative offset is always a 32-bitimmediate value which is sign extended to 64-bits before it is added tothe value in the RIP register for the target calculation. As withabsolute offsets, the operand-size attribute determines the size of thetarget operand (16, 32, or 64 bits). In 64-bit mode the target operandwill always be 64-bits because the operand size is forced to 64-bits fornear branches.Far Calls in Real-Address or Virtual-8086 Mode. When executing a farcall in real- address or virtual-8086 mode, the processor pushes thecurrent value of both the CS and EIP registers on the stack for use as areturn-instruction pointer. The processor then performs a 'far branch'to the code segment and offset specified with the target operand for thecalled procedure. The target operand specifies an absolute far addresseither directly with a pointer (ptr16:16 or ptr16:32) or indirectly witha memory location (m16:16 or m16:32). With the pointer method, thesegment and offset of the called procedure is encoded in the instructionusing a 4-byte (16-bit operand size) or 6-byte (32-bit operand size) faraddress immediate. With the indirect method, the target operandspecifies a memory location that contains a 4-byte (16-bit operand size)or 6-byte (32-bit operand size) far address. The operand-size attributedetermines the size of the offset (16 or 32 bits) in the far address.The far address is loaded directly into the CS and EIP registers. If theoperand-size attribute is 16, the upper two bytes of the EIP registerare cleared.Far Calls in Protected Mode. When the processor is operating inprotected mode, the CALL instruction can be used to perform thefollowing types of far calls:-   Far call to the same privilege level-   Far call to a different privilege level (inter-privilege level call)-   Task switch (far call to another task)In protected mode, the processor always uses the segment selector partof the far address to access the corresponding descriptor in the GDT orLDT. The descriptor type (code segment, call gate, task gate, or TSS)and access rights determine the type of call operation to be performed.If the selected descriptor is for a code segment, a far call to a codesegment at the same privilege level is performed. (If the selected codesegment is at a different privilege level and the code segment isnon-conforming, a general-protection exception is generated.) A far callto the same privilege level in protected mode is very similar to onecarried out in real-address or virtual-8086 mode. The target operandspecifies an absolute far address either directly with a pointer(ptr16:16 or ptr16:32) or indirectly with a memory location (m16:16 orm16:32). The operand- size attribute determines the size of the offset(16 or 32 bits) in the far address. The new code segment selector andits descriptor are loaded into CS register; the offset from theinstruction is loaded into the EIP register.A call gate (described in the next paragraph) can also be used toperform a far call to a code segment at the same privilege level. Usingthis mechanism provides an extra level of indirection and is thepreferred method of making calls between 16-bit and 32-bit codesegments.When executing an inter-privilege-level far call, the code segment forthe procedure being called must be accessed through a call gate. Thesegment selector specified by the target operand identifies the callgate. The target operand can specify the call gate segment selectoreither directly with a pointer (ptr16:16 or ptr16:32) or indirectly witha memory location (m16:16 or m16:32). The processor obtains the segmentselector for the new code segment and the new instruction pointer(offset) from the call gate descriptor. (The offset from the targetoperand is ignored when a call gate is used.)On inter-privilege-level calls, the processor switches to the stack forthe privilege level of the called procedure. The segment selector forthe new stack segment is specified in the TSS for the currently runningtask. The branch to the new code segment occurs after the stack switch.(Note that when using a call gate to perform a far call to a segment atthe same privilege level, no stack switch occurs.) On the new stack, theprocessor pushes the segment selector and stack pointer for the callingprocedure's stack, an optional set of parameters from the callingprocedures stack, and the segment selector and instruction pointer forthe calling procedure's code segment. (A value in the call gatedescriptor determines how many parameters to copy to the new stack.)Finally, the processor branches to the address of the procedure beingcalled within the new code segment.Executing a task switch with the CALL instruction is similar toexecuting a call through a call gate. The target operand specifies thesegment selector of the task gate for the new task activated by theswitch (the offset in the target operand is ignored). The task gate inturn points to the TSS for the new task, which contains the segmentselectors for the task's code and stack segments. Note that the TSS alsocontains the EIP value for the next instruction that was to be executedbefore the calling task was suspended. This instruction pointer value isloaded into the EIP register to re-start the calling task.The CALL instruction can also specify the segment selector of the TSSdirectly, which eliminates the indirection of the task gate. See Chapter7, 'Task Management,' in theIntel 64 and IA-32 Architectures Software Developer's Manual, Volume3A, for information on the mechanics of a task switch.When you execute at task switch with a CALL instruction, the nested taskflag (NT) is set in the EFLAGS register and the new TSS's previous tasklink field is loaded with the old task's TSS selector. Code is expectedto suspend this nested task by executing an IRET instruction which,because the NT flag is set, automatically uses the previous task link toreturn to the calling task. (See 'Task Linking' in Chapter 7 oftheIntel 64 and IA-32 Architectures Software Developer's Manual, Volume3A, for information on nested tasks.) Switching tasks with the CALLinstruction differs in this regard from JMP instruction. JMP does notset the NT flag and therefore does not expect an IRET instruction tosuspend the task.Mixing 16-Bit and 32-Bit Calls. When making far calls between 16-bit and32-bit code segments, use a call gate. If the far call is from a 32-bitcode segment to a 16-bit code segment, the call should be made from thefirst 64 KBytes of the 32-bit code segment. This is because theoperand-size attribute of the instruction is set to 16, so only a 16-bitreturn address offset can be saved. Also, the call should be made usinga 16-bit call gate so that 16-bit values can be pushed on the stack. SeeChapter 18,'Mixing 16-Bit and 32-Bit Code,' in theIntel 64 and IA-32Architectures SoftwareDeveloper's Manual, Volume 3A, for moreinformation.Far Calls in Compatibility Mode. When the processor is operating incompatibility mode, the CALL instruction can be used to perform thefollowing types of far calls:-   Far call to the same privilege level, remaining in compatibility    mode-   Far call to the same privilege level, transitioning to 64-bit mode-   Far call to a different privilege level (inter-privilege level    call), transitioning to 64bit modeNote that a CALL instruction can not be used to cause a task switch incompatibility mode since task switches are not supported in IA-32e mode.In compatibility mode, the processor always uses the segment selectorpart of the far address to access the corresponding descriptor in theGDT or LDT. The descriptor type (code segment, call gate) and accessrights determine the type of call operation to be performed.If the selected descriptor is for a code segment, a far call to a codesegment at the same privilege level is performed. (If the selected codesegment is at a different privilege level and the code segment isnon-conforming, a general-protection exception is generated.) A far callto the same privilege level in compatibility mode is very similar to onecarried out in protected mode. The target operand specifies an absolutefar address either directly with a pointer (ptr16:16 or ptr16:32) orindirectly with a memory location (m16:16 or m16:32). The operand-sizeattribute determines the size of the offset (16 or 32 bits) in the faraddress. The new code segment selector and its descriptor are loadedinto CS register and the offset from the instruction is loaded into theEIP register. The difference is that 64-bit mode may be entered. Thisspecified by the L bit in the new code segment descriptor.Note that a 64-bit call gate (described in the next paragraph) can alsobe used to perform a far call to a code segment at the same privilegelevel. However, using this mechanism requires that the target codesegment descriptor have the L bit set, causing an entry to 64-bit mode.When executing an inter-privilege-level far call, the code segment forthe procedure being called must be accessed through a 64-bit call gate.The segment selector specified by the target operand identifies the callgate. The target operand can specify the call gate segment selectoreither directly with a pointer (ptr16:16 or ptr16:32) or indirectly witha memory location (m16:16 or m16:32). The processor obtains the segmentselector for the new code segment and the new instruction pointer(offset) from the 16-byte call gate descriptor. (The offset from thetarget operand is ignored when a call gate is used.)On inter-privilege-level calls, the processor switches to the stack forthe privilege level of the called procedure. The segment selector forthe new stack segment is set to NULL. The new stack pointer is specifiedin the TSS for the currently running task. The branch to the new codesegment occurs after the stack switch. (Note that when using a call gateto perform a far call to a segment at the same privilege level, animplicit stack switch occurs as a result of entering 64-bit mode. The SSselector is unchanged, but stack segment accesses use a segment base of0x0, the limit is ignored, and the default stack size is 64-bits. Thefull value of RSP is used for the offset, of which the upper 32-bits areundefined.) On the new stack, the processor pushes the segment selectorand stack pointer for the calling procedure's stack and the segmentselector and instruction pointer for the calling procedure's codesegment. (Parameter copy is not supported in IA-32e mode.) Finally, theprocessor branches to the address of the procedure being called withinthe new code segment.Near/(Far) Calls in 64-bit Mode. When the processor is operating in64-bit mode, the CALL instruction can be used to perform the followingtypes of far calls:-   Far call to the same privilege level, transitioning to compatibility    mode-   Far call to the same privilege level, remaining in 64-bit mode-   Far call to a different privilege level (inter-privilege level    call), remaining in 64-bit modeNote that in this mode the CALL instruction can not be used to cause atask switch in 64-bit mode since task switches are not supported inIA-32e mode.In 64-bit mode, the processor always uses the segment selector part ofthe far address to access the corresponding descriptor in the GDT orLDT. The descriptor type (code segment, call gate) and access rightsdetermine the type of call operation to be performed.If the selected descriptor is for a code segment, a far call to a codesegment at the same privilege level is performed. (If the selected codesegment is at a different privilege level and the code segment isnon-conforming, a general-protection exception is generated.) A far callto the same privilege level in 64-bit mode is very similar to onecarried out in compatibility mode. The target operand specifies anabsolute far address indirectly with a memory location (m16:16, m16:32or m16:64). The form of CALL with a direct specification of absolute faraddress is not defined in 64-bit mode. The operand-size attributedetermines the size of the offset (16, 32, or 64 bits) in the faraddress. The new code segment selector and its descriptor are loadedinto the CS register; the offset from the instruction is loaded into theEIP register. The new code segment may specify entry either intocompatibility or 64-bit mode, based on the L bit value.A 64-bit call gate (described in the next paragraph) can also be used toperform a far call to a code segment at the same privilege level.However, using this mechanism requires that the target code segmentdescriptor have the L bit set.When executing an inter-privilege-level far call, the code segment forthe procedure being called must be accessed through a 64-bit call gate.The segment selector specified by the target operand identifies the callgate. The target operand can only specify the call gate segment selectorindirectly with a memory location (m16:16, m16:32 or m16:64). Theprocessor obtains the segment selector for the new code segment and thenew instruction pointer (offset) from the 16-byte call gate descriptor.(The offset from the target operand is ignored when a call gate isused.)On inter-privilege-level calls, the processor switches to the stack forthe privilege level of the called procedure. The segment selector forthe new stack segment is set to NULL. The new stack pointer is specifiedin the TSS for the currently running task. The branch to the new codesegment occurs after the stack switch.Note that when using a call gate to perform a far call to a segment atthe same privilege level, an implicit stack switch occurs as a result ofentering 64-bit mode. The SS selector is unchanged, but stack segmentaccesses use a segment base of 0x0, the limit is ignored, and thedefault stack size is 64-bits. (The full value of RSP is used for theoffset.) On the new stack, the processor pushes the segment selector andstack pointer for the calling procedure's stack and the segment selectorand instruction pointer for the calling procedure's code segment.(Parameter copy is not supported in IA-32e mode.) Finally, the processorbranches to the address of the procedure being called within the newcode segment."	^ self 		addInstruction: #call		operands: { anAddressSource }! !!AJx86Assembler methodsFor: 'function calls'!callCleanup: anAJCdeclCallInfo 	^ self addInstruction:   (AJCallCleanup new callInfo: anAJCdeclCallInfo )! !!AJx86Assembler methodsFor: 'function calls'!cdeclCall: aBlock alignment: align	^ self performingCall: (self newCdeclCall alignment: align) in: aBlock! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!clflush: aMemoryOperand	"Flush Cache Line	Pseudo Code-----------Flush_Cache_Line(SRC);Description-----------Invalidates the cache line that contains the linear address specifiedwith the source operand from all levels of the processor cache hierarchy(data and instruction). The invalidation is broadcast throughout thecache coherence domain. If, at any level of the cache hierarchy, theline is inconsistent with memory (dirty) it is written to memory beforeinvalidation. The source operand is a byte memory location.The availability of CLFLUSH is indicated by the presence of the CPUIDfeature flag CLFSH (bit 19 of the EDX register, see 'CPUIDCPUIdentification' in this chapter).The aligned cache line size affected isalso indicated with the CPUID instruction (bits 8 through 15 of the EBXregister when the initial value in the EAX register is 1).The memory attribute of the page containing the affected line has noeffect on the behavior of this instruction. It should be noted thatprocessors are free to speculatively fetch and cache data from systemmemory regions assigned a memory-type allowing for speculative reads(such as, the WB, WC, and WT memory types). PREFETCHh instructions canbe used to provide the processor with hints for this speculativebehavior. Because this speculative fetching can occur at any time and isnot tied to instruction execution, the CLFLUSH instruction is notordered with respect to PREFETCHh instructions or any of the speculativefetching mechanisms (that is, data can be speculatively loaded into acache line just before, during, or after the execution of a CLFLUSHinstruction that references the cache line).CLFLUSH is only ordered by the MFENCE instruction. It is not guaranteedto be ordered by any other fencing or serializing instructions or byanother CLFLUSH instruction. For example, software can use an MFENCEinstruction to ensure that previous stores are included in thewrite-back.The CLFLUSH instruction can be used at all privilege levels and issubject to all permission checking and faults associated with a byteload (and in addition, a CLFLUSH instruction is allowed to flush alinear address in an execute-only segment). Like a load, the CLFLUSHinstruction sets the A bit but not the D bit in the page tables.The CLFLUSH instruction was introduced with the SSE2 extensions;however, because it has its own CPUID feature flag, it can beimplemented in IA-32 processors that do not include the SSE2 extensions.Also, detecting the presence of the SSE2 extensions with the CPUIDinstruction does not guarantee that the CLFLUSH instruction isimplemented in the processor.CLFLUSH operation is the same in non-64-bit modes and 64-bit mode."	^ self 		addInstruction: #clflush		operands: { aMemoryOperand }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!cmova: aRegister with: aSourceRegisterOrMemory	"	"	^ self 		addInstruction: #cmova		operands: { aRegister . aSourceRegisterOrMemory }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!cmovae: aRegister with: aSourceRegisterOrMemory	"	"	^ self 		addInstruction: #cmovae		operands: { aRegister . aSourceRegisterOrMemory }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!cmovb: aRegister with: aSourceRegisterOrMemory	"Conditional Move - below/not above or equal/carry (CF=1)	"	^ self 		addInstruction: #cmovb		operands: { aRegister . aSourceRegisterOrMemory }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!cmovbe: aRegister with: aSourceRegisterOrMemory	"Conditional Move - below or equal/not above (CF=1 AND ZF=1)	"	^ self 		addInstruction: #cmovbe		operands: { aRegister . aSourceRegisterOrMemory }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!cmovc: aRegister with: aSourceRegisterOrMemory	"	"	^ self 		addInstruction: #cmovc		operands: { aRegister . aSourceRegisterOrMemory }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!cmove: aRegister with: aSourceRegisterOrMemory	"	"	^ self 		addInstruction: #cmove		operands: { aRegister . aSourceRegisterOrMemory }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!cmovg: aRegister with: aSourceRegisterOrMemory	"	"	^ self 		addInstruction: #cmovg		operands: { aRegister . aSourceRegisterOrMemory }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!cmovge: aRegister with: aSourceRegisterOrMemory	"	"	^ self 		addInstruction: #cmovge		operands: { aRegister . aSourceRegisterOrMemory }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!cmovl: aRegister with: aSourceRegisterOrMemory	"Conditional Move - less/not greater (SF!!=OF)	"	^ self 		addInstruction: #cmovl		operands: { aRegister . aSourceRegisterOrMemory }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!cmovle: aRegister with: aSourceRegisterOrMemory	"Conditional Move - less or equal/not greater ((ZF=1) OR (SF!!=OF))	"	^ self 		addInstruction: #cmovle		operands: { aRegister . aSourceRegisterOrMemory }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!cmovna: aRegister with: aSourceRegisterOrMemory	"	"	^ self 		addInstruction: #cmovna		operands: { aRegister . aSourceRegisterOrMemory }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!cmovnae: aRegister with: aSourceRegisterOrMemory	"	"	^ self 		addInstruction: #cmovnae		operands: { aRegister . aSourceRegisterOrMemory }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!cmovnb: aRegister with: aSourceRegisterOrMemory	"Conditional Move - not below/above or equal/not carry (CF=0)	"	^ self 		addInstruction: #cmovnb		operands: { aRegister . aSourceRegisterOrMemory }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!cmovnbe: aRegister with: aSourceRegisterOrMemory	"Conditional Move - not below or equal/above (CF=0 AND ZF=0)	"	^ self 		addInstruction: #cmovnbe		operands: { aRegister . aSourceRegisterOrMemory }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!cmovnc: aRegister with: aSourceRegisterOrMemory	"	"	^ self 		addInstruction: #cmovnc		operands: { aRegister . aSourceRegisterOrMemory }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!cmovne: aRegister with: aSourceRegisterOrMemory	"	"	^ self 		addInstruction: #cmovne		operands: { aRegister . aSourceRegisterOrMemory }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!cmovng: aRegister with: aSourceRegisterOrMemory	"	"	^ self 		addInstruction: #cmovng		operands: { aRegister . aSourceRegisterOrMemory }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!cmovnge: aRegister with: aSourceRegisterOrMemory	"	"	^ self 		addInstruction: #cmovnge		operands: { aRegister . aSourceRegisterOrMemory }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!cmovnl: aRegister with: aSourceRegisterOrMemory	"Conditional Move - not less/greater or equal (SF=OF)	"	^ self 		addInstruction: #cmovnl		operands: { aRegister . aSourceRegisterOrMemory }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!cmovnle: aRegister with: aSourceRegisterOrMemory	"Conditional Move - not less nor equal/greater ((ZF=0) AND (SF=OF))	"	^ self 		addInstruction: #cmovnle		operands: { aRegister . aSourceRegisterOrMemory }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!cmovno: aRegister with: aSourceRegisterOrMemory	"Conditional Move - not overflow (OF=0)	"	^ self 		addInstruction: #cmovno		operands: { aRegister . aSourceRegisterOrMemory }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!cmovnp: aRegister with: aSourceRegisterOrMemory	"Conditional Move - not parity/parity odd	"	^ self 		addInstruction: #cmovnp		operands: { aRegister . aSourceRegisterOrMemory }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!cmovns: aRegister with: aSourceRegisterOrMemory	"Conditional Move - not sign (SF=0)	"	^ self 		addInstruction: #cmovns		operands: { aRegister . aSourceRegisterOrMemory }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!cmovnz: aRegister with: aSourceRegisterOrMemory	"Conditional Move - not zero/not equal (ZF=1)	"	^ self 		addInstruction: #cmovnz		operands: { aRegister . aSourceRegisterOrMemory }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!cmovo: aRegister with: aSourceRegisterOrMemory	"Conditional Move - overflow (OF=1)	"	^ self 		addInstruction: #cmovo		operands: { aRegister . aSourceRegisterOrMemory }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!cmovp: aRegister with: aSourceRegisterOrMemory	"Conditional Move - parity/parity even (PF=1)	"	^ self 		addInstruction: #cmovp		operands: { aRegister . aSourceRegisterOrMemory }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!cmovpe: aRegister with: aSourceRegisterOrMemory	"	"	^ self 		addInstruction: #cmovpe		operands: { aRegister . aSourceRegisterOrMemory }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!cmovpo: aRegister with: aSourceRegisterOrMemory	"	"	^ self 		addInstruction: #cmovpo		operands: { aRegister . aSourceRegisterOrMemory }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!cmovs: aRegister with: aSourceRegisterOrMemory	"Conditional Move - sign (SF=1)	"	^ self 		addInstruction: #cmovs		operands: { aRegister . aSourceRegisterOrMemory }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!cmovz: aRegister with: aSourceRegisterOrMemory	"Conditional Move - zero/equal (ZF=0)	"	^ self 		addInstruction: #cmovz		operands: { aRegister . aSourceRegisterOrMemory }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!cmp: aRegisterOrMemoryOperand with: aSource	"Compare Two Operands	Pseudo Code-----------temp = SRC1 - SignExtend(SRC2);ModifyStatusFlags; (* Modify status flags in the same manner as the SUB instruction *)Description-----------Compares the first source operand with the second source operand andsets the status flags in the EFLAGS register according to the results.The comparison is performed by subtracting the second operand from thefirst operand and then setting the status flags in the same manner asthe SUB instruction. When an immediate value is used as an operand, itis sign-extended to the length of the first operand.The condition codes used by the Jcc, CMOVcc, and SETcc instructions arebased on the results of a CMP instruction. Appendix B, 'EFLAGS ConditionCodes,' in theIntel 64 and IA-32 Architectures Software Developer'sManual, Volume 1, shows the relationship of the status flags and thecondition codes.In 64-bit mode, the instruction's default operation size is 32 bits. Useof the REX.R prefix permits access to additional registers (R8-R15). Useof the REX.W prefix promotes operation to 64 bits. See the summary chartat the beginning of this section for encoding data and limits."	^ self 		addInstruction: #cmp		operands: { aRegisterOrMemoryOperand . aSource }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!cmpxchg16b: aMemoryOperand	"...	"	^ self 		addInstruction: #cmpxchg16b		operands: { aMemoryOperand }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!cmpxchg8b: aMemoryOperand	"Compare and Exchange Bytes	"	^ self 		addInstruction: #cmpxchg8b		operands: { aMemoryOperand }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!cmpxchg: aDestinationRegisterOrMemory with: aSourceRegister	"Compare and Exchange	Pseudo Code-----------(* Accumulator = AL, AX, EAX, or RAX depending on whether a byte, word, doubleword, or quadword comparison is being performed *)IF accumulator = DEST    ZF = 1;    DEST = SRC;ELSE    ZF = 0;    accumulator = DEST;FI;Description-----------Compares the value in the AL, AX, EAX, or RAX register with the firstoperand (destination operand). If the two values are equal, the secondoperand (source operand) is loaded into the destination operand.Otherwise, the destination operand is loaded into the AL, AX, EAX or RAXregister. RAX register is available only in 64-bit mode.This instruction can be used with a LOCK prefix to allow the instructionto be executed atomically. To simplify the interface to the processor'sbus, the destination operand receives a write cycle without regard tothe result of the comparison. The destination operand is written back ifthe comparison fails; otherwise, the source operand is written into thedestination. (The processor never produces a locked read without alsoproducing a locked write.)In 64-bit mode, the instruction's default operation size is 32 bits. Useof the REX.R prefix permits access to additional registers (R8-R15). Useof the REX.W prefix promotes operation to 64 bits. See the summary chartat the beginning of this section for encoding data and limits."	^ self 		addInstruction: #cmpxchg		operands: { aDestinationRegisterOrMemory . aSourceRegister }! !!AJx86Assembler methodsFor: 'register'!counter	^ self is32BitMode ifTrue: [ ECX ] ifFalse: [ CX ]! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!crc32: aRegister with: aSourceRegisterOrMemory	"Accumulate CRC32 Value	Description-----------Starting with an initial value in the first operand (destinationoperand), accumulates a CRC32 (polynomial 0x11EDC6F41) value for thesecond operand (source operand) and stores the result in the destinationoperand. The source operand can be a register or a memory location. Thedestination operand must be an r32 or r64 register. If the destinationis an r64 register, then the 32-bit result is stored in the leastsignificant double word and 00000000H is stored in the most significantdouble word of the r64 register.The initial value supplied in the destination operand is a double wordinteger stored in the r32 register or the least significant double wordof the r64 register. To incrementally accumulate a CRC32 value, softwareretains the result of the previous CRC32 operation in the destinationoperand, then executes the CRC32 instruction again with new input datain the source operand. Data contained in the source operand is processedin reflected bit order. This means that the most significant bit of thesource operand is treated as the least significant bit of the quotient,and so on, for all the bits of the source operand. Likewise, the resultof the CRC operation is stored in the destination operand in reflectedbit order. This means that the most significant bit of the resulting CRC(bit 31) is stored in the least significant bit of the destinationoperand (bit 0), and so on, for all the bits of the CRC."	^ self 		addInstruction: #crc32		operands: { aRegister . aSourceRegisterOrMemory }! !!AJx86Assembler methodsFor: 'register'!data	^ self is32BitMode ifTrue: [ EDX ] ifFalse: [ DX ]! !!AJx86Assembler methodsFor: 'convenience'!db: aByteValue	^ self addInstruction: (AJData byte: aByteValue)! !!AJx86Assembler methodsFor: 'convenience' stamp: 'CamilloBruni 4/19/2012 13:20'!dd: aByteArray	self assert: aByteArray size == SizeDWord.	^ self addInstruction: (AJData data: aByteArray)! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!dec: aRegisterOrMemory	"Decrement by 1	Pseudo Code-----------DEST = DEST - 1;Description-----------Subtracts 1 from the destination operand, while preserving the state ofthe CF flag. The destination operand can be a register or a memorylocation. This instruction allows a loop counter to be updated withoutdisturbing the CF flag. (To perform a decrement operation that updatesthe CF flag, use a SUB instruction with an immediate operand of 1.)This instruction can be used with a LOCK prefix to allow the instructionto be executed atomically.In 64-bit mode, DEC r16 and DEC r32 are not encodable (because opcodes48H through 4FH are REX prefixes). Otherwise, the instruction's 64-bitmode default operation size is 32 bits. Use of the REX.R prefix permitsaccess to additional registers (R8-R15). Use of the REX.W prefixpromotes operation to 64 bits.See the summary chart at the beginning of this section for encoding dataand limits."	^ self 		addInstruction: #dec		operands: { aRegisterOrMemory }! !!AJx86Assembler methodsFor: 'instruction list' stamp: 'CamilloBruni 7/23/2012 13:29'!decorateWith: annotation during: aBlock	self addInstruction: (AJInstructionDecoration new start annotation: annotation).	level := level + 1.	aBlock ensure: [		level := level - 1.		self addInstruction: (AJInstructionDecoration new end annotation: annotation)	]	! !!AJx86Assembler methodsFor: 'register'!destinationIndex	^ self is32BitMode ifTrue: [ EDI ] ifFalse: [ DI ]! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!div: aDestination	"Unsigned Divide	Description-----------Divides unsigned the value in the AX, DX:AX, EDX:EAX, or RDX:RAXregisters (dividend) by the source operand (divisor) and stores theresult in the AX (AH:AL), DX:AX, EDX:EAX, or RDX:RAX registers. Thesource operand can be a general-purpose register or a memory location.The action of this instruction depends on the operand size(dividend/divisor). Division using 64-bit operand is available only in64-bit mode.Non-integral results are truncated (chopped) towards 0. The remainder isalways less than the divisor in magnitude. Overflow is indicated withthe \#DE (divide error) exception rather than with the CF flag.In 64-bit mode, the instruction's default operation size is 32 bits. Useof the REX.R prefix permits access to additional registers (R8-R15). Useof the REX.W prefix promotes operation to 64 bits. In 64-bit mode whenREX.W is applied, the instruction divides the unsigned value in RDX:RAXby the source operand and stores the quotient in RAX, the remainder inRDX.See the summary chart at the beginning of this section for encoding dataand limits. See the following table.DIV ActionMaximumOperand SizeDividendDivisorQuotientRemainderQuotientWord/byteAXr/m8ALAH255Doubleword/wordDX:AXr/m16AXDX65,535Quadword/doublewordEDX:EAXr/m32EAXEDX2^32^ - 1Doublequadword/quadwordRDX:RAXr/m64RAXRDX2^64^ - 1"	^ self 		addInstruction: #div		operands: { aDestination }! !!AJx86Assembler methodsFor: 'dnu' stamp: 'CamilloBruni 4/17/2012 17:51'!doesNotUnderstand: aMessage	"try to dispatch a message based on instruction name"		| sel pos |	sel := aMessage selector. 	sel isBinary ifTrue: [		"binary selectors"		^ super doesNotUnderstand: aMessage ].		"use the first keyword to find the instruction"	pos := sel indexOf: $:.	pos > 0 ifTrue: [ sel := (sel first: pos - 1) asSymbol ].	self instructionDesciptions at: sel ifPresent: [ :description|		^ self addInstruction: sel description: description operands: aMessage arguments	].		^ super doesNotUnderstand: aMessage! !!AJx86Assembler methodsFor: 'convenience'!dw: aByteArray	self assert: aByteArray size == SizeWord.	^ self addInstruction: (AJData data: aByteArray)! !!AJx86Assembler methodsFor: 'stack management'!emitEpilogue: popExtraBytes	^ stackManager emitEpilogue: popExtraBytes assembler: self! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!enter: stackFrameSize with: lexicalNesting	"Make Stack Frame for Procedure Parameters	Description-----------Creates a stack frame for a procedure. The first operand (size operand)specifies the size of the stack frame (that is, the number of bytes ofdynamic storage allocated on the stack for the procedure). The secondoperand (nesting level operand) gives the lexical nesting level (0 to31) of the procedure. The nesting level determines the number of stackframe pointers that are copied into the 'display area' of the new stackframe from the preceding frame. Both of these operands are immediatevalues.The stack-size attribute determines whether the BP (16 bits), EBP (32bits), or RBP (64 bits) register specifies the current frame pointer andwhether SP (16 bits), ESP (32 bits), or RSP (64 bits) specifies thestack pointer. In 64-bit mode, stack-size attribute is always 64-bits.The ENTER and companion LEAVE instructions are provided to support blockstructured languages. The ENTER instruction (when used) is typically thefirst instruction in a procedure and is used to set up a new stack framefor a procedure. The LEAVE instruction is then used at the end of theprocedure (just before the RET instruction) to release the stack frame.If the nesting level is 0, the processor pushes the frame pointer fromthe BP/EBP/RBP register onto the stack, copies the current stack pointerfrom the SP/ESP/RSP register into the BP/EBP/RBP register, and loads theSP/ESP/RSP register with the current stack-pointer value minus the valuein the size operand. For nesting levels of 1 or greater, the processorpushes additional frame pointers on the stack before adjusting the stackpointer. These additional frame pointers provide the called procedurewith access points to other nested frames on the stack. See 'ProcedureCalls for Block-Structured Languages' in Chapter 6 of theIntel64 andIA-32 ArchitecturesSoftware Developer's Manual, Volume 1, for moreinformation about the actions of the ENTER instruction.The ENTER instruction causes a page fault whenever a write using thefinal value of the stack pointer (within the current stack segment)would do so.In 64-bit mode, default operation size is 64 bits; 32-bit operation sizecannot be encoded."	^ self 		addInstruction: #enter		operands: { stackFrameSize . lexicalNesting }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fadd: aMemoryOperand	"Add	"	^ self 		addInstruction: #fadd		operands: { aMemoryOperand }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fadd: aX87Register1 with: aX87Register2	"	see #fadd"	^ self 		addInstruction: #fadd		operands: { aX87Register1 . aX87Register2 }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!faddp: aX87Register	"Add and Pop	"	^ self 		addInstruction: #faddp		operands: { aX87Register }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fbld: aMemoryOperand	"Load Binary Coded Decimal	Pseudo Code-----------TOP = TOP - 1;ST(0) = ConvertToDoubleExtendedPrecisionFP(SRC);Description-----------Converts the BCD source operand into double extended-precisionfloating-point format and pushes the value onto the FPU stack. Thesource operand is loaded without rounding errors. The sign of the sourceoperand is preserved, including that of -0.The packed BCD digits are assumed to be in the range 0 through 9; theinstruction does not check for invalid digits (AH through FH).Attempting to load an invalid encoding produces an undefined result.This instruction's operation is the same in non-64-bit modes and 64-bitmode."	^ self 		addInstruction: #fbld		operands: { aMemoryOperand }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fbstp: aMemoryOperand	"Store BCD Integer and Pop	Pseudo Code-----------DEST = BCD(ST(0));PopRegisterStack;Description-----------Converts the value in the ST(0) register to an 18-digit packed BCDinteger, stores the result in the destination operand, and pops theregister stack. If the source value is a non-integral value, it isrounded to an integer value, according to rounding mode specified by theRC field of the FPU control word. To pop the register stack, theprocessor marks the ST(0) register as empty and increments the stackpointer (TOP) by 1.The destination operand specifies the address where the first bytedestination value is to be stored. The BCD value (including its signbit) requires 10 bytes of space in memory.The following table shows the results obtained when storing variousclasses of numbers in packed BCD format.  ST(0)                                    DEST  ---------------------------------------- ------  - = or Value Too Large for DEST Format   \*  F \<= - 1                                - D  -1 \< F \< -0                            \*\*  - 0                                      - 0  + 0                                      + 0  + 0 \< F \< +1                           \*\*  F \>= +1                                 + D  + = or Value Too Large for DEST Format   \*  NaN                                      \*  : FBSTP Results-   Notes:-   F refers to a finite floating-point value.-   D refers to packed-BCD number.-   \* Indicates floating-point invalid-operation (\#IA) exception.-   \*\* 0 or 1, depending on the rounding mode.If the converted value is too large for the destination format, or ifthe source operand is an , SNaN, QNAN, or is in an unsupported format,an invalid-arithmetic-operand condition is signaled. If theinvalid-operation exception is not masked, an invalidarithmetic-operandexception (\#IA) is generated and no value is stored in the desti-nationoperand. If the invalid-operation exception is masked, the packed BCDindefinite value is stored in memory.This instruction's operation is the same in non-64-bit modes and 64-bitmode."	^ self 		addInstruction: #fbstp		operands: { aMemoryOperand }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fcmovb: aX87Register	"FP Conditional Move - below (CF=1)	"	^ self 		addInstruction: #fcmovb		operands: { aX87Register }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fcmovbe: aX87Register	"FP Conditional Move - below or equal (CF=1 or ZF=1)	"	^ self 		addInstruction: #fcmovbe		operands: { aX87Register }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fcmove: aX87Register	"FP Conditional Move - equal (ZF=1)	"	^ self 		addInstruction: #fcmove		operands: { aX87Register }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fcmovnb: aX87Register	"FP Conditional Move - not below (CF=0)	"	^ self 		addInstruction: #fcmovnb		operands: { aX87Register }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fcmovnbe: aX87Register	"FP Conditional Move - below or equal (CF=0 and ZF=0)	"	^ self 		addInstruction: #fcmovnbe		operands: { aX87Register }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fcmovne: aX87Register	"FP Conditional Move - not equal (ZF=0)	"	^ self 		addInstruction: #fcmovne		operands: { aX87Register }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fcmovnu: aX87Register	"FP Conditional Move - not unordered (PF=0)	"	^ self 		addInstruction: #fcmovnu		operands: { aX87Register }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fcmovu: aX87Register	"FP Conditional Move - unordered (PF=1)	"	^ self 		addInstruction: #fcmovu		operands: { aX87Register }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fcom: aMemoryOperand	"Compare Real	"	^ self 		addInstruction: #fcom		operands: { aMemoryOperand }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fcom: aX87Register1 with: aX87Register2	"	see #fcom"	^ self 		addInstruction: #fcom		operands: { aX87Register1 . aX87Register2 }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fcomi: aX87Register	"Compare Floating Point Values and Set EFLAGS	"	^ self 		addInstruction: #fcomi		operands: { aX87Register }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fcomip: aX87Register	"Compare Floating Point Values and Set EFLAGS and Pop	"	^ self 		addInstruction: #fcomip		operands: { aX87Register }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fcomp: aMemoryOperand	"Compare Real and Pop	"	^ self 		addInstruction: #fcomp		operands: { aMemoryOperand }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fcomp: aX87Register1 with: aX87Register2	"	see #fcomp"	^ self 		addInstruction: #fcomp		operands: { aX87Register1 . aX87Register2 }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fdiv: aMemoryOperand	"Divide	"	^ self 		addInstruction: #fdiv		operands: { aMemoryOperand }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fdiv: aX87Register1 with: aX87Register2	"	see #fdiv"	^ self 		addInstruction: #fdiv		operands: { aX87Register1 . aX87Register2 }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fdivp: aX87Register	"Divide and Pop	"	^ self 		addInstruction: #fdivp		operands: { aX87Register }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fdivr: aMemoryOperand	"Reverse Divide	"	^ self 		addInstruction: #fdivr		operands: { aMemoryOperand }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fdivr: aX87Register1 with: aX87Register2	"	see #fdivr"	^ self 		addInstruction: #fdivr		operands: { aX87Register1 . aX87Register2 }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fdivrp: aX87Register	"Reverse Divide and Pop	"	^ self 		addInstruction: #fdivrp		operands: { aX87Register }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!ffree: aX87Register	"Free Floating-Point Register	"	^ self 		addInstruction: #ffree		operands: { aX87Register }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fiadd: aMemoryOperand	"Add	"	^ self 		addInstruction: #fiadd		operands: { aMemoryOperand }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!ficom: aMemoryOperand	"Compare Integer	"	^ self 		addInstruction: #ficom		operands: { aMemoryOperand }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!ficomp: aMemoryOperand	"Compare Integer and Pop	"	^ self 		addInstruction: #ficomp		operands: { aMemoryOperand }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fidiv: aMemoryOperand	"Divide	"	^ self 		addInstruction: #fidiv		operands: { aMemoryOperand }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fidivr: aMemoryOperand	"Reverse Divide	"	^ self 		addInstruction: #fidivr		operands: { aMemoryOperand }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fild: aMemoryOperand	"Load Integer	Pseudo Code-----------TOP = TOP - 1;ST(0) = ConvertToDoubleExtendedPrecisionFP(SRC);Description-----------Converts the signed-integer source operand into doubleextended-precision floating-point format and pushes the value onto theFPU register stack. The source operand can be a word, doubleword, orquadword integer. It is loaded without rounding errors. The sign of thesource operand is preserved.This instruction's operation is the same in non-64-bit modes and 64-bitmode."	^ self 		addInstruction: #fild		operands: { aMemoryOperand }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fimul: aMemoryOperand	"Multiply	"	^ self 		addInstruction: #fimul		operands: { aMemoryOperand }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fist: aMemoryOperand	"Store Integer	"	^ self 		addInstruction: #fist		operands: { aMemoryOperand }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fistp: aMemoryOperand	"Store Integer and Pop	"	^ self 		addInstruction: #fistp		operands: { aMemoryOperand }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fisttp: aMemoryOperand	"Store Integer with Truncation and Pop	Pseudo Code-----------DEST = ST;pop ST;Description-----------FISTTP converts the value in ST into a signed integer using truncation(chop) as rounding mode, transfers the result to the destination, andpop ST. FISTTP accepts word, short integer, and long integerdestinations.The following table shows the results obtained when storing variousclasses of numbers in integer format.  ST(0)                                   DEST  --------------------------------------- ------  - or Value Too Large for DEST Format   \*  F  - 1                                 - I  - 1 \< F \< + 1                         0  F  + 1                                 + I  + or Value Too Large for DEST Format   \*  NaN                                     \*  : FISTTP Results-   Notes-   F means finite floating-point value.-   I means integer.-   Indicates floating-point invalid-operation (\#IA) exception.This instruction's operation is the same in non-64-bit modes and 64-bitmode."	^ self 		addInstruction: #fisttp		operands: { aMemoryOperand }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fisub: aMemoryOperand	"Subtract	"	^ self 		addInstruction: #fisub		operands: { aMemoryOperand }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fisubr: aMemoryOperand	"Reverse Subtract	"	^ self 		addInstruction: #fisubr		operands: { aMemoryOperand }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fld: aMemoryOrX87Register	"Load Floating Point Value	Description-----------Pushes the source operand onto the FPU register stack. The sourceoperand can be in single-precision, double-precision, or doubleextended-precision floating-point format. If the source operand is insingle-precision or double-precision floating-point format, it isautomatically converted to the double extended-precision floating-pointformat before being pushed on the stack.The FLD instruction can also push the value in a selected FPU register[ST(i)] onto the stack. Here, pushing register ST(0) duplicates thestack top.This instruction's operation is the same in non-64-bit modes and 64-bitmode."	^ self 		addInstruction: #fld		operands: { aMemoryOrX87Register }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fldcw: aMemoryOperand	"Load x87 FPU Control Word	"	^ self 		addInstruction: #fldcw		operands: { aMemoryOperand }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fldenv: aMemoryOperand	"Load x87 FPU Environment	Pseudo Code-----------FPUControlWord = SRC[FPUControlWord];FPUStatusWord = SRC[FPUStatusWord];FPUTagWord = SRC[FPUTagWord];FPUDataPointer = SRC[FPUDataPointer];FPUInstructionPointer = SRC[FPUInstructionPointer];FPULastInstructionOpcode = SRC[FPULastInstructionOpcode];Description-----------Loads the complete x87 FPU operating environment from memory into theFPU registers. The source operand specifies the first byte of theoperating-environment data in memory. This data is typically written tothe specified memory location by a FSTENV or FNSTENV instruction.The FPU operating environment consists of the FPU control word, statusword, tag word, instruction pointer, data pointer, and last opcode.Figures 8-9 through 8-12 in the Intel 64 and IA-32 ArchitecturesSoftware Developer's Manual, Volume 1, show the layout in memory of theloaded environment, depending on the operating mode of the processor(protected or real) and the current operand-size attribute (16-bit or32-bit). In virtual-8086 mode, the real mode layouts are used.The FLDENV instruction should be executed in the same operating mode asthe corresponding FSTENV/FNSTENV instruction.If one or more unmasked exception flags are set in the new FPU statusword, a floating-point exception will be generated upon execution of thenext floating-point instruction (except for the no-wait floating-pointinstructions, see the section titled 'Software Exception Handling' inChapter 8 of the Intel64 and IA-32 ArchitecturesSoftware Developer'sManual, Volume 1). To avoid generating exceptions when loading a newenvironment, clear all the exception flags in the FPU status word thatis being loaded.If a page or limit fault occurs during the execution of thisinstruction, the state of the x87 FPU registers as seen by the faulthandler may be different than the state being loaded from memory. Insuch situations, the fault handler should ignore the status of the x87FPU registers, handle the fault, and return. The FLDENV instruction willthen complete the loading of the x87 FPU registers with no resultingcontext inconsistency.This instruction's operation is the same in non-64-bit modes and 64-bitmode."	^ self 		addInstruction: #fldenv		operands: { aMemoryOperand }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fmul: aMemoryOperand	"Multiply	"	^ self 		addInstruction: #fmul		operands: { aMemoryOperand }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fmul: aX87Register1 with: aX87Register2	"	see #fmul"	^ self 		addInstruction: #fmul		operands: { aX87Register1 . aX87Register2 }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fmulp: aX87Register	"Multiply and Pop	"	^ self 		addInstruction: #fmulp		operands: { aX87Register }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fnsave: aMemoryOperand	"Store x87 FPU State	"	^ self 		addInstruction: #fnsave		operands: { aMemoryOperand }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fnstcw: aMemoryOperand	"Store x87 FPU Control Word	"	^ self 		addInstruction: #fnstcw		operands: { aMemoryOperand }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fnstenv: aMemoryOperand	"Store x87 FPU Environment	"	^ self 		addInstruction: #fnstenv		operands: { aMemoryOperand }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!frstor: aMemoryOperand	"Restore x87 FPU State	Description-----------Loads the FPU state (operating environment and register stack) from thememory area specified with the source operand. This state data istypically written to the specified memory location by a previousFSAVE/FNSAVE instruction.The FPU operating environment consists of the FPU control word, statusword, tag word, instruction pointer, data pointer, and last opcode.Figures 8-9 through 8-12 in the Intel 64 and IA-32 ArchitecturesSoftware Developer's Manual, Volume 1, show the layout in memory of thestored environment, depending on the operating mode of the processor(protected or real) and the current operand-size attribute (16-bit or32-bit). In virtual-8086 mode, the real mode layouts are used. Thecontents of the FPU register stack are stored in the 80 bytesimmediately following the operating environment image.The FRSTOR instruction should be executed in the same operating mode asthe corresponding FSAVE/FNSAVE instruction.If one or more unmasked exception bits are set in the new FPU statusword, a floating-point exception will be generated. To avoid raisingexceptions when loading a new operating environment, clear all theexception flags in the FPU status word that is being loaded.This instruction's operation is the same in non-64-bit modes and 64-bitmode."	^ self 		addInstruction: #frstor		operands: { aMemoryOperand }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fsave: aMemoryOperand	"Store x87 FPU State	"	^ self 		addInstruction: #fsave		operands: { aMemoryOperand }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fst: aMemoryOrX87Register	"Store Floating Point Value	"	^ self 		addInstruction: #fst		operands: { aMemoryOrX87Register }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fstcw: aMemoryOperand	"Store x87 FPU Control Word	"	^ self 		addInstruction: #fstcw		operands: { aMemoryOperand }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fstenv: aMemoryOperand	"Store x87 FPU Environment	"	^ self 		addInstruction: #fstenv		operands: { aMemoryOperand }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fstp: aMemoryOrX87Register	"Store Floating Point Value and Pop	"	^ self 		addInstruction: #fstp		operands: { aMemoryOrX87Register }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fsub: aMemoryOperand	"Subtract	"	^ self 		addInstruction: #fsub		operands: { aMemoryOperand }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fsub: aX87Register1 with: aX87Register2	"	see #fsub"	^ self 		addInstruction: #fsub		operands: { aX87Register1 . aX87Register2 }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fsubp: aX87Register	"Subtract and Pop	"	^ self 		addInstruction: #fsubp		operands: { aX87Register }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fsubr: aMemoryOperand	"Reverse Subtract	"	^ self 		addInstruction: #fsubr		operands: { aMemoryOperand }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fsubr: aX87Register1 with: aX87Register2	"	see #fsubr"	^ self 		addInstruction: #fsubr		operands: { aX87Register1 . aX87Register2 }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fsubrp: aX87Register	"Reverse Subtract and Pop	"	^ self 		addInstruction: #fsubrp		operands: { aX87Register }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fucom: aX87Register	"Unordered Compare Floating Point Values	"	^ self 		addInstruction: #fucom		operands: { aX87Register }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fucomi: aX87Register	"Unordered Compare Floating Point Values and Set EFLAGS	"	^ self 		addInstruction: #fucomi		operands: { aX87Register }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fucomip: aX87Register	"Unordered Compare Floating Point Values and Set EFLAGS and Pop	"	^ self 		addInstruction: #fucomip		operands: { aX87Register }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fucomp: aX87Register	"Unordered Compare Floating Point Values and Pop	"	^ self 		addInstruction: #fucomp		operands: { aX87Register }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fxch: aX87Register	"Exchange Register Contents	Description-----------Exchanges the contents of registers ST(0) and ST(i). If no sourceoperand is specified, the contents of ST(0) and ST(1) are exchanged.This instruction provides a simple means of moving values in the FPUregister stack to the top of the stack [ST(0)], so that they can beoperated on by those floating-point instructions that can only operateon values in ST(0). For example, the following instruction sequencetakes the square root of the third register from the top of the registerstack:    FXCH ST(3);    FSQRT;    FXCH ST(3);This instruction's operation is the same in non-64-bit modes and 64-bitmode."	^ self 		addInstruction: #fxch		operands: { aX87Register }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fxrstor: aMemoryOperand	"Restore x87 FPU, MMX, XMM, and MXCSR State	Pseudo Code-----------(x87 FPU, MMX, XMM7-XMM0, MXCSR) = Load(SRC);Description-----------Reloads the x87 FPU, MMX technology, XMM, and MXCSR registers from the512-byte memory image specified in the source operand. This data shouldhave been written to memory previously using the FXSAVE instruction, andin the same format as required by the operating modes. The first byte ofthe data should be located on a 16-byte boundary. There are threedistinct layouts of the FXSAVE state map: one for legacy andcompatibility mode, a second format for 64-bit mode FXSAVE/FXRSTOR withREX.W=0, and the third format is for 64-bit mode withFXSAVE64/FXRSTOR64. Table 3-48 ('Non-64-bit-Mode Layout of FXSAVE andFXRSTOR Memory Region') shows the layout of the legacy/compatibilitymode state information inmemory and describes the fields in the memoryimage for the FXRSTOR and FXSAVE instructions.Table 3-51 shows thelayout of the 64-bit mode state information whenREX.W is set(FXSAVE64/FXRSTOR64). Table 3-52 shows the layout of the 64-bitmodestate information when REX.W is clear (FXSAVE/FXRSTOR).The state image referenced with an FXRSTOR instruction must have beensaved using an FXSAVE instruction or be in the same format as requiredby Table 3-48, Table 3-51, or Table 3-52. Referencing a state imagesaved with an FSAVE, FNSAVEinstruction or incompatible field layout willresult in an incorrect state restoration.The FXRSTOR instruction does not flush pending x87 FPU exceptions. Tocheck and raise exceptions when loading x87 FPU state information withthe FXRSTOR instruction, use an FWAIT instruction after the FXRSTORinstruction.If the OSFXSR bit in control register CR4 is not set, the FXRSTORinstruction may not restore the states of the XMM and MXCSR registers.This behavior is implementation dependent.If the MXCSR state contains an unmasked exception with a correspondingstatus flag also set, loading the register with the FXRSTOR instructionwill not result in a SIMD floating-point error condition beinggenerated. Only the next occurrence of this unmasked exception willresult in the exception being generated.Bits 16 through 32 of the MXCSR register are defined as reserved andshould be set to 0. Attempting to write a 1 in any of these bits fromthe saved state image will result in a general protection exception(\#GP) being generated.Bytes 464:511 of an FXSAVE image are available for software use. FXRSTORignores the content of bytes 464:511 in an FXSAVE state image."	^ self 		addInstruction: #fxrstor		operands: { aMemoryOperand }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!fxsave: aMemoryOperand	"Save x87 FPU, MMX, XMM, and MXCSR State	Description-----------Saves the current state of the x87 FPU, MMX technology, XMM, and MXCSRregisters to a 512-byte memory location specified in the destinationoperand. The content layout of the 512 byte region depends on whetherthe processor is operating in non-64-bit operating modes or 64-bitsub-mode of IA-32e mode.Bytes 464:511 are available to software use. The processor does notwrite to bytes 464:511 of an FXSAVE area.The operation of FXSAVE in non-64-bit modes is described first.### Non-64-Bit Mode OperationThe following table shows the layout of the state information in memorywhen the processoris operating in legacy modes.  ------------- --------- -------- ----- -------- ----- ----- ----- --- --- --- --- --- --- --- --- --  15            14        13       12    11       10    9     8     7   6   5   4   3   2   1   0     Rsrvd         CS        FPU IP   FOP   Rs rvd   FTW   FSW   FCW   0  MXCSR\_MASK   MXCSR     Rsrvd    DS    FPU DP   16  Reserved      ST0/MM0   32  Reserved      ST1/MM1   48  Reserved      ST2/MM2   64  Reserved      ST3/MM3   80  Reserved      ST4/MM4   96  Reserved      ST5/MM5   112  Reserved      ST6/MM6   128  Reserved      ST7/MM7   144  XMM0          160  XMM1          176  XMM2          192  XMM3          208  XMM4          224  XMM5          240  XMM6          256  XMM7          272  Reserved      288  Reserved      304  Reserved      320  Reserved      336  Reserved      352  Reserved      368  Reserved      384  Reserved      400  Reserved      416  Reserved      432  Reserved      448  Available     464  Available     480  Available     496  ------------- --------- -------- ----- -------- ----- ----- ----- --- --- --- --- --- --- --- --- --  : Non-64-bit-Mode Layout of FXSAVE and FXRSTOR Memory RegionThe destination operand contains the first byte of the memory image, andit must be aligned on a 16-byte boundary. A misaligned destinationoperand will result in a general-protection (\#GP) exception beinggenerated (or in some cases, an alignment check exception [\#AC]).The FXSAVE instruction is used when an operating system needs to performa context switch or when an exception handler needs to save and examinethe current state of the x87 FPU, MMX technology, and/or XMM and MXCSRregisters.The fields used in the previous table are defined in the followingtable.Field DefinitionsFieldDefinitionFCWx87 FPU Control Word (16 bits). See Figure 8-6 in the Intel 64 andIA-32 Architectures Software Developer's Manual, Volume 1, for thelayout of the x87 FPU control word.FSWx87 FPU Status Word (16 bits). See Figure 8-4 in the Intel 64 and IA-32Architectures Software Developer's Manual, Volume 1, for the layout ofthe x87 FPU status word.Abridged FTWx87 FPU Tag Word (8 bits). The tag information saved here is abridged,as described in the following paragraphs.FOPx87 FPU Opcode (16 bits). The lower 11 bits of this field contain theopcode, upper 5 bits are reserved. See Figure 8-8 in the Intel 64 andIA-32 Architectures Software Developer's Manual, Volume 1, for thelayout of the x87 FPU opcode field.FPU IPx87 FPU Instruction Pointer Offset (32 bits). The contents of this fielddiffer depending on the current addressing mode (32-bit or 16-bit) ofthe processor when the FXSAVE instruction was executed:-   32-bit mode  32-bit IP offset.-   16-bit mode  low 16 bits are IP offset; high 16 bits are reserved.See 'x87 FPU Instruction and Operand (Data) Pointers' in Chapter 8 ofthe Intel 64 and IA-32 Architectures Software Developer's Manual,Volume 1, for a description of the x87 FPU instruction pointer.CSx87 FPU Instruction Pointer Selector (16 bits).FPU DPx87 FPU Instruction Operand (Data) Pointer Offset (32 bits). Thecontents of this field differ depending on the current addressing mode(32-bit or 16bit) of the processor when the FXSAVE instruction wasexecuted:-   32-bit mode  32-bit DP offset.-   16-bit mode  low 16 bits are DP offset; high 16 bits are reserved.See 'x87 FPU Instruction and Operand (Data) Pointers' in Chapter 8 ofthe Intel 64 and IA-32 Architectures Software Developer's Manual,Volume 1, for a description of the x87 FPU operand pointer.DSx87 FPU Instruction Operand (Data) Pointer Selector (16 bits).MXCSRMXCSR Register State (32 bits). See Figure 10-3 in the Intel 64 andIA-32 Architectures Software Developer's Manual, Volume 1, for thelayout of the MXCSR register. If the OSFXSR bit in control register CR4is not set, the FXSAVE instruction may not save this register. Thisbehavior is implementation dependent.MXCSR\_MXCSR\_MASK (32 bits). This mask can be used to adjust values written toMASKthe MXCSR register, ensuring that reserved bits are set to 0. Set themask bits and flags in MXCSR to the mode of operation desired for SSEand SSE2 SIMD floating-point instructions. See 'Guidelines for Writingto the MXCSR Register' in Chapter 11 of the Intel 64 and IA-32Architectures Software Developer's Manual, Volume 1, for instructionsfor how to determine and use the MXCSR\_MASK value.ST0/MM0 throughx87 FPU or MMX technology registers. These 80-bit fields contain the x87ST7/MM7FPU data registers or the MMX technology registers, depending on thestate of the processor prior to the execution of the FXSAVE instruction.If the processor had been executing x87 FPU instruction prior to theFXSAVE instruction, the x87 FPU data registers are saved; if it had beenexecuting MMX instructions (or SSE or SSE2 instructions that operated onthe MMX technology registers), the MMX technology registers are saved.When the MMX technology registers are saved, the high 16 bits of thefield are reserved.XMM0 through XMM7XMM registers (128 bits per field). If the OSFXSR bit in controlregister CR4 is not set, the FXSAVE instruction may not save theseregisters. This behavior is implementation dependent.The FXSAVE instruction saves an abridged version of the x87 FPU tag wordin the FTW field (unlike the FSAVE instruction, which saves the completetag word). The tag information is saved in physical register order (R0through R7), rather than in top-ofstack (TOS) order. With the FXSAVEinstruction, however, only a single bit (1 for valid or 0 for empty) issaved for each tag. For example, assume that the tag word is currentlyset as follows:  ---- ---- ---- ---- ---- ---- ---- ----  R7   R6   R5   R4   R3   R2   R1   R0  11   xx   xx   xx   11   11   11   11  ---- ---- ---- ---- ---- ---- ---- ----Here, 11B indicates empty stack elements and 'xx' indicates valid (00B),zero (01B), or special (10B).For this example, the FXSAVE instruction saves only the following 8 bitsof information:  ---- ---- ---- ---- ---- ---- ---- ----  R7   R6   R5   R4   R3   R2   R1   R0  0    1    1    1    0    0    0    0  ---- ---- ---- ---- ---- ---- ---- ----Here, a 1 is saved for any valid, zero, or special tag, and a 0 is savedfor any empty tag.The operation of the FXSAVE instruction differs from that of the FSAVEinstruction, the as follows:-   FXSAVE instruction does not check for pending unmasked    floating-point exceptions. (The FXSAVE operation in this regard is    similar to the operation of the FNSAVE instruction).-   After the FXSAVE instruction has saved the state of the x87 FPU, MMX    technology, XMM, and MXCSR registers, the processor retains the    contents of the registers. Because of this behavior, the FXSAVE    instruction cannot be used by an application program to pass a    'clean' x87 FPU state to a procedure, since it retains the current    state. To clean the x87 FPU state, an application must explicitly    execute an FINIT instruction after an FXSAVE instruction to    reinitialize the x87 FPU state.-   The format of the memory image saved with the FXSAVE instruction is    the same regardless of the current addressing mode (32-bit or    16-bit) and operating mode (protected, real address, or system    management). This behavior differs from the FSAVE instructions,    where the memory image format is different depending on the    addressing mode and operating mode. Because of the different image    formats, the memory image saved with the FXSAVE instruction cannot    be restored correctly with the FRSTOR instruction, and likewise the    state saved with the FSAVE instruction cannot be restored correctly    with the FXRSTOR instruction.The FSAVE format for FTW can be recreated from the FTW valid bits andthe stored 80-bit FP data (assuming the stored data was not the contentsof MMX technology registers) using Table 3-50.  Exponent all 1's                    Exponent all 0's   Fraction all 0's   J and M bits   FTW valid bit   x87 FTW  ----------------------------------- ------------------ ------------------ -------------- --------------- --------- ----  0                                   0                  0                  0x             1               Special   10  0                                   0                  0                  1x             1               Valid     00  0                                   0                  1                  00             1               Special   10  0                                   0                  1                  10             1               Valid     00  0                                   1                  0                  0x             1               Special   10  0                                   1                  0                  1x             1               Special   10  0                                   1                  1                  00             1               Zero      01  0                                   1                  1                  10             1               Special   10  1                                   0                  0                  1x             1               Special   10  1                                   0                  0                  1x             1               Special   10  1                                   0                  1                  00             1               Special   10  1                                   0                  1                  10             1               Special   10  For all legal combinations above.   0                  Empty              11  : Recreating FSAVE FormatThe J-bit is defined to be the 1-bit binary integer to the left of thedecimal place in the significand. The M-bit is defined to be the mostsignificant bit of the fractional portion of the significand (i.e., thebit immediately to the right of the decimal place).When the M-bit is the most significant bit of the fractional portion ofthe significand, it must be 0 if the fraction is all 0's.### IA-32e Mode OperationIn compatibility sub-mode of IA-32e mode, legacy SSE registers, XMM0through XMM7, are saved according to the legacy FXSAVE map. In 64-bitmode, all of the SSE registers, XMM0 through XMM15, are saved.Additionally, there are two different layouts of the FXSAVE map in64-bit mode, corresponding to FXSAVE64 (which requires REX.W=1) andFXSAVE (REX.W=0). In the FXSAVE64 map (following table), theFPU IP andFPU DP pointers are 64-bit wide. In the FXSAVE map for 64-bit mode (seethe following tables), the FPU IP and FPU DP pointers are 32-bits.  ------------- --------- ---------- ----- ----- ----- --- --- --- --- --- --- --- --- --- --- --  15            14        13         12    11    10    9   8   7   6   5   4   3   2   1   0     FPU IP        FOP       Reserved   FTW   FSW   FCW   0  MXCSR\_MASK   MXCSR     FPU DP     16  Reserved      ST0/MM0   32  Reserved      ST1/MM1   48  Reserved      ST2/MM2   64  Reserved      ST3/MM3   80  Reserved      ST4/MM4   96  Reserved      ST5/MM5   112  Reserved      ST6/MM6   128  Reserved      ST7/MM7   144  XMM0          160  XMM1          176  XMM2          192  XMM3          208  XMM4          224  XMM5          240  XMM6          256  XMM7          272  XMM8          288  XMM9          304  XMM10         320  XMM11         336  XMM12         352  XMM13         368  XMM14         384  XMM15         400  Reserved      416  Reserved      432  Reserved      448  Available     464  Available     480  Available     496  ------------- --------- ---------- ----- ----- ----- --- --- --- --- --- --- --- --- --- --- --  : Layout of the 64-bit-mode FXSAVE64 Map (requires REX.W = 1)  ------------- --------- ---------- -------- ---------- ----- ----- ----- --- --- --- --- --- --- --- --- --  15            14        13         12       11         10    9     8     7   6   5   4   3   2   1   0     Reserved      CS        FPU IP     FOP      Reserved   FTW   FSW   FCW   0  MXCSR\_MASK   MXCSR     Reserved   FPU DP   16  Reserved      ST0/MM0   32  Reserved      ST1/MM1   48  Reserved      ST2/MM2   64  Reserved      ST3/MM3   80  ------------- --------- ---------- -------- ---------- ----- ----- ----- --- --- --- --- --- --- --- --- --  : Layout of the 64-bit-mode FXSAVE Map (REX.W = 0)ReservedST4/MM496ReservedST5/MM5112ReservedST6/MM6128ReservedST7/MM7144XMM0160XMM1176XMM2192XMM3208XMM4224XMM5240XMM6256XMM7272XMM8288XMM9304XMM10320XMM11336XMM12352XMM13368XMM14384XMM15400Reserved416Reserved432Reserved448Available464Available480Available496"	^ self 		addInstruction: #fxsave		operands: { aMemoryOperand }! !!AJx86Assembler methodsFor: 'debugging'!gccDisassemble	^ self gccDisassemble: self bytes.! !!AJx86Assembler methodsFor: 'debugging' stamp: 'CamilloBruni 7/23/2012 15:25'!gccDisassemble: bytes		'disas.sh' asFileReference delete writeStreamDo: [:s|		s 			nextPutAll: '#!!/bin/bash'; lf;			nextPutAll: 'gcc -g -O0 ';			nextPutAll: (self is32 ifTrue: ['-m32'] ifFalse: [ '-m64' ]);			nextPutAll: ' disas.test.c >> /dev/null 2>&1'; lf;			nextPutAll: 'gdb -q -x gdb.commands  a.out | grep "^0x" > disas.output'; lf].	'gdb.commands' asFileReference delete writeStreamDo: [:s|		s 			nextPutAll: 'b 4'; lf; 			nextPutAll: 'r'; lf;			nextPutAll: 'x /'; print: bytes size; nextPutAll: 'xb &instructions'; lf;			nextPutAll: 'x /'; print: bytes size; nextPutAll: 'ub &instructions'; lf; 			nextPutAll: 'disas &instructions &instructions+1'; lf; 			nextPutAll: 'q'].	'disas.test.c' asFileReference delete writeStreamDo: [ :f|		{			'#include <stdio.h>'.			'void main() {'	.			'const char instructions[]= {'.				String streamContents: [:s|				bytes 						do: [:b | s print: b]					separatedBy: [ s << ', ']].			'};'.			'printf("%d", instructions);'.			'}'		}		do: [:x | f nextPutAll: x value asString; lf ]].		Smalltalk 		at: #OSProcess 		ifPresent: [ :cls|			cls waitForCommand: 'cd "', Smalltalk imagePath, '"; chmod a+x ./disas.sh; sh ./disas.sh'.			^ 'disas.output' asFileReference readStream contents asString].		self inform: 'OSProcess has to be installed to run gccDisassemble'.! !!AJx86Assembler methodsFor: 'code generation'!generatedCode	^ AJGeneratedCode new		fromInstructions: self prepareInstructions.! !!AJx86Assembler methodsFor: 'testing'!hasLabelNamed: aName	^ labels includesKey: aName ! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!idiv: aDestination	"Signed Divide	Description-----------Divides the (signed) value in the AX, DX:AX, or EDX:EAX (dividend) bythe source operand (divisor) and stores the result in the AX (AH:AL),DX:AX, or EDX:EAX registers. The source operand can be a general-purposeregister or a memory location. The action of this instruction depends onthe operand size (dividend/divisor).Non-integral results are truncated (chopped) towards 0. The remainder isalways less than the divisor in magnitude. Overflow is indicated withthe \#DE (divide error) exception rather than with the CF flag.In 64-bit mode, the instruction's default operation size is 32 bits. Useof the REX.R prefix permits access to additional registers (R8-R15). Useof the REX.W prefix promotes operation to 64 bits. In 64-bit mode whenREX.W is applied, the instruction divides the signed value in RDX:RAX bythe source operand. RAX contains a 64-bit quotient; RDX contains a64-bit remainder.See the summary chart at the beginning of this section for encoding dataand limits. See the following.  Operand Size              Dividend   Divisor   Quotient   Remainder   Quotient Range  ------------------------- ---------- --------- ---------- ----------- ---------------------  Word/byte                 AX         r/m8      AL         AH          -128 to +127  Doubleword/word           DX:AX      r/m16     AX         DX          -32,768 to +32,767  Quadword/doubleword       EDX:EAX    r/m32     EAX        EDX         -2^31^ to 2^32^ - 1  Doublequadword/quadword   RDX:RAX    r/m64     RAX        RDX         -2^63^ to 2^64^ - 1  : IDIV Results"	^ self 		addInstruction: #idiv		operands: { aDestination }! !!AJx86Assembler methodsFor: 'converting'!imm: value	^ value asImm ! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!imul: aRegisterOrMemory	"Signed Multiply	Description-----------Performs a signed multiplication of two operands. This instruction hasthree forms, depending on the number of operands.-   One-operand form  This form is identical to that used by the MUL    instruction. Here, the source operand (in a general-purpose register    or memory location) is multiplied by the value in the AL, AX, EAX,    or RAX register (depending on the operand size) and the product is    stored in the AX, DX:AX, EDX:EAX, or RDX:RAX registers,    respectively.-   Two-operand form  With this form the destination operand (the first    operand) is multiplied by the source operand (second operand). The    destination operand is a general-purpose register and the source    operand is an immediate value, a general-purpose register, or a    memory location. The product is then stored in the destination    operand location.-   Three-operand form  This form requires a destination operand (the    first operand) and two source operands (the second and the third    operands). Here, the first source operand (which can be a    general-purpose register or a memory location) is multiplied by the    second source operand (an immediate value). The product is then    stored in the destination operand (a general-purpose register).When an immediate value is used as an operand, it is sign-extended tothe length of the destination operand format.The CF and OF flags are set when significant bit (including the signbit) are carried into the upper half of the result. The CF and OF flagsare cleared when the result (including the sign bit) fits exactly in thelower half of the result.The three forms of the IMUL instruction are similar in that the lengthof the product is calculated to twice the length of the operands. Withthe one-operand form, the product is stored exactly in the destination.With the two- and three- operand forms, however, the result is truncatedto the length of the destination before it is stored in the destinationregister. Because of this truncation, the CF or OF flag should be testedto ensure that no significant bits are lost.The two- and three-operand forms may also be used with unsigned operandsbecause the lower half of the product is the same regardless if theoperands are signed or unsigned. The CF and OF flags, however, cannot beused to determine if the upper half of the result is non-zero.In 64-bit mode, the instruction's default operation size is 32 bits. Useof the REX.R prefix permits access to additional registers (R8-R15). Useof the REX.W prefix promotes operation to 64 bits. Use of REX.W modifiesthe three forms of the instruction as follows.-   One-operand form The source operand (in a 64-bit general-purpose    register or memory location) is multiplied by the value in the RAX    register and the product is stored in the RDX:RAX registers.-   Two-operand form  The source operand is promoted to 64 bits if it    is a register or a memory location. If the source operand is an    immediate, it is sign extended to 64 bits. The destination operand    is promoted to 64 bits.-   Three-operand form  The first source operand (either a register or    a memory location) and destination operand are promoted to 64 bits."	^ self 		addInstruction: #imul		operands: { aRegisterOrMemory }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!imul: aRegister with: aRegisterOrMemoryOrImmediate	"	see #imul"	^ self 		addInstruction: #imul		operands: { aRegister . aRegisterOrMemoryOrImmediate }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!imul: aRegister with: aRegisterOrMemory with: anImmediate	"	see #imul"	^ self 		addInstruction: #imul		operands: { aRegister . aRegisterOrMemory . anImmediate }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!inc: aRegisterOrMemory	"Increment by 1	Pseudo Code-----------DEST = DEST + 1;AFlags AffectedThe CF flag is not affected. The OF, SF, ZF, AF, and PF flags are set according to the result.Description-----------Adds 1 to the destination operand, while preserving the state of the CFflag. The destination operand can be a register or a memory location.This instruction allows a loop counter to be updated without disturbingthe CF flag. (Use a ADD instruction with an immediate operand of 1 toperform an increment operation that does updates the CF flag.)This instruction can be used with a LOCK prefix to allow the instructionto be executed atomically.In 64-bit mode, INC r16 and INC r32 are not encodable (because opcodes40H through 47H are REX prefixes). Otherwise, the instruction's 64-bitmode default operation size is 32 bits. Use of the REX.R prefix permitsaccess to additional registers (R8-R15). Use of the REX.W prefixpromotes operation to 64 bits."	^ self 		addInstruction: #inc		operands: { aRegisterOrMemory }! !!AJx86Assembler methodsFor: 'initialize-release' stamp: 'CamilloBruni 3/30/2012 16:20'!initialize	is64 := false.	self reset.! !!AJx86Assembler methodsFor: 'instruction list'!insert: i after: instruction	| next |	i ifNil: [ "nothing to insert" ^ self ].	i do: [:each |		each increaseLevel: instruction level		].	next := instruction next.	instruction next: i.	i last next: next! !!AJx86Assembler methodsFor: 'instruction list'!insert: newInstruction before: anInstruction	"insert one or more instructions before an instruction"		^ instructions := instructions insert: newInstruction before: anInstruction! !!AJx86Assembler methodsFor: 'accessing' stamp: 'CamilloBruni 8/23/2012 16:01'!instructionDesciptions	^ AJx86InstructionDescription instructions! !!AJx86Assembler methodsFor: 'register'!instructionPointer	"not available on 32bit x86 CPUs"	self notYetImplemented ! !!AJx86Assembler methodsFor: 'instruction list'!instructionsFor: aBlockWithCode	| old new |	old := instructions.	instructions := nil.	[		aBlockWithCode value.	] ensure: [ 		new := instructions.		instructions := old ].	^ new! !!AJx86Assembler methodsFor: 'testing'!is32	^ true! !!AJx86Assembler methodsFor: 'testing'!isLabelUsed: aLabel	| used |	used := false.	instructions do: [:instr |		used := used or: [instr isLabelUsed: aLabel ] ].	^ used! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!ja: targetLabel	"	"	^ self 		addInstruction: #ja		operands: { targetLabel }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!jae: targetLabel	"	"	^ self 		addInstruction: #jae		operands: { targetLabel }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!jb: targetLabel	"Jump short if below/not above or equal/carry (CF=1)	"	^ self 		addInstruction: #jb		operands: { targetLabel }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!jbe: targetLabel	"Jump short if below or equal/not above (CF=1 AND ZF=1)	"	^ self 		addInstruction: #jbe		operands: { targetLabel }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!jc: targetLabel	"	"	^ self 		addInstruction: #jc		operands: { targetLabel }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!je: targetLabel	"	"	^ self 		addInstruction: #je		operands: { targetLabel }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!jg: targetLabel	"	"	^ self 		addInstruction: #jg		operands: { targetLabel }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!jge: targetLabel	"	"	^ self 		addInstruction: #jge		operands: { targetLabel }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!jl: targetLabel	"Jump short if less/not greater (SF!!=OF)	"	^ self 		addInstruction: #jl		operands: { targetLabel }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!jle: targetLabel	"Jump short if less or equal/not greater ((ZF=1) OR (SF!!=OF))	"	^ self 		addInstruction: #jle		operands: { targetLabel }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!jmp: aLabelOrRegisterOrMemory	"Jump	Description-----------Transfers program control to a different point in the instruction streamwithout recording return information. The destination (target) operandspecifies the address of the instruction being jumped to. This operandcan be an immediate value, a general-purpose register, or a memorylocation.This instruction can be used to execute four different types of jumps:-   Near jumpA jump to an instruction within the current code segment    (the segment currently pointed to by the CS register), sometimes    referred to as an intrasegment jump.-   Short jumpA near jump where the jump range is limited to -128 to    +127 from the current EIP value.-   Far jumpA jump to an instruction located in a different segment    than the current code segment but at the same privilege level,    sometimes referred to as an intersegment jump.-   Task switchA jump to an instruction located in a different task.A task switch can only be executed in protected mode (see Chapter 7, intheIntel 64 and IA-32 Architectures Software Developer's Manual, Volume3A, for information on performing task switches with the JMPinstruction).Near and Short Jumps. When executing a near jump, the processor jumps tothe address (within the current code segment) that is specified with thetarget operand. The target operand specifies either an absolute offset(that is an offset from the base of the code segment) or a relativeoffset (a signed displacement relative to the current value of theinstruction pointer in the EIP register). A near jump to a relativeoffset of 8-bits (rel8) is referred to as a short jump. The CS registeris not changed on near and short jumps.An absolute offset is specified indirectly in a general-purpose registeror a memory location (r/m16 or r/m32). The operand-size attributedetermines the size of the target operand (16 or 32 bits). Absoluteoffsets are loaded directly into the EIP register. If the operand-sizeattribute is 16, the upper two bytes of the EIP register are cleared,resulting in a maximum instruction pointer size of 16 bits.A relative offset (rel8, rel16, or rel32) is generally specified as alabel in assembly code, but at the machine code level, it is encoded asa signed 8-, 16-, or 32-bit immediate value. This value is added to thevalue in the EIP register. (Here, the EIP register contains the addressof the instruction following the JMP instruction). When using relativeoffsets, the opcode (for short vs. near jumps) and the operand-sizeattribute (for near relative jumps) determines the size of the targetoperand (8, 16, or 32 bits).Far Jumps in Real-Address or Virtual-8086 Mode. When executing a farjump in real-address or virtual-8086 mode, the processor jumps to thecode segment and offset specified with the target operand. Here thetarget operand specifies an absolute far address either directly with apointer (ptr16:16 or ptr16:32) or indirectly with a memory location(m16:16 or m16:32). With the pointer method, the segment and address ofthe called procedure is encoded in the instruction, using a 4-byte(16-bit operand size) or 6-byte (32-bit operand size) far addressimmediate. With the indirect method, the target operand specifies amemory location that contains a 4-byte (16-bit operand size) or 6-byte(32-bit operand size) far address. The far address is loaded directlyinto the CS and EIP registers. If the operand-size attribute is 16, theupper two bytes of the EIP register are cleared.Far Jumps in Protected Mode. When the processor is operating inprotected mode, the JMP instruction can be used to perform the followingthree types of far jumps:-   A far jump to a conforming or non-conforming code segment.-   A far jump through a call gate.-   A task switch.(The JMP instruction cannot be used to perform inter-privilege-level farjumps.)In protected mode, the processor always uses the segment selector partof the far address to access the corresponding descriptor in the GDT orLDT. The descriptor type (code segment, call gate, task gate, or TSS)and access rights determine the type of jump to be performed.If the selected descriptor is for a code segment, a far jump to a codesegment at the same privilege level is performed. (If the selected codesegment is at a different privilege level and the code segment isnon-conforming, a general-protection exception is generated.) A far jumpto the same privilege level in protected mode is very similar to onecarried out in real-address or virtual-8086 mode. The target operandspecifies an absolute far address either directly with a pointer(ptr16:16 or ptr16:32) or indirectly with a memory location (m16:16 orm16:32). The operand-size attribute determines the size of the offset(16 or 32 bits) in the far address. The new code segment selector andits descriptor are loaded into CS register, and the offset from theinstruction is loaded into the EIP register. Note that a call gate(described in the next paragraph) can also be used to perform far callto a code segment at the same privilege level. Using this mechanismprovides an extra level of indirection and is the preferred method ofmaking jumps between 16-bit and 32-bit code segments.When executing a far jump through a call gate, the segment selectorspecified by the target operand identifies the call gate. (The offsetpart of the target operand is ignored.) The processor then jumps to thecode segment specified in the call gate descriptor and begins executingthe instruction at the offset specified in the call gate. No stackswitch occurs. Here again, the target operand can specify the faraddress of the call gate either directly with a pointer (ptr16:16 orptr16:32) or indirectly with a memory location (m16:16 or m16:32).Executing a task switch with the JMP instruction is somewhat similar toexecuting a jump through a call gate. Here the target operand specifiesthe segment selector of the task gate for the task being switched to(and the offset part of the target operand is ignored). The task gate inturn points to the TSS for the task, which contains the segmentselectors for the task's code and stack segments. The TSS also containsthe EIP value for the next instruction that was to be executed beforethe task was suspended. This instruction pointer value is loaded intothe EIP register so that the task begins executing again at this nextinstruction.The JMP instruction can also specify the segment selector of the TSSdirectly, which eliminates the indirection of the task gate. See Chapter7 inIntel 64 and IA-32Architectures Software Developer's Manual, Volume3A, for detailed information on the mechanics of a task switch.Note that when you execute at task switch with a JMP instruction, thenested task flag (NT) is not set in the EFLAGS register and the newTSS's previous task link field is not loaded with the old task's TSSselector. A return to the previous task can thus not be carried out byexecuting the IRET instruction. Switching tasks with the JMP instructiondiffers in this regard from the CALL instruction which does set the NTflag and save the previous task link information, allowing a return tothe calling task with an IRET instruction.In 64-Bit Mode  The instruction's operation size is fixed at 64 bits.If a selector points to a gate, then RIP equals the 64-bit displacementtaken from gate; else RIP equals the zero-extended offset from the farpointer referenced in the instruction.See the summary chart at the beginning of this section for encoding dataand limits."	^ self 		addInstruction: #jmp		operands: { aLabelOrRegisterOrMemory }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!jna: targetLabel	"	"	^ self 		addInstruction: #jna		operands: { targetLabel }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!jnae: targetLabel	"	"	^ self 		addInstruction: #jnae		operands: { targetLabel }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!jnb: targetLabel	"Jump short if not below/above or equal/not carry (CF=0)	"	^ self 		addInstruction: #jnb		operands: { targetLabel }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!jnbe: targetLabel	"Jump short if not below or equal/above (CF=0 AND ZF=0)	"	^ self 		addInstruction: #jnbe		operands: { targetLabel }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!jnc: targetLabel	"	"	^ self 		addInstruction: #jnc		operands: { targetLabel }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!jne: targetLabel	"	"	^ self 		addInstruction: #jne		operands: { targetLabel }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!jng: targetLabel	"	"	^ self 		addInstruction: #jng		operands: { targetLabel }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!jnge: targetLabel	"	"	^ self 		addInstruction: #jnge		operands: { targetLabel }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!jnl: targetLabel	"Jump short if not less/greater or equal (SF=OF)	"	^ self 		addInstruction: #jnl		operands: { targetLabel }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!jnle: targetLabel	"Jump short if not less nor equal/greater ((ZF=0) AND (SF=OF))	"	^ self 		addInstruction: #jnle		operands: { targetLabel }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!jno: targetLabel	"Jump short if not overflow (OF=0)	"	^ self 		addInstruction: #jno		operands: { targetLabel }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!jnp: targetLabel	"Jump short if not parity/parity odd	"	^ self 		addInstruction: #jnp		operands: { targetLabel }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!jns: targetLabel	"Jump short if not sign (SF=0)	"	^ self 		addInstruction: #jns		operands: { targetLabel }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!jnz: targetLabel	"Jump short if not zero/not equal (ZF=1)	"	^ self 		addInstruction: #jnz		operands: { targetLabel }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!jo: targetLabel	"Jump short if overflow (OF=1)	"	^ self 		addInstruction: #jo		operands: { targetLabel }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!jp: targetLabel	"Jump short if parity/parity even (PF=1)	"	^ self 		addInstruction: #jp		operands: { targetLabel }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!jpe: targetLabel	"	"	^ self 		addInstruction: #jpe		operands: { targetLabel }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!jpo: targetLabel	"	"	^ self 		addInstruction: #jpo		operands: { targetLabel }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!js: targetLabel	"Jump short if sign (SF=1)	"	^ self 		addInstruction: #js		operands: { targetLabel }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!jz: targetLabel	"Jump short if zero/equal (ZF=0)	"	^ self 		addInstruction: #jz		operands: { targetLabel }! !!AJx86Assembler methodsFor: 'labels' stamp: 'CamilloBruni 5/29/2012 13:15'!label: aNameOrLabel	^ self 		label: aNameOrLabel 		ifPresent: [ self error: 'label ', aNameOrLabel asString, ' already set' ].! !!AJx86Assembler methodsFor: 'labels' stamp: 'CamilloBruni 7/18/2012 16:27'!label: aNameOrLabel ifPresent: anExceptionBlock	| label |	label := aNameOrLabel.	label isString 		ifTrue: [ label := self labelNamed: label ].		label isSet 		ifTrue: [ ^ anExceptionBlock cull: label ].		label isSet: true.	^ self addInstruction: label.  ! !!AJx86Assembler methodsFor: 'labels' stamp: 'CamilloBruni 5/29/2012 13:06'!labelNamed: aNameOrLabel		"directly use an object as label"	aNameOrLabel isString ifFalse: [ 		self assert: (labels at: aNameOrLabel name ) = aNameOrLabel.		^ aNameOrLabel ].		^ labels at: aNameOrLabel ifAbsentPut: [		AJJumpLabel new			name: aNameOrLabel 		]! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!ldmxcsr: aMemoryOperand	"Load MXCSR Register	Pseudo Code-----------MXCSR = m32;C/C++ Compiler Intrinsic Equivalent_mm_setcsr(unsigned int i)Description-----------Loads the source operand into the MXCSR control/status register. Thesource operand is a 32-bit memory location. See 'MXCSR Control andStatus Register' in Chapter 10, of theIntel64 and IA-32 ArchitecturesSoftware Developer's Manual,Volume 1, for a description of the MXCSRregister and its contents.The LDMXCSR instruction is typically used in conjunction with theSTMXCSR instruction, which stores the contents of the MXCSR register inmemory.The default MXCSR value at reset is 1F80H.If a LDMXCSR instruction clears a SIMD floating-point exception mask bitand sets the corresponding exception flag bit, a SIMD floating-pointexception will not be immediately generated. The exception will begenerated only upon the execution of the next SSE or SSE2 instructionthat causes that particular SIMD floating-point exception to bereported.This instruction's operation is the same in non-64-bit modes and 64-bitmode."	^ self 		addInstruction: #ldmxcsr		operands: { aMemoryOperand }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!lea: aDestinationRegister with: aSourceMemory	"Load Effective Address	"	^ self 		addInstruction: #lea		operands: { aDestinationRegister . aSourceMemory }! !!AJx86Assembler methodsFor: 'convenience'!mov: assoc	"convenience"	^ self mov: assoc key to: assoc value! !!AJx86Assembler methodsFor: 'convenience' stamp: 'IgorStasenko 5/26/2012 15:14'!mov: src to: dest	"Ensure right src/dest order"		src = dest ifTrue: [ ^ self ]. "do not if source and dest are same "  		^ self mov: dest with: src! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!mov: aDestinationRegisterOrMemory with: aSource	"Move	Description-----------Copies the second operand (source operand) to the first operand(destination operand). The source operand can be an immediate value,general-purpose register, segment register, or memory location; thedestination register can be a general-purpose register, segmentregister, or memory location. Both operands must be the same size, whichcan be a byte, a word, a doubleword, or a quadword.The MOV instruction cannot be used to load the CS register. Attemptingto do so results in an invalid opcode exception (\#UD). To load the CSregister, use the far JMP, CALL, or RET instruction.If the destination operand is a segment register (DS, ES, FS, GS, orSS), the source operand must be a valid segment selector. In protectedmode, moving a segment selector into a segment register automaticallycauses the segment descriptor information associated with that segmentselector to be loaded into the hidden (shadow) part of the segmentregister. While loading this information, the segment selector andsegment descriptor information is validated (see the 'Operation'algorithm below). The segment descriptor data is obtained from the GDTor LDT entry for the specified segment selector.A NULL segment selector (values 0000-0003) can be loaded into the DS,ES, FS, and GS registers without causing a protection exception.However, any subsequent attempt to reference a segment whosecorresponding segment register is loaded with a NULL value causes ageneral protection exception (\#GP) and no memory reference occurs.Loading the SS register with a MOV instruction inhibits all interruptsuntil after the execution of the next instruction. This operation allowsa stack pointer to be loaded into the ESP register with the nextinstruction (MOV ESP, stack-pointer value) before an interrupt occurs1.Be aware that the LSS instruction offers a more efficient method ofloading the SS and ESP registers.When operating in 32-bit mode and moving data between a segment registerand a general-purpose register, the 32-bit IA-32 processors do notrequire the use of the 16-bit operand-size prefix (a byte with the value66H) with this instruction, but most assemblers will insert it if thestandard form of the instruction is used (for example, MOV DS, AX). Theprocessor will execute this instruction correctly, but it will usuallyrequire an extra clock. With most assemblers, using the instruction formMOV DS, EAX will avoid this unneeded 66H prefix. When the processorexecutes the instruction with a 32-bit general-purpose register, itassumes that the 16 least-significant bits of the general-purposeregister are the destination or source operand. If the register is adestination operand, the resulting value in the two high-order bytes ofthe register is implementation dependent. For the Pentium 4, Intel Xeon,and P6 family processors, the two high-order bytes are filled withzeros; for earlier 32-bit IA-32 processors, the two high order bytes areundefined.In 64-bit mode, the instruction's default operation size is 32 bits. Useof the REX.R prefix permits access to additional registers (R8-R15). Useof the REX.W prefix promotes operation to 64 bits. See the summary chartat the beginning of this section for encoding data and limits."	^ self 		addInstruction: #mov		operands: { aDestinationRegisterOrMemory . aSource }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!movPtr: aRegisterOrImmedate1 with: aRegisterOrImmedate2	"	"	^ self 		addInstruction: #movPtr		operands: { aRegisterOrImmedate1 . aRegisterOrImmedate2 }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!movapd: aRegisterOrMemory1 with: aRegisterOrMemory2	"Move Aligned Packed Double-FP Values	Pseudo Code-----------DEST = SRC;(* #GP if SRC or DEST unaligned memory operand *)Description-----------Moves a double quadword containing two packed double-precisionfloating-point values from the source operand (second operand) to thedestination operand (first operand). This instruction can be used toload an XMM register from a 128-bit memory location, to store thecontents of an XMM register into a 128-bit memory location, or to movedata between two XMM registers. When the source or destination operandis a memory operand, the operand must be aligned on a 16-byte boundaryor a general-protection exception (\#GP) will be generated.To move double-precision floating-point values to and from unalignedmemory locations, use the MOVUPD instruction.In 64-bit mode, use of the REX.R prefix permits this instruction toaccess additional registers (XMM8-XMM15)."	^ self 		addInstruction: #movapd		operands: { aRegisterOrMemory1 . aRegisterOrMemory2 }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!movaps: aRegisterOrMemory1 with: aRegisterOrMemory2	"Move Aligned Packed Single-FP Values	Pseudo Code-----------DEST = SRC;(* #GP if SRC or DEST unaligned memory operand *)Description-----------Moves a double quadword containing four packed single-precisionfloating-point values from the source operand (second operand) to thedestination operand (first operand). This instruction can be used toload an XMM register from a 128-bit memory location, to store thecontents of an XMM register into a 128-bit memory location, or to movedata between two XMM registers. When the source or destination operandis a memory operand, the operand must be aligned on a 16-byte boundaryor a general-protection exception (\#GP) is generated.To move packed single-precision floating-point values to or fromunaligned memory locations, use the MOVUPS instruction.In 64-bit mode, use of the REX.R prefix permits this instruction toaccess additional registers (XMM8-XMM15)."	^ self 		addInstruction: #movaps		operands: { aRegisterOrMemory1 . aRegisterOrMemory2 }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!movddup: aRegisterOrMemory1 with: aRegisterOrMemory2	"Move One Double-FP and Duplicate	Description-----------The linear address corresponds to the address of the least-significantbyte of the referenced memory data. When a memory address is indicated,the 8 bytes of data at memory location m64 are loaded. When theregister-register form of this operation is used, the lower half of the128-bit source register is duplicated and copied into the 128-bitdestination register.In 64-bit mode, use of the REX.R prefix permits this instruction toaccess additional registers (XMM8-XMM15)."	^ self 		addInstruction: #movddup		operands: { aRegisterOrMemory1 . aRegisterOrMemory2 }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!movdq2q: aRegisterOrMemory1 with: aRegisterOrMemory2	"Move Quadword from XMM to MMX Technology Register	Pseudo Code-----------DEST = SRC[63:0];Description-----------Moves the low quadword from the source operand (second operand) to thedestination operand (first operand). The source operand is an XMMregister and the destination operand is an MMX technology register.This instruction causes a transition from x87 FPU to MMX technologyoperation (that is, the x87 FPU top-of-stack pointer is set to 0 and thex87 FPU tag word is set to all 0s [valid]). If this instruction isexecuted while an x87 FPU floating-point exception is pending, theexception is handled before the MOVDQ2Q instruction is executed.In 64-bit mode, use of the REX.R prefix permits this instruction toaccess additional registers (XMM8-XMM15)."	^ self 		addInstruction: #movdq2q		operands: { aRegisterOrMemory1 . aRegisterOrMemory2 }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!movdqa: aRegisterOrMemory1 with: aRegisterOrMemory2	"Move Aligned Double Quadword	Pseudo Code-----------DEST = SRC;(* #GP if SRC or DEST unaligned memory operand *)Description-----------Moves a double quadword from the source operand (second operand) to thedestination operand (first operand). This instruction can be used toload an XMM register from a 128-bit memory location, to store thecontents of an XMM register into a 128-bit memory location, or to movedata between two XMM registers. When the source or destination operandis a memory operand, the operand must be aligned on a 16-byte boundaryor a general-protection exception (\#GP) will be generated.To move a double quadword to or from unaligned memory locations, use theMOVDQU instruction.In 64-bit mode, use of the REX.R prefix permits this instruction toaccess additional registers (XMM8-XMM15)."	^ self 		addInstruction: #movdqa		operands: { aRegisterOrMemory1 . aRegisterOrMemory2 }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!movdqu: aRegisterOrMemory1 with: aRegisterOrMemory2	"Move Unaligned Double Quadword	Pseudo Code-----------DEST = SRC;1. If alignment checking is enabled (CR0.AM = 1, RFLAGS.AC = 1, and CPL = 3), an alignment-check exception (#AC) may or may not be generated (depending on processor implementation) when the operand is not aligned on an 8-byte boundary.Description-----------Moves a double quadword from the source operand (second operand) to thedestination operand (first operand). This instruction can be used toload an XMM register from a 128-bit memory location, to store thecontents of an XMM register into a 128-bit memory location, or to movedata between two XMM registers. When the source or destination operandis a memory operand, the operand may be unaligned on a 16-byte boundarywithout causing a general-protection exception (\#GP) to be generated.1To move a double quadword to or from memory locations that are known tobe aligned on 16-byte boundaries, use the MOVDQA instruction.While executing in 16-bit addressing mode, a linear address for a128-bit data access that overlaps the end of a 16-bit segment is notallowed and is defined as reserved behavior. A specific processorimplementation may or may not generate a general-protection exception(\#GP) in this situation, and the address that spans the end of thesegment may or may not wrap around to the beginning of the segment.In 64-bit mode, use of the REX.R prefix permits this instruction toaccess additional registers (XMM8-XMM15)."	^ self 		addInstruction: #movdqu		operands: { aRegisterOrMemory1 . aRegisterOrMemory2 }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!movhlps: aRegisterOrMemory1 with: aRegisterOrMemory2	"Move Packed Single-FP Values High to Low	Pseudo Code-----------DEST[63:0] = SRC[127:64]; (* DEST[127:64] unchanged *)Description-----------Moves two packed single-precision floating-point values from the highquadword of the source operand (second operand) to the low quadword ofthe destination operand (first operand). The high quadword of thedestination operand is left unchanged.In 64-bit mode, use of the REX.R prefix permits this instruction toaccess additional registers (XMM8-XMM15)."	^ self 		addInstruction: #movhlps		operands: { aRegisterOrMemory1 . aRegisterOrMemory2 }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!movhpd: aRegisterOrMemory1 with: aRegisterOrMemory2	"Move High Packed Double-FP Value	Pseudo Code-----------(* MOVHPD instruction for memory to XMM move *)DEST[127:64] = SRC;(* DEST[63:0] unchanged *)(* MOVHPD instruction for XMM to memory move *)DEST = SRC[127:64];Description-----------Moves a double-precision floating-point value from the source operand(second operand) to the destination operand (first operand). The sourceand destination operands can be an XMM register or a 64-bit memorylocation. This instruction allows a double-precision floating-pointvalue to be moved to and from the high quadword of an XMM register andmemory. It cannot be used for register to register or memory to memorymoves. When the destination operand is an XMM register, the lowquad-word of the register remains unchanged.In 64-bit mode, use of the REX.R prefix permits this instruction toaccess additional registers (XMM8-XMM15)."	^ self 		addInstruction: #movhpd		operands: { aRegisterOrMemory1 . aRegisterOrMemory2 }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!movhps: aRegisterOrMemory1 with: aRegisterOrMemory2	"Move High Packed Single-FP Values	Pseudo Code-----------(* MOVHPS instruction for memory to XMM move *)DEST[127:64] = SRC;(* DEST[63:0] unchanged *)(* MOVHPS instruction for XMM to memory move *)DEST = SRC[127:64];Description-----------Moves two packed single-precision floating-point values from the sourceoperand (second operand) to the destination operand (first operand). Thesource and destination operands can be an XMM register or a 64-bitmemory location. This instruction allows two single-precisionfloating-point values to be moved to and from the high quadword of anXMM register and memory. It cannot be used for register to register ormemory to memory moves. When the destination operand is an XMM register,the low quadword of the register remains unchanged.In 64-bit mode, use of the REX.R prefix permits this instruction toaccess additional registers (XMM8-XMM15)."	^ self 		addInstruction: #movhps		operands: { aRegisterOrMemory1 . aRegisterOrMemory2 }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!movlhps: aRegisterOrMemory1 with: aRegisterOrMemory2	"Move Packed Single-FP Values Low to High	Pseudo Code-----------DEST[127:64] = SRC[63:0]; (* DEST[63:0] unchanged *)Description-----------Moves two packed single-precision floating-point values from the lowquadword of the source operand (second operand) to the high quadword ofthe destination operand (first operand). The low quadword of thedestination operand is left unchanged.In 64-bit mode, use of the REX.R prefix permits this instruction toaccess additional registers (XMM8-XMM15)."	^ self 		addInstruction: #movlhps		operands: { aRegisterOrMemory1 . aRegisterOrMemory2 }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!movlpd: aRegisterOrMemory1 with: aRegisterOrMemory2	"Move Low Packed Double-FP Value	Pseudo Code-----------(* MOVLPD instruction for memory to XMM move *)DEST[63:0] = SRC;(* DEST[127:64] unchanged *)(* MOVLPD instruction for XMM to memory move *)DEST = SRC[63:0];Description-----------Moves a double-precision floating-point value from the source operand(second operand) to the destination operand (first operand). The sourceand destination operands can be an XMM register or a 64-bit memorylocation. This instruction allows a double-precision floating-pointvalue to be moved to and from the low quadword of an XMM register andmemory. It cannot be used for register to register or memory to memorymoves. When the destination operand is an XMM register, the highquad-word of the register remains unchanged.In 64-bit mode, use of the REX.R prefix permits this instruction toaccess additional registers (XMM8-XMM15)."	^ self 		addInstruction: #movlpd		operands: { aRegisterOrMemory1 . aRegisterOrMemory2 }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!movlps: aRegisterOrMemory1 with: aRegisterOrMemory2	"Move Low Packed Single-FP Values	Pseudo Code-----------(* MOVLPD instruction for memory to XMM move *)DEST[63:0] = SRC;(* DEST[127:64] unchanged *)(* MOVLPD instruction for XMM to memory move *)DEST = SRC[63:0];Description-----------Moves two packed single-precision floating-point values from the sourceoperand (second operand) and the destination operand (first operand).The source and destination operands can be an XMM register or a 64-bitmemory location. This instruction allows two single-precisionfloating-point values to be moved to and from the low quadword of an XMMregister and memory. It cannot be used for register to register ormemory to memory moves. When the destination operand is an XMM register,the high quadword of the register remains unchanged.In 64-bit mode, use of the REX.R prefix permits this instruction toaccess additional registers (XMM8-XMM15)."	^ self 		addInstruction: #movlps		operands: { aRegisterOrMemory1 . aRegisterOrMemory2 }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!movmskpd: aRegisterOrMemory1 with: aRegisterOrMemory2	"Extract Packed Double-FP Sign Mask	Pseudo Code-----------DEST[0] = SRC[63];DEST[1] = SRC[127];IF DEST = r32    DEST[31:2] = ZeroExtend;ELSE    DEST[63:2] = ZeroExtend;FI;Description-----------Extracts the sign bits from the packed double-precision floating-pointvalues in the source operand (second operand), formats them into a 2-bitmask, and stores the mask in the destination operand (first operand).The source operand is an XMM register, and the destination operand is ageneral-purpose register. The mask is stored in the 2 low-order bits ofthe destination operand. Zero-extend the upper bits of the destination.In 64-bit mode, the instruction can access additional registers(XMM8-XMM15, R8-R15) when used with a REX.R prefix. The default operandsize is 64-bit in 64-bit mode."	^ self 		addInstruction: #movmskpd		operands: { aRegisterOrMemory1 . aRegisterOrMemory2 }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!movmskps: aRegisterOrMemory1 with: aRegisterOrMemory2	"Extract Packed Single-FP Sign Mask	Description-----------Extracts the sign bits from the packed single-precision floating-pointvalues in the source operand (second operand), formats them into a 4-bitmask, and stores the mask in the destination operand (first operand).The source operand is an XMM register, and the destination operand is ageneral-purpose register. The mask is stored in the 4 low-order bits ofthe destination operand. Zero-extend the upper bits of the destinationoperand.In 64-bit mode, the instruction can access additional registers(XMM8-XMM15, R8-R15) when used with a REX.R prefix. The default operandsize is 64-bit in 64-bit mode."	^ self 		addInstruction: #movmskps		operands: { aRegisterOrMemory1 . aRegisterOrMemory2 }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!movntdq: aRegisterOrMemory1 with: aRegisterOrMemory2	"Store Double Quadword Using Non-Temporal Hint	Pseudo Code-----------DEST = SRC;Description-----------Moves the double quadword in the source operand (second operand) to thedestination operand (first operand) using a non-temporal hint to preventcaching of the data during the write to memory. The source operand is anXMM register, which is assumed to contain integer data (packed bytes,words, doublewords, or quadwords). The destination operand is a 128-bitmemory location.The non-temporal hint is implemented by using a write combining (WC)memory type protocol when writing the data to memory. Using thisprotocol, the processor does not write the data into the cachehierarchy, nor does it fetch the corresponding cache line from memoryinto the cache hierarchy. The memory type of the region being written tocan override the non-temporal hint, if the memory address specified forthe non-temporal store is in an uncacheable (UC) or write protected (WP)memory region. For more information on non-temporal stores, see 'Cachingof Temporal vs. Non-Temporal Data' in Chapter 10 in theIntel64 andIA-32 Architectures Software Developer's Manual, Volume 1.Because the WC protocol uses a weakly-ordered memory consistency model,a fencing operation implemented with the SFENCE or MFENCE instructionshould be used in conjunction with MOVNTDQ instructions if multipleprocessors might use different memory types to read/write thedestination memory locations.In 64-bit mode, use of the REX.R prefix permits this instruction toaccess additional registers (XMM8-XMM15)."	^ self 		addInstruction: #movntdq		operands: { aRegisterOrMemory1 . aRegisterOrMemory2 }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!movntdqa: aRegisterOrMemory1 with: aRegisterOrMemory2	"Load Double Quadword Non-Temporal Aligned Hint	Pseudo Code-----------DST = SRC;Description-----------MOVNTDQA loads a double quadword from the source operand (secondoperand) to the destination operand (first operand) using a non-temporalhint. A processor implementation may make use of the non-temporal hintassociated with this instruction if the memory source is WC (writecombining) memory type. An implementation may also make use of thenon-temporal hint associated with this instruction if the memory sourceis WB (write back) memory type.A processor's implementation of the non-temporal hint does not overridethe effective memory type semantics, but the implementation of the hintis processor dependent. For example, a processor implementation maychoose to ignore the hint and process the instruction as a normal MOVDQAfor any memory type. Another implementation of the hint for WC memorytype may optimize data transfer throughput of WC reads. A thirdimplementation may optimize cache reads generated by MOVNTDQA on WBmemory type to reduce cache evictions.WC Streaming Load HintFor WC memory type in particular, the processor never appears to readthe data into the cache hierarchy. Instead, the non-temporal hint may beimplemented by loading a temporary internal buffer with the equivalentof an aligned cache line without filling this data to the cache. Anymemory-type aliased lines in the cache will be snooped and flushed.Subsequent MOVNTDQA reads to unread portions of the WC cache line willreceive data from the temporary internal buffer if data is available.The temporary internal buffer may be flushed by the processor at anytime for any reason, for example:-   A load operation other than a MOVNTDQA which references memory    already resident in a temporary internal buffer.-   A non-WC reference to memory already resident in a temporary    internal buffer.-   Interleaving of reads and writes to memory currently residing in a    single temporary internal buffer.-   Repeated MOVNTDQA loads of a particular 16-byte item in a streaming    line.-   Certain micro-architectural conditions including resource shortages,    detection of a mis-speculation condition, and various fault    conditionsThe memory type of the region being read can override the non-temporalhint, if the memory address specified for the non-temporal read is not aWC memory region. Information on non-temporal reads and writes can befound in Chapter 11, 'MemoryCache Control' ofIntel 64 and IA-32Architectures Software Developer's Manual,Volume 3A.Because the WC protocol uses a weakly-ordered memory consistency model,an MFENCE or locked instruction should be used in conjunction withMOVNTDQA instructions if multiple processors might reference the same WCmemory locations or in order to synchronize reads of a processor withwrites by other agents in the system. Because of the speculative natureof fetching due to MOVNTDQA, Streaming loads must not be used toreference memory addresses that are mapped to I/O devices having sideeffects or when reads to these devices are destructive. For additionalinformation on MOVNTDQA usages, see Section 12.10.3 in Chapter 12,'Programming with SSE3, SSSE3 and SSE4' ofIntel64 and IA-32Architectures SoftwareDeveloper's Manual, Volume 1."	^ self 		addInstruction: #movntdqa		operands: { aRegisterOrMemory1 . aRegisterOrMemory2 }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!movnti: aRegisterOrMemory1 with: aRegisterOrMemory2	"Store Doubleword Using Non-Temporal Hint	Pseudo Code-----------DEST = SRC;Description-----------Moves the doubleword integer in the source operand (second operand) tothe destination operand (first operand) using a non-temporal hint tominimize cache pollution during the write to memory. The source operandis a general-purpose register. The destination operand is a 32-bitmemory location.The non-temporal hint is implemented by using a write combining (WC)memory type protocol when writing the data to memory. Using thisprotocol, the processor does not write the data into the cachehierarchy, nor does it fetch the corresponding cache line from memoryinto the cache hierarchy. The memory type of the region being written tocan override the non-temporal hint, if the memory address specified forthe non-temporal store is in an uncacheable (UC) or write protected (WP)memory region. For more information on non-temporal stores, see 'Cachingof Temporal vs. Non-Temporal Data' in Chapter 10 in theIntel64 andIA-32 Architectures Software Developer's Manual, Volume 1.Because the WC protocol uses a weakly-ordered memory consistency model,a fencing operation implemented with the SFENCE or MFENCE instructionshould be used in conjunction with MOVNTI instructions if multipleprocessors might use different memory types to read/write thedestination memory locations.In 64-bit mode, the instruction's default operation size is 32 bits. Useof the REX.R prefix permits access to additional registers (R8-R15). Useof the REX.W prefix promotes operation to 64 bits. See the summary chartat the beginning of this section for encoding data and limits."	^ self 		addInstruction: #movnti		operands: { aRegisterOrMemory1 . aRegisterOrMemory2 }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!movntpd: aRegisterOrMemory1 with: aRegisterOrMemory2	"Store Packed Double-FP Values Using Non-Temporal Hint	Pseudo Code-----------DEST = SRC;Description-----------Moves the double quadword in the source operand (second operand) to thedestination operand (first operand) using a non-temporal hint tominimize cache pollution during the write to memory. The source operandis an XMM register, which is assumed to contain two packeddouble-precision floating-point values. The destination operand is a128-bit memory location.The non-temporal hint is implemented by using a write combining (WC)memory type protocol when writing the data to memory. Using thisprotocol, the processor does not write the data into the cachehierarchy, nor does it fetch the corresponding cache line from memoryinto the cache hierarchy. The memory type of the region being written tocan override the non-temporal hint, if the memory address specified forthe non-temporal store is in an uncacheable (UC) or write protected (WP)memory region. For more information on non-temporal stores, see 'Cachingof Temporal vs. Non-Temporal Data' in Chapter 10 in theIntel64 andIA-32 Architectures Software Developer's Manual, Volume 1.Because the WC protocol uses a weakly-ordered memory consistency model,a fencing operation implemented with the SFENCE or MFENCE instructionshould be used in conjunction with MOVNTPD instructions if multipleprocessors might use different memory types to read/write thedestination memory locations.In 64-bit mode, use of the REX.R prefix permits this instruction toaccess additional registers (XMM8-XMM15)."	^ self 		addInstruction: #movntpd		operands: { aRegisterOrMemory1 . aRegisterOrMemory2 }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!movntps: aRegisterOrMemory1 with: aRegisterOrMemory2	"Store Packed Single-FP Values Using Non-Temporal Hint	Pseudo Code-----------DEST = SRC;Description-----------Moves the double quadword in the source operand (second operand) to thedestination operand (first operand) using a non-temporal hint tominimize cache pollution during the write to memory. The source operandis an XMM register, which is assumed to contain four packedsingle-precision floating-point values. The destination operand is a128-bit memory location.The non-temporal hint is implemented by using a write combining (WC)memory type protocol when writing the data to memory. Using thisprotocol, the processor does not write the data into the cachehierarchy, nor does it fetch the corresponding cache line from memoryinto the cache hierarchy. The memory type of the region being written tocan override the non-temporal hint, if the memory address specified forthe non-temporal store is in an uncacheable (UC) or write protected (WP)memory region. For more information on non-temporal stores, see 'Cachingof Temporal vs. Non-Temporal Data' in Chapter 10 in theIntel64 andIA-32 Architectures Software Developer's Manual, Volume 1.Because the WC protocol uses a weakly-ordered memory consistency model,a fencing operation implemented with the SFENCE or MFENCE instructionshould be used in conjunction with MOVNTPS instructions if multipleprocessors might use different memory types to read/write thedestination memory locations.In 64-bit mode, use of the REX.R prefix permits this instruction toaccess additional registers (XMM8-XMM15)."	^ self 		addInstruction: #movntps		operands: { aRegisterOrMemory1 . aRegisterOrMemory2 }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!movntq: aRegisterOrMemory1 with: aRegisterOrMemory2	"Store of Quadword Using Non-Temporal Hint	Pseudo Code-----------DEST = SRC;Description-----------Moves the quadword in the source operand (second operand) to thedestination operand (first operand) using a non-temporal hint tominimize cache pollution during the write to memory. The source operandis an MMX technology register, which is assumed to contain packedinteger data (packed bytes, words, or doublewords). The destinationoperand is a 64-bit memory location.The non-temporal hint is implemented by using a write combining (WC)memory type protocol when writing the data to memory. Using thisprotocol, the processor does not write the data into the cachehierarchy, nor does it fetch the corresponding cache line from memoryinto the cache hierarchy. The memory type of the region being written tocan override the non-temporal hint, if the memory address specified forthe non-temporal store is in an uncacheable (UC) or write protected (WP)memory region. For more information on non-temporal stores, see 'Cachingof Temporal vs. Non-Temporal Data' in Chapter 10 in theIntel64 andIA-32 Architectures Software Developer's Manual, Volume 1.Because the WC protocol uses a weakly-ordered memory consistency model,a fencing operation implemented with the SFENCE or MFENCE instructionshould be used in conjunction with MOVNTQ instructions if multipleprocessors might use different memory types to read/write thedestination memory locations.This instruction's operation is the same in non-64-bit modes and 64-bitmode."	^ self 		addInstruction: #movntq		operands: { aRegisterOrMemory1 . aRegisterOrMemory2 }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!movss: aRegisterOrMemory1 with: aRegisterOrMemory2	"Move Scalar Single-FP Values	Description-----------Moves a scalar single-precision floating-point value from the sourceoperand (second operand) to the destination operand (first operand). Thesource and destination operands can be XMM registers or 32-bit memorylocations. This instruction can be used to move a single-precisionfloating-point value to and from the low doubleword of an XMM registerand a 32-bit memory location, or to move a single-precisionfloating-point value between the low doublewords of two XMM registers.The instruction cannot be used to transfer data between memorylocations.When the source and destination operands are XMM registers, the threehigh-order doublewords of the destination operand remain unchanged. Whenthe source operand is a memory location and destination operand is anXMM registers, the three high-order doublewords of the destinationoperand are cleared to all 0s.In 64-bit mode, use of the REX.R prefix permits this instruction toaccess additional registers (XMM8-XMM15)."	^ self 		addInstruction: #movss		operands: { aRegisterOrMemory1 . aRegisterOrMemory2 }! !!AJx86Assembler methodsFor: 'convenience'!movsx: src to: dest	"Ensure right src/dest order"	^ self movsx: dest with: src! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!movsx: aDestinationRegister with: aSourceRegisterOrMemory	"Move with Sign-Extension	"	^ self 		addInstruction: #movsx		operands: { aDestinationRegister . aSourceRegisterOrMemory }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!movsxd: aDestinationRegister with: aSourceRegisterOrMemory	"Move with Sign-Extension	"	^ self 		addInstruction: #movsxd		operands: { aDestinationRegister . aSourceRegisterOrMemory }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!movupd: aRegisterOrMemory1 with: aRegisterOrMemory2	"Move Unaligned Packed Double-FP Value	Pseudo Code-----------DEST = SRC;Description-----------Moves a double quadword containing two packed double-precisionfloating-point values from the source operand (second operand) to thedestination operand (first operand). This instruction can be used toload an XMM register from a 128-bit memory location, store the contentsof an XMM register into a 128-bit memory location, or move data betweentwo XMM registers. When the source or destination operand is a memoryoperand, the operand may be unaligned on a 16-byte boundary withoutcausing a general-protection exception (\#GP) to be generated.1To move double-precision floating-point values to and from memorylocations that are known to be aligned on 16-byte boundaries, use theMOVAPD instruction.While executing in 16-bit addressing mode, a linear address for a128-bit data access that overlaps the end of a 16-bit segment is notallowed and is defined as reserved behavior. A specific processorimplementation may or may not generate a general-protection exception(\#GP) in this situation, and the address that spans the end of thesegment may or may not wrap around to the beginning of the segment.In 64-bit mode, use of the REX.R prefix permits this instruction toaccess additional registers (XMM8-XMM15).1. If alignment checking is enabled (CR0.AM = 1, RFLAGS.AC = 1, and CPL= 3), an alignment-check exception (\#AC) may or may not be generated(depending on processor implementation) when the operand is not alignedon an 8-byte boundary."	^ self 		addInstruction: #movupd		operands: { aRegisterOrMemory1 . aRegisterOrMemory2 }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!movups: aRegisterOrMemory1 with: aRegisterOrMemory2	"Move Unaligned Packed Single-FP Values	Pseudo Code-----------DEST = SRC;Description-----------Moves a double quadword containing four packed single-precisionfloating-point values from the source operand (second operand) to thedestination operand (first operand). This instruction can be used toload an XMM register from a 128-bit memory location, store the contentsof an XMM register into a 128-bit memory location, or move data betweentwo XMM registers. When the source or destination operand is a memoryoperand, the operand may be unaligned on a 16-byte boundary withoutcausing a general-protection exception (\#GP) to be generated.1To move packed single-precision floating-point values to and from memorylocations that are known to be aligned on 16-byte boundaries, use theMOVAPS instruction.While executing in 16-bit addressing mode, a linear address for a128-bit data access that overlaps the end of a 16-bit segment is notallowed and is defined as reserved behavior. A specific processorimplementation may or may not generate a general-protection exception(\#GP) in this situation, and the address that spans the end of thesegment may or may not wrap around to the beginning of the segment.In 64-bit mode, use of the REX.R prefix permits this instruction toaccess additional registers (XMM8-XMM15).1. If alignment checking is enabled (CR0.AM = 1, RFLAGS.AC = 1, and CPL= 3), an alignment-check exception (\#AC) may or may not be generated(depending on processor implementation) when the operand is not alignedon an 8-byte boundary."	^ self 		addInstruction: #movups		operands: { aRegisterOrMemory1 . aRegisterOrMemory2 }! !!AJx86Assembler methodsFor: 'convenience'!movzx: src to: dest	"Ensure right src/dest order"	^ self movzx: dest with: src! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!movzx: aDestinationRegister with: aSourceRegisterOrMemory	"Move with Zero-Extend	Pseudo Code-----------DEST = ZeroExtend(SRC);Description-----------Copies the contents of the source operand (register or memory location)to the destination operand (register) and zero extends the value. Thesize of the converted value depends on the operand-size attribute.In 64-bit mode, the instruction's default operation size is 32 bits. Useof the REX.R prefix permits access to additional registers (R8-R15). Useof the REX.W prefix promotes operation to 64 bit operands. See thesummary chart at the beginning of this section for encoding data andlimits."	^ self 		addInstruction: #movzx		operands: { aDestinationRegister . aSourceRegisterOrMemory }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!mul: aDestination	"Unsigned Multiply	Description-----------Performs an unsigned multiplication of the first operand (destinationoperand) and the second operand (source operand) and stores the resultin the destination operand. The destination operand is an impliedoperand located in register AL, AX or EAX (depending on the size of theoperand); the source operand is located in a general-purpose register ora memory location. The action of this instruction and the location ofthe result depends on the opcode and the operand size as shown in thefollowing table.The result is stored in register AX, register pair DX:AX, or registerpair EDX:EAX (depending on the operand size), with the high-order bitsof the product contained in register AH, DX, or EDX, respectively. Ifthe high-order bits of the product are 0, the CF and OF flags arecleared; otherwise, the flags are set.In 64-bit mode, the instruction's default operation size is 32 bits. Useof the REX.R prefix permits access to additional registers (R8 - R15).Use of the REX.W prefix promotes operation to 64 bits.See the summary chart at the beginning of this section for encoding dataand limits.  Operand Size   Source 1   Source 2   Destination  -------------- ---------- ---------- -------------  Byte           AL         r/m8       AX  Word           AX         r/m16      DX:AX  Doubleword     EAX        r/m32      EDX:EAX  Quadword       RAX        r/m64      RDX:RAX  : MUL Results"	^ self 		addInstruction: #mul		operands: { aDestination }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!neg: aDestination	"Two's Complement Negation	Pseudo Code-----------IF DEST = 0    CF = 0;ELSE    CF = 1;FI;DEST = [- (DEST)]Description-----------Replaces the value of operand (the destination operand) with its two'scomplement. (This operation is equivalent to subtracting the operandfrom 0.) The destination operand is located in a general-purposeregister or a memory location.This instruction can be used with a LOCK prefix to allow the instructionto be executed atomically.In 64-bit mode, the instruction's default operation size is 32 bits.Using a REX prefix in the form of REX.R permits access to additionalregisters (R8-R15). Using a REX prefix in the form of REX.W promotesoperation to 64 bits. See the summary chart at the beginning of thissection for encoding data and limits."	^ self 		addInstruction: #neg		operands: { aDestination }! !!AJx86Assembler methodsFor: 'function calls'!newCdeclCall	"answer an instance of CallInfo"	^ stackManager newCdeclCall asm: self.! !!AJx86Assembler methodsFor: 'accessing' stamp: 'CamilloBruni 4/18/2012 15:26'!newInstruction	^ AJx86Instruction new! !!AJx86Assembler methodsFor: 'instruction list' stamp: 'IgorStasenko 8/13/2013 13:39'!newInstruction: name description: description operands: operands	"check if name is jump "	description isJump		ifTrue: [ ^ self newJumpInstruction: name description: description operands: operands ].	^ self newInstruction		name: name;		description: description;		operands: operands;		checkOperandsForConflict	"Cannot check that at construction stage. Some operands may not be resolved yet (as AJReserveTemp)		checkOperandsForConflict "! !!AJx86Assembler methodsFor: 'accessing' stamp: 'CamilloBruni 8/22/2012 14:26'!newJumpInstruction	^ AJx86JumpInstruction new! !!AJx86Assembler methodsFor: 'instruction list' stamp: 'MartinMcClure 2/9/2013 14:29'!newJumpInstruction: name description: description operands: operands	| jumpInstruction destination |	jumpInstruction := self newJumpInstruction		name: name;		description: description.	operands size ~= 1		ifTrue: [ Error signal: 'Jump instruction only takes one argument!!' ].	destination := operands first.	destination isString		ifTrue: [ ^ jumpInstruction label: (self labelNamed: destination) ].	destination isLabel		ifTrue: [ ^ jumpInstruction label: destination ].	^ self newInstruction		name: name;		description: description;		operands: operands;		checkOperandsForConflict! !!AJx86Assembler methodsFor: 'function calls'!newStdCall	^ stackManager newStdCall asm: self! !!AJx86Assembler methodsFor: 'options'!noStackFrame	stackManager noStackFrame.! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!not: aDestination	"One's Complement Negation	Pseudo Code-----------DEST = NOT DEST;Description-----------Performs a bitwise NOT operation (each 1 is set to 0, and each 0 is setto 1) on the destination operand and stores the result in thedestination operand location. The destination operand can be a registeror a memory location.This instruction can be used with a LOCK prefix to allow the instructionto be executed atomically.In 64-bit mode, the instruction's default operation size is 32 bits.Using a REX prefix in the form of REX.R permits access to additionalregisters (R8-R15). Using a REX prefix in the form of REX.W promotesoperation to 64 bits. See the summary chart at the beginning of thissection for encoding data and limits."	^ self 		addInstruction: #not		operands: { aDestination }! !!AJx86Assembler methodsFor: 'function calls'!noticePush: numBytes forCall: aCallInfo	self addInstruction: (AJCallArgument new size: numBytes; callInfo: aCallInfo ).! !!AJx86Assembler methodsFor: 'accessing'!numGPRegisters	"answer the total number of general-purpose registers for target platform"	^ 8! !!AJx86Assembler methodsFor: 'converting'!operand: anObject	anObject isInteger ifTrue: [		^ anObject asImm		].		anObject isString ifTrue: [		^ anObject		].		^ anObject! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!or: aRegisterOrMemoryOperand with: aSource	"Logical Inclusive OR	Pseudo Code-----------DEST = DEST OR SRC;Description-----------Performs a bitwise inclusive OR operation between the destination(first) and source (second) operands and stores the result in thedestination operand location. The source operand can be an immediate, aregister, or a memory location; the destination operand can be aregister or a memory location. (However, two memory operands cannot beused in one instruction.) Each bit of the result of the OR instructionis set to 0 if both corresponding bits of the first and second operandsare 0; otherwise, each bit is set to 1.This instruction can be used with a LOCK prefix to allow the instructionto be executed atomically.In 64-bit mode, the instruction's default operation size is 32 bits.Using a REX prefix in the form of REX.R permits access to additionalregisters (R8-R15). Using a REX prefix in the form of REX.W promotesoperation to 64 bits. See the summary chart at the beginning of thissection for encoding data and limits."	^ self 		addInstruction: #or		operands: { aRegisterOrMemoryOperand . aSource }! !!AJx86Assembler methodsFor: 'function calls'!performingCall: ci in: aBlock	ci 		asm: self;		alignmentInsertionPoint: last.	aBlock value: ci.	self callCleanup: ci.! !!AJx86Assembler methodsFor: 'accessing'!pointerSize	"the default pointer size in bytes on this CPU"	^ 4! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!pop: aRegisterOrMemoryDestination	"Pop a Value from the Stack	Description-----------Loads the value from the top of the stack to the location specified withthe destination operand (or explicit opcode) and then increments thestack pointer. The destination operand can be a general-purposeregister, memory location, or segment register.The address-size attribute of the stack segment determines the stackpointer size (16, 32, 64 bits) and the operand-size attribute of thecurrent code segment determines the amount the stack pointer isincremented (2, 4, 8 bytes).For example, if the address- and operand-size attributes are 32, the32-bit ESP register (stack pointer) is incremented by 4; if they are 16,the 16-bit SP register is incremented by 2. (The B flag in the stacksegment's segment descriptor determines the stack's address-sizeattribute, and the D flag in the current code segment's segmentdescriptor, along with prefixes, determines the operand-size attributeand also the address-size attribute of the destination operand.)If the destination operand is one of the segment registers DS, ES, FS,GS, or SS, the value loaded into the register must be a valid segmentselector. In protected mode, popping a segment selector into a segmentregister automatically causes the descriptor information associated withthat segment selector to be loaded into the hidden (shadow) part of thesegment register and causes the selector and the descriptor informationto be validated (see the 'Operation' section below).A NULL value (0000-0003) may be popped into the DS, ES, FS, or GSregister without causing a general protection fault. However, anysubsequent attempt to reference a segment whose corresponding segmentregister is loaded with a NULL value causes a general protectionexception (\#GP). In this situation, no memory reference occurs and thesaved value of the segment register is NULL.The POP instruction cannot pop a value into the CS register. To load theCS register from the stack, use the RET instruction.If the ESP register is used as a base register for addressing adestination operand in memory, the POP instruction computes theeffective address of the operand after it increments the ESP register.For the case of a 16-bit stack where ESP wraps to 0H as a result of thePOP instruction, the resulting location of the memory write isprocessor-family-specific.The POP ESP instruction increments the stack pointer (ESP) before dataat the old top of stack is written into the destination.A POP SS instruction inhibits all interrupts, including the NMIinterrupt, until after execution of the next instruction. This actionallows sequential execution of POP SS and MOV ESP, EBP instructionswithout the danger of having an invalid stack during an interrupt1.However, use of the LSS instruction is the preferred method of loadingthe SS and ESP registers.In 64-bit mode, using a REX prefix in the form of REX.R permits accessto additional registers (R8-R15). When in 64-bit mode, POPs using 32-bitoperands are not encodable and POPs to DS, ES, SS are not valid. See thesummary chart at the beginning of this section for encoding data andlimits."	^ self 		addInstruction: #pop		operands: { aRegisterOrMemoryDestination }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!popcnt: aRegister with: aSourceRegisterOrMemory	"Bit Population Count	Description-----------This instruction calculates of number of bits set to 1 in the secondoperand (source) and returns the count in the first operand (adestination register)."	^ self 		addInstruction: #popcnt		operands: { aRegister . aSourceRegisterOrMemory }! !!AJx86Assembler methodsFor: 'code generation'!prepareInstructions	"A final step before generating machine code: 	prepare instructions by injecting a stack alignment	and reifying jump labels.	Prepared instructions will contain machine code, ready for use	"	instructions := stackManager analyzeInstructions: instructions assembler: self.	instructions emitCodeAtOffset: 0 assembler: self.	^ instructions! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!push: aSource	"Push Word, Doubleword or Quadword Onto the Stack	"	^ self 		addInstruction: #push		operands: { aSource }! !!AJx86Assembler methodsFor: 'function calls'!pushArgument: anArgument forCall: call	| arg argSize |		arg := anArgument.	anArgument isInteger ifTrue: [		arg := anArgument asImm size: call defaultArgumentSize.	].		self addInstruction: (AJCallArgument new size: arg stackSize; callInfo: call ).		arg emitPushOnStack: self! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!rcl: aDestinationRegisterOrMemory with: aRegisterOrImmediate	"Rotate	"	^ self 		addInstruction: #rcl		operands: { aDestinationRegisterOrMemory . aRegisterOrImmediate }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!rcr: aDestinationRegisterOrMemory with: aRegisterOrImmediate	"Rotate	"	^ self 		addInstruction: #rcr		operands: { aDestinationRegisterOrMemory . aRegisterOrImmediate }! !!AJx86Assembler methodsFor: 'accessing' stamp: 'CamilloBruni 3/28/2012 14:43'!reg16: index	"answer one of 16bit general-purpose registers, based on index"	| code |		index < 0 ifTrue: [ self invalidRegisterIndex ].	(index >= self numGPRegisters) ifTrue: [ self invalidRegisterIndex ].	code := 16r10 + index.	^ AJx86Registers code: code! !!AJx86Assembler methodsFor: 'accessing' stamp: 'CamilloBruni 3/28/2012 14:43'!reg32: index	"answer one of 32bit general-purpose registers, based on index"	| code |		index < 0 ifTrue: [ self invalidRegisterIndex ].	(index >= self numGPRegisters) ifTrue: [ self invalidRegisterIndex ].	code := 16r20 + index.	^ AJx86Registers code: code! !!AJx86Assembler methodsFor: 'accessing' stamp: 'CamilloBruni 3/28/2012 14:43'!reg8: index	"answer one of 8bit general-purpose registers, based on index"		index < 0 ifTrue: [ self invalidRegisterIndex ].	(index >= self numGPRegisters) ifTrue: [ self invalidRegisterIndex ].	^ AJx86Registers code: index! !!AJx86Assembler methodsFor: 'accessing'!reg: index size: nBytes	nBytes = 1 ifTrue: [ ^ self reg8: index ].	nBytes = 2 ifTrue: [ ^ self reg16: index ].	nBytes = 4 ifTrue: [ ^ self reg32: index ].	nBytes = 8 ifTrue: [ ^ self reg64: index ].	self error: 'invalid register size'.! !!AJx86Assembler methodsFor: 'stack management'!releaseTemps: count	^ self addInstruction: (AJReleaseTemps new count: count).! !!AJx86Assembler methodsFor: 'instruction list'!replace: anInstruction with: otherInstructions	"replace a single instruction with one or more other instructions"		^ instructions := instructions replace: anInstruction with: otherInstructions.! !!AJx86Assembler methodsFor: 'stack management'!reserveExtraBytesOnStack: numBytes	^ stackManager reserveExtraBytesOnStack: numBytes ! !!AJx86Assembler methodsFor: 'stack management'!reserveTemp	^ self addInstruction: (AJReserveTemp new size: self wordSize).! !!AJx86Assembler methodsFor: 'initialize-release'!reset 	instructions := last := nil. 	labels := Dictionary new.	stackManager		ifNil: [stackManager := AJRoutineStackManager new.]		ifNotNil: #reset.			level := 0.	self addInstruction: AJRoutinePrologue new.  ! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!ret: anImmediate	"	"	^ self 		addInstruction: #ret		operands: { anImmediate }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!rol: aDestinationRegisterOrMemory with: aRegisterOrImmediate	"Rotate	"	^ self 		addInstruction: #rol		operands: { aDestinationRegisterOrMemory . aRegisterOrImmediate }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!ror: aDestinationRegisterOrMemory with: aRegisterOrImmediate	"Rotate	"	^ self 		addInstruction: #ror		operands: { aDestinationRegisterOrMemory . aRegisterOrImmediate }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!sal: aDestinationRegisterOrMemory with: aRegisterOrImmediate	"	"	^ self 		addInstruction: #sal		operands: { aDestinationRegisterOrMemory . aRegisterOrImmediate }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!sar: aDestinationRegisterOrMemory with: aRegisterOrImmediate	"Shift	"	^ self 		addInstruction: #sar		operands: { aDestinationRegisterOrMemory . aRegisterOrImmediate }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!sbb: aRegisterOrMemoryOperand with: aSource	"Integer Subtraction with Borrow	"	^ self 		addInstruction: #sbb		operands: { aRegisterOrMemoryOperand . aSource }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!shl: aDestinationRegisterOrMemory with: aRegisterOrImmediate	"Shift	"	^ self 		addInstruction: #shl		operands: { aDestinationRegisterOrMemory . aRegisterOrImmediate }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!shld: aDestinationRegisterOrMemory with: aSourceRegister with: aSourceRegisterOrImmediate	"Double Precision Shift Left	Description-----------The SHLD instruction is used for multi-precision shifts of 64 bits ormore.The instruction shifts the first operand (destination operand) to theleft the number of bits specified by the third operand (count operand).The second operand (source operand) provides bits to shift in from theright (starting with bit 0 of the destination operand).The destination operand can be a register or a memory location; thesource operand is a register. The count operand is an unsigned integerthat can be stored in an immediate byte or in the CL register. If thecount operand is CL, the shift count is the logical AND of CL and acount mask. In non-64-bit modes and default 64-bit mode; only bits 0through 4 of the count are used. This masks the count to a value between0 and 31. If a count is greater than the operand size, the result isundefined.If the count is 1 or greater, the CF flag is filled with the last bitshifted out of the destination operand. For a 1-bit shift, the OF flagis set if a sign change occurred; otherwise, it is cleared. If the countoperand is 0, flags are not affected.In 64-bit mode, the instruction's default operation size is 32 bits.Using a REX prefix in the form of REX.R permits access to additionalregisters (R8-R15). Using a REX prefix in the form of REX.W promotesoperation to 64 bits (upgrading the count mask to 6 bits). See thesummary chart at the beginning of this section for encoding data andlimits."	^ self 		addInstruction: #shld		operands: { aDestinationRegisterOrMemory . aSourceRegister . aSourceRegisterOrImmediate }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!shr: aDestinationRegisterOrMemory with: aRegisterOrImmediate	"Shift	"	^ self 		addInstruction: #shr		operands: { aDestinationRegisterOrMemory . aRegisterOrImmediate }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!shrd: aDestinationRegisterOrMemory with: aSourceRegister with: aSourceRegisterOrImmediate	"Double Precision Shift Right	Description-----------The SHRD instruction is useful for multi-precision shifts of 64 bits ormore.The instruction shifts the first operand (destination operand) to theright the number of bits specified by the third operand (count operand).The second operand (source operand) provides bits to shift in from theleft (starting with the most significant bit of the destinationoperand).The destination operand can be a register or a memory location; thesource operand is a register. The count operand is an unsigned integerthat can be stored in an immediate byte or the CL register. If the countoperand is CL, the shift count is the logical AND of CL and a countmask. In non-64-bit modes and default 64-bit mode, the width of thecount mask is 5 bits. Only bits 0 through 4 of the count register areused (masking the count to a value between 0 and 31). If the count isgreater than the operand size, the result is undefined.If the count is 1 or greater, the CF flag is filled with the last bitshifted out of the destination operand. For a 1-bit shift, the OF flagis set if a sign change occurred; otherwise, it is cleared. If the countoperand is 0, flags are not affected.In 64-bit mode, the instruction's default operation size is 32 bits.Using a REX prefix in the form of REX.R permits access to additionalregisters (R8-R15). Using a REX prefix in the form of REX.W promotesoperation to 64 bits (upgrading the count mask to 6 bits). See thesummary chart at the beginning of this section for encoding data andlimits."	^ self 		addInstruction: #shrd		operands: { aDestinationRegisterOrMemory . aSourceRegister . aSourceRegisterOrImmediate }! !!AJx86Assembler methodsFor: 'register'!sourceIndex	^ self is32BitMode ifTrue: [ RSI ] ifFalse: [ SI ]! !!AJx86Assembler methodsFor: 'stack management' stamp: 'MartinMcClure 2/9/2013 14:25'!stackFrameValueAtOffset: offset	^ EBP ptr32 - offset! !!AJx86Assembler methodsFor: 'accessing'!stackManager: aStackManager	stackManager := aStackManager ! !!AJx86Assembler methodsFor: 'register' stamp: 'CamilloBruni 1/10/2013 18:58'!stackPointer	^ self is32 ifTrue: [ ESP ] ifFalse: [ RSP ]! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!stmxcsr: aMemoryOperand	"Store MXCSR Register State	Pseudo Code-----------m32 = MXCSR;Description-----------Stores the contents of the MXCSR control and status register to thedestination operand. The destination operand is a 32-bit memorylocation. The reserved bits in the MXCSR register are stored as 0s.This instruction's operation is the same in non-64-bit modes and 64-bitmode."	^ self 		addInstruction: #stmxcsr		operands: { aMemoryOperand }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!sub: aRegisterOrMemoryOperand with: aSource	"Subtract	Pseudo Code-----------DEST = (DEST - SRC);Description-----------Subtracts the second operand (source operand) from the first operand(destination operand) and stores the result in the destination operand.The destination operand can be a register or a memory location; thesource operand can be an immediate, register, or memory location.(However, two memory operands cannot be used in one instruction.) Whenan immediate value is used as an operand, it is sign-extended to thelength of the destination operand format.The SUB instruction performs integer subtraction. It evaluates theresult for both signed and unsigned integer operands and sets the OF andCF flags to indicate an overflow in the signed or unsigned result,respectively. The SF flag indicates the sign of the signed result.In 64-bit mode, the instruction's default operation size is 32 bits.Using a REX prefix in the form of REX.R permits access to additionalregisters (R8-R15). Using a REX prefix in the form of REX.W promotesoperation to 64 bits. See the summary chart at the beginning of thissection for encoding data and limits.This instruction can be used with a LOCK prefix to allow the instructionto be executed atomically."	^ self 		addInstruction: #sub		operands: { aRegisterOrMemoryOperand . aSource }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'MartinMcClure 12/15/2012 13:37'!syscall	"SYSCALL saves the RIP of the instruction following SYSCALL to RCX and loads a newRIP from the IA32_LSTAR (64-bit mode). Upon return, SYSRET copies the valuesaved in RCX to the RIP.SYSCALL saves RFLAGS (lower 32 bit only) in R11. It then masks RFLAGS with anOS-defined value using the IA32_FMASK (MSR C000_0084). The actual mask valueused by the OS is the complement of the value written to the IA32_FMASK MSR.None of the bits in RFLAGS are automatically cleared (except for RF). SYSRETrestores RFLAGS from R11 (the lower 32 bits only).Software should not alter the CS or SS descriptors in a manner that violates thefollowing assumptions made by SYSCALL/SYSRET:* The CS and SS base and limit remain the same for all processes, including theoperating system (the base is 0H and the limit is 0FFFFFFFFH).* The CS of the SYSCALL target has a privilege level of 0.* The CS of the SYSRET target has a privilege level of 3.SYSCALL/SYSRET do not check for violations of these assumptions.OperationIF (CS.L ~= 1 ) or (IA32_EFER.LMA ~= 1) or (IA32_EFER.SCE ~= 1)(* Not in 64-Bit Mode or SYSCALL/SYSRET not enabled in IA32_EFER *)  THEN #UD; FI;RCX := RIP;RIP := LSTAR_MSR;R11 := EFLAGS;EFLAGS := (EFLAGS MASKED BY IA32_FMASK);CPL := 0;CS(SEL) := IA32_STAR_MSR[47:32];CS(DPL) := 0;CS(BASE) := 0;CS(LIMIT) := 0xFFFFF;CS(GRANULAR) := 1;SS(SEL) := IA32_STAR_MSR[47:32] + 8;SS(DPL) := 0;SS(BASE) := 0;SS(LIMIT) := 0xFFFFF;SS(GRANULAR) := 1; SS(LIMIT) := 0xFFFFF;SS(GRANULAR) := 1;"	^ self addInstruction: #syscall operands: #()! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!test: aRegisterOrMemory with: aRegisterOrImmediate	"Logical Compare	Description-----------Computes the bit-wise logical AND of first operand (source 1 operand)and the second operand (source 2 operand) and sets the SF, ZF, and PFstatus flags according to the result. The result is then discarded.In 64-bit mode, using a REX prefix in the form of REX.R permits accessto additional registers (R8-R15). Using a REX prefix in the form ofREX.W promotes operation to 64 bits. See the summary chart at thebeginning of this section for encoding data and limits."	^ self 		addInstruction: #test		operands: { aRegisterOrMemory . aRegisterOrImmediate }! !!AJx86Assembler methodsFor: 'accessing'!undefinedLabels	"answer a collection of labels, which having no defined position "	| lbls |	lbls := OrderedCollection new.		labels keysAndValuesDo: [:key :value |		value ifNil: [ lbls add: key]		].	^ lbls! !!AJx86Assembler methodsFor: 'labels'!uniqueLabelName: aName	^ self labelNamed: aName, labels size asString! !!AJx86Assembler methodsFor: 'accessing'!wordSize	^ 4! !!AJx86Assembler methodsFor: 'debugging' stamp: 'IgorStasenko 5/28/2012 02:25'!writeCodeToFile: aFileName	aFileName asReference asReference delete writeStreamDo: [:s|		s nextPutAll: self bytes		]! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!xadd: aDestinationRegisterOrMemory with: aSourceRegister	"Exchange and Add	Pseudo Code-----------TEMP = SRC + DEST;SRC = DEST;DEST = TEMP;Description-----------Exchanges the first operand (destination operand) with the secondoperand (source operand), then loads the sum of the two values into thedestination operand. The destination operand can be a register or amemory location; the source operand is a register.In 64-bit mode, the instruction's default operation size is 32 bits.Using a REX prefix in the form of REX.R permits access to additionalregisters (R8-R15). Using a REX prefix in the form of REX.W promotesoperation to 64 bits. See the summary chart at the beginning of thissection for encoding data and limits.This instruction can be used with a LOCK prefix to allow the instructionto be executed atomically."	^ self 		addInstruction: #xadd		operands: { aDestinationRegisterOrMemory . aSourceRegister }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!xchg: aDestinationRegisterOrMemory with: aSourceRegister	"Exchange Register/Memory with Register	Pseudo Code-----------TEMP = DEST;DEST = SRC;SRC = TEMP;Description-----------Exchanges the contents of the destination (first) and source (second)operands. The operands can be two general-purpose registers or aregister and a memory location. If a memory operand is referenced, theprocessor's locking protocol is automatically implemented for theduration of the exchange operation, regardless of the presence orabsence of the LOCK prefix or of the value of the IOPL. (See the LOCKprefix description in this chapter for more information on the lockingprotocol.)This instruction is useful for implementing semaphores or similar datastructures for process synchronization. (See 'Bus Locking' in Chapter 8of theIntel 64 and IA-32Architectures Software Developer's Manual,Volume 3A, for more information on bus locking.)The XCHG instruction can also be used instead of the BSWAP instructionfor 16-bit operands.In 64-bit mode, the instruction's default operation size is 32 bits.Using a REX prefix in the form of REX.R permits access to additionalregisters (R8-R15). Using a REX prefix in the form of REX.W promotesoperation to 64 bits. See the summary chart at the beginning of thissection for encoding data and limits."	^ self 		addInstruction: #xchg		operands: { aDestinationRegisterOrMemory . aSourceRegister }! !!AJx86Assembler methodsFor: 'instructions generated' stamp: 'CamilloBruni 7/17/2012 13:38'!xor: aRegisterOrMemoryOperand with: aSource	"Logical Exclusive OR	Pseudo Code-----------DEST = DEST XOR SRC;Description-----------Performs a bitwise exclusive OR (XOR) operation on the destination(first) and source (second) operands and stores the result in thedestination operand location. The source operand can be an immediate, aregister, or a memory location; the destination operand can be aregister or a memory location. (However, two memory operands cannot beused in one instruction.) Each bit of the result is 1 if thecorresponding bits of the operands are different; each bit is 0 if thecorresponding bits are the same.This instruction can be used with a LOCK prefix to allow the instructionto be executed atomically.In 64-bit mode, using a REX prefix in the form of REX.R permits accessto additional registers (R8-R15). Using a REX prefix in the form ofREX.W promotes operation to 64 bits. See the summary chart at thebeginning of this section for encoding data and limits."	^ self 		addInstruction: #xor		operands: { aRegisterOrMemoryOperand . aSource }! !!AJx64RipRegister methodsFor: 'converting'!as16	^ AJx86Registers at: #IP! !!AJx64RipRegister methodsFor: 'converting'!as32	^ AJx86Registers at: #EIP! !!AJx64RipRegister methodsFor: 'converting'!as64	^ AJx86Registers at: #RIP! !!AJx64RipRegister methodsFor: 'converting'!as8		self error: 'No 8bit register available for instruction pointer relative addressing'! !!AJx64RipRegister methodsFor: 'accessing'!code	self ripAccessError! !!AJx64RipRegister methodsFor: 'printing' stamp: 'CamilloBruni 7/17/2012 11:08'!descriptionOn: s	s nextPutAll: 'A '; print: self size * 8; nextPutAll: 'bit instruction pointer register'.! !!AJx64RipRegister methodsFor: 'accessing'!index	self ripAccessError! !!AJx64RipRegister methodsFor: 'accessing' stamp: 'CamilloBruni 7/17/2012 12:48'!influencingRegisters	self is16		ifFalse: [ ^ self as16 influencingRegisters ].	^ { self as16. self as32. self as64 }! !!AJx64RipRegister methodsFor: 'testing'!isGeneralPurpose	^ false! !!AJx64RipRegister methodsFor: 'testing'!isRip	^ true! !!AJx64RipRegister methodsFor: 'testing'!isUpperBank	^ false! !!AJx64RipRegister methodsFor: 'testing' stamp: 'CamilloBruni 7/17/2012 11:01'!isX86 	^ false! !!AJx64RipRegister methodsFor: 'error'!ripAccessError	self error: 'RIP register ', self name, ' cannot be used only for relative addressing'! !!AJx86GPRegister methodsFor: 'converting' stamp: 'MartinMcClure 1/30/2013 21:42'!as16	^ self isHighByte		ifTrue: [ self asLowByte as16 ]		ifFalse: [ 			AJx86Registers				generalPurposeWithIndex: self index				size: 2				requiresRex: self index > 7				prohibitsRex: false ]! !!AJx86GPRegister methodsFor: 'converting' stamp: 'MartinMcClure 1/30/2013 21:43'!as32	^ self isHighByte		ifTrue: [ self asLowByte as32 ]		ifFalse: [ 			AJx86Registers				generalPurposeWithIndex: self index				size: 4				requiresRex: self index > 7				prohibitsRex: false ]! !!AJx86GPRegister methodsFor: 'converting' stamp: 'MartinMcClure 1/30/2013 21:44'!as64	^ self isHighByte		ifTrue: [ self asLowByte as64 ]		ifFalse: [ 			AJx86Registers				generalPurposeWithIndex: self index				size: 8				requiresRex: self index > 7				prohibitsRex: false ]! !!AJx86GPRegister methodsFor: 'converting' stamp: 'MartinMcClure 1/30/2013 21:40'!as8	"8-bit low-byte registers require REX if they have a high index (>7), or if they are one of BPL, SIL, DIL, SPL (indices 4-7).	The only way to get AH, BH, CH, or DH out of this method is to send it to one of those registers."	^ self is8		ifTrue: [ self ]		ifFalse: [ 			AJx86Registers				generalPurposeWithIndex: self index				size: 1				requiresRex: self index > 3				prohibitsRex: false ]! !!AJx86GPRegister methodsFor: 'converting' stamp: 'MartinMcClure 1/30/2013 21:53'!asHighByte	self isHighByte		ifTrue: [ ^ self ].	self isLowByte		ifFalse: [ Error signal: 'Can only convert AH, BH, CH, or DH to high byte' ].	^ AJx86Registers		generalPurposeWithIndex: self index + 2r100		size: 1		requiresRex: false		prohibitsRex: true! !!AJx86GPRegister methodsFor: 'converting' stamp: 'MartinMcClure 1/30/2013 21:46'!asLowByte	self isLowByte		ifTrue: [ ^ self ].	self isHighByte		ifFalse: [ Error signal: 'Can only convert high byte 8bit register to low byte' ].	^ AJx86Registers		generalPurposeWithIndex: self index - 2r100		size: 1		requiresRex: false		prohibitsRex: false! !!AJx86GPRegister methodsFor: 'accessing' stamp: 'CamilloBruni 7/17/2012 11:07'!descriptionOn: s	s nextPutAll: 'A '; print: self size * 8; nextPutAll: 'bit general purpose register'.! !!AJx86GPRegister methodsFor: 'emitting'!emitModRM: emitter code: rCode immSize: immSize	"Receiver is register, hence mod = 3 	immSize is ignored"	^ emitter emitMod: 3 reg: rCode rm: self code! !!AJx86GPRegister methodsFor: 'testing'!isGeneralPurpose	^ true! !!AJx86GPRegister methodsFor: 'testing' stamp: 'MartinMcClure 1/30/2013 21:33'!isHighByte	"return true for 8bit high-byte registers (AH - DH)"	^ self prohibitsRex! !!AJx86GPRegister methodsFor: 'testing' stamp: 'MartinMcClure 1/30/2013 21:55'!isLowByte	"return true for 8bit low-byte register (AL - DL)"	"Note that this does *not* answer true for all byte registers -- send #is8 for that."	^ self code <= 3! !!AJx86GPRegister methodsFor: 'printing' stamp: 'MartinMcClure 1/1/2013 18:55'!printAsMemBaseOn: aStream	aStream nextPutAll: self registerName ! !!AJx86GPRegister methodsFor: 'printing'!printOn: aStream		aStream nextPutAll: self registerName ! !!AJx86GPRegister methodsFor: 'converting'!ptr	"turn receiver into a memory operand with receiver as base"		^ AJMem new base: self! !!AJx86GPRegister methodsFor: 'accessing' stamp: 'CamilloBruni 3/20/2012 18:48'!registerName 	^ name asString.! !!AJx86GPRegister methodsFor: 'accessing'!stackSize	^ self size! !!AJx64InstructionDescription methodsFor: 'code emitting' stamp: 'MartinMcClure 1/30/2013 22:14'!emitalu: emitter operand1: op1 operand2: op2 operand3: op3	| opCode opReg |	opCode := opCode1.	opReg := opCodeR.	" Mem <- Reg "	(op1 isMem and: [ op2 isReg ])		ifTrue: [ 			^ emitter				emitX86RM: opCode + op2 isRegTypeGPB not asBit				size: op2 size				regOrCode: op2				rm: op1 ].	"Reg <- Reg|Mem"	(op1 isReg and: [ op2 isRegMem ])		ifTrue: [ 			(op2 isReg and: [ op1 size ~= op2 size ])				ifTrue: [ self invalidInstruction ].			^ emitter				emitX86RM: opCode + 2 + op1 isRegTypeGPB not asBit				size: op1 size				regOrCode: op1				rm: op2 ].	op2 isImm		ifFalse: [ self invalidInstruction ].	" AL, AX, EAX, RAX register shortcuts"	(op1 isRegIndex: 0)		ifTrue: [ 			op1 is16				ifTrue: [ emitter emitByte: 16r66	" 16 bit " ].			op1 is64				ifTrue: [ emitter emitByte: 16r48	" REX.W" ].			emitter emitByte: (opReg << 3 bitOr: 16r04 + op1 isRegTypeGPB not asBit).			^ emitter emitImmediate: op2 size: (op1 size min: 4) ].	"short constant"	op2 isInt8		ifTrue: [ 			| szBits |			szBits := op1 size = 1				ifTrue: [ 0 ]				ifFalse: [ 3 ].			emitter				emitX86RM: opCode2 + szBits				size: op1 size				regOrCode: opReg				rm: op1				immSize: 1.			^ emitter emitImmediate: op2 size: 1 ].	op1 isRegMem		ifTrue: [ 			| immSize szBits |			immSize := op2 isInt8				ifTrue: [ 1 ]				ifFalse: [ op1 size min: 4 ].			szBits := op1 size ~= 1				ifTrue: [ 					immSize ~= 1						ifTrue: [ 1 ]						ifFalse: [ 3 ] ]				ifFalse: [ 0 ].			emitter				emitX86RM: opCode2 + szBits				size: op1 size				regOrCode: opReg				rm: op1				immSize: immSize.			^ emitter emitImmediate: op2 size: immSize ].	self invalidInstruction! !!AJx64InstructionDescription methodsFor: 'code emitting'!emitbswap: emitter operand1: op1 operand2: op2 operand3: op3	op1 isReg ifTrue: [		emitter emitRexForSingleOperand: op1.		emitter emitByte: 16r0F.		^ emitter emitModR: 1 r: op1 code	].	self invalidInstruction.! !!AJx64InstructionDescription methodsFor: 'code emitting' stamp: 'CamilloBruni 4/17/2012 18:43'!emitcall: emitter operand1: op1 operand2: op2 operand3: op3	(op1 isReg and: [ op1 is64 and: [ op1 isUpperBank not ]]) ifTrue: [ 		"shortcut"		emitter emitByte: 16rFF. 		op1 emitModRM: emitter code: 2 immSize: 4.		^ self].		(op1 isMem and: [op1 hasBase and: [ op1 base is64 and: [ op1 base isUpperBank not ]]]) ifTrue: [ 		"shortcut"		emitter emitByte: 16rFF. 		op1 emitModRM: emitter code: 2 immSize: 4.		^ self].		(op1 isMem or: [ op1 isReg and: [ op1 is64 ] ]) ifTrue: [		^ emitter emitX86RM:  16rFF			size: 4			regOrCode: 2  			rm: op1  	].	op1 isImm ifTrue: [ "call by relative offset, you should be really sure what you're' doing"		emitter emitByte: 16rE8. 		op1 emitUsing: emitter size: 4.		^ self.		].		op1 isLabel ifTrue: [		emitter emitByte: 16rE8. 		emitter emitDisplacement: op1 inlinedDisp: -4.		^ self	].	self invalidInstruction.! !!AJx64InstructionDescription methodsFor: 'code emitting' stamp: 'IgorStasenko 5/28/2012 03:01'!emitmov: emitter operand1: dst operand2: src operand3: op3		src isReg & dst isReg ifTrue: [		self assert: (src isRegTypeGPB | src isRegTypeGPW | src isRegTypeGPD | src isRegTypeGPQ ).		]. 		" reg <- mem "	dst isReg & src isRegMem ifTrue: [		self assert: (dst isRegTypeGPB | dst isRegTypeGPW | dst isRegTypeGPD | dst isRegTypeGPQ ).		src isMem			ifTrue: [ (src base notNil and: [ src base is64 not ])				ifTrue: [ Error signal: 'use a 64bit base register instead of ', src base asString, '(', (src base size * 8) asString, 'bit) for memory access on a 64bit CPU' ]]			ifFalse:[ (src size = dst size) 				ifFalse: [ Error signal: 'source ',src asString,' and destination ',dst asString,' need to have the same size' ]].		^ emitter emitX86RM: 16r0000008A + dst isRegTypeGPB not asBit 			size:  dst size 			regOrCode:  dst 			rm: src		].	" reg <- imm "	dst isReg & src isImm ifTrue: [		| immSize |		immSize := dst size.		"Optimize instruction size by using 32 bit immediate if value can fit to it"		emitter is64BitMode & immSize = 8 & src isInt32 & (src relocMode == #RelocNone) ifTrue: [			 emitter emitX86RM: 16rC7				size: dst size				regOrCode: 0 rm: dst.	        immSize := 4		] ifFalse: [			emitter emitX86Inl: (immSize=1 ifTrue: [16rB0] ifFalse: [16rB8]) reg: dst.		].		^ emitter emitImmediate: src size: immSize	].	"mem <- reg"	dst isMem & src isReg ifTrue: [		self assert: (src isRegTypeGPB | src isRegTypeGPW | src isRegTypeGPD | src isRegTypeGPQ ).		^ emitter emitX86RM: 16r88 + src isRegTypeGPB not asBit			size: src size regOrCode: src rm: dst	].	"mem <- imm"	dst isMem & src isImm ifTrue: [ | immSize |				immSize := dst size <= 4 ifTrue: [ dst size ] ifFalse: [4].				emitter emitX86RM: 16rC6 + ((dst size = 1) not) asBit			size: dst size 			regOrCode:  0 rm:  dst 			immSize: immSize.				^ emitter emitImmediate: src size: immSize	].	self invalidInstruction ! !!AJx64InstructionDescription methodsFor: 'code emitting'!emitmovPtr: emitter operand1: op1 operand2: op2 operand3: op3	| reg imm opCode |	(op1 isReg & op2 isImm) | (op1 isImm & op2 isReg) ifFalse: [		self invalidInstruction ].		opCode := op1 isReg 		ifTrue: [reg := op1. imm := op2. 16rA0] 		ifFalse: [reg := op2. imm := op1. 16rA2].		reg index ~= 0 ifTrue: [ self invalidInstruction ].	reg isRegTypeGPW ifTrue: [ emitter emitByte: 16r66 ].	emitter emitRexForSingleOperand: reg.	emitter emitByte: opCode + (reg size ~=1) asBit.	emitter emitImmediate: imm size: reg size! !!AJx64InstructionDescription methodsFor: 'code emitting' stamp: 'MartinMcClure 1/30/2013 22:13'!emitmovSxZx: emitter operand1: dst operand2: src operand3: op3	dst isReg & src isRegMem		ifFalse: [ self invalidInstruction ].	src size >= dst size		ifTrue: [ self invalidInstruction ].	dst isGeneralPurpose		ifFalse: [ self invalidInstruction ].	src is16		ifTrue: [ 			^ emitter				emitX86RM: opCode1 + 1				size: dst size				regOrCode: dst				rm: src ].	src is32		ifTrue: [ self invalidInstruction ].	"64 bit source"	emitter		emitX86RM: opCode1		size: dst size		regOrCode: dst		rm: src! !!AJx64InstructionDescription methodsFor: 'code emitting'!emitpop: emitter operand1: op1 operand2: op2 operand3: op3	op1 isReg ifTrue: [		self assert: op1 isGeneralPurpose.		(op1 is32 or: [ op1 is8 ]) 			ifTrue: [ Error signal: 'invalid register ', op1 name, '. push/pop requires 64bit/16bit reg in 64bit mode'].		^ emitter emitX86Inl: opCode1 reg: op1 withRex: op1 isUpperBank.		].		op1 isMem ifFalse: [ self invalidInstruction ].	emitter emitX86RM: opCode2 size: op1 size regOrCode: opCodeR rm: op1! !!AJx86InstructionDescription class methodsFor: 'initialization' stamp: 'CamilloBruni 4/17/2012 17:39'!at: instructionName		^ instructions 		at: instructionName ! !!AJx86InstructionDescription class methodsFor: 'testing'!checkInstructionsIntegrity	" self checkInstructionsIntegrity"	| data |		data := self instructionData.		data do: [:dt | | instr |				instr := instructions at: dt first.		self assert: [			(instr name = (dt at: 1)) &			(instr group = (dt at: 2)) &			(instr o1Flags = (dt at:3)) &			(instr o2Flags = (dt at:4)) &			(instr opCodeR = (dt at:5)) &			(instr opCode1 = (dt at:6)) &			(instr opCode2 = (dt at:7)) 		].	].! !!AJx86InstructionDescription class methodsFor: 'instance creation' stamp: 'CamilloBruni 4/13/2012 14:30'!fromArray: aSpecArray	^ self basicNew		fromArray: aSpecArray! !!AJx86InstructionDescription class methodsFor: 'initialization' stamp: 'CamilloBruni 4/13/2012 14:47'!initInstructions	" self initInstructions "	| data |	instructions := IdentityDictionary new.	data := OrderedCollection new.	data addAll: self instructionData;		addAll: self instructionsCDQ;		addAll: self instructionsOther.		data do: [:dt | 		instructions at: dt first put: (self fromArray: dt) ].		^ instructions! !!AJx86InstructionDescription class methodsFor: 'initialization'!initialize	self initInstructions.! !!AJx86InstructionDescription class methodsFor: 'initialization' stamp: 'MartinMcClure 12/15/2012 13:35'!instructionData^ #((#adc #alu 0 0 "R" 2 "C1" 16r00000010 "C2" 16r00000080 )(#add #alu 0 0 "R" 0 0 "C2" 16r00000080 )(#addpd #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r66000F58 0 )(#addps #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r00000F58 0 )(#addsd #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16rF2000F58 0 )(#addss #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16rF3000F58 0 )(#addsubpd #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r66000FD0 0 )(#addsubps #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16rF2000FD0 0 )(#amdprefetch #mem "op1" 2r1000000 0 "R" 0 "C1" 16r00000F0D 0 )(#amdprefetchw #mem "op1" 2r1000000 0 "R" 1 "C1" 16r00000F0D 0 )(#and #alu 0 0 "R" 4 "C1" 16r00000020 "C2" 16r00000080 )(#andnpd #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r66000F55 0 )(#andnps #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r00000F55 0 )(#andpd #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r66000F54 0 )(#andps #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r00000F54 0 )(#blendpd #mmuRmImm8 "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r660F3A0D 0 )(#blendps #mmuRmImm8 "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r660F3A0C 0 )(#blendvpd #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r660F3815 0 )(#blendvps #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r660F3814 0 )(#bsf #rrm 0 0 "R" 0 "C1" 16r00000FBC 0 )(#bsr #rrm 0 0 "R" 0 "C1" 16r00000FBD 0 )(#bswap #bswap 0 0 "R" 0 0 0 )(#bt #bt "op1" 2r1001110 "op2" 2r10001110 "R" 4 "C1" 16r00000FA3 "C2" 16r00000FBA )(#btc #bt "op1" 2r1001110 "op2" 2r10001110 "R" 7 "C1" 16r00000FBB "C2" 16r00000FBA )(#btr #bt "op1" 2r1001110 "op2" 2r10001110 "R" 6 "C1" 16r00000FB3 "C2" 16r00000FBA )(#bts #bt "op1" 2r1001110 "op2" 2r10001110 "R" 5 "C1" 16r00000FAB "C2" 16r00000FBA )(#call #call 0 0 "R" 0 0 0 )(#clc #emit 0 0 "R" 0 "C1" 16r000000F8 0 )(#cld #emit 0 0 "R" 0 "C1" 16r000000FC 0 )(#clflush #mem "op1" 2r1000000 0 "R" 7 "C1" 16r00000FAE 0 )(#cmc #emit 0 0 "R" 0 "C1" 16r000000F5 0 )(#cmova #rrm 0 0 "R" 0 "C1" 16r00000F47 0 )(#cmovae #rrm 0 0 "R" 0 "C1" 16r00000F43 0 )(#cmovb #rrm 0 0 "R" 0 "C1" 16r00000F42 0 )(#cmovbe #rrm 0 0 "R" 0 "C1" 16r00000F46 0 )(#cmovc #rrm 0 0 "R" 0 "C1" 16r00000F42 0 )(#cmove #rrm 0 0 "R" 0 "C1" 16r00000F44 0 )(#cmovg #rrm 0 0 "R" 0 "C1" 16r00000F4F 0 )(#cmovge #rrm 0 0 "R" 0 "C1" 16r00000F4D 0 )(#cmovl #rrm 0 0 "R" 0 "C1" 16r00000F4C 0 )(#cmovle #rrm 0 0 "R" 0 "C1" 16r00000F4E 0 )(#cmovna #rrm 0 0 "R" 0 "C1" 16r00000F46 0 )(#cmovnae #rrm 0 0 "R" 0 "C1" 16r00000F42 0 )(#cmovnb #rrm 0 0 "R" 0 "C1" 16r00000F43 0 )(#cmovnbe #rrm 0 0 "R" 0 "C1" 16r00000F47 0 )(#cmovnc #rrm 0 0 "R" 0 "C1" 16r00000F43 0 )(#cmovne #rrm 0 0 "R" 0 "C1" 16r00000F45 0 )(#cmovng #rrm 0 0 "R" 0 "C1" 16r00000F4E 0 )(#cmovnge #rrm 0 0 "R" 0 "C1" 16r00000F4C 0 )(#cmovnl #rrm 0 0 "R" 0 "C1" 16r00000F4D 0 )(#cmovnle #rrm 0 0 "R" 0 "C1" 16r00000F4F 0 )(#cmovno #rrm 0 0 "R" 0 "C1" 16r00000F41 0 )(#cmovnp #rrm 0 0 "R" 0 "C1" 16r00000F4B 0 )(#cmovns #rrm 0 0 "R" 0 "C1" 16r00000F49 0 )(#cmovnz #rrm 0 0 "R" 0 "C1" 16r00000F45 0 )(#cmovo #rrm 0 0 "R" 0 "C1" 16r00000F40 0 )(#cmovp #rrm 0 0 "R" 0 "C1" 16r00000F4A 0 )(#cmovpe #rrm 0 0 "R" 0 "C1" 16r00000F4A 0 )(#cmovpo #rrm 0 0 "R" 0 "C1" 16r00000F4B 0 )(#cmovs #rrm 0 0 "R" 0 "C1" 16r00000F48 0 )(#cmovz #rrm 0 0 "R" 0 "C1" 16r00000F44 0 )(#cmp #alu 0 0 "R" 7 "C1" 16r00000038 "C2" 16r00000080 )(#cmppd #mmuRmImm8 "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r66000FC2 0 )(#cmpps #mmuRmImm8 "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r00000FC2 0 )(#cmpsd #mmuRmImm8 "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16rF2000FC2 0 )(#cmpss #mmuRmImm8 "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16rF3000FC2 0 )(#cmpxchg #rmr 0 0 "R" 0 "C1" 16r00000FB0 0 )(#cmpxchg16b #mem "op1" 2r1000000 0 "R" 1 "C1" 16r00000FC7 "C2" 16r00000001 )(#cmpxchg8b #mem "op1" 2r1000000 0 "R" 1 "C1" 16r00000FC7 0 )(#comisd #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r66000F2F 0 )(#comiss #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r00000F2F 0 )(#cpuid #emit 0 0 "R" 0 "C1" 16r00000FA2 0 )(#crc32 #crc32 0 0 "R" 0 "C1" 16rF20F38F0 0 )(#cvtdq2pd #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16rF3000FE6 0 )(#cvtdq2ps #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r00000F5B 0 )(#cvtpd2dq #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16rF2000FE6 0 )(#cvtpd2pi #mmurmi "op1" 2r10000 "op2" 2r1100000 "R" 0 "C1" 16r66000F2D 0 )(#cvtpd2ps #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r66000F5A 0 )(#cvtpi2pd #mmurmi "op1" 2r100000 "op2" 2r1010000 "R" 0 "C1" 16r66000F2A 0 )(#cvtpi2ps #mmurmi "op1" 2r100000 "op2" 2r1010000 "R" 0 "C1" 16r00000F2A 0 )(#cvtps2dq #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r66000F5B 0 )(#cvtps2pd #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r00000F5A 0 )(#cvtps2pi #mmurmi "op1" 2r10000 "op2" 2r1100000 "R" 0 "C1" 16r00000F2D 0 )(#cvtsd2si #mmurmi "op1" 2r1100 "op2" 2r1100000 "R" 0 "C1" 16rF2000F2D 0 )(#cvtsd2ss #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16rF2000F5A 0 )(#cvtsi2sd #mmurmi "op1" 2r100000 "op2" 2r1001100 "R" 0 "C1" 16rF2000F2A 0 )(#cvtsi2ss #mmurmi "op1" 2r100000 "op2" 2r1001100 "R" 0 "C1" 16rF3000F2A 0 )(#cvtss2sd #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16rF3000F5A 0 )(#cvtss2si #mmurmi "op1" 2r1100 "op2" 2r1100000 "R" 0 "C1" 16rF3000F2D 0 )(#cvttpd2dq #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r66000FE6 0 )(#cvttpd2pi #mmurmi "op1" 2r10000 "op2" 2r1100000 "R" 0 "C1" 16r66000F2C 0 )(#cvttps2dq #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16rF3000F5B 0 )(#cvttps2pi #mmurmi "op1" 2r10000 "op2" 2r1100000 "R" 0 "C1" 16r00000F2C 0 )(#cvttsd2si #mmurmi "op1" 2r1100 "op2" 2r1100000 "R" 0 "C1" 16rF2000F2C 0 )(#cvttss2si #mmurmi "op1" 2r1100 "op2" 2r1100000 "R" 0 "C1" 16rF3000F2C 0 )(#daa #emit #x86 0 "R" 0 "C1" 16r00000027 0 )(#das #emit #x86 0 "R" 0 "C1" 16r0000002F 0 )(#dec #incdec 0 0 "R" 1 "C1" 16r00000048 "C2" 16r000000FE )(#div #rm 0 0 "R" 6 "C1" 16r000000F6 0 )(#divpd #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r66000F5E 0 )(#divps #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r00000F5E 0 )(#divsd #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16rF2000F5E 0 )(#divss #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16rF3000F5E 0 )(#dppd #mmuRmImm8 "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r660F3A41 0 )(#dpps #mmuRmImm8 "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r660F3A40 0 )(#emms #emit 0 0 "R" 0 "C1" 16r00000F77 0 )(#enter #enter 0 0 "R" 0 "C1" 16r000000C8 0 )(#extractps #mmuRmImm8 "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r660F3A17 0 )(#f2xm1 #emit 0 0 "R" 0 "C1" 16r0000D9F0 0 )(#fabs #emit 0 0 "R" 0 "C1" 16r0000D9E1 0 )(#fadd #x87fpu 0 0 "R" 0 "C1" 16rD8DCC0C0 0 )(#faddp #x87sti 0 0 "R" 0 "C1" 16r0000DEC0 0 )(#fbld #mem "op1" 2r1000000 0 "R" 4 "C1" 16r000000DF 0 )(#fbstp #mem "op1" 2r1000000 0 "R" 6 "C1" 16r000000DF 0 )(#fchs #emit 0 0 "R" 0 "C1" 16r0000D9E0 0 )(#fclex #emit 0 0 "R" 0 "C1" 16r9B00DBE2 0 )(#fcmovb #x87sti 0 0 "R" 0 "C1" 16r0000DAC0 0 )(#fcmovbe #x87sti 0 0 "R" 0 "C1" 16r0000DAD0 0 )(#fcmove #x87sti 0 0 "R" 0 "C1" 16r0000DAC8 0 )(#fcmovnb #x87sti 0 0 "R" 0 "C1" 16r0000DBC0 0 )(#fcmovnbe #x87sti 0 0 "R" 0 "C1" 16r0000DBD0 0 )(#fcmovne #x87sti 0 0 "R" 0 "C1" 16r0000DBC8 0 )(#fcmovnu #x87sti 0 0 "R" 0 "C1" 16r0000DBD8 0 )(#fcmovu #x87sti 0 0 "R" 0 "C1" 16r0000DAD8 0 )(#fcom #x87fpu 0 0 "R" 2 "C1" 16rD8DCD0D0 0 )(#fcomi #x87sti 0 0 "R" 0 "C1" 16r0000DBF0 0 )(#fcomip #x87sti 0 0 "R" 0 "C1" 16r0000DFF0 0 )(#fcomp #x87fpu 0 0 "R" 3 "C1" 16rD8DCD8D8 0 )(#fcompp #emit 0 0 "R" 0 "C1" 16r0000DED9 0 )(#fcos #emit 0 0 "R" 0 "C1" 16r0000D9FF 0 )(#fdecstp #emit 0 0 "R" 0 "C1" 16r0000D9F6 0 )(#fdiv #x87fpu 0 0 "R" 6 "C1" 16rD8DCF0F8 0 )(#fdivp #x87sti 0 0 "R" 0 "C1" 16r0000DEF8 0 )(#fdivr #x87fpu 0 0 "R" 7 "C1" 16rD8DCF8F0 0 )(#fdivrp #x87sti 0 0 "R" 0 "C1" 16r0000DEF0 0 )(#ffree #x87sti 0 0 "R" 0 "C1" 16r0000DDC0 0 )(#fiadd #x87mem "op1" 2r110 0 "R" 0 "C1" 16rDEDA0000 0 )(#ficom #x87mem "op1" 2r110 0 "R" 2 "C1" 16rDEDA0000 0 )(#ficomp #x87mem "op1" 2r110 0 "R" 3 "C1" 16rDEDA0000 0 )(#fidiv #x87mem "op1" 2r110 0 "R" 6 "C1" 16rDEDA0000 0 )(#fidivr #x87mem "op1" 2r110 0 "R" 7 "C1" 16rDEDA0000 0 )(#fild #x87mem "op1" 2r1110 0 "R" 0 "C1" 16rDFDBDF05 0 )(#fimul #x87mem "op1" 2r110 0 "R" 1 "C1" 16rDEDA0000 0 )(#fincstp #emit 0 0 "R" 0 "C1" 16r0000D9F7 0 )(#finit #emit 0 0 "R" 0 "C1" 16r9B00DBE3 0 )(#fist #x87mem "op1" 2r110 0 "R" 2 "C1" 16rDFDB0000 0 )(#fistp #x87mem "op1" 2r1110 0 "R" 3 "C1" 16rDFDBDF07 0 )(#fisttp #x87mem "op1" 2r1110 0 "R" 1 "C1" 16rDFDBDD01 0 )(#fisub #x87mem "op1" 2r110 0 "R" 4 "C1" 16rDEDA0000 0 )(#fisubr #x87mem "op1" 2r110 0 "R" 5 "C1" 16rDEDA0000 0 )(#fld #x87memSti "op1" 2r11100 0 "R" 0 "C1" 16r00D9DD00 "C2" 16rD9C0DB05 )(#fld1 #emit 0 0 "R" 0 "C1" 16r0000D9E8 0 )(#fldcw #mem "op1" 2r1000000 0 "R" 5 "C1" 16r000000D9 0 )(#fldenv #mem "op1" 2r1000000 0 "R" 4 "C1" 16r000000D9 0 )(#fldl2e #emit 0 0 "R" 0 "C1" 16r0000D9EA 0 )(#fldl2t #emit 0 0 "R" 0 "C1" 16r0000D9E9 0 )(#fldlg2 #emit 0 0 "R" 0 "C1" 16r0000D9EC 0 )(#fldln2 #emit 0 0 "R" 0 "C1" 16r0000D9ED 0 )(#fldpi #emit 0 0 "R" 0 "C1" 16r0000D9EB 0 )(#fldz #emit 0 0 "R" 0 "C1" 16r0000D9EE 0 )(#fmul #x87fpu 0 0 "R" 1 "C1" 16rD8DCC8C8 0 )(#fmulp #x87sti 0 0 "R" 0 "C1" 16r0000DEC8 0 )(#fnclex #emit 0 0 "R" 0 "C1" 16r0000DBE2 0 )(#fninit #emit 0 0 "R" 0 "C1" 16r0000DBE3 0 )(#fnop #emit 0 0 "R" 0 "C1" 16r0000D9D0 0 )(#fnsave #mem "op1" 2r1000000 0 "R" 6 "C1" 16r000000DD 0 )(#fnstcw #mem "op1" 2r1000000 0 "R" 7 "C1" 16r000000D9 0 )(#fnstenv #mem "op1" 2r1000000 0 "R" 6 "C1" 16r000000D9 0 )(#fnstsw #x87fstsw "op1" 2r1000000 0 "R" 7 "C1" 16r000000DD "C2" 16r0000DFE0 )(#fpatan #emit 0 0 "R" 0 "C1" 16r0000D9F3 0 )(#fprem #emit 0 0 "R" 0 "C1" 16r0000D9F8 0 )(#fprem1 #emit 0 0 "R" 0 "C1" 16r0000D9F5 0 )(#fptan #emit 0 0 "R" 0 "C1" 16r0000D9F2 0 )(#frndint #emit 0 0 "R" 0 "C1" 16r0000D9FC 0 )(#frstor #mem "op1" 2r1000000 0 "R" 4 "C1" 16r000000DD 0 )(#fsave #mem "op1" 2r1000000 0 "R" 6 "C1" 16r9B0000DD 0 )(#fscale #emit 0 0 "R" 0 "C1" 16r0000D9FD 0 )(#fsin #emit 0 0 "R" 0 "C1" 16r0000D9FE 0 )(#fsincos #emit 0 0 "R" 0 "C1" 16r0000D9FB 0 )(#fsqrt #emit 0 0 "R" 0 "C1" 16r0000D9FA 0 )(#fst #x87memSti "op1" 2r1100 0 "R" 2 "C1" 16r00D9DD02 "C2" 16rDDD00000 )(#fstcw #mem "op1" 2r1000000 0 "R" 7 "C1" 16r9B0000D9 0 )(#fstenv #mem "op1" 2r1000000 0 "R" 6 "C1" 16r9B0000D9 0 )(#fstp #x87memSti "op1" 2r11100 0 "R" 3 "C1" 16r00D9DD03 "C2" 16rDDD8DB07 )(#fstsw #x87fstsw "op1" 2r1000000 0 "R" 7 "C1" 16r9B0000DD "C2" 16r9B00DFE0 )(#fsub #x87fpu 0 0 "R" 4 "C1" 16rD8DCE0E8 0 )(#fsubp #x87sti 0 0 "R" 0 "C1" 16r0000DEE8 0 )(#fsubr #x87fpu 0 0 "R" 5 "C1" 16rD8DCE8E0 0 )(#fsubrp #x87sti 0 0 "R" 0 "C1" 16r0000DEE0 0 )(#ftst #emit 0 0 "R" 0 "C1" 16r0000D9E4 0 )(#fucom #x87sti 0 0 "R" 0 "C1" 16r0000DDE0 0 )(#fucomi #x87sti 0 0 "R" 0 "C1" 16r0000DBE8 0 )(#fucomip #x87sti 0 0 "R" 0 "C1" 16r0000DFE8 0 )(#fucomp #x87sti 0 0 "R" 0 "C1" 16r0000DDE8 0 )(#fucompp #emit 0 0 "R" 0 "C1" 16r0000DAE9 0 )(#fwait #emit 0 0 "R" 0 "C1" 16r0000009B 0 )(#fxam #emit 0 0 "R" 0 "C1" 16r0000D9E5 0 )(#fxch #x87sti 0 0 "R" 0 "C1" 16r0000D9C8 0 )(#fxrstor #mem 0 0 "R" 1 "C1" 16r00000FAE 0 )(#fxsave #mem 0 0 "R" 0 "C1" 16r00000FAE 0 )(#fxtract #emit 0 0 "R" 0 "C1" 16r0000D9F4 0 )(#fyl2x #emit 0 0 "R" 0 "C1" 16r0000D9F1 0 )(#fyl2xp1 #emit 0 0 "R" 0 "C1" 16r0000D9F9 0 )(#haddpd #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r66000F7C 0 )(#haddps #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16rF2000F7C 0 )(#hsubpd #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r66000F7D 0 )(#hsubps #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16rF2000F7D 0 )(#idiv #rm 0 0 "R" 7 "C1" 16r000000F6 0 )(#imul #imul 0 0 "R" 0 0 0 )(#inc #incdec 0 0 "R" 0 "C1" 16r00000040 "C2" 16r000000FE )(#int3 #emit 0 0 "R" 0 "C1" 16r000000CC 0 )(#ja #cjmp 0 0 "R" 0 "C1" 16r00000007 0 )(#jae #cjmp 0 0 "R" 0 "C1" 16r00000003 0 )(#jb #cjmp 0 0 "R" 0 "C1" 16r00000002 0 )(#jbe #cjmp 0 0 "R" 0 "C1" 16r00000006 0 )(#jc #cjmp 0 0 "R" 0 "C1" 16r00000002 0 )(#je #cjmp 0 0 "R" 0 "C1" 16r00000004 0 )(#jg #cjmp 0 0 "R" 0 "C1" 16r0000000F 0 )(#jge #cjmp 0 0 "R" 0 "C1" 16r0000000D 0 )(#jl #cjmp 0 0 "R" 0 "C1" 16r0000000C 0 )(#jle #cjmp 0 0 "R" 0 "C1" 16r0000000E 0 )(#jmp #jmp 0 0 "R" 0 0 0 )(#jna #cjmp 0 0 "R" 0 "C1" 16r00000006 0 )(#jnae #cjmp 0 0 "R" 0 "C1" 16r00000002 0 )(#jnb #cjmp 0 0 "R" 0 "C1" 16r00000003 0 )(#jnbe #cjmp 0 0 "R" 0 "C1" 16r00000007 0 )(#jnc #cjmp 0 0 "R" 0 "C1" 16r00000003 0 )(#jne #cjmp 0 0 "R" 0 "C1" 16r00000005 0 )(#jng #cjmp 0 0 "R" 0 "C1" 16r0000000E 0 )(#jnge #cjmp 0 0 "R" 0 "C1" 16r0000000C 0 )(#jnl #cjmp 0 0 "R" 0 "C1" 16r0000000D 0 )(#jnle #cjmp 0 0 "R" 0 "C1" 16r0000000F 0 )(#jno #cjmp 0 0 "R" 0 "C1" 16r00000001 0 )(#jnp #cjmp 0 0 "R" 0 "C1" 16r0000000B 0 )(#jns #cjmp 0 0 "R" 0 "C1" 16r00000009 0 )(#jnz #cjmp 0 0 "R" 0 "C1" 16r00000005 0 )(#jo #cjmp 0 0 "R" 0 0 0 )(#jp #cjmp 0 0 "R" 0 "C1" 16r0000000A 0 )(#jpe #cjmp 0 0 "R" 0 "C1" 16r0000000A 0 )(#jpo #cjmp 0 0 "R" 0 "C1" 16r0000000B 0 )(#js #cjmp 0 0 "R" 0 "C1" 16r00000008 0 )(#jz #cjmp 0 0 "R" 0 "C1" 16r00000004 0 )(#lddqu #mmurmi "op1" 2r100000 "op2" 2r1000000 "R" 0 "C1" 16rF2000FF0 0 )(#ldmxcsr #mem "op1" 2r1000000 0 "R" 2 "C1" 16r00000FAE 0 )(#lea #lea 0 0 "R" 0 0 0 )(#leave #emit 0 0 "R" 0 "C1" 16r000000C9 0 )(#lfence #emit 0 0 "R" 0 "C1" 16r000FAEE8 0 )(#lock #emit 0 0 "R" 0 "C1" 16r000000F0 0 )(#maskmovdqu #mmurmi "op1" 2r100000 "op2" 2r100000 "R" 0 "C1" 16r66000F57 0 )(#maskmovq #mmurmi "op1" 2r10000 "op2" 2r10000 "R" 0 "C1" 16r00000FF7 0 )(#maxpd #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r66000F5F 0 )(#maxps #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r00000F5F 0 )(#maxsd #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16rF2000F5F 0 )(#maxss #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16rF3000F5F 0 )(#mfence #emit 0 0 "R" 0 "C1" 16r000FAEF0 0 )(#minpd #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r66000F5D 0 )(#minps #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r00000F5D 0 )(#minsd #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16rF2000F5D 0 )(#minss #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16rF3000F5D 0 )(#monitor #emit 0 0 "R" 0 "C1" 16r000F01C8 0 )(#mov #mov 0 0 "R" 0 0 0 )(#movPtr #movPtr 0 0 "R" 0 0 0 )(#movapd #mmuMov "op1" 2r1100000 "op2" 2r1100000 "R" 0 "C1" 16r66000F28 "C2" 16r66000F29 )(#movaps #mmuMov "op1" 2r1100000 "op2" 2r1100000 "R" 0 "C1" 16r00000F28 "C2" 16r00000F29 )(#movbe #movbe "op1" 2r1001110 "op2" 2r1001110 "R" 0 "C1" 16r000F38F0 "C2" 16r000F38F1 )(#movd #mmuMovD 0 0 "R" 0 0 0 )(#movddup #mmuMov "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16rF2000F12 0 )(#movdq2q #mmuMov "op1" 2r10000 "op2" 2r100000 "R" 0 "C1" 16rF2000FD6 0 )(#movdqa #mmuMov "op1" 2r1100000 "op2" 2r1100000 "R" 0 "C1" 16r66000F6F "C2" 16r66000F7F )(#movdqu #mmuMov "op1" 2r1100000 "op2" 2r1100000 "R" 0 "C1" 16rF3000F6F "C2" 16rF3000F7F )(#movhlps #mmuMov "op1" 2r100000 "op2" 2r100000 "R" 0 "C1" 16r00000F12 0 )(#movhpd #mmuMov "op1" 2r1100000 "op2" 2r1100000 "R" 0 "C1" 16r66000F16 "C2" 16r66000F17 )(#movhps #mmuMov "op1" 2r1100000 "op2" 2r1100000 "R" 0 "C1" 16r00000F16 "C2" 16r00000F17 )(#movlhps #mmuMov "op1" 2r100000 "op2" 2r100000 "R" 0 "C1" 16r00000F16 0 )(#movlpd #mmuMov "op1" 2r1100000 "op2" 2r1100000 "R" 0 "C1" 16r66000F12 "C2" 16r66000F13 )(#movlps #mmuMov "op1" 2r1100000 "op2" 2r1100000 "R" 0 "C1" 16r00000F12 "C2" 16r00000F13 )(#movmskpd #mmuMov "op1" 2r1101 "op2" 2r100000 "R" 0 "C1" 16r66000F50 0 )(#movmskps #mmuMov "op1" 2r1101 "op2" 2r100000 "R" 0 "C1" 16r00000F50 0 )(#movntdq #mmuMov "op1" 2r1000000 "op2" 2r100000 "R" 0 0 "C2" 16r66000FE7 )(#movntdqa #mmuMov "op1" 2r100000 "op2" 2r1000000 "R" 0 "C1" 16r660F382A 0 )(#movnti #mmuMov "op1" 2r1000000 "op2" 2r1100 "R" 0 0 "C2" 16r00000FC3 )(#movntpd #mmuMov "op1" 2r1000000 "op2" 2r100000 "R" 0 0 "C2" 16r66000F2B )(#movntps #mmuMov "op1" 2r1000000 "op2" 2r100000 "R" 0 0 "C2" 16r00000F2B )(#movntq #mmuMov "op1" 2r1000000 "op2" 2r10000 "R" 0 0 "C2" 16r00000FE7 )(#movq #mmuMovQ 0 0 "R" 0 0 0 )(#movq2dq #mmurmi "op1" 2r100000 "op2" 2r10000 "R" 0 "C1" 16rF3000FD6 0 )(#movsd #mmuMov "op1" 2r1100000 "op2" 2r1100000 "R" 0 "C1" 16rF2000F10 "C2" 16rF2000F11 )(#movshdup #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16rF3000F16 0 )(#movsldup #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16rF3000F12 0 )(#movss #mmuMov "op1" 2r1100000 "op2" 2r1100000 "R" 0 "C1" 16rF3000F10 "C2" 16rF3000F11 )(#movsx #movSxZx 0 0 "R" 0 "C1" 16r00000FBE 0 )(#movsxd #movsxd 0 0 "R" 0 0 0 )(#movupd #mmuMov "op1" 2r1100000 "op2" 2r1100000 "R" 0 "C1" 16r66000F10 "C2" 16r66000F11 )(#movups #mmuMov "op1" 2r1100000 "op2" 2r1100000 "R" 0 "C1" 16r00000F10 "C2" 16r00000F11 )(#movzx #movSxZx 0 0 "R" 0 "C1" 16r00000FB6 0 )(#mpsadbw #mmuRmImm8 "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r660F3A42 0 )(#mul #rm 0 0 "R" 4 "C1" 16r000000F6 0 )(#mulpd #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r66000F59 0 )(#mulps #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16rF3000F59 0 )(#mulsd #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16rF2000F59 0 )(#mulss #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16rF3000F59 0 )(#mwait #emit 0 0 "R" 0 "C1" 16r000F01C9 0 )(#neg #rm 0 0 "R" 3 "C1" 16r000000F6 0 )(#nop #emit 0 0 "R" 0 "C1" 16r00000090 0 )(#not #rm 0 0 "R" 2 "C1" 16r000000F6 0 )(#or #alu 0 0 "R" 1 "C1" 16r00000008 "C2" 16r00000080 )(#orpd #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r66000F56 0 )(#orps #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r00000F56 0 )(#pabsb #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r000F381C 0 )(#pabsd #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r000F381E 0 )(#pabsw #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r000F381D 0 )(#packssdw #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r00000F6B 0 )(#packsswb #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r00000F63 0 )(#packusdw #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r660F382B 0 )(#packuswb #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r00000F67 0 )(#paddb #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r00000FFC 0 )(#paddd #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r00000FFE 0 )(#paddq #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r00000FD4 0 )(#paddsb #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r00000FEC 0 )(#paddsw #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r00000FED 0 )(#paddusb #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r00000FDC 0 )(#paddusw #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r00000FDD 0 )(#paddw #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r00000FFD 0 )(#palignr #mmuRmImm8 "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r000F3A0F 0 )(#pand #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r00000FDB 0 )(#pandn #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r00000FDF 0 )(#pause #emit 0 0 "R" 0 "C1" 16rF3000090 0 )(#pavgb #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r00000FE0 0 )(#pavgw #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r00000FE3 0 )(#pblendvb #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r660F3810 0 )(#pblendw #mmuRmImm8 "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r660F3A0E 0 )(#pcmpeqb #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r00000F74 0 )(#pcmpeqd #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r00000F76 0 )(#pcmpeqq #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r660F3829 0 )(#pcmpeqw #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r00000F75 0 )(#pcmpestri #mmuRmImm8 "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r660F3A61 0 )(#pcmpestrm #mmuRmImm8 "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r660F3A60 0 )(#pcmpgtb #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r00000F64 0 )(#pcmpgtd #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r00000F66 0 )(#pcmpgtq #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r660F3837 0 )(#pcmpgtw #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r00000F65 0 )(#pcmpistri #mmuRmImm8 "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r660F3A63 0 )(#pcmpistrm #mmuRmImm8 "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r660F3A62 0 )(#pextrb #mmuPextr "op1" 2r1000101 "op2" 2r100000 "R" 0 "C1" 16r000F3A14 0 )(#pextrd #mmuPextr "op1" 2r1000100 "op2" 2r100000 "R" 0 "C1" 16r000F3A16 0 )(#pextrq #mmuPextr "op1" 2r1001100 "op2" 2r100000 "R" 1 "C1" 16r000F3A16 0 )(#pextrw #mmuPextr "op1" 2r1000100 "op2" 2r110000 "R" 0 "C1" 16r000F3A16 0 )(#pf2id #mmuRm3DNow "op1" 2r10000 "op2" 2r1010000 "R" 0 "C1" 16r00000F0F "C2" 16r0000001D )(#pf2iw #mmuRm3DNow "op1" 2r10000 "op2" 2r1010000 "R" 0 "C1" 16r00000F0F "C2" 16r0000001C )(#pfacc #mmuRm3DNow "op1" 2r10000 "op2" 2r1010000 "R" 0 "C1" 16r00000F0F "C2" 16r000000AE )(#pfadd #mmuRm3DNow "op1" 2r10000 "op2" 2r1010000 "R" 0 "C1" 16r00000F0F "C2" 16r0000009E )(#pfcmpeq #mmuRm3DNow "op1" 2r10000 "op2" 2r1010000 "R" 0 "C1" 16r00000F0F "C2" 16r000000B0 )(#pfcmpge #mmuRm3DNow "op1" 2r10000 "op2" 2r1010000 "R" 0 "C1" 16r00000F0F "C2" 16r00000090 )(#pfcmpgt #mmuRm3DNow "op1" 2r10000 "op2" 2r1010000 "R" 0 "C1" 16r00000F0F "C2" 16r000000A0 )(#pfmax #mmuRm3DNow "op1" 2r10000 "op2" 2r1010000 "R" 0 "C1" 16r00000F0F "C2" 16r000000A4 )(#pfmin #mmuRm3DNow "op1" 2r10000 "op2" 2r1010000 "R" 0 "C1" 16r00000F0F "C2" 16r00000094 )(#pfmul #mmuRm3DNow "op1" 2r10000 "op2" 2r1010000 "R" 0 "C1" 16r00000F0F "C2" 16r000000B4 )(#pfnacc #mmuRm3DNow "op1" 2r10000 "op2" 2r1010000 "R" 0 "C1" 16r00000F0F "C2" 16r0000008A )(#pfpnacc #mmuRm3DNow "op1" 2r10000 "op2" 2r1010000 "R" 0 "C1" 16r00000F0F "C2" 16r0000008E )(#pfrcp #mmuRm3DNow "op1" 2r10000 "op2" 2r1010000 "R" 0 "C1" 16r00000F0F "C2" 16r00000096 )(#pfrcpit1 #mmuRm3DNow "op1" 2r10000 "op2" 2r1010000 "R" 0 "C1" 16r00000F0F "C2" 16r000000A6 )(#pfrcpit2 #mmuRm3DNow "op1" 2r10000 "op2" 2r1010000 "R" 0 "C1" 16r00000F0F "C2" 16r000000B6 )(#pfrsqit1 #mmuRm3DNow "op1" 2r10000 "op2" 2r1010000 "R" 0 "C1" 16r00000F0F "C2" 16r000000A7 )(#pfrsqrt #mmuRm3DNow "op1" 2r10000 "op2" 2r1010000 "R" 0 "C1" 16r00000F0F "C2" 16r00000097 )(#pfsub #mmuRm3DNow "op1" 2r10000 "op2" 2r1010000 "R" 0 "C1" 16r00000F0F "C2" 16r0000009A )(#pfsubr #mmuRm3DNow "op1" 2r10000 "op2" 2r1010000 "R" 0 "C1" 16r00000F0F "C2" 16r000000AA )(#phaddd #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r000F3802 0 )(#phaddsw #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r000F3803 0 )(#phaddw #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r000F3801 0 )(#phminposuw #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r660F3841 0 )(#phsubd #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r000F3806 0 )(#phsubsw #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r000F3807 0 )(#phsubw #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r000F3805 0 )(#pi2fd #mmuRm3DNow "op1" 2r10000 "op2" 2r1010000 "R" 0 "C1" 16r00000F0F "C2" 16r0000000D )(#pi2fw #mmuRm3DNow "op1" 2r10000 "op2" 2r1010000 "R" 0 "C1" 16r00000F0F "C2" 16r0000000C )(#pinsrb #mmuRmImm8 "op1" 2r100000 "op2" 2r1000100 "R" 0 "C1" 16r660F3A20 0 )(#pinsrd #mmuRmImm8 "op1" 2r100000 "op2" 2r1000100 "R" 0 "C1" 16r660F3A22 0 )(#pinsrq #mmuRmImm8 "op1" 2r100000 "op2" 2r1001000 "R" 0 "C1" 16r660F3A22 0 )(#pinsrw #mmuRmImm8 "op1" 2r110000 "op2" 2r1000100 "R" 0 "C1" 16r00000FC4 0 )(#pmaddubsw #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r000F3804 0 )(#pmaddwd #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r00000FF5 0 )(#pmaxsb #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r660F383C 0 )(#pmaxsd #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r660F383D 0 )(#pmaxsw #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r00000FEE 0 )(#pmaxub #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r00000FDE 0 )(#pmaxud #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r660F383F 0 )(#pmaxuw #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r660F383E 0 )(#pminsb #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r660F3838 0 )(#pminsd #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r660F3839 0 )(#pminsw #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r00000FEA 0 )(#pminub #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r00000FDA 0 )(#pminud #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r660F383B 0 )(#pminuw #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r660F383A 0 )(#pmovmskb #mmurmi "op1" 2r1100 "op2" 2r110000 "R" 0 "C1" 16r00000FD7 0 )(#pmovsxbd #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r660F3821 0 )(#pmovsxbq #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r660F3822 0 )(#pmovsxbw #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r660F3820 0 )(#pmovsxdq #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r660F3825 0 )(#pmovsxwd #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r660F3823 0 )(#pmovsxwq #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r660F3824 0 )(#pmovzxbd #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r660F3831 0 )(#pmovzxbq #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r660F3832 0 )(#pmovzxbw #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r660F3830 0 )(#pmovzxdq #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r660F3835 0 )(#pmovzxwd #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r660F3833 0 )(#pmovzxwq #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r660F3834 0 )(#pmuldq #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r660F3828 0 )(#pmulhrsw #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r000F380B 0 )(#pmulhuw #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r00000FE4 0 )(#pmulhw #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r00000FE5 0 )(#pmulld #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r660F3840 0 )(#pmullw #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r00000FD5 0 )(#pmuludq #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r00000FF4 0 )(#pop #pop 0 0 "R" 0 "C1" 16r00000058 "C2" 16r0000008F )(#popad #emit #x86 0 "R" 0 "C1" 16r00000061 0 )(#popcnt #rrm 0 0 "R" 0 "C1" 16rF3000FB8 0 )(#popfd #emit 0 0 "R" 0 "C1" 16r0000009D 0 )(#popfq #emit 0 0 "R" 0 "C1" 16r4800009D 0 )(#por #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r00000FEB 0 )(#prefetch #mmuPrefetch "op1" 2r1000000 "op2" 2r10000000 "R" 0 0 0 )(#psadbw #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r00000FF6 0 )(#pshufb #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r000F3800 0 )(#pshufd #mmuRmImm8 "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r66000F70 0 )(#pshufhw #mmuRmImm8 "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16rF3000F70 0 )(#pshuflw #mmuRmImm8 "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16rF2000F70 0 )(#pshufw #mmuRmImm8 "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r00000F70 0 )(#psignb #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r000F3808 0 )(#psignd #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r000F380A 0 )(#psignw #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r000F3809 0 )(#pslld #mmurmi "op1" 2r110000 "op2" 2r11110000 "R" 6 "C1" 16r00000FF2 "C2" 16r00000F72 )(#pslldq #mmurmi "op1" 2r100000 "op2" 2r10000000 "R" 7 0 "C2" 16r66000F73 )(#psllq #mmurmi "op1" 2r110000 "op2" 2r11110000 "R" 6 "C1" 16r00000FF3 "C2" 16r00000F73 )(#psllw #mmurmi "op1" 2r110000 "op2" 2r11110000 "R" 6 "C1" 16r00000FF1 "C2" 16r00000F71 )(#psrad #mmurmi "op1" 2r110000 "op2" 2r11110000 "R" 4 "C1" 16r00000FE2 "C2" 16r00000F72 )(#psraw #mmurmi "op1" 2r110000 "op2" 2r11110000 "R" 4 "C1" 16r00000FE1 "C2" 16r00000F71 )(#psrld #mmurmi "op1" 2r110000 "op2" 2r11110000 "R" 2 "C1" 16r00000FD2 "C2" 16r00000F72 )(#psrldq #mmurmi "op1" 2r100000 "op2" 2r10000000 "R" 3 0 "C2" 16r66000F73 )(#psrlq #mmurmi "op1" 2r110000 "op2" 2r11110000 "R" 2 "C1" 16r00000FD3 "C2" 16r00000F73 )(#psrlw #mmurmi "op1" 2r110000 "op2" 2r11110000 "R" 2 "C1" 16r00000FD1 "C2" 16r00000F71 )(#psubb #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r00000FF8 0 )(#psubd #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r00000FFA 0 )(#psubq #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r00000FFB 0 )(#psubsb #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r00000FE8 0 )(#psubsw #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r00000FE9 0 )(#psubusb #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r00000FD8 0 )(#psubusw #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r00000FD9 0 )(#psubw #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r00000FF9 0 )(#pswapd #mmuRm3DNow "op1" 2r10000 "op2" 2r1010000 "R" 0 "C1" 16r00000F0F "C2" 16r000000BB )(#ptest #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r660F3817 0 )(#punpckhbw #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r00000F68 0 )(#punpckhdq #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r00000F6A 0 )(#punpckhqdq #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r66000F6D 0 )(#punpckhwd #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r00000F69 0 )(#punpcklbw #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r00000F60 0 )(#punpckldq #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r00000F62 0 )(#punpcklqdq #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r66000F6C 0 )(#punpcklwd #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r00000F61 0 )(#push #push 0 0 "R" 6 "C1" 16r00000050 "C2" 16r000000FF )(#pushad #emit #x86 0 "R" 0 "C1" 16r00000060 0 )(#pushf #emit 0 0 "R" 0 "C1" 16r6600009C 0 )(#pushfd #emit #x86 0 "R" 0 "C1" 16r0000009C 0 )(#pushfq #emit #x64 0 "R" 0 "C1" 16r0000009C 0 )(#pxor #mmurmi "op1" 2r110000 "op2" 2r1110000 "R" 0 "C1" 16r00000FEF 0 )(#rcl #rot 0 0 "R" 2 0 0 )(#rcpps #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r00000F53 0 )(#rcpss #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16rF3000F53 0 )(#rcr #rot 0 0 "R" 3 0 0 )(#rdtsc #emit 0 0 "R" 0 "C1" 16r00000F31 0 )(#rdtscp #emit 0 0 "R" 0 "C1" 16r000F01F9 0 )(#ret #ret 0 0 "R" 0 0 0 )(#rol #rot 0 0 "R" 0 0 0 )(#ror #rot 0 0 "R" 1 0 0 )(#roundpd #mmuRmImm8 "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r660F3A09 0 )(#roundps #mmuRmImm8 "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r660F3A08 0 )(#roundsd #mmuRmImm8 "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r660F3A0B 0 )(#roundss #mmuRmImm8 "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r660F3A0A 0 )(#rsqrtps #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r00000F52 0 )(#rsqrtss #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16rF3000F52 0 )(#sahf #emit 0 0 "R" 0 "C1" 16r0000009E 0 )(#sal #rot 0 0 "R" 4 0 0 )(#sar #rot 0 0 "R" 7 0 0 )(#sbb #alu 0 0 "R" 3 "C1" 16r00000018 "C2" 16r00000080 )(#sfence #emit 0 0 "R" 0 "C1" 16r000FAEF8 0 )(#shl #rot 0 0 "R" 4 0 0 )(#shld #shldShrd 0 0 "R" 0 "C1" 16r00000FA4 0 )(#shr #rot 0 0 "R" 5 0 0 )(#shrd #shldShrd 0 0 "R" 0 "C1" 16r00000FAC 0 )(#shufps #mmuRmImm8 "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r00000FC6 0 )(#sqrtpd #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r66000F51 0 )(#sqrtps #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r00000F51 0 )(#sqrtsd #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16rF2000F51 0 )(#sqrtss #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16rF3000F51 0 )(#stc #emit 0 0 "R" 0 "C1" 16r000000F9 0 )(#std #emit 0 0 "R" 0 "C1" 16r000000FD 0 )(#stmxcsr #mem "op1" 2r1000000 0 "R" 3 "C1" 16r00000FAE 0 )(#sub #alu 0 0 "R" 5 "C1" 16r00000028 "C2" 16r00000080 )(#subpd #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r66000F5C 0 )(#subps #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r00000F5C 0 )(#subsd #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16rF2000F5C 0 )(#subss #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16rF3000F5C 0 )(#syscall #emit "op1" 2r100000000 0 "R" 0 "C1" 16r00000F05 0 )(#test #test 0 0 "R" 0 0 0 )(#ucomisd #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r66000F2E 0 )(#ucomiss #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r00000F2E 0 )(#ud2 #emit 0 0 "R" 0 "C1" 16r00000F0B 0 )(#unpckhpd #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r66000F15 0 )(#unpckhps #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r00000F15 0 )(#unpcklpd #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r66000F14 0 )(#unpcklps #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r00000F14 0 )(#xadd #rmr 0 0 "R" 0 "C1" 16r00000FC0 0 )(#xchg #xchg 0 0 "R" 0 0 0 )(#xor #alu 0 0 "R" 6 "C1" 16r00000030 "C2" 16r00000080 )(#xorpd #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r66000F57 0 )(#xorps #mmurmi "op1" 2r100000 "op2" 2r1100000 "R" 0 "C1" 16r00000F57 0 ))! !!AJx86InstructionDescription class methodsFor: 'accessing'!instructions	^ instructions ifNil: [ self initInstructions ]! !!AJx86InstructionDescription class methodsFor: 'initialization'!instructionsCDQ"CBW/CWDE/CDQE Convert Byte to Word/Convert Word toDoubleword/Convert Doubleword to Quadword"^#((#cbw #emit 0 0 "R" 0 "C1" 16r66000098 0 )(#cwde #emit 0 0 "R" 0 "C1" 16r00000098 0 )(#cdqe #emit #x64 0 "R" 0 "C1" 16r48000098 0 )"CWD/CDQ/CQO Convert Word to Doubleword/Convert Doubleword toQuadword"(#cwd #emit 0 0 "R" 0 "C1" 16r66000099 0 )(#cdq #emit 0 0 "R" 0 "C1" 16r00000099 0 )(#cqo #emit #x64 0 "R" 0 "C1" 16r48000099 0 ))! !!AJx86InstructionDescription class methodsFor: 'initialization' stamp: 'IgorStasenko 9/18/2012 17:23'!instructionsOther^ #((#femms #emit 0 0 "R" 0 "C1" 16r00000F0E 0 )  " looks like invalid one "(#movsb #emit 0 0 "R" 0 "C1" 16r000000A4 0 )  (#movsd #emit 0 0 "R" 0 "C1" 16r000000A5 0 )   "in 64bit mode - moves 64bits"(#rep #emit 0 0 "R" 0 "C1" 16r000000F3 0 )   "repeat prefix"(#repe #emit 0 0 "R" 0 "C1" 16r000000F3 0 )   "repeat prefix"(#repz #emit 0 0 "R" 0 "C1" 16r000000F3 0 )   "repeat prefix"(#repne #emit 0 0 "R" 0 "C1" 16r000000F2 0 )   "repeat prefix"(#repnz #emit 0 0 "R" 0 "C1" 16r000000F2 0 )   "repeat prefix"(#cmpsb #emit 0 0 "R" 0 "C1" 16r000000A6 0 )  "(#cmpsw #emit 0 0 0  16r000000A7 0 )  "(#cmpsd #emit 0 0 "R" 0 "C1" 16r000000A7 0 )  )! !!AJx86InstructionDescription class methodsFor: 'printing'!printInstructions	" AJInstructionDescription printInstructions.		AJInstructionDescription printInstructions openInWorkspaceWithTitle: 'x86 instructions'	 "	^ String streamContents: [:str | self printInstructionsOn: str ]! !!AJx86InstructionDescription class methodsFor: 'printing'!printInstructionsOn: aStream	" AJInstructionDescription printInstructionsOn: (FileStream newFileNamed: 'asm.st'). "		aStream nextPutAll: '#(' ; cr.		self instructions keys asSortedCollection do: [:aname | 		| instr |				instr := instructions at: aname.				instr printOn: aStream.		aStream cr.	].	aStream cr;		nextPut: $); cr! !!AJx86InstructionDescription methodsFor: 'accessing' stamp: 'CamilloBruni 4/13/2012 15:44'!comment	^ comment! !!AJx86InstructionDescription methodsFor: 'accessing' stamp: 'CamilloBruni 4/13/2012 15:44'!comment: aString	comment := aString! !!AJx86InstructionDescription methodsFor: 'accessing' stamp: 'CamilloBruni 4/13/2012 14:51'!description	^ description! !!AJx86InstructionDescription methodsFor: 'accessing' stamp: 'CamilloBruni 4/13/2012 14:51'!description: aString	description := aString! !!AJx86InstructionDescription methodsFor: 'emitting-dispatch'!emitUsing: emitter operand1: op1 operand2: op2 operand3: op3	(self is64BitOnly and: [ emitter is64BitMode not ]) ifTrue: [ 		self error: 'instruction is only for 64 bit mode' ].	(self is32BitOnly and: [ emitter is32BitMode not ]) ifTrue: [ 		self error: 'instruction is only for 32 bit mode' ].		^ self perform: groupEmitSelector withArguments: 	{ emitter. op1. op2. op3 }! !!AJx86InstructionDescription methodsFor: 'emitting-dispatch' stamp: 'CamilloBruni 3/30/2012 17:05'!emitUsing: emitter operands: operands	|args|		(self is64BitOnly and: [ emitter is64BitMode not ]) ifTrue: [ 		self error: 'instruction ', self name asUppercase,' is only for 64 bit mode' ].	(self is32BitOnly and: [ emitter is32BitMode not ]) ifTrue: [ 		self error: 'instruction ', self name asUppercase,' is only for 32 bit mode' ].		"manually create the arguments array"	args := Array new: 4.	args at: 1 put: emitter.	args replaceFrom: 2		to: (operands size + 1 min: 4)		with: operands		startingAt: 1.			^ self 		perform: groupEmitSelector 		withArguments: args! !!AJx86InstructionDescription methodsFor: 'emitting'!emitalu: emitter operand1: op1 operand2: op2 operand3: op3	| opCode opReg |	opCode := opCode1.	opReg := opCodeR.		" Mem <- Reg "	(op1 isMem and: [ op2 isReg ]) ifTrue: [		^ emitter emitX86RM: opCode + op2 isRegTypeGPB not asBit			size: op2 size			regOrCode: op2			rm: op1	].	"Reg <- Reg|Mem"	(op1 isReg and: [op2 isRegMem]) ifTrue: [		^ emitter emitX86RM: opCode + 2 + op1 isRegTypeGPB not asBit			size: op1 size			regOrCode: op1			rm: op2	].	op2 isImm ifFalse: [	self invalidInstruction ].	"short constant"	op2 isInt8 ifTrue: [ 		| szBits |		szBits := op1 size = 1 ifTrue: [ 0 ] ifFalse: [ 3 ].		emitter emitX86RM: opCode2 + szBits			size: op1 size			regOrCode: opReg			rm: op1			immSize: 1.		^ emitter emitImmediate: op2 size: 1.	].	      " AL, AX, EAX, RAX register shortcuts"	(op1 isRegIndex: 0) ifTrue: [				op1 isRegTypeGPW ifTrue: [ emitter emitByte: 16r66 " 16 bit " ].		op1 isRegTypeGPQ ifTrue: [ emitter emitByte: 16r48 " REX.W" ].		emitter emitByte: (opReg << 3 bitOr: (16r04 + op1 isRegTypeGPB not asBit)).		^ emitter emitImmediate: op2 size: (op1 size min: 4)	].	(op1 isRegMem) ifTrue: [ | immSize szBits |		immSize := op2 isInt8 ifTrue: [1] ifFalse: [ op1 size min: 4].		szBits := op1 size ~= 1 ifTrue: [ immSize ~= 1 ifTrue: [1] ifFalse: [3]] ifFalse: [ 0].		emitter emitX86RM: opCode2 + szBits			size: op1 size			regOrCode: opReg			rm: op1			immSize: immSize.		^ emitter emitImmediate: op2 size: immSize.	].	self invalidInstruction.	! !!AJx86InstructionDescription methodsFor: 'emitting'!emitbswap: emitter operand1: op1 operand2: op2 operand3: op3	op1 isReg ifTrue: [		emitter emitRexR: op1 isRegTypeGPQ opReg: 1 regCode: op1 code.		emitter emitByte: 16r0F.		^ emitter emitModR: 1 r: op1 code	].	self invalidInstruction.! !!AJx86InstructionDescription methodsFor: 'emitting' stamp: 'CamilloBruni 5/15/2012 14:18'!emitbt: emitter operand1: dst operand2: src operand3: op3	dst isRegMem		ifFalse: [ self error: 'Expected register or memory but got ', dst asString ].		(dst isReg and: [ dst is8 ])		ifTrue: [ self error: '8 bit register ', dst asString, ' not supported for bit test operations'].	 	src isReg ifTrue: [		^ emitter emitX86RM: opCode1			size: src size			regOrCode: src			rm: dst	].	src isImm ifTrue: [		src isInt8 			ifFalse: [ self error: 'Expected imm8 but got ', src size asString, ' immediate.' ].		emitter emitX86RM: opCode2			size: dst size			regOrCode: opCodeR			rm: dst			immSize: 1.		^ emitter emitImmediate: src size: 1	].	self invalidInstruction	! !!AJx86InstructionDescription methodsFor: 'emitting'!emitcall: emitter operand1: op1 operand2: op2 operand3: op3	(op1 isMem or: [ op1 isReg and: [ op1 index = 0 "EAX" ] ]) ifTrue: [		^ emitter emitX86RM:  16rFF			size: 4			regOrCode: 2  			rm: op1  	].	op1 isImm ifTrue: [ "call by relative offset, you should be really sure what you're' doing"		emitter emitByte: 16rE8. 		op1 emitUsing: emitter size: 4.		^ self.		].		op1 isLabel ifTrue: [		emitter emitByte: 16rE8. 		emitter emitDisplacement: op1 inlinedDisp: -4.		^ self	].	self invalidInstruction.! !!AJx86InstructionDescription methodsFor: 'emitting'!emitcjmp: emitter operand1: target operand2: hint operand3: op3	"Conditional jump.	Use only symbols as labels"		target isString ifTrue: [		"jump on label"		^ emitter addJump: target condition: opCode1 hint: hint	].		"we could check if label is bound , and emit short jump, 	instead of 32-bit relative jump address"	self invalidInstruction.	emitter emitByte: 16r0F;		emitByte: (16r80 bitOr: opCode1);		emitDisplacement: target inlinedDisp: -4! !!AJx86InstructionDescription methodsFor: 'emitting'!emitcrc32: emitter operand1: dst operand2: src operand3: op3	(dst isReg and: [ src isRegMem ]) ifTrue: [		self assert: (dst isRegTypeGPD | dst isRegTypeGPQ).		^ emitter emitX86RM: opCode1 + (src size ~= 1) asBit			size: src size			regOrCode: dst			rm: src		].		self invalidInstruction.! !!AJx86InstructionDescription methodsFor: 'emitting'!emitemit: emitter operand1: op1 operand2: op2 operand3: op3	^ emitter emitOpCode: opCode1! !!AJx86InstructionDescription methodsFor: 'emitting'!emitenter: emitter operand1: op1 operand2: op2 operand3: op3	(op1 isImm and: [ op2 isImm ]) ifFalse: [ self invalidInstruction ].		emitter emitByte: 16rC8.	emitter emitImmediate: op1 size: 2.	emitter emitImmediate: op2 size: 1.! !!AJx86InstructionDescription methodsFor: 'emitting' stamp: 'CamilloBruni 4/17/2012 19:02'!emitimul: emitter operand1: op1 operand2: op2 operand3: op3	| immSize |		op1 isRegMem ifFalse: [  ^ self invalidInstruction ].		" 1 operand "	(op2 isNil and: [ op3 isNil ]) ifTrue: [		^ emitter emitX86RM:  16rF6 + (op1 size ~= 1) asBit			size: op1 size			regOrCode:  5			rm:  op1		].	op1 isReg ifFalse: [  ^ self invalidInstruction ].		"2 operands"	op3 isNil ifTrue: ["		self assert: op1 isRegTypeGPW."		op2 isRegMem ifTrue: [			^ emitter emitX86RM: 16r0FAF				size: op1 size				regOrCode: op1 code				rm:  op2			].		op2 isImm ifFalse: [ ^ self invalidInstruction ].		(op2 isInt8 and: [ op2 relocMode == #RelocNone ]) ifTrue: [			emitter emitX86RM: 16r6B				size: op1 size				regOrCode:  op1 code				rm:  op1				immSize: 1.			^ emitter emitImmediate: op2 size: 1.			].		immSize := op1 isRegTypeGPW ifTrue: [ 2 ] ifFalse: [ 4 ].		emitter emitX86RM: 16r69			size: op1 size			regOrCode:  op1 code			rm:  op1			immSize: immSize.		^ emitter emitImmediate: op2 size: immSize.	].	" 3 operands "	(op2 isRegMem and: [op3 isImm ]) ifFalse: [ ^ self invalidInstruction ].		(op3 isInt8 and: [ op3 relocMode == #RelocNone ]) ifTrue: [		emitter emitX86RM: 16r6B			size: op1 size			regOrCode:  op1			rm: op2 immSize: 1.		^ emitter emitImmediate: op3 size: 1.		].    	immSize := op1 isRegTypeGPW ifTrue: [2] ifFalse: [4].	emitter emitX86RM: 16r69		size: op1 size		regOrCode:  op1		rm:  op2 immSize: immSize.	emitter emitImmediate: op3 size: immSize.! !!AJx86InstructionDescription methodsFor: 'emitting'!emitincdec: emitter operand1: dst operand2: op2 operand3: op3	dst isRegMem ifFalse: [ ^ self invalidInstruction ].	"INC [r16|r32] in 64 bit mode is not encodable."	emitter is32BitMode ifTrue: [		(dst isReg & dst isRegTypeGPW & dst isRegTypeGPD) ifTrue: [ 		^ emitter emitX86Inl: opCode1	reg: dst	]].	emitter emitX86RM:  opCode2 + (dst size ~= 1) asBit		size: dst size		regOrCode:  opCodeR		rm:  dst! !!AJx86InstructionDescription methodsFor: 'emitting'!emitjmp: emitter operand1: target operand2: op2 operand3: op3		target isString ifTrue: [		"jump on label"		^ emitter addJump: target condition: nil hint: nil	].	target isRegMem ifTrue: [		^ emitter emitX86RM: 16rFF			size: 0 			regOrCode:  4			rm:  target	].	emitter emitByte: 16rE9.	emitter emitDisplacement: target inlinedDisp: -4! !!AJx86InstructionDescription methodsFor: 'emitting' stamp: 'CamilloBruni 4/17/2012 17:41'!emitlea: emitter operand1: op1 operand2: op2 operand3: op3	(op1 isReg and: [ op2 isMem ]) 		ifFalse: [ self error: 'LEA: Expected Reg and Mem but got ', op1 asString, ' and ', op2 asString ].		emitter emitX86RM: 16r8D		size: op1 size		regOrCode: op1		rm: op2! !!AJx86InstructionDescription methodsFor: 'emitting'!emitmem: emitter operand1: op1 operand2: op2 operand3: op3	op1 isMem ifFalse: [ self invalidInstruction ].	self assert: (opCode2 = 0 or: [ opCode2 = 1 ]).	emitter emitX86RM: opCode1		size: opCode2 << 3		regOrCode: opCodeR 		rm: op1! !!AJx86InstructionDescription methodsFor: 'emitting'!emitmmuMov: emitter operand1: op1 operand2: op2 operand3: op3		self shouldBeImplemented.		self assert: o1Flags ~= 0.	self assert: o2Flags ~= 0.	      "Check parameters (X)MM|GP32_64 <- (X)MM|GP32_64|Mem|Imm"	(op1 isMem & ((o1Flags bitAnd: OMEM) = 0)) |	(op1 isRegTypeMM & ((o1Flags bitAnd: OMM) = 0)) |	(op1 isRegTypeXMM & ((o1Flags bitAnd: OXMM) = 0)) |	(op1 isRegTypeGPD & ((o1Flags bitAnd: OG32) = 0)) |	(op1 isRegTypeGPQ & ((o1Flags bitAnd: OG64) = 0)) |	(op2 isRegTypeMM & ((o2Flags bitAnd: OMM) = 0)) |	(op2 isRegTypeXMM & ((o2Flags bitAnd: OXMM) = 0)) |	(op2 isRegTypeGPD & ((o2Flags bitAnd: OG32) = 0)) |	(op2 isRegTypeGPQ & ((o2Flags bitAnd: OG64) = 0)) |	(op2 isMem & ((o2Flags bitAnd: OMEM) = 0)) |	(op1 isMem & op2 isMem)		ifTrue: [ self invalidInstruction ].			! !!AJx86InstructionDescription methodsFor: 'emitting'!emitmmuMovD: emitter operand1: op1 operand2: op2 operand3: op3	self shouldBeImplemented! !!AJx86InstructionDescription methodsFor: 'emitting'!emitmmuMovQ: emitter operand1: op1 operand2: op2 operand3: op3	self shouldBeImplemented! !!AJx86InstructionDescription methodsFor: 'emitting'!emitmmuPextr: emitter operand1: op1 operand2: op2 operand3: op3	self shouldBeImplemented! !!AJx86InstructionDescription methodsFor: 'emitting'!emitmmuPrefetch: emitter operand1: op1 operand2: op2 operand3: op3	self shouldBeImplemented! !!AJx86InstructionDescription methodsFor: 'emitting'!emitmmuRm3DNow: emitter operand1: op1 operand2: op2 operand3: op3	self shouldBeImplemented! !!AJx86InstructionDescription methodsFor: 'emitting'!emitmmuRmImm8: emitter operand1: op1 operand2: op2 operand3: op3	self shouldBeImplemented! !!AJx86InstructionDescription methodsFor: 'emitting'!emitmmurmi: emitter operand1: op1 operand2: op2 operand3: op3	self shouldBeImplemented! !!AJx86InstructionDescription methodsFor: 'emitting' stamp: 'IgorStasenko 3/20/2012 16:08'!emitmov: emitter operand1: dst operand2: src operand3: op3	src isReg & dst isReg ifTrue: [		self assert: (src isRegTypeGPB | src isRegTypeGPW | src isRegTypeGPD | src isRegTypeGPQ ).		]. 		" reg <- mem "	dst isReg & src isRegMem ifTrue: [		self assert: (dst isRegTypeGPB | dst isRegTypeGPW | dst isRegTypeGPD | dst isRegTypeGPQ ).	"	(src size = dst size) ifFalse: [ self invalidInstruction ]. "		^ emitter emitX86RM: 16r0000008A + dst isRegTypeGPB not asBit 			size:  dst size 			regOrCode:  dst 			rm: src		].	" reg <- imm "		dst isReg & src isImm ifTrue: [		| immSize |		immSize := dst size.		emitter is64BitMode & immSize = 8 & src isInt32 & (src relocMode == #RelocNone) ifTrue: [			"Optimize instruction size by using 32 bit immediate if value can fit to it"			 emitter emitX86RM: 16rC7				size: dst size				regOrCode: 0 rm: dst.	            immSize := 4		] ifFalse: [			emitter emitX86Inl: (immSize=1 ifTrue: [16rB0] ifFalse: [16rB8]) reg: dst		].		^ emitter emitImmediate: src size: immSize	].	"mem <- reg"	dst isMem & src isReg ifTrue: [		self assert: (src isRegTypeGPB | src isRegTypeGPW | src isRegTypeGPD | src isRegTypeGPQ ).		^ emitter emitX86RM: 16r88 + src isRegTypeGPB not asBit			size: src size regOrCode: src rm: dst	].	"mem <- imm"	dst isMem & src isImm ifTrue: [ | immSize |				immSize := dst size <= 4 ifTrue: [ dst size ] ifFalse: [4].				emitter emitX86RM: 16rC6 + ((dst size = 1) not) asBit			size: dst size 			regOrCode:  0 rm:  dst 			immSize: immSize.				^ emitter emitImmediate: src size: immSize	].	self invalidInstruction ! !!AJx86InstructionDescription methodsFor: 'emitting'!emitmovPtr: emitter operand1: op1 operand2: op2 operand3: op3	| reg imm opCode |	(op1 isReg & op2 isImm) | (op1 isImm & op2 isReg) ifFalse: [		self invalidInstruction ].		opCode := op1 isReg 		ifTrue: [reg := op1. imm := op2. 16rA0] 		ifFalse: [reg := op2. imm := op1. 16rA2].		reg index ~= 0 ifTrue: [ self invalidInstruction ].	reg isRegTypeGPW ifTrue: [ emitter emitByte: 16r66 ].	emitter emitRexR: (reg size=8) opReg: 0 regCode: 0.	emitter emitByte: opCode + (reg size ~=1) asBit.	emitter emitImmediate: imm size: reg size! !!AJx86InstructionDescription methodsFor: 'emitting'!emitmovSxZx: emitter operand1: dst operand2: src operand3: op3	dst isReg & src isRegMem ifFalse: [ self invalidInstruction ].		dst isRegTypeGPB ifTrue: [ self invalidInstruction ].		(src size ~= 2 and: [src size ~= 1 ]) ifTrue: [ self invalidInstruction ].	(src size = 2 and: [dst isRegTypeGPW ]) ifTrue: [ self invalidInstruction ].		src size = 2 ifTrue: [		^ emitter emitX86RM: opCode1 + 1 size: dst size regOrCode: dst rm: src		].		emitter emitX86RM: opCode1 size: dst size regOrCode: dst rm: src! !!AJx86InstructionDescription methodsFor: 'emitting'!emitmovbe: anAJx86Assembler operand1: anUndefinedObject operand2: anUndefinedObject3 operand3: anUndefinedObject4 	self shouldBeImplemented! !!AJx86InstructionDescription methodsFor: 'emitting'!emitmovsxd: emitter operand1: dst operand2: src operand3: op3	emitter is64BitMode ifFalse: [ self invalidInstruction ].	dst isReg & src isRegMem ifFalse: [ self invalidInstruction ].		emitter emitX86RM: 16r63 		size: dst size		regOrCode: dst  rm: src! !!AJx86InstructionDescription methodsFor: 'emitting' stamp: 'CamilloBruni 4/25/2012 15:15'!emitpop: emitter operand1: op1 operand2: op2 operand3: op3	op1 isReg ifTrue: [		(op1 isRegTypeGPW | (emitter isGPNRegister: op1)) 			ifFalse: [ self error: 'Invalid register given: ', op1 asString].		^ emitter emitX86Inl: opCode1 reg: op1.		].		op1 isMem ifFalse: [ self invalidInstruction ].	emitter emitX86RM: opCode2 size: op1 size regOrCode: opCodeR rm: op1! !!AJx86InstructionDescription methodsFor: 'emitting'!emitpush: emitter operand1: op1 operand2: op2 operand3: op3	"This section is only for immediates, memory/register operands are handled in emitpop:..."	op1 isImm ifTrue: [		op1 isInt8 & (op1 relocMode == #RelocNone) ifTrue: [			emitter emitByte: 16r6A.			^ emitter emitImmediate: op1 size: 1 ].				emitter emitByte: 16r68.		^ emitter emitImmediate: op1 size: 4		].		^ self emitpop: emitter operand1: op1 operand2: op2 operand3: op3! !!AJx86InstructionDescription methodsFor: 'emitting'!emitret: emitter operand1: op1 operand2: op2 operand3: op3	op1 ifNil: [ ^ emitter emitByte: 16rC3 ].		op1 isImm ifFalse: [ self invalidInstruction ].		self assert: (op1 isUnsigned and: [op1 fitsInSize: 2]).		(op1 value = 0 and: [ op1 relocMode  == #RelocNone ]) ifTrue: [		^ emitter emitByte: 16rC3	].			emitter emitByte: 16rC2.	emitter emitImmediate: op1 size: 2! !!AJx86InstructionDescription methodsFor: 'emitting'!emitrm: emitter operand1: dst operand2: src operand3: op3	emitter emitX86RM: opCode1 + (dst isRegTypeGPB not) asBit		size: dst size		regOrCode: opCodeR rm: dst! !!AJx86InstructionDescription methodsFor: 'emitting'!emitrmr: emitter operand1: dst operand2: src operand3: op3	dst isRegMem & src isReg ifFalse: [ self invalidInstruction ].		emitter emitX86RM: opCode1 + (src isRegTypeGPB not) asBit		size: src size		regOrCode: src rm: dst! !!AJx86InstructionDescription methodsFor: 'emitting'!emitrot: emitter operand1: op1 operand2: op2 operand3: op3	| useImm8 opCode |	op1 isRegMem & ((op2 isRegTypeGPB and: [ op2 index =  1 "cl" ]) | op2 isImm) ifFalse: [ self invalidInstruction ].		useImm8 := op2 isImm and: [ (op2 value ~= 1) | (op2 relocMode ~~ #RelocNone) ].	opCode := useImm8 ifTrue: [ 16rC0 ] ifFalse: [ 16rD0 ].	op1 size ~= 1 ifTrue: [ opCode := opCode bitOr: 1 ].	op2 isReg ifTrue: [ opCode := opCode bitOr: 2 ].		emitter emitX86RM: opCode		size: op1 size		regOrCode: opCodeR		rm: 	op1		immSize: useImm8 asBit.		useImm8 ifTrue: [		emitter emitImmediate: op2 size: 1		]! !!AJx86InstructionDescription methodsFor: 'emitting'!emitrrm: emitter operand1: dst operand2: src operand3: op3	dst isReg & src isRegMem ifFalse: [ self invalidInstruction ].		self assert: (dst isRegTypeGPB not).		emitter emitX86RM: opCode1		size: dst size		regOrCode: dst rm: src! !!AJx86InstructionDescription methodsFor: 'emitting'!emitshldShrd: emitter operand1: dst operand2: src1 operand3: src2	(src2 isImm or: [ src2 isRegTypeGPB and: [ src2 index = 1 "cl"]]) ifFalse: [ self invalidInstruction ].		dst isRegMem & src1 isReg ifFalse: [ self invalidInstruction ].	self assert: (dst size = src1 size).		emitter emitX86RM: opCode1 + src2 isReg asBit		size: src1 size		regOrCode: src1 rm: dst immSize: src2 isImm asBit.			src2 isImm ifTrue: [		emitter emitImmediate: src2 size: 1		]! !!AJx86InstructionDescription methodsFor: 'code emitting' stamp: 'MartinMcClure 1/30/2013 22:13'!emittest: emitter operand1: op1 operand2: op2 operand3: op3	| immSize |	op1 isRegMem & op2 isReg		ifTrue: [ 			op1 size notNil & (op1 size ~= op2 size)				ifTrue: [ 					self						error:							'Operands ' , op1 asString , ' and ' , op2 asString , ' don''t match in size: ' , op1 size asString , ' !!= '								, op2 size asString ].			^ emitter				emitX86RM: 16r84 + op2 isRegTypeGPB not asBit				size: op2 size				regOrCode: op2				rm: op1 ].	(op1 isReg and: [ op1 index = 0 and: [ op2 isImm ] ])		ifTrue: [ 			immSize := op1 size min: 4.			op1 is16				ifTrue: [ emitter emitByte: 16r66	"16bit" ].			emitter emitRexRM: op1 is64 regCode: 0 rm: op1.			emitter emitByte: 16rA8 + (op1 size ~= 1) asBit.			^ emitter emitImmediate: op2 size: immSize ].	(op1 isRegMem and: [ op2 isImm ])		ifFalse: [ self invalidInstruction ].	immSize := op1 size min: 4.	(op2 fitsInSize: immSize)		ifFalse: [ self invalidInstruction ].	emitter emitSegmentPrefix: op1.	emitter emitOperandSizeOverridePrefix: op1.	emitter emitByte: 16rF6 + (op1 size ~= 1) asBit.	op1 emitModRM: emitter code: 0 immSize: immSize.	emitter emitImmediate: op2 size: immSize! !!AJx86InstructionDescription methodsFor: 'emitting' stamp: 'CamilloBruni 7/17/2012 11:10'!emitx87addp: emitter operand1: op1 operand2: op2 operand3: op3	| opp |	opp := op1 ifNil:  [ AJx87Register new code: 1 ].		opp isRegTypeX87 ifTrue: [		emitter emitByte: (opCode1 bitAnd: 16rFF00)>>8.		emitter emitByte: (opCode1 bitAnd: 16rFF)			+ opp index.		^ self 	].	^self emitx87sti: emitter operand1: opp operand2: op2 operand3: op3	! !!AJx86InstructionDescription methodsFor: 'emitting'!emitx87fpu: emitter operand1: op1 operand2: op2 operand3: op3 	"Either we are in memory, and carry out by using D8 / DC followed by modRM where reg indicates the operation"	op1 isMem 		ifTrue: [		(op2 notNil or: [op3]) notNil ifTrue: [self error: 'Invalid arguments!!'].				emitter emitByte: (opCode1 >> (32 - (op1 size* 2)) bitAnd: 16rFF).		^op1 emitModRM: emitter code: opCodeR immSize: nil].	"Or both my arguments are X87 registers, one of which is ST0.	Store in op1 register."	(op1 isRegTypeX87 and: [op2 isRegTypeX87]) ifTrue: [|shift offset|		op1 index = 0 			ifTrue: [shift := 24.					offset := op2 index]			ifFalse: [			op2 index = 0 				ifTrue: [shift = 16.					offset := op1 index]				ifFalse: [self error: 'ST0 must be one of arguments']].		"D8 if Storing in ST0, DC if storing in other"		emitter emitByte: (opCode1 >> shift bitAnd: 16rFF).			emitter emitByte: (opCode1 >> (shift - 16) bitAnd: 16rFF) + offset		]		ifFalse: [self error: 'Invalid arguments!!']	! !!AJx86InstructionDescription methodsFor: 'emitting'!emitx87fstsw: anAJx86Assembler operand1: anUndefinedObject operand2: anUndefinedObject3 operand3: anUndefinedObject4 	self shouldBeImplemented! !!AJx86InstructionDescription methodsFor: 'emitting'!emitx87mem: emitter operand1: m operand2: op2 operand3: op3	| opCode mod |      m isMem ifFalse: [ ^ self invalidInstruction ].	opCode := mod := 0.	(m is16 and: [ (o1Flags bitAnd: OFM2) ~= 0 ]) ifTrue: [		opCode := (opCode1 bitAnd: 16rFF000000) >> 24.		mod := opCodeR ].	(m is32 and: [ (o1Flags bitAnd: OFM4) ~= 0 ]) ifTrue: [		opCode := (opCode1 bitAnd: 16r00FF0000) >> 16.		mod := opCodeR ].		(m is64 and: [ (o1Flags bitAnd: OFM8) ~= 0 ]) ifTrue: [		opCode := (opCode1 bitAnd: 16r0000FF00) >> 8.		mod :=  (opCode1 bitAnd: 16r000000FF) ].	opCode = 0 ifTrue: [ self invalidInstruction ].	emitter emitSegmentPrefix: m;		emitByte: opCode.	m emitModRM: emitter code: mod immSize: 0.! !!AJx86InstructionDescription methodsFor: 'emitting'!emitx87memSti: emitter operand1: op1 operand2: op2 operand3: op3	op1 isRegTypeX87 ifTrue: [		emitter emitByte: (opCode2 bitAnd: 16rFF000000)>>24.		emitter emitByte: (opCode2 bitAnd: 16r00FF0000)>>16			+ op1 index.		^ self 	].      " ... fall through to I_X87_MEM ... "	^ self emitx87mem: emitter operand1: op1 operand2: op2 operand3: op3! !!AJx86InstructionDescription methodsFor: 'emitting' stamp: 'CamilloBruni 7/23/2012 15:21'!emitx87sti: emitter operand1: op1 operand2: op2 operand3: op3	(op1 isNil and: [ op2 isNil and: [ op3 isNil ]])		ifTrue: [ "Convenience fallback for ST1 "			^ self emitx87sti: emitter operand1: AJx86Registers ST1 operand2: nil operand3: nil ].			op1 isRegTypeX87 ifTrue: [		emitter emitByte: (opCode1 bitAnd: 16rFF00)>>8.		emitter emitByte: (opCode1 bitAnd: 16rFF) + op1 index.		^ self 	].	self invalidInstruction! !!AJx86InstructionDescription methodsFor: 'emitting'!emitxchg: emitter operand1: dst operand2: src operand3: op3	dst isRegMem & src isReg ifFalse: [ self invalidInstruction ].		emitter emitSizePrefix: src segment: dst.		"Special opcode for index 0 registers (AX, EAX, RAX vs register)"	dst isReg & (dst size > 1) & (dst index =0 or: [ src index = 0 ] ) ifTrue: [			| index |			index := dst index + src index.			^ emitter emitByte: 16r90 + index.		].		emitter emitByte: 16r86 + src isRegTypeGPB not asBit.	dst emitModRM: emitter code: src code immSize: 0! !!AJx86InstructionDescription methodsFor: 'initialize-release'!fromArray: arr	| tmp |	name := arr at: 1.	group := arr at: 2.	groupEmitSelector := ('emit', group,':operand1:operand2:operand3:') asSymbol.		tmp := arr at: 3.	tmp isSymbol ifTrue: [ tmp := self translateSymFlag: tmp ].	o1Flags := tmp.	o2Flags := arr at: 4.	opCodeR := arr at: 5.	opCode1 := arr at: 6.	opCode2 := arr at: 7.! !!AJx86InstructionDescription methodsFor: 'accessing'!group	^ group! !!AJx86InstructionDescription methodsFor: 'accessing'!group: anObject	"Set the value of group"	group := anObject! !!AJx86InstructionDescription methodsFor: 'errors'!invalidInstruction	self error: 'invalid instruction'! !!AJx86InstructionDescription methodsFor: 'testing'!is32BitOnly	^ (o1Flags bitAnd: 2r1000000000) ~= 0! !!AJx86InstructionDescription methodsFor: 'testing'!is64BitOnly	^ (o1Flags bitAnd: 2r100000000) ~= 0! !!AJx86InstructionDescription methodsFor: 'testing'!isJump	^ group == #cjmp or: [ group == #jmp ]! !!AJx86InstructionDescription methodsFor: 'accessing'!name	^ name! !!AJx86InstructionDescription methodsFor: 'accessing'!name: anObject	"Set the value of name"	name := anObject! !!AJx86InstructionDescription methodsFor: 'accessing'!o1Flags	"Answer the value of o1Flags"	^ o1Flags! !!AJx86InstructionDescription methodsFor: 'accessing'!o1Flags: anObject	"Set the value of o1Flags"	o1Flags := anObject! !!AJx86InstructionDescription methodsFor: 'accessing'!o2Flags	"Answer the value of o2Flags"	^ o2Flags! !!AJx86InstructionDescription methodsFor: 'accessing'!o2Flags: anObject	"Set the value of o2Flags"	o2Flags := anObject! !!AJx86InstructionDescription methodsFor: 'accessing'!opCode1	"Answer the value of opCode1"	^ opCode1! !!AJx86InstructionDescription methodsFor: 'accessing'!opCode1: anObject	"Set the value of opCode1"	opCode1 := anObject! !!AJx86InstructionDescription methodsFor: 'accessing'!opCode2	"Answer the value of opCode2"	^ opCode2! !!AJx86InstructionDescription methodsFor: 'accessing'!opCode2: anObject	"Set the value of opCode2"	opCode2 := anObject! !!AJx86InstructionDescription methodsFor: 'accessing'!opCodeR	"Answer the value of opCodeR"	^ opCodeR! !!AJx86InstructionDescription methodsFor: 'accessing'!opCodeR: anObject	"Set the value of opCodeR"	opCodeR := anObject! !!AJx86InstructionDescription methodsFor: 'printing'!printDWord: value	| str |	str := value printStringBase: 16.		[str size < 8] whileTrue: [ str:= '0',str ].	^ '16r', str! !!AJx86InstructionDescription methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: '(';	nextPutAll: name printString;	space;	nextPutAll: group printString;	space.	"print o1Flags"	o1Flags > 0 ifTrue: [ aStream nextPutAll: '"op1" 2r' , (o1Flags printStringBase: 2) ]		ifFalse: [ aStream nextPutAll: '0'].	aStream space.		"print o2Flags"	o2Flags > 0 ifTrue: [ aStream nextPutAll: '"op2" 2r' , (o2Flags printStringBase: 2) ]		ifFalse: [ aStream nextPutAll: '0'].	aStream space.	"print opCodeR"	aStream nextPutAll: '"R" '.	opCodeR printOn: aStream.	aStream space.		"print opCode1"	opCode1 > 0 ifTrue: [ 		aStream nextPutAll: '"C1" '.		aStream nextPutAll:  (self printDWord: opCode1 ) ]		ifFalse: [ aStream nextPutAll: '0'].			aStream space.	"print opCode2"	opCode2 > 0 ifTrue: [ 		aStream nextPutAll: '"C2" '.		aStream nextPutAll:  (self printDWord: opCode2 ) ]		ifFalse: [ aStream nextPutAll: '0'].	aStream space;	nextPut: $) 	! !!AJx86InstructionDescription methodsFor: 'initialize-release'!translateSymFlag: aflag	" 64-bit mode only instruction "	aflag == #x64 ifTrue: [ ^ 2r100000000 ].	" 32-bit mode only instruction "	aflag == #x86 ifTrue: [ ^ 2r1000000000 ].	self error: 'unknown flag'.! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!AH	"A 8bit general purpose register	This register overlaps with AH, AX, EAX, RAX"	^ self at: #AH! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!AL	"A 8bit general purpose register	This register overlaps with AL, AX, EAX, RAX"	^ self at: #AL! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!AX	"A 16bit general purpose register	This register overlaps with AL, AX, EAX, RAX"	^ self at: #AX! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!BH	"A 8bit general purpose register	This register overlaps with BH, BX, EBX, RBX"	^ self at: #BH! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!BL	"A 8bit general purpose register	This register overlaps with BL, BX, EBX, RBX"	^ self at: #BL! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!BP	"A 16bit general purpose register	This register overlaps with CH, CX, ECX, RCX"	^ self at: #BP! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!BX	"A 16bit general purpose register	This register overlaps with BL, BX, EBX, RBX"	^ self at: #BX! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!CH	"A 8bit general purpose register	This register overlaps with CH, CX, ECX, RCX"	^ self at: #CH! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!CL	"A 8bit general purpose register	This register overlaps with CL, CX, ECX, RCX"	^ self at: #CL! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!CX	"A 16bit general purpose register	This register overlaps with CL, CX, ECX, RCX"	^ self at: #CX! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!DH	"A 8bit general purpose register	This register overlaps with DH, DX, EDX, RDX"	^ self at: #DH! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!DI	"A 16bit general purpose register	This register overlaps with BH, BX, EBX, RBX"	^ self at: #DI! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!DL	"A 8bit general purpose register	This register overlaps with DL, DX, EDX, RDX"	^ self at: #DL! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!DX	"A 16bit general purpose register	This register overlaps with DL, DX, EDX, RDX"	^ self at: #DX! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!EAX	"A 32bit general purpose register	This register overlaps with AL, AX, EAX, RAX"	^ self at: #EAX! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!EBP	"A 32bit general purpose register	This register overlaps with CH, CX, ECX, RCX"	^ self at: #EBP! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!EBX	"A 32bit general purpose register	This register overlaps with BL, BX, EBX, RBX"	^ self at: #EBX! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!ECX	"A 32bit general purpose register	This register overlaps with CL, CX, ECX, RCX"	^ self at: #ECX! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!EDI	"A 32bit general purpose register	This register overlaps with BH, BX, EBX, RBX"	^ self at: #EDI! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!EDX	"A 32bit general purpose register	This register overlaps with DL, DX, EDX, RDX"	^ self at: #EDX! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!EIP	"A 32bit instruction pointer register	This register overlaps with IP, EIP, RIP"	^ self at: #EIP! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!ESI	"A 32bit general purpose register	This register overlaps with DH, DX, EDX, RDX"	^ self at: #ESI! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!ESP	"A 32bit general purpose register	This register overlaps with AH, AX, EAX, RAX"	^ self at: #ESP! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!IP	"A 16bit instruction pointer register	This register overlaps with IP, EIP, RIP"	^ self at: #IP! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!MM0	"An MMX register"	^ self at: #MM0! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!MM1	"An MMX register"	^ self at: #MM1! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!MM2	"An MMX register"	^ self at: #MM2! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!MM3	"An MMX register"	^ self at: #MM3! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!MM4	"An MMX register"	^ self at: #MM4! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!MM5	"An MMX register"	^ self at: #MM5! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!MM6	"An MMX register"	^ self at: #MM6! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!MM7	"An MMX register"	^ self at: #MM7! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!R10	"A 64bit general purpose register	This register overlaps with R10B, R10W, R10D, R10"	^ self at: #R10! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!R10B	"A 8bit general purpose register	This register overlaps with R10B, R10W, R10D, R10"	^ self at: #R10B! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!R10D	"A 32bit general purpose register	This register overlaps with R10B, R10W, R10D, R10"	^ self at: #R10D! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!R10W	"A 16bit general purpose register	This register overlaps with R10B, R10W, R10D, R10"	^ self at: #R10W! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!R11	"A 64bit general purpose register	This register overlaps with R11B, R11W, R11D, R11"	^ self at: #R11! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!R11B	"A 8bit general purpose register	This register overlaps with R11B, R11W, R11D, R11"	^ self at: #R11B! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!R11D	"A 32bit general purpose register	This register overlaps with R11B, R11W, R11D, R11"	^ self at: #R11D! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!R11W	"A 16bit general purpose register	This register overlaps with R11B, R11W, R11D, R11"	^ self at: #R11W! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!R12	"A 64bit general purpose register	This register overlaps with R12B, R12W, R12D, R12"	^ self at: #R12! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!R12B	"A 8bit general purpose register	This register overlaps with R12B, R12W, R12D, R12"	^ self at: #R12B! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!R12D	"A 32bit general purpose register	This register overlaps with R12B, R12W, R12D, R12"	^ self at: #R12D! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!R12W	"A 16bit general purpose register	This register overlaps with R12B, R12W, R12D, R12"	^ self at: #R12W! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!R13	"A 64bit general purpose register	This register overlaps with R13B, R13W, R13D, R13"	^ self at: #R13! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!R13B	"A 8bit general purpose register	This register overlaps with R13B, R13W, R13D, R13"	^ self at: #R13B! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!R13D	"A 32bit general purpose register	This register overlaps with R13B, R13W, R13D, R13"	^ self at: #R13D! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!R13W	"A 16bit general purpose register	This register overlaps with R13B, R13W, R13D, R13"	^ self at: #R13W! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!R14	"A 64bit general purpose register	This register overlaps with R14B, R14W, R14D, R14"	^ self at: #R14! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!R14B	"A 8bit general purpose register	This register overlaps with R14B, R14W, R14D, R14"	^ self at: #R14B! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!R14D	"A 32bit general purpose register	This register overlaps with R14B, R14W, R14D, R14"	^ self at: #R14D! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!R14W	"A 16bit general purpose register	This register overlaps with R14B, R14W, R14D, R14"	^ self at: #R14W! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!R15	"A 64bit general purpose register	This register overlaps with R15B, R15W, R15D, R15"	^ self at: #R15! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!R15B	"A 8bit general purpose register	This register overlaps with R15B, R15W, R15D, R15"	^ self at: #R15B! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!R15D	"A 32bit general purpose register	This register overlaps with R15B, R15W, R15D, R15"	^ self at: #R15D! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!R15W	"A 16bit general purpose register	This register overlaps with R15B, R15W, R15D, R15"	^ self at: #R15W! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!R8	"A 64bit general purpose register	This register overlaps with R8B, R8W, R8D, R8"	^ self at: #R8! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!R8B	"A 8bit general purpose register	This register overlaps with R8B, R8W, R8D, R8"	^ self at: #R8B! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!R8D	"A 32bit general purpose register	This register overlaps with R8B, R8W, R8D, R8"	^ self at: #R8D! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!R8W	"A 16bit general purpose register	This register overlaps with R8B, R8W, R8D, R8"	^ self at: #R8W! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!R9	"A 64bit general purpose register	This register overlaps with R9B, R9W, R9D, R9"	^ self at: #R9! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!R9B	"A 8bit general purpose register	This register overlaps with R9B, R9W, R9D, R9"	^ self at: #R9B! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!R9D	"A 32bit general purpose register	This register overlaps with R9B, R9W, R9D, R9"	^ self at: #R9D! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!R9W	"A 16bit general purpose register	This register overlaps with R9B, R9W, R9D, R9"	^ self at: #R9W! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!RAX	"A 64bit general purpose register	This register overlaps with AL, AX, EAX, RAX"	^ self at: #RAX! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!RBP	"A 64bit general purpose register	This register overlaps with CH, CX, ECX, RCX"	^ self at: #RBP! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!RBX	"A 64bit general purpose register	This register overlaps with BL, BX, EBX, RBX"	^ self at: #RBX! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!RCX	"A 64bit general purpose register	This register overlaps with CL, CX, ECX, RCX"	^ self at: #RCX! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!RDI	"A 64bit general purpose register	This register overlaps with BH, BX, EBX, RBX"	^ self at: #RDI! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!RDX	"A 64bit general purpose register	This register overlaps with DL, DX, EDX, RDX"	^ self at: #RDX! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!RIP	"A 64bit instruction pointer register	This register overlaps with IP, EIP, RIP"	^ self at: #RIP! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!RSI	"A 64bit general purpose register	This register overlaps with DH, DX, EDX, RDX"	^ self at: #RSI! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!RSP	"A 64bit general purpose register	This register overlaps with AH, AX, EAX, RAX"	^ self at: #RSP! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!SI	"A 16bit general purpose register	This register overlaps with DH, DX, EDX, RDX"	^ self at: #SI! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!SP	"A 16bit general purpose register	This register overlaps with AH, AX, EAX, RAX"	^ self at: #SP! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!ST0	"A floating point register"	^ self at: #ST0! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!ST1	"A floating point register"	^ self at: #ST1! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!ST2	"A floating point register"	^ self at: #ST2! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!ST3	"A floating point register"	^ self at: #ST3! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!ST4	"A floating point register"	^ self at: #ST4! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!ST5	"A floating point register"	^ self at: #ST5! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!ST6	"A floating point register"	^ self at: #ST6! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!ST7	"A floating point register"	^ self at: #ST7! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!XMM0	"An SSE register"	^ self at: #XMM0! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!XMM1	"An SSE register"	^ self at: #XMM1! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!XMM10	"An SSE register"	^ self at: #XMM10! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!XMM11	"An SSE register"	^ self at: #XMM11! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!XMM12	"An SSE register"	^ self at: #XMM12! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!XMM13	"An SSE register"	^ self at: #XMM13! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!XMM14	"An SSE register"	^ self at: #XMM14! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!XMM15	"An SSE register"	^ self at: #XMM15! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!XMM2	"An SSE register"	^ self at: #XMM2! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!XMM3	"An SSE register"	^ self at: #XMM3! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!XMM4	"An SSE register"	^ self at: #XMM4! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!XMM5	"An SSE register"	^ self at: #XMM5! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:48'!XMM6	"An SSE register"	^ self at: #XMM6! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!XMM7	"An SSE register"	^ self at: #XMM7! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!XMM8	"An SSE register"	^ self at: #XMM8! !!AJx86Registers class methodsFor: 'accessing registers' stamp: 'AsmJIT 8/21/2012 17:47'!XMM9	"An SSE register"	^ self at: #XMM9! !!AJx86Registers class methodsFor: 'accessing'!all	^ Codes values collect: [ :each| self classPool at: each ]! !!AJx86Registers class methodsFor: 'accessing'!all16	^ self all select: [:reg| reg is16 ]! !!AJx86Registers class methodsFor: 'accessing'!all32	^ self all select: [:reg| reg is32 ]! !!AJx86Registers class methodsFor: 'accessing'!all64	^ self all select: [:reg| reg is64 ]! !!AJx86Registers class methodsFor: 'accessing'!all8	^ self all select: [:reg| reg is8 ]! !!AJx86Registers class methodsFor: 'accessing' stamp: 'CamilloBruni 7/17/2012 10:54'!at: aRegisterIdentifierSymbol	^ self classPool at: aRegisterIdentifierSymbol! !!AJx86Registers class methodsFor: 'accessing' stamp: 'MarcusDenker 5/7/2013 15:27'!code: registerCode	"Access a register by its code.	Example:		RBP == (self code: RBP code)"	| registerName |	self flag: 'XXX now this is some ugly code... add an instance variable for the requiresRex boolean instead of encoding it in #code'.	registerName := Codes at: registerCode ifAbsent: [ 				Codes at: registerCode + 16r100 ifAbsent: [ 					Codes at: registerCode + 16r200 ifAbsent: [  KeyNotFound signalFor: registerCode ] ] ].	^ self classPool at: registerName! !!AJx86Registers class methodsFor: 'accessing'!doesNotUnderstand: aMessage	self classPool at: aMessage selector ifPresent: [:val| ^ val ].	^ super doesNotUnderstand: aMessage! !!AJx86Registers class methodsFor: 'accessing'!generalPurpose	^ self all select: [ :reg| reg isGeneralPurpose ]! !!AJx86Registers class methodsFor: 'accessing'!generalPurpose16	^ self sortRegistersByIndex: (self generalPurpose select: [:reg| reg is16 ])! !!AJx86Registers class methodsFor: 'accessing'!generalPurpose32	^ self sortRegistersByIndex: (self generalPurpose select: [:reg| reg is32 ])! !!AJx86Registers class methodsFor: 'accessing'!generalPurpose64	^ self sortRegistersByIndex: (self generalPurpose select: [:reg| reg is64 ])! !!AJx86Registers class methodsFor: 'accessing'!generalPurpose8	^ self sortRegistersByIndex: (self generalPurpose select: [:reg| reg is8 ])! !!AJx86Registers class methodsFor: 'accessing' stamp: 'MartinMcClure 1/30/2013 21:13'!generalPurposeWithIndex: index size: numBytes requiresRex: requiresRex prohibitsRex: prohibitsRex	"Access a register by its properties.	Example:		RBP == (self generalPurposeWithIndex: RBP index size: RBP size requiresRex: RBP requiresRex prohibitsRex: RBP prohibitsRex )"	| type code |	type := numBytes = 1		ifTrue: [ 0 ]		ifFalse: [ 			numBytes = 2				ifTrue: [ 16r10 ]				ifFalse: [ 					numBytes = 4						ifTrue: [ 16r20 ]						ifFalse: [ 							numBytes = 8								ifTrue: [ 16r30 ]								ifFalse: [ self error: 'Size must be 1, 2, 4, or 8 bytes' ] ] ] ].	code := type + index.	requiresRex		ifTrue: [ code := code + RegRequiresRexMask ].	prohibitsRex		ifTrue: [ code := code + RegProhibitsRexMask ].	^ self classPool at: (Codes at: code)! !!AJx86Registers class methodsFor: 'initialization' stamp: 'MartinMcClure 1/27/2013 14:46'!initialize	"AJx86Registers initialize"			self classPool at: #Codes put: IdentityDictionary new. 		self initializeGeneralPurpose8BitRegisters.	self initializeGeneralPurpose16BitRegisters.	self initializeGeneralPurpose32BitRegisters.	self initializeGeneralPurpose64BitRegisters.		self initializeInstructionPointerRegisters.		self initializeX87Registers.	self initializeMMXRegisters.	self initializeSSERegisters.! !!AJx86Registers class methodsFor: 'initialization' stamp: 'MartinMcClure 1/27/2013 09:57'!initializeGeneralPurpose16BitRegisters	"initialize general purpose 16 bit registers "	self		registerBase: 16r10			class: AJx86GPRegister			rex: #dontCare			values: #(#AX #CX #DX #BX #SP #BP #SI #DI);		registerBase: 16r18			class: AJx86GPRegister			rex: #required			values: #(#R8W #R9W #R10W #R11W #R12W #R13W #R14W #R15W)! !!AJx86Registers class methodsFor: 'initialization' stamp: 'MartinMcClure 1/27/2013 09:58'!initializeGeneralPurpose32BitRegisters	"initialize general purpose 32 bit registers "	self		registerBase: 16r20			class: AJx86GPRegister			rex: #dontCare			values: #(#EAX #ECX #EDX #EBX #ESP #EBP #ESI #EDI);		registerBase: 16r28			class: AJx86GPRegister			rex: #required			values: #(#R8D #R9D #R10D #R11D #R12D #R13D #R14D #R15D)! !!AJx86Registers class methodsFor: 'initialization' stamp: 'CamilloBruni 5/21/2013 17:28'!initializeGeneralPurpose64BitRegisters	"initialize general purpose 64 bit registers"		self		registerBase: 16r30			class: AJx86GPRegister			rex: #dontCare			values: #(#RAX #RCX #RDX #RBX #RSP #RBP #RSI #RDI);		registerBase: 16r38			class: AJx86GPRegister			rex: #required			values: #(#R8 #R9 #R10 #R11 #R12 #R13 #R14 #R15)! !!AJx86Registers class methodsFor: 'initialization' stamp: 'MartinMcClure 1/27/2013 10:06'!initializeGeneralPurpose8BitRegisters	"general purpose 8 bit registers "	self		registerBase: 0			class: AJx86GPRegister			rex: #dontCare			values: #(#AL #CL #DL #BL);		registerBase: 4			class: AJx86GPRegister			rex: #prohibited			values: #(#AH #CH #DH #BH);		registerBase: 4			class: AJx86GPRegister			rex: #required			values: #(#SPL #BPL #SIL #DIL #R8B #R9B #R10B #R11B #R12B #R13B #R14B #R15B)! !!AJx86Registers class methodsFor: 'initialization' stamp: 'CamilloBruni 7/17/2012 11:04'!initializeInstructionPointerRegisters	| ip eip rip |		ip := AJx64RipRegister code: SI code name: #IP.	eip := AJx64RipRegister code: ESI code name: #EIP.	rip := AJx64RipRegister code: RSI code name: #RIP.		Codes 		at: SI code negated put: #IP;		at: ESI code negated put: #EIP;		at: RSI code negated put: #RIP.		self classPool 		at: #IP put: ip;		at: #EIP put: eip;		at: #RIP put: rip.! !!AJx86Registers class methodsFor: 'initialization'!initializeMMXRegisters	" MMX registers "	self registerBase: 16r60  class: AJMMRegister values: #(		#MM0 #MM1   #MM2   #MM3   #MM4   #MM5   #MM6   #MM7 ).! !!AJx86Registers class methodsFor: 'initialization' stamp: 'CamilloBruni 7/17/2012 11:10'!initializeSSERegisters	" SSE registers "	self registerBase: 16r70 class: AJxMMRegister  values: #(		#XMM0 #XMM1  #XMM2  #XMM3  #XMM4  #XMM5  #XMM6  #XMM7 		#XMM8 #XMM9  #XMM10 #XMM11 #XMM12 #XMM13 #XMM14 #XMM15).! !!AJx86Registers class methodsFor: 'initialization' stamp: 'CamilloBruni 7/17/2012 11:10'!initializeX87Registers	"X87 registers"	self registerBase: 16r50 class: AJx87Register values: #(		#ST0 #ST1 #ST2 #ST3 #ST4 #ST5 #ST6 #ST7 ).! !!AJx86Registers class methodsFor: 'method compilation' stamp: 'CamilloBruni 7/17/2012 11:28'!installRegister: register accessorCategory: registerAccessorsCategory	^ self class		compile:(String streamContents: [ :s | 			s nextPutAll: register name; crtab.			self printRegister: register descriptionOn: s.			s crtab; nextPutAll: '^ self at: #'; nextPutAll: register name ])		classified: registerAccessorsCategory! !!AJx86Registers class methodsFor: 'method compilation' stamp: 'CamilloBruni 7/17/2012 11:18'!installRegister: register accessorCategory: registerAccessorsCategory on: aClass		aClass 		compile: (String	streamContents: [ :s | 			s nextPutAll: register name; crtab.			self printRegister: register descriptionOn: s.			s crtab; nextPutAll: '^ '; nextPutAll: register name ])		classified: registerAccessorsCategory ! !!AJx86Registers class methodsFor: 'method compilation' stamp: 'CamilloBruni 7/17/2012 11:14'!installRegisterAccessors	"this method creates simple accessors for all registers"	| registerAccessorsCategory |		registerAccessorsCategory := 'accessing registers'.			"remove all methods in the 'accessing register' category"	self class methodDict values		select: [ :method | method category = registerAccessorsCategory ]		thenDo: [ :method | self class removeSelector: method selector ].			self all 		do: [ :register | | method |			"install the direct accessor on this class"			self installRegister: register accessorCategory: registerAccessorsCategory.			"install the accessor on the assembler"			self 				installRegister: register 				accessorCategory: registerAccessorsCategory				on: (register isX86 ifTrue: [ AJx86Assembler ]  ifFalse: [ AJx64Assembler ])]		displayingProgress: [ :each| each name ].! !!AJx86Registers class methodsFor: 'method compilation' stamp: 'CamilloBruni 7/17/2012 11:27'!printRegister: register descriptionOn: s	s nextPut: $".	register descriptionOn: s.	register influencingRegisters ifNotEmpty: [ :registers|		s crtab nextPutAll: 'This register overlaps with '.		registers do: [ :reg| s nextPutAll: reg name ] separatedBy: [ s nextPutAll: ', ']].	s nextPut: $"! !!AJx86Registers class methodsFor: 'initialization' stamp: 'MartinMcClure 1/27/2013 09:56'!registerBase: base class: regClass rex: rexSymbol values: names 	| val |	val := 0.	rexSymbol == #required		ifTrue: [ val := 16r100 ].	rexSymbol == #prohibited		ifTrue: [ val := 16r200 ].	val := val + base.	names		do: [ :regName | 			| reg |			reg := regClass code: val name: regName.			self classPool at: regName put: reg.			Codes at: val put: regName.			val := val + 1 ]! !!AJx86Registers class methodsFor: 'initialization' stamp: 'CamilloBruni 3/20/2012 18:45'!registerBase: base class: regClass values: names	| val |	val := base.	names do: [ :regName | | reg |		reg := regClass code: val name: regName.		self classPool at: regName put: reg. 		Codes at: val put: regName.		val := val + 1].! !!AJx86Registers class methodsFor: 'initialization'!sortRegistersByIndex: aRegisterCollection	^ aRegisterCollection sort: [ :regA :regB| regA index < regB index ].! !"AsmJit-x86"!!AJStackAlignmentTests methodsFor: 'utility'!newAssembler 	^ AJx86Assembler new! !!AJStackAlignmentTests methodsFor: 'tests'!testJumps	| asm callInfo |		asm := self newAssembler.	asm noStackFrame.		asm jmp: #foo;		nop;		nop;		nop;		nop;		nop;		nop;		nop;		nop;	label: #foo.		^ asm generatedCode.! !!AJStackAlignmentTests methodsFor: 'tests'!testNewProtocolForAlignedCalls	| asm callInfo |		asm := self newAssembler.			asm cdeclCall:  [:call |		call 			push: EAX;			push: EAX;			push: 4.		asm call: EAX.		callInfo := call.	] alignment: 32.			asm generatedCode. "to analyze instructions"	self assert: callInfo stackSize = 12.	self assert: callInfo needsAlignment 	! !!AJx64AssemblerTests class methodsFor: 'as yet unclassified'!shouldInheritSelectors	^ true! !!AJx64AssemblerTests methodsFor: 'utility'!newAssembler 	^ AJx64Assembler new		noStackFrame;		yourself! !!AJx64AssemblerTests methodsFor: 'tests' stamp: 'MartinMcClure 1/1/2013 22:30'!testAssembly0	self assert: [ :a | a mov: 16rfeedface -> RAX ] 		bytes: #[72 184 206 250 237 254 0 0 0 0]! !!AJx64AssemblerTests methodsFor: 'tests' stamp: 'MartinMcClure 1/1/2013 22:30'!testAssembly01	self		assert: [ :a | 			self assert: (a reg: 8 size: 4) = R8D.	"mov    $0xfeedface,%r8d"			a mov: 16rfeedface asUImm to: R8D ]		bytes: #[65 184 206 250 237 254]! !!AJx64AssemblerTests methodsFor: 'tests' stamp: 'MartinMcClure 1/1/2013 22:31'!testAssembly1		self 		assert: [ :a|			a 				push: a RBP;				mov: a RSP -> a RBP;				mov: 1024 -> a RAX;				mov: a RBP -> a RSP;				pop: a RBP;				ret.]			bytes: #[			85 			72 139 236 			72	199	192	0	4	0	0			72 139 229 			93 			195]! !!AJx64AssemblerTests methodsFor: 'tests' stamp: 'MartinMcClure 1/1/2013 22:31'!testAssembly2	self 		assert: [ :a|		asm 			push: a BP;			mov: a SP -> a BP;			mov: 16r400 -> a RAX;			mov: a BP -> a SP;			pop: a RSP;			ret. ]		bytes: #[			102 85			102 139 236 			72	199	192 0 4 0 0			102 139 229 			92 			195]	! !!AJx64AssemblerTests methodsFor: 'tests' stamp: 'MartinMcClure 1/1/2013 22:12'!testAssembly3	" instructions without operands.	(AJInstructionDescription instructions select: [:each | each group = #emit]) keys asSortedCollection	 "	| str |	str :=#(#cbw 16r66 16r98#cdq 16r99#cdqe 16r48 16r98#clc 16rF8#cld 16rFC#cmc 16rF5 #cpuid 16r0F 16rA2#cqo  16r48	16r99 "64 bit "#cwd 16r66 16r99#cwde 16r98"#daa 16r27 32 bit""#das 16r2F 32 bit"#emms 16r0F 16r77#f2xm1 16rD9 16rF0#fabs  16rD9 16rE1#fchs 16rD9 16rE0#fclex 16r9B 16rDB 16rE2#fcompp 16rDE 16rD9#fcos 16rD9 16rFF#fdecstp 16rD9 16rF6#fincstp 16rD9 16rF7#finit 16r9B 16rDB 16rE3#fld1 16rD9 16rE8#fldl2e 16rD9 16rEA#fldl2t 16rD9 16rE9#fldlg2 16rD9 16rEC#fldln2 16rD9 16rED#fldpi 16rD9 16rEB#fldz 16rD9 16rEE#fnclex 16rDB 16rE2#fninit 16rDB 16rE3#fnop 16rD9 16rD0#fpatan 16rD9 16rF3#fprem 16rD9 16rF8#fprem1 16rD9 16rF5#fptan 16rD9 16rF2#frndint 16rD9 16rFC#fscale 16rD9 16rFD#fsin 16rD9 16rFE#fsincos 16rD9 16rFB#fsqrt 16rD9 16rFA#ftst 16rD9 16rE4#fucompp 16rDA 16rE9#fwait 16r9B#fxam 16rD9 16rE5#fxtract  16rD9 16rF4#fyl2x  16rD9 16rF1#fyl2xp1 16rD9 16rF9#int3 16rCC#leave  16rC9#lfence 16r0F 16rAE 16rE8#lock 16rF0 "prefix"#mfence 16r0F 16rAE 16rF0#monitor 16r0F 16r01 16rC8#mwait 16r0F 16r01 16rC9#nop 16r90#pause 16rF3 16r90"#popad 16r61 32 bit"#popfd 16r9D#popfq 16r48 16r9D   "- 64 bit ""#pushad 16r60 32 bit"#pushf 16r66 16r9C"#pushfd 16r9C 32 bit"#pushfq 16r9c" -64 bit"#rdtsc 16r0F 16r31  #rdtscp 16r0F 16r01 16rF9#sahf 16r9E#sfence 16r0F 16rAE 16rF8#stc 16rF9#std 16rFD#ud2 16r0F 16r0B#std 16rFD "dummy") readStream.[ str atEnd ] whileFalse: [	| instr tst bytes |	instr := str next.	tst := OrderedCollection new.	[ str peek isInteger ] whileTrue: [ tst add: str next  ].	asm reset noStackFrame.	asm perform: instr.	bytes := asm bytes.	self assert: (bytes = tst asByteArray ) description: instr, ' failed. expected ', tst asByteArray printString, ' but got ', bytes asByteArray printString.].! !!AJx64AssemblerTests methodsFor: 'tests' stamp: 'MartinMcClure 1/25/2013 20:37'!testAssemblyImmAddr	"This is not supported in 64-bit mode -- the ModRM value for this results in RIP-relative addressing."	<expectedFailure>	super testAssemblyImmAddr! !!AJx64AssemblerTests methodsFor: 'tests' stamp: 'MartinMcClure 1/1/2013 22:32'!testAssemblyMemBase	self 		assert: [ :a | a mov: a RAX ptr to: a EAX ]		bytes: #[ 16r8B 2r00000000 ].			self 		assert: [ :a | a mov: a RSP ptr to: a EAX]		bytes: #[ 16r8B 16r04 16r24 ].	self 		assert: [ :a | a mov: a RBP ptr to: a EAX ]		bytes: #[ 16r8B 16r45 16r00 ].! !!AJx64AssemblerTests methodsFor: 'tests' stamp: 'MartinMcClure 1/1/2013 22:14'!testAssemblyMemBaseDisp	asm		mov: RAX ptr + 1 -> EAX;		mov: RBX ptr + ECX -> EAX.	self assert: asm bytes = #(16r8B 16r40 16r01 16r8B 16r04 16r0B) asByteArray! !!AJx64AssemblerTests methodsFor: 'tests' stamp: 'MartinMcClure 1/1/2013 22:14'!testAssemblyMemBaseDisp2	asm		mov: RAX ptr - 1 -> EAX;		mov: (RBX ptr + ECX) * 2 - 5 -> EAX.	self assert: asm bytes = #(16r8B 16r40 16rFF 16r8B 16r44 16r4B 16rFB) asByteArray! !!AJx64AssemblerTests methodsFor: 'tests' stamp: 'MartinMcClure 1/1/2013 22:14'!testAssemblyMemBytes	asm		mov: (RSI ptr + ECX size: 1) -> BL;		mov: BL -> (RSI ptr + ECX size: 1).	self assert: asm bytes = #(16r8A 16r1C 16r0E 16r88 16r1C 16r0E) asByteArray! !!AJx64AssemblerTests methodsFor: 'tests' stamp: 'CamilloBruni 5/15/2012 14:19'!testBitTest	"8 Bit ====================================================="	self asmShould: [ :a| a bt: a R8B with: 16r1. ] raise: Error.		"16 bit ====================================================="	"lower bank 16bit register opcode + ModR/M"	self 		assert: [ :a| a bt: a AX with: 16r01 ]		bytes: #[ "16bit mode" 16r66  "OP" 16r0f 16rba "ModRM" 2r11100000 "immediate" 16r01].	"upper bank 16bit register opcode + ModR/M"	self 		assert: [ :a| a bt: a R8W with: 16r01 ]		bytes: #[ "16bit mode" 16r66 "REX" 2r01000001 "OP" 16r0f 16rba "ModRM" 2r11100000 "immediate" 16r01].			"32 bit ====================================================="	"lower bank 32bit register opcode + ModR/M"	self 		assert: [ :a| a bt: a EAX with: 16r01 ]		bytes: #[ "OP" 16r0f 16rba "ModRM" 2r11100000 "immediate" 16r01].		"upper bank 32bit register opcode + ModR/M"	self 		assert: [ :a| a bt: a R8D with: 16r01 ]		bytes: #[ "REX" 2r01000001 "OP" 16r0f 16rba "ModRM" 2r11100000 "immediate" 16r01].		"64 bit ====================================================="	"lower bank 32bit register opcode + ModR/M"	self 		assert: [ :a| a bt: a RAX with: 16r01 ]		bytes: #[ "REX" 2r01001000 "OP" 16r0f 16rba "ModRM" 2r11100000 "immediate" 16r01].		"upper bank 32bit register opcode + ModR/M"	self 		assert: [ :a| a bt: a R8 with: 16r01 ]		bytes: #[ "REX" 2r01001001 "OP" 16r0f 16rba "ModRM" 2r11100000 "immediate" 16r01].! !!AJx64AssemblerTests methodsFor: 'tests' stamp: 'MartinMcClure 1/27/2013 21:32'!testByteRegs4through7	"Test valid uses of byte registers SPL BPL SIL DIL, only available in 64-bit mode, and when using a REX prefix.	Can't be used in the same instruction with AH, CH, DH, or BH -- this is tested in testHighByteRegistersInvalid."	| byteRegs op2codes opBothCodes mixedWidthOpCodes byteRMOperands wideRegisters |	"byteRegs -- register -> contribution to ModRM byte when used as the reg operand"	byteRegs := {(SPL -> 16r20).	(BPL -> 16r28).	(SIL -> 16r30).	(DIL -> 16r38)}.	"opBothCodes -- #selector -> #(opcode when byteReg second arg, opcode when byteReg first arg)"	opBothCodes := {(#adc:with: -> #(16r10 16r12)).	(#add:with: -> #(16r00 16r02)).	(#mov:with: -> #(16r88 16r8A)).	(#cmp:with: -> #(16r38 16r3A)).	(#or:with: -> #(16r08 16r0A)).	(#sbb:with: -> #(16r18 16r1A)).	(#sub:with -> #(16r28 16r2A)).	(#xor:with: -> #(16r30 16r32))}.	"op2Codes -- #selector -> multiByteBytecode. ByteReg is always the second arg"	op2codes := {(#cmpxchg:with: -> #[16r0F 16rB0]).	(#test:with: -> #[16r84]).	(#xadd:with: -> #[16r0F 16rC0])	"xchg is not actually supported at this time (#xchg:with: -> #[16r86])"}.	"mixedWidthOpCodes -- #selector -> multiByteBytecode. ByteReg is always the second arg"	mixedWidthOpCodes := {(#movsx:with: -> #[16r0F 16rBE]).	(#movzx:with: -> #[16r0F 16rB6])}.	"**** Handle #crc32:with: separately due to its legacy prefix ****"	"wideRegisters -- register -> #[REX prefix, contribution to ModRM byte when used as r/m operand]"	wideRegisters := {(EAX -> #[16r40 16rC0]).	(RAX -> #[16r48 16rC0]).	(R8D -> #[16r44 16rC0]).	(R8 -> #[16r4C 16rC0])}.	"byteRMOperands -- operand -> #(REX prefix, #[modRMContribution, SIB and displacement bytes if any])"	byteRMOperands := {(SPL -> #(16r40 #[16rC4])).	(BPL -> #(16r40 #[16rC5])).	(SIL -> #(16r40 #[16rC6])).	(DIL -> #(16r40 #[16rC7])).	(R8B -> #(16r41 #[16rC0])).	(AL -> #(16r40 #[16rC0])).	(R8 ptr -> #(16r41 #[16r00])).	(RAX ptr -> #(16r40 #[16r00])).	(R8 ptr + 16r12 -> #(16r41 #[16r40 16r12])).	(RAX ptr + 16r12 -> #(16r40 #[16r40 16r12])).	(R8 ptr + 16r1234 -> #(16r41 #[16r80 16r34 16r12 16r00 16r00])).	(RAX ptr + 16r1234 -> #(16r40 #[16r80 16r34 16r12 16r00 16r00])).	((RAX ptr + R8) * 2 -> #(16r42 #[16r04 16r40])).	((RAX ptr + RAX) * 2 -> #(16r40 #[16r04 16r40])).	((RAX ptr + R8) * 4 + 16r12 -> #(16r42 #[16r44 16r80 16r12])).	((RAX ptr + RAX) * 4 + 16r12 -> #(16r40 #[16r44 16r80 16r12])).	((RAX ptr + R8) * 8 + 16r1234 -> #(16r42 #[16r84 16rC0 16r34 16r12 16r00 16r00])).	((RAX ptr + RAX) * 8 + 16r1234 -> #(16r40 #[16r84 16rC0 16r34 16r12 16r00 16r00]))}.	byteRegs		do: [ :reg | 			byteRMOperands				do: [ :rm | 					opBothCodes						do: [ :opcode | 							| opcodeByte op1 op2 |							op1 := reg key.							op2 := rm key.							opcodeByte := opcode value last.							self								assert: [ :a | a perform: opcode key with: op1 with: op2 ]								bytes:									(ByteArray with: rm value first with: opcodeByte with: reg value | rm value last first) , rm value last allButFirst	"REX"	"ModRM"	"SIB and displacement"	"Need to add the necessary data to allow testing the reverse order of operands." ].					op2codes						do: [ :opcode | 							self								assert: [ :a | a perform: opcode key with: rm key with: reg key ]								bytes:									((ByteArray with: rm value first) , opcode value copyWith: reg value | rm value last first) , rm value last allButFirst	"REX"	"ModRM"	"SIB and displacement" ] ].			mixedWidthOpCodes				do: [ :opcode | 					wideRegisters						do: [ :rm | 							self								assert: [ :a | a perform: opcode key with: rm key with: reg key ]								bytes: ((ByteArray with: rm value first) , opcode value copyWith: reg value >> 3 | rm value last)	"REX"	"ModRM"	"SIB and displacement" ] ] ]! !!AJx64AssemblerTests methodsFor: 'tests' stamp: 'MartinMcClure 1/27/2013 16:46'!testCall	"relative calls ==================================================================="	"8bit offset"	self assert: [:a | a call: 16r12 ] bytes: #[ 16rE8 16r12 0 0 0].	"16bit offset"	self assert: [:a | a call: 16r1234 ] bytes: #[ 16rE8 16r34 16r12 0 0 ].	"32bit offset"	self assert: [:a | a call: 16r12345678 ] bytes: #[ 16rE8 16r78 16r56 16r34 16r12 ].		"indirect calls ==================================================================="	"lower bank register"	self assert: [:a | a call: asm RAX ] bytes: #[ 16rFF 2r11010000 ].	self assert: [:a | a call: asm RDI ] bytes: #[ 16rFF 2r11010111 ].		"upper bank register (require REX prefix)"	self assert: [:a | a call: asm R8 ] bytes: #[ 2r01001001 16rFF 2r11010000 ].	self assert: [:a | a call: asm R15 ] bytes: #[ 2r01001001 16rFF 2r11010111 ].		"double indirect calls (with ModR/M) =============================================="	"mod = 2r00"	"lower bank register"	self assert: [:a | a call: a RAX ptr ] bytes: #[ 16rFF 2r00010000 ].	self assert: [:a | a call: a RDI ptr ] bytes: #[ 16rFF 2r00010111 ].		"upper bank register (require REX prefix)"	self assert: [:a | a call: a R8 ptr ] bytes: #[ 2r01000001 16rFF 2r00010000 ].	self assert: [:a | a call: a R15 ptr ] bytes: #[ 2r01000001 16rFF 2r00010111 ].		"double indirect calls with offsets =============================================="	"mod = 2r01 hence with a folllwing 8bit offset"	"lower bank register"	self assert: [:a | a call: a RAX ptr + 8 ] bytes: #[ 16rFF 2r01010000 8].	self assert: [:a | a call: a RDI ptr + 8 ] bytes: #[ 16rFF 2r01010111 8].		"upper bank register (require REX prefix)"	self assert: [:a | a call: a R8 ptr + 8] bytes: #[ 2r01000001 16rFF 2r01010000 8].	self assert: [:a | a call: a R15 ptr + 8] bytes: #[ 2r01000001 16rFF 2r01010111 8].		"double indirect calls with offsets =============================================="	"mod = 2r10 hence with a following 32bit offset"	"lower bank register"	self assert: [:a | a call: a RAX ptr + 16r12345678 ] bytes: #[ 16rFF 2r10010000 16r78 16r56 16r34 16r12].	self assert: [:a | a call: a RDI ptr + 16r12345678 ] bytes: #[ 16rFF 2r10010111 16r78 16r56 16r34 16r12].		"upper bank register (require REX prefix)"	self assert: [:a | a call: a R8 ptr + 16r12345678] bytes: #[ 2r01000001 16rFF 2r10010000 16r78 16r56 16r34 16r12].	self assert: [:a | a call: a R15 ptr + 16r12345678] bytes: #[ 2r01000001 16rFF 2r10010111 16r78 16r56 16r34 16r12].! !!AJx64AssemblerTests methodsFor: 'tests' stamp: 'MartinMcClure 1/25/2013 19:31'!testCallInvalid	"on 64 bit ..	- only 32bit relative offset are allowed	- only 64bit registers for indirect addresses"	"relative calls with 64bit addresses are not supported"	self asmShould: [ :a | a call: 16r123456789ABCDEF ] raise: Error.	AJx86Registers generalPurpose		do: [ :register | 			register is64				ifFalse: [ self asmShould: [ :a | a call: register ] raise: Error ]				ifTrue: [ self deny: (self bytes: [ :a | a call: register ]) isEmpty ] ]! !!AJx64AssemblerTests methodsFor: 'tests' stamp: 'MartinMcClure 1/26/2013 15:50'!testHighByteRegistersInvalid	"Can't access AH, BH, CH, DH if a REX byte is required.	This test attempts to test every instruction supported by AsmJit that can access an 8-bit general-purpose register AND also require a REX prefix."	| legacyHRegs op2codes opBothCodes mixedWidthOpCodes byteOperandsRequiringRex wideRegistersRequiringRex |	legacyHRegs := {AH.	CH.	DH.	BH}.	opBothCodes := #(#adc:with: #add:with: #mov:to: #cmp:with: #or:with: #sbb:with: #sub:with #xchg:with: #xor:with:).	op2codes := #(#cmpxchg:with: #test:with: #xadd:with:).	mixedWidthOpCodes := #(#crc32:with: #movsx:to: #movzx:to:).	wideRegistersRequiringRex := {RAX.	R8D}.	"RAX requires REX.W, R8D requires REX.R or REX.B"	byteOperandsRequiringRex := {SPL.	BPL.	SIL.	DIL.	R8B.	(R8 ptr).	(R8 ptr + 16r12).	(R8 ptr + 16r1234).	((RAX ptr + R8) * 2).	((RAX ptr + R8) * 4 + 16r12).	((RAX ptr + R8) * 8 + 16r1234)}.	legacyHRegs		do: [ :hreg | 			byteOperandsRequiringRex				do: [ :operand | 					opBothCodes						do: [ :opcode | 							self asmShould: [ :a | a perform: opcode with: hreg with: operand ] raise: Error.							self asmShould: [ :a | a perform: opcode with: operand with: hreg ] raise: Error ].					op2codes do: [ :opcode | self asmShould: [ :a | a perform: opcode with: operand with: hreg ] raise: Error ] ].			mixedWidthOpCodes				do: [ :opcode | 					wideRegistersRequiringRex						do: [ :wideReg | self asmShould: [ :a | a perform: opcode with: wideReg with: hreg ] raise: Error ] ] ]! !!AJx64AssemblerTests methodsFor: 'tests' stamp: 'MartinMcClure 1/1/2013 22:14'!testImmLabels	"test immediates with labels"	| code pos |	asm		mov: RAX ptr -> EAX;		mov: (16rFFFFFFFF asUImm label: (asm labelNamed: #foo)) to: EAX.	code := asm generatedCode.	pos := code offsetAt: #foo.	self assert: (code bytes at: pos + 1) = 255.	self assert: (code bytes at: pos + 2) = 255.	self assert: (code bytes at: pos + 3) = 255.	self assert: (code bytes at: pos + 4) = 255! !!AJx64AssemblerTests methodsFor: 'tests' stamp: 'MartinMcClure 1/3/2013 21:36'!testIndexScales	self		assert: [ :a | a mov: RAX -> ((RCX ptr + RDX) * 1) ] bytes: #[16r48 16r89 16r04 16r11];		assert: [ :a | a mov: RAX -> ((RCX ptr + RDX) * 2) ] bytes: #[16r48 16r89 16r04 16r51];		assert: [ :a | a mov: RAX -> ((RCX ptr + RDX) * 4) ] bytes: #[16r48 16r89 16r04 16r91];		assert: [ :a | a mov: RAX -> ((RCX ptr + RDX) * 8) ] bytes: #[16r48 16r89 16r04 16rD1].	self		assert: [ :a | a mov: (RCX ptr + RDX) * 1 -> RAX ] bytes: #[16r48 16r8B 16r04 16r11];		assert: [ :a | a mov: (RCX ptr + RDX) * 2 -> RAX ] bytes: #[16r48 16r8B 16r04 16r51];		assert: [ :a | a mov: (RCX ptr + RDX) * 4 -> RAX ] bytes: #[16r48 16r8B 16r04 16r91];		assert: [ :a | a mov: (RCX ptr + RDX) * 8 -> RAX ] bytes: #[16r48 16r8B 16r04 16rD1]! !!AJx64AssemblerTests methodsFor: 'tests' stamp: 'MartinMcClure 1/25/2013 20:53'!testInvalidTest	"In 64-bit mode, r/m8 cannot be encoded to access the following byte registers if an REX prefix is used: AH, BH, CH, DH."	{AH.	CH.	DH.	BH}		do: [ :reg | 			self deny: (self bytes: [ :a | a test: reg with: AL ]) isEmpty.			self deny: (self bytes: [ :a | a test: AL with: reg ]) isEmpty.			self deny: (self bytes: [ :a | a test: reg with: 16r12 ]) isEmpty.	"with an upper bank byte register => requires REX prefix"			self asmShould: [ :a | a test: reg with: R8B ] raise: Error.			self asmShould: [ :a | a test: R8B with: reg ] raise: Error.	"with a 64bit register requring again an REX prefix"			self asmShould: [ :a | a test: reg with: RAX ] raise: Error.			self asmShould: [ :a | a test: RAX with: reg ] raise: Error ]! !!AJx64AssemblerTests methodsFor: 'tests' stamp: 'MartinMcClure 1/1/2013 22:36'!testJumps	self 		assert: [:a|			a 				label: #label1;				nop;				nop;				nop;				jz: #label1.		] bytes: #[144 144 144 16r74 251 "-5 asByte"].				asm 		reset; noStackFrame;		label: #label1.		126 timesRepeat: [ asm nop ].		asm jz: #label1.	self assert: (asm bytes size = 128).	self 		assert: [:a |			a				reset; noStackFrame;				label: #label1;				nop;				nop;				nop;				jmp: #label1.		] bytes: #[144 144 144 235 251 ].		self 		assert: [:a |			a 				reset; noStackFrame;				jmp: #label1;				label: #label1.		] bytes: #[ 16rEB 0 ].		! !!AJx64AssemblerTests methodsFor: 'tests' stamp: 'MartinMcClure 1/4/2013 21:57'!testMovHighIndexRegister	"Mov that use r8-r15 as an index register, therefore requiring REX.X"	self		assert: [ :a | a mov: RAX -> ((RCX ptr + R14) * 1) ] bytes: #[16r4A 16r89 16r04 16r31];		assert: [ :a | a mov: (RCX ptr + R14) * 1 -> RAX ] bytes: #[16r4A 16r8B 16r04 16r31]! !!AJx64AssemblerTests methodsFor: 'tests' stamp: 'MartinMcClure 1/1/2013 22:37'!testMovImmediate	"8bit immediate to 8bit register"	self 		assert: [:a | a mov: 16r12 to: a AL ] 		bytes: #[16rB0     16r12].			"16bit immediate to 16bit register (requires 16bit fallback prefix)"	self 		assert: [:a | a mov: 16r1234 to: a AX ] 		bytes: #[16r66 16rB8     16r34 16r12].		"32bit immediate to 32bit register"	self 		assert: [:a | a mov: 16r12345678 to: a EAX ] 		bytes: #[16rB8     16r78 16r56 16r34 16r12].		"64bit immediate to 64bit register (requires REX prefix)"	self 		assert: [:a | a mov: 16r123456789ABCDEF0 to: a RAX ] 		bytes: #[2r01001000 16rB8    16rF0 16rDE 16rBC 16r9A 16r78 16r56 16r34 16r12].			"32bit immediate sign-extended to 64bit register (REX prefix)"	self		assert: [:a | a mov: 16r12345678 to: a RAX]		bytes: #[ 2r01001000 16rc7 "ModR/M"16rc0    16r78 16r56 16r34 16r12 ]! !!AJx64AssemblerTests methodsFor: 'tests' stamp: 'MartinMcClure 1/1/2013 22:37'!testMovMemory	"mov memory to 8bit register =========================="	self 		assert: [:a | a mov: a RCX ptr to: a AL ] 		bytes: #[16r8A 16r00000001 "ModR/M"].	! !!AJx64AssemblerTests methodsFor: 'tests' stamp: 'MartinMcClure 1/25/2013 21:11'!testMovZX	"byte to word ========================================"	"lower bank 8bit to lower bank 16bit"	self 		assert: [:a | a movzx: a AL to: a AX ]		bytes: #[102 15 182 192 ].	"lower bank 8bit to upper bank 16bit"	self 		assert: [:a | a movzx: a AL to: a R8W ]		bytes: #[102 68 15 182 192].	"upper bank 8bit to lower bank 16bit"	self 		assert: [:a | a movzx: a R8B to: a AX ]		bytes: #[102 65 15 182 192].	"upper bank 8bit to upper bank 16bit"	self 		assert: [:a | a movzx: a R8B to: a R8W ]		bytes: #[102 69 15 182 192].		"byte to doubleword ================================"	"lower bank 8bit to lower bank 32bit"	self 		assert: [:a | a movzx: a AL to: a EAX ]		bytes: #[15 182 192 ].	"lower bank 8bit to upper bank 32bit"	self 		assert: [:a | a movzx: a AL to: a R8D ]		bytes: #[68 15 182 192].	"upper bank 8bit to lower bank 32bit"	self 		assert: [:a | a movzx: a R8B to: a EAX ]		bytes: #[65 15 182 192].	"upper bank 8bit to upper bank 32bit"	self 		assert: [:a | a movzx: a R8B to: a R8D ]		bytes: #[69 15 182 192].		"byte to quadword ==================="	"lower bank 8bit to lower bank 64bit"	self 		assert: [:a | a movzx: a AL to: a RAX ]		bytes: #[72 15 182 192 ].	"lower bank 8bit to upper bank 64bit"	self 		assert: [:a | a movzx: a AL to: a R8 ]		bytes: #[76 15 182 192].	"upper bank 8bit to lower bank 64bit"	self 		assert: [:a | a movzx: a R8B to: a RAX ]		bytes: #[73 15 182 192 ].	"upper bank 8bit to upper bank 64bit"	self 		assert: [:a | a movzx: a R8B to: a R8 ]		bytes: #[77 15 182 192].		"word to quadword ==================="	"lower bank 16bit to lower bank 64bit"	self 		assert: [:a | a movzx: a AX to: a RAX ]		bytes: #[72 15 183 192].	"lower bank 16bit to upper bank 64bit"	self 		assert: [:a | a movzx: a AX to: a R8 ]		bytes: #[76 15 183 192].	"upper bank 16bit to lower bank 64bit"	self 		assert: [:a| a movzx: a R8W to: a RAX ]		bytes: #[73 15 183 192].	"upper bank 16bit to upper bank 64bit"	self 		assert: [:a | a movzx: a R8W to: a R8 ]		bytes: #[77 15 183 192].! !!AJx64AssemblerTests methodsFor: 'tests' stamp: 'MartinMcClure 1/25/2013 19:34'!testMovZxSxInvalid	{AH.	CH.	DH.	BH}		do: [ :reg | 			self deny: (self bytes: [ :a | a movzx: reg to: a EAX ]) isEmpty.			self asmShould: [ :a | a movzx: reg to: a RAX ] raise: Error ]! !!AJx64AssemblerTests methodsFor: 'tests' stamp: 'MartinMcClure 1/1/2013 22:40'!testMul	"8bit unsigned multiplication =================================="	"lower bank register: AX := AL * CL"	self 		assert: [ :a | a mul: a CL]		bytes: #[ 16rF6 "ModR/M" 2r11100001 ].	"upper bank register needs an REX prefix: AX := AL * R8B"	self 		assert: [ :a | a mul: a R9B]		bytes: #[ 2r01000001 16rF6 2r11100001].			"16bit unsigned multiplication =================================="		"DX:AX := AX * CX"	self 		assert: [ :a | a mul: a CX]		bytes: #[ "16bit fallback" 16r66 16rF7 2r11100001].	"32bit unsigned multiplication =================================="		"EDX:EAX := EAX * ECX"	self 		assert: [ :a | a mul: a ECX]		bytes: #[ 16rF7 2r11100001 ].	"64bit unsigned multiplication =================================="		"RDX:RAX := RAX * RCX"	self 		assert: [ :a| a mul: a RCX]		bytes: #[ 2r01001000 16rF7 2r11100001].! !!AJx64AssemblerTests methodsFor: 'tests' stamp: 'MartinMcClure 1/1/2013 22:42'!testNeg	"8bit ======================================================"	self 		assert: [ :a | a neg: a AL]		bytes: #[ 16rF6 "ModR/M" 2r11011000 ].	"8bit upper bank with REX"	self 		assert: [ :a | a neg: a R8B]		bytes: #[ 2r01000001 16rF6 "ModR/M" 2r11011000 ].		"16bit with fallback ======================================="	self 		assert: [ :a | a neg: a AX]		bytes: #[ 16r66 16rF7"ModR/M" 2r11011000 ].	"16bit upper bank with REX"	self 		assert: [ :a | a neg: a R8W]		bytes: #[ 16r66 2r01000001 16rF7"ModR/M" 2r11011000 ].	"word 16bit IP relative "	self 		assert: [ :a | a neg: a IP ptr16 + 16r12345678]		bytes: #[16r66 16rF7 "ModR/M"2r00011101 16r78 16r56 16r34 16r12].			"32bit ===================================================="	self 		assert: [ :a | a neg: a EAX]		bytes: #[ 16rF7"ModR/M" 2r11011000 ].	"32bit upper bank with REX"	self 		assert: [ :a | a neg: a R8D]		bytes: #[ 2r01000001 16rF7"ModR/M" 2r11011000 ].	"negate double word 32bit EIP relative "	self 		assert: [ :a | a neg: a EIP ptr32 + 16r12345678]		bytes: #[16rF7 "ModR/M"2r00011101 16r78 16r56 16r34 16r12].			"64bit with REX =========================================="	self 		assert: [ :a | a neg: a RAX]		bytes: #[ 2r01001000 16rF7 "ModR/M"2r11011000 ].	"64bit upper bank"	self 		assert: [ :a | a neg: a R8]		bytes: #[ 2r01001001 16rF7 "ModR/M"2r11011000 ].	"negate quadword 64bit RIP relative "	self 		assert: [ :a | a neg: a RIP ptr64 + 16r12345678]		bytes: #["REX"2r01001000 16rF7 "ModR/M"2r00011101 16r78 16r56 16r34 16r12].		! !!AJx64AssemblerTests methodsFor: 'tests' stamp: 'MartinMcClure 1/1/2013 22:42'!testPop	"lower bank 64bit register"			self assert: [:a | a pop: a RSP ]		bytes: #[ 16r5c ].! !!AJx64AssemblerTests methodsFor: 'tests' stamp: 'MartinMcClure 1/1/2013 22:42'!testPush	"lower bank 64bit register"			self assert: [:a | a push: a RSP ]		bytes: #[ 16r54 "16r50 + RSP index" ].! !!AJx64AssemblerTests methodsFor: 'tests' stamp: 'MartinMcClure 12/15/2012 13:13'!testSyscall	self assert: [ :a | a syscall ] bytes: #[16r0F 16r05]! !!AJx64AssemblerTests methodsFor: 'tests' stamp: 'MartinMcClure 1/1/2013 22:44'!testTest	"8bit operand  and lower bank 8bit register"			self assert: [:a | a test: a CL with: 16r12 ]		bytes: #[246	 193 16r12].	"8bit operand  and uppe bank 8bit register"		self assert: [:a | a test: a R8B with: 16r12]		bytes: #[2r01000001 2r11110110  2r11000000  16r12].		"16bit operand  and lower bank 16bit register"			self assert: [:a | a test: a CX with: 16r1234]		bytes: #[102 247 193   16r34 16r12].	"16bit operand  and uppe bank 16bit register"		self assert: [:a | a test: a R8W with: 16r1234]		bytes: #[102 65 247 192   16r34 16r12].		"32bit operand  and lower bank 32bit register"			self assert: [:a | a test: a ECX with: 16r12345678]		bytes: #[247 193   16r78 16r56 16r34 16r12].	"32bit operand  and uppe bank 32bit register"		self assert: [:a | a test: a R8D with: 16r12345678]		bytes: #[65 247 192   16r78 16r56 16r34 16r12].		"32bit operand  and lower bank 64bit register"			self assert: [:a| a test: a RCX with: 16r12345678]		bytes: #[72 247 193   16r78 16r56 16r34 16r12].	"32bit operand  and uppe bank 64bit register"		self assert: [:a| a test: a R8 with: 16r12345678]		bytes: #[73 247 192	  16r78 16r56 16r34 16r12].			! !!AJx64AssemblerTests methodsFor: 'tests' stamp: 'MartinMcClure 1/1/2013 22:44'!testXor	"8bit register xor 8bit immediate =================================="			"lower bank 8bit register opcode + ModR/M"	self 		assert: [ :a | a xor: a CL with: 16r12]		bytes: #[ 16r80 2r11110001    16r12].			"upper bank 8bit register requiring REX"	self 		assert: [ :a | a xor: a R8B with: 16r12]		bytes: #[2r01000001 16r80 2r11110000    16r12].			"16bit register xor 8bit immediate =================================="	"lower bank 16bit register"	self 		assert: [ :a | a xor: a CX with: 16r1234]		bytes: #[16r66 16r81 2r11110001    16r34 16r12].	"upper bank 16bit"	self 		assert: [ :a | a xor: a R8W with: 16r1234]		bytes: #[16r66 2r01000001 16r81 2r11110000 16r34 16r12].			"32bit register ====================================================="	"lower bank 32bit register"	self 		assert: [ :a | a xor: a ECX with: 16r12345678]		bytes: #[16r81 2r11110001    16r78 16r56 16r34 16r12].			"upper bank register requiring REX prefix"	self 		assert: [ :a | a xor: a R8D with: 16r12345678]		bytes: #[2r01000001 16r81 2r11110000     16r78 16r56 16r34 16r12]	! !!AJx64AssemblerTests methodsFor: 'tests' stamp: 'MartinMcClure 1/1/2013 22:45'!testXorFastCode	self  "shortcut for AL + 8bit immedidate"		assert: [ :a | a xor: a AL with: 16r12]		bytes: #[ 16r34    16r12].			self  "shortcut for AX + 16bit immedidate"		assert: [ :a | a xor: a AX with: 16r1234]		bytes: #[ 16r66 16r35    16r34 16r12].			self  "shortcut for EAX + 16bit immedidate"		assert: [ :a | a xor: a EAX with: 16r12345678]		bytes: #[ 16r35    16r78 16r56 16r34 16r12].			self  "shortcut for RAX + 32bit immedidate"		assert: [ :a | a xor: a RAX with: 16r12345678]		bytes: #[ 2r01001000 16r35    16r78 16r56 16r34 16r12].! !!AJx64AssemblerTests methodsFor: 'tests' stamp: 'MartinMcClure 1/25/2013 19:41'!testXorInvalid	"xor registers with non-matching sizes"	self asmShould: [ :a | a xor: AL to: RAX ] raise: Error.	self asmShould: [ :a | a xor: RAX to: AL ] raise: Error.	self asmShould: [ :a | a xor: R8B to: RAX ] raise: Error.	self asmShould: [ :a | a xor: RAX to: R8B ] raise: Error.	"in 64bit mode AH CH DH and BH cannot be encoded when an REX prefix is present"	{AH.	CH.	DH.	BH} do: [ :reg | self asmShould: [ :a | a xor: reg to: a R8B ] raise: Error ]! !!AJx86AssemblerTests methodsFor: 'utility'!asmShould: aBlock raise: anError	self should: [self bytes: aBlock] raise: anError.! !!AJx86AssemblerTests methodsFor: 'utility' stamp: 'CamilloBruni 8/22/2012 14:47'!assert: aBlock bytes: aByteArray	self assert: (self bytes: aBlock) equals: aByteArray .! !!AJx86AssemblerTests methodsFor: 'utility' stamp: 'MartinMcClure 1/1/2013 22:19'!bytes: aBlock	asm := self newAssembler.	aBlock value: asm.	^ asm bytes! !!AJx86AssemblerTests methodsFor: 'utility' stamp: 'CamilloBruni 4/3/2012 09:56'!newAssembler 	^ AJx86Assembler new		noStackFrame;		yourself! !!AJx86AssemblerTests methodsFor: 'running'!setUp	super setUp.	asm := self newAssembler.! !!AJx86AssemblerTests methodsFor: 'tests-data' stamp: 'CamilloBruni 4/12/2012 14:25'!setUpDataBytes	^ self setUpDataBytesAlign: 1! !!AJx86AssemblerTests methodsFor: 'tests-data'!setUpDataBytesAlign: alignToBytes	asm nop.	asm align: alignToBytes.	^ asm db: 16r12.! !!AJx86AssemblerTests methodsFor: 'tests' stamp: 'CamilloBruni 4/3/2012 10:22'!testAssembly1		asm 		push: EBP;		mov: ESP -> EBP;		mov: 1024 -> EAX;		mov: EBP -> ESP;		pop: EBP;		ret.		self assert: asm bytes = #(85 139 236 184 0 4 0 0 139 229 93 195) asByteArray! !!AJx86AssemblerTests methodsFor: 'tests' stamp: 'CamilloBruni 4/3/2012 10:22'!testAssembly3	" instructions without operands.	(AJInstructionDescription instructions select: [:each | each group = #emit]) keys asSortedCollection	 "	| str |	str :=#(#cbw 16r66 16r98#cdq 16r99"#cdqe  64 bit "#clc 16rF8#cld 16rFC#cmc 16rF5 #cpuid 16r0F 16rA2"#cqo  64 bit "#cwd 16r66 16r99#cwde 16r98#daa 16r27#das 16r2F#emms 16r0F 16r77#f2xm1 16rD9 16rF0#fabs  16rD9 16rE1#fchs 16rD9 16rE0#fclex 16r9B 16rDB 16rE2#fcompp 16rDE 16rD9#fcos 16rD9 16rFF#fdecstp 16rD9 16rF6#fincstp 16rD9 16rF7#finit 16r9B 16rDB 16rE3#fld1 16rD9 16rE8#fldl2e 16rD9 16rEA#fldl2t 16rD9 16rE9#fldlg2 16rD9 16rEC#fldln2 16rD9 16rED#fldpi 16rD9 16rEB#fldz 16rD9 16rEE#fnclex 16rDB 16rE2#fninit 16rDB 16rE3#fnop 16rD9 16rD0#fpatan 16rD9 16rF3#fprem 16rD9 16rF8#fprem1 16rD9 16rF5#fptan 16rD9 16rF2#frndint 16rD9 16rFC#fscale 16rD9 16rFD#fsin 16rD9 16rFE#fsincos 16rD9 16rFB#fsqrt 16rD9 16rFA#ftst 16rD9 16rE4#fucompp 16rDA 16rE9#fwait 16r9B#fxam 16rD9 16rE5#fxtract  16rD9 16rF4#fyl2x  16rD9 16rF1#fyl2xp1 16rD9 16rF9#int3 16rCC#leave  16rC9#lfence 16r0F 16rAE 16rE8#lock 16rF0 "prefix"#mfence 16r0F 16rAE 16rF0#monitor 16r0F 16r01 16rC8#mwait 16r0F 16r01 16rC9#nop 16r90#pause 16rF3 16r90#popad 16r61#popfd 16r9D" #popfq 16r48 16r9D   - 64 bit "#pushad 16r60#pushf 16r66 16r9C#pushfd 16r9C" #pushfq -64 bit"#rdtsc 16r0F 16r31  #rdtscp 16r0F 16r01 16rF9#sahf 16r9E#sfence 16r0F 16rAE 16rF8#stc 16rF9#std 16rFD#ud2 16r0F 16r0B#std 16rFD "dummy") readStream.[ str atEnd ] whileFalse: [	| instr tst |	instr := str next.	tst := OrderedCollection new.	[ str peek isInteger ] whileTrue: [ tst add: str next  ].	asm reset noStackFrame.	asm perform: instr.	self assert: (asm bytes = tst asByteArray )].! !!AJx86AssemblerTests methodsFor: 'tests' stamp: 'IgorStasenko 5/28/2012 02:58'!testAssemblyImmAddr	"test generating immediate address, 	note GDB disassembling it to:		0x1fab <instructions.1862>:     0x8b    0x05    0xef    0xbe    0xad    0xde		0x00001fab <instructions.1862+0>:       mov    0xdeadbeef,%eax	which is WRONG!!	"	asm		mov: 16rdeadbeef asUImm ptr32 to: asm EAX. 	" 8b05efbeadde                   mov         eax, [deadbeef] "		self assert: asm bytes =  #[139 5 239 190 173 222]	! !!AJx86AssemblerTests methodsFor: 'tests' stamp: 'CamilloBruni 4/3/2012 10:22'!testAssemblyMemBase		asm 		mov: EAX ptr  -> EAX;		mov: ESP ptr -> EAX;		mov: EBP ptr -> EAX.		self assert: asm bytes = #(16r8B 0 16r8B 16r04 16r24 16r8B 16r45 16r00) asByteArray! !!AJx86AssemblerTests methodsFor: 'tests' stamp: 'CamilloBruni 4/3/2012 10:22'!testAssemblyMemBaseDisp	asm 		mov: EAX ptr + 1 -> EAX;		mov: EBX ptr + ECX -> EAX.		self assert: asm bytes = #(16r8B 16r40 16r01 16r8B 16r04 16r0B) asByteArray! !!AJx86AssemblerTests methodsFor: 'tests' stamp: 'CamilloBruni 4/3/2012 10:22'!testAssemblyMemBaseDisp2	asm 		mov: EAX ptr - 1 -> EAX;		mov: EBX ptr + ECX * 2 - 5 -> EAX.		self assert: asm bytes = #(16r8B 16r40 16rFF 16r8B 16r44 16r4B 16rFB) asByteArray! !!AJx86AssemblerTests methodsFor: 'tests' stamp: 'CamilloBruni 4/3/2012 10:22'!testAssemblyMemBytes	asm 		mov: ((ESI ptr + ECX) size: 1) -> BL;		mov: BL -> ((ESI ptr + ECX) size:1).			self assert: asm bytes = #(16r8A 16r1C 16r0E 16r88 16r1C 16r0E ) asByteArray! !!AJx86AssemblerTests methodsFor: 'tests' stamp: 'CamilloBruni 4/3/2012 10:22'!testBitTest	asm 		bt: EAX with: 0.	self assert: asm bytes =  #(16r0F 16rBA 16rE0 16r00) asByteArray! !!AJx86AssemblerTests methodsFor: 'tests' stamp: 'CamilloBruni 4/3/2012 10:22'!testCall	asm 		call: EAX;		call: EAX ptr - 4;		call: EAX ptr.	self assert: asm bytes =  #(255 208 255 80 252 255 16) asByteArray! !!AJx86AssemblerTests methodsFor: 'tests-data'!testDataBytes		|data|	data := self setUpDataBytes.		self assert: asm bytes equals: #[144   16r12].! !!AJx86AssemblerTests methodsFor: 'tests-data' stamp: 'CamilloBruni 4/12/2012 14:24'!testDataBytesAlignDouble		|data|	data := self setUpDataBytesAlign: 4.		self assert: asm bytes equals: #[144   0 0 0 16r12].! !!AJx86AssemblerTests methodsFor: 'tests-data' stamp: 'CamilloBruni 4/12/2012 14:24'!testDataBytesAlignQuad		|data|	data := self setUpDataBytesAlign: 8. 	self assert: asm bytes equals: #[144   0 0 0   0 0 0 0   16r12].! !!AJx86AssemblerTests methodsFor: 'tests-data' stamp: 'CamilloBruni 4/12/2012 14:25'!testDataBytesAlignWord		|data|	data := self setUpDataBytesAlign: 2.		self assert: asm bytes equals: #[144   0 16r12].! !!AJx86AssemblerTests methodsFor: 'tests-data' stamp: 'CamilloBruni 4/19/2012 11:51'!testDataDouble		| data|		asm nop.	data := asm dd: #[16r78 16r56 16r34 16r12].		self assert: asm bytes equals: #[144   16r78 16r56 16r34 16r12].! !!AJx86AssemblerTests methodsFor: 'tests-data'!testDataWord		| data|	asm nop.	data := asm dw: #[16r34 16r12].		self assert: asm bytes equals: #[144   16r34 16r12].		! !!AJx86AssemblerTests methodsFor: 'tests-FPU' stamp: 'CamilloBruni 7/23/2012 15:03'!testFXCH	self 		assert: [ :a|		a fxch "the same as: asm fxch: asm ST1" ]		bytes: #[	2r11011001 2r11001001 ]	! !!AJx86AssemblerTests methodsFor: 'tests-FPU' stamp: 'CamilloBruni 7/23/2012 15:15'!testFXCHST1	self 		assert: [ :a| a fxch: asm ST1 ]		bytes: #[	2r11011001 2r11001001 ]	! !!AJx86AssemblerTests methodsFor: 'tests' stamp: 'CamilloBruni 4/3/2012 10:23'!testForwardJumps		asm		jmp: #label1;		label: #label1.	self assert: asm bytes =  #(16rEB 0 ) asByteArray.		! !!AJx86AssemblerTests methodsFor: 'tests' stamp: 'CamilloBruni 4/3/2012 10:23'!testImmLabels	"test immediates with labels"		| code pos |		asm 		mov: EAX ptr  -> EAX;		mov: (16rFFFFFFFF asUImm label: (asm labelNamed: #foo) ) to:  EAX.		code := asm generatedCode.	pos := code offsetAt: #foo.	self assert: (code bytes at: pos+1) = 255.	self assert: (code bytes at: pos+2) = 255.	self assert: (code bytes at: pos+3) = 255.	self assert: (code bytes at: pos+4) = 255.! !!AJx86AssemblerTests methodsFor: 'tests' stamp: 'CamilloBruni 8/22/2012 14:50'!testJMPRegister		self 		assert: [  :assembler |			assembler jmp: assembler EAX ]		bytes: #[ 16rFF 2r11100000 ].			self 		assert: [  :assembler |			assembler jmp: assembler ECX ]		bytes: #[ 16rFF 2r11100001 ].			self 		assert: [  :assembler |			assembler jmp: assembler EDX ]		bytes: #[ 16rFF 2r11100010 ]! !!AJx86AssemblerTests methodsFor: 'tests' stamp: 'CamilloBruni 4/3/2012 10:23'!testJumps		asm 		label: #label1;		nop;		nop;		nop;		jz: #label1.			self assert: asm bytes =  #(144 144 144 116 251) asByteArray.		asm 		reset; noStackFrame;		label: #label1.		126 timesRepeat: [ asm nop ].		asm jz: #label1.	self assert: (asm bytes size = 128).		asm 		reset; noStackFrame;		label: #label1;		nop;		nop;		nop;		jmp: #label1.			self assert: asm bytes =  #(144 144 144 235 251) asByteArray.		asm		reset; noStackFrame;		jmp: #label1;		label: #label1.			self assert: asm bytes =  #(16rEB 0 ) asByteArray.		! !!AJx86AssemblerTests methodsFor: 'tests' stamp: 'CamilloBruni 4/3/2012 10:23'!testMovSxZx	asm 		movsx: asm AX to: asm EAX;		movzx: asm AX to: asm EAX;		movsx: asm AL to: asm EAX;		movzx: asm AH to: asm EAX.	self assert: asm bytes = 	#[		16r0F 16rBF 16rC0		16r0F 16rB7 16rC0		16r0F 16rBE 16rC0		16r0F 16rB6 16rC4 ]! !!AJx86AssemblerTests methodsFor: 'tests'!testRegistersOf: asm	| numRegs |	numRegs := asm numGPRegisters.		0 to: numRegs-1 do: [:i |		self assert: (asm reg8: i) size = 1.		self assert: (asm reg8: i) index = i.				self assert: (asm reg16: i) size = 2.		self assert: (asm reg16: i) index = i.				self assert: (asm reg32: i) size = 4.		self assert: (asm reg32: i) index = i.		self assert: (asm isGPNRegister: (asm nReg: i)).			asm is64BitMode ifTrue: [			self assert: (asm reg64: i) size = 8.			self assert: (asm reg64: i) index = i.			]		].	! !!AJx86AssemblerTests methodsFor: 'tests' stamp: 'MartinMcClure 12/15/2012 13:39'!testSyscall	"Syscall instruction is only valid in 64-bit mode"	self asmShould: [ :a | a syscall ] raise: Error! !!AJx86AssemblerTests methodsFor: 'tests' stamp: 'CamilloBruni 4/3/2012 10:23'!testTest	"Special RAX opcodes"		"8bit operand  opcode"			asm 		test: AL with: 5.	self assert: asm bytes = #[16rA8 05].		asm reset;		test: AX with: 5.	"16bit operand Prefix byte, 16bit immediate (LSB)"	self assert: asm bytes = #[16r66 16rA9 05 0].	"32bit operand "	asm reset;		test: EAX with: 1.	self assert: asm bytes =  #[16rA9 01 00 00 00].		"Need more assert for non-EAX receiver, non-immediate operands"			! !!AJx86RegisterTests methodsFor: 'as yet unclassified' stamp: 'MartinMcClure 1/30/2013 21:56'!testAsHighByte	| highByteRegs lowByteRegs otherGPRegs |	highByteRegs := {AH.	CH.	DH.	BH}.	lowByteRegs := {AL.	CL.	DL.	BL}.	otherGPRegs := AJx86Registers generalPurpose reject: [ :r | r isHighByte | r isLowByte ].	self assert: (highByteRegs collect: [ :r | r asHighByte ]) equals: highByteRegs.	self assert: (lowByteRegs collect: [ :r | r asHighByte ]) equals: highByteRegs.	self assert: otherGPRegs size equals: 60.	"16 of each size, less the lowByteRegs"	otherGPRegs do: [ :r | self should: [ r asHighByte ] raise: Error ]! !!AJx86RegisterTests methodsFor: 'as yet unclassified' stamp: 'MartinMcClure 1/30/2013 21:57'!testAsLowByte	| highByteRegs lowByteRegs otherGPRegs |	highByteRegs := {AH.	CH.	DH.	BH}.	lowByteRegs := {AL.	CL.	DL.	BL}.	otherGPRegs := AJx86Registers generalPurpose reject: [ :r | r isHighByte | r isLowByte ].	self assert: (highByteRegs collect: [ :r | r asLowByte ]) equals: lowByteRegs.	self assert: (lowByteRegs collect: [ :r | r asLowByte ]) equals: lowByteRegs.	self assert: otherGPRegs size equals: 60.	"16 of each size, less the lowByteRegs"	otherGPRegs do: [ :r | self should: [ r asLowByte ] raise: Error ]! !!AJx86RegisterTests methodsFor: 'as yet unclassified' stamp: 'MartinMcClure 1/30/2013 19:40'!testRegisterWidthConversions	"Test the generalPurpose register methods #as8, #as16, #as32, #as64. 	Some resulting registers are not valid except in 64-bit mode, but that is not checked until you try to use the register in an instruction."	| regs8 regs16 regs32 regs64 highByteRegs |	regs8 := {AL.	CL.	DL.	BL.	SPL.	BPL.	SIL.	DIL.	R8B.	R9B.	R10B.	R11B.	R12B.	R13B.	R14B.	R15B}.	regs16 := {AX.	CX.	DX.	BX.	SP.	BP.	SI.	DI.	R8W.	R9W.	R10W.	R11W.	R12W.	R13W.	R14W.	R15W}.	regs32 := {EAX.	ECX.	EDX.	EBX.	ESP.	EBP.	ESI.	EDI.	R8D.	R9D.	R10D.	R11D.	R12D.	R13D.	R14D.	R15D}.	regs64 := {RAX.	RCX.	RDX.	RBX.	RSP.	RBP.	RSI.	RDI.	R8.	R9.	R10.	R11.	R12.	R13.	R14.	R15}.	highByteRegs := {AH.	CH.	DH.	BH}.	self		assert: (regs8 collect: [ :r | r as8 ]) equals: regs8;		assert: (regs16 collect: [ :r | r as8 ]) equals: regs8;		assert: (regs32 collect: [ :r | r as8 ]) equals: regs8;		assert: (regs64 collect: [ :r | r as8 ]) equals: regs8.	self		assert: (regs8 collect: [ :r | r as16 ]) equals: regs16;		assert: (regs16 collect: [ :r | r as16 ]) equals: regs16;		assert: (regs32 collect: [ :r | r as16 ]) equals: regs16;		assert: (regs64 collect: [ :r | r as16 ]) equals: regs16.	self		assert: (regs8 collect: [ :r | r as32 ]) equals: regs32;		assert: (regs16 collect: [ :r | r as32 ]) equals: regs32;		assert: (regs32 collect: [ :r | r as32 ]) equals: regs32;		assert: (regs64 collect: [ :r | r as32 ]) equals: regs32.	self		assert: (regs8 collect: [ :r | r as64 ]) equals: regs64;		assert: (regs16 collect: [ :r | r as64 ]) equals: regs64;		assert: (regs32 collect: [ :r | r as64 ]) equals: regs64;		assert: (regs64 collect: [ :r | r as64 ]) equals: regs64.	self		assert: (highByteRegs collect: [ :r | r as8 ]) equals: highByteRegs;		assert: (highByteRegs collect: [ :r | r as16 ])			equals:				{AX.					CX.					DX.					BX};		assert: (highByteRegs collect: [ :r | r as32 ])			equals:				{EAX.					ECX.					EDX.					EBX};		assert: (highByteRegs collect: [ :r | r as64 ])			equals:				{RAX.					RCX.					RDX.					RBX}! !"AsmJit-Tests"!!NativeBoostConstants class methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 4/9/2010 11:00'!currentPlatformId	<primitive: 'primitivePlatformId' module: 'NativeBoostPlugin'>		self primitiveFailed! !!NativeBoostConstants class methodsFor: 'error codes' stamp: 'IgorStasenko 9/21/2012 15:46'!initErrorCodes	"An error codes used by Cog NB plugin.	Note, at the moment of writing this, a primitive error codes 	supported only in Cog VMs"		NBErrorBase := 500.	"execution of native code is not enabled by plugin"	ErrNotEnabled := NBErrorBase + 1.  		"failed to find a native code for primitive method"	ErrNoNativeCodeInMethod := NBErrorBase + 2. 		"native code generated for different platform"	ErrInvalidPlatformId := NBErrorBase + 3. 		 "the method which containing foreign call missing a #primitiveNativeCall primitive pragma"	ErrNoNBPrimitive := NBErrorBase + 4.	 	"the method has a 220 primitive (primitiveVoltage), but VM decided to execute this method via interpreter "	ErrRunningViaInterpreter := NBErrorBase + 5.		"A method uses primitive 220 (primitiveVoltage), but does not use an error code: <primitive: 220 error: errorCode> "	ErrInvalidPrimitiveVoltageUse := NBErrorBase + 6.! !!NativeBoostConstants class methodsFor: 'error codes' stamp: 'IgorStasenko 9/21/2012 15:37'!initErrorDescriptions	NBErrorDescriptions := Dictionary newFromPairs:	{		NBPrimNoErr. 'No error'.		NBPrimErrGenericFailure. 'Generic failure'.		NBPrimErrBadReceiver. 'Bad receiver'.		NBPrimErrBadArgument. 'Bad argument'.		NBPrimErrBadIndex. 'Bad index'.		NBPrimErrBadNumArgs. 'Invalid number of arguments'.		NBPrimErrInappropriate. 'Inappropriate operation'.		NBPrimErrUnsupported. 'unsupported operation'. 		NBPrimErrNoModification. 'No modification allowed to immutable object'.		NBPrimErrNoMemory. 'Insufficient object memory'.		NBPrimErrNoCMemory. 'Insufficient C memory'.		NBPrimErrNotFound. 'Not found'.		NBPrimErrBadMethod. 'Bad method'.		NBPrimErrNamedInternal. 'Internal error in named primitive machinery'.		NBPrimErrObjectMayMove. 'Object may move'.		NBPrimErrLimitExceeded. 'Resource limit exceeded'.			ErrNotEnabled. 'Execution of native code is not enabled by plugin'.		ErrNoNativeCodeInMethod. 'No native code installed in primitive method'.		ErrInvalidPlatformId. 'Native code in primitive method are for different platform'.			ErrNoNBPrimitive. 'A method where native code will be installed, missing a <primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode> pragma'.		ErrRunningViaInterpreter.  'A method with primitive 220 (primitiveVoltage), contains JIT code, but VM decided to execute this method via interpreter '.		ErrInvalidPrimitiveVoltageUse. 'A method uses primitive 220 (primitiveVoltage), but does not use an error code: <primitive: 220 error: errorCode> '	 }! !!NativeBoostConstants class methodsFor: 'error codes' stamp: 'IgorStasenko 8/6/2011 18:04'!initVMErrorCodes"took from OSCog's sqVirtualMachine.h"	NBPrimNoErr := 0.	NBPrimErrGenericFailure := 1.	NBPrimErrBadReceiver := 2.	NBPrimErrBadArgument := 3.	NBPrimErrBadIndex := 4.	NBPrimErrBadNumArgs := 5.	NBPrimErrInappropriate := 6.	NBPrimErrUnsupported := 7.	NBPrimErrNoModification := 8.	NBPrimErrNoMemory := 9.	NBPrimErrNoCMemory := 10.	NBPrimErrNotFound := 11.	NBPrimErrBadMethod := 12.	NBPrimErrNamedInternal := 13.	NBPrimErrObjectMayMove := 14.	NBPrimErrLimitExceeded := 15.! !!NativeBoostConstants class methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 8/6/2011 18:10'!initialize	"self initialize"	" Here the platform codes, defined to identify a platform on which VM runs.	A compiled method which contain native code using this id to indicate for what platform 	the native code is generated. 	A primitive, which responsible for running native code, checks that platform id in method matching the platform id,	specified by plugin, and if not, then primitive fails without attempt to run native code"	"x86 platform codes"	Linux32PlatformId := 1.	Mac32PlatformId := 2. 	Win32PlatformId := 3.	self 		initErrorCodes;		initVMErrorCodes;		initErrorDescriptions.	! !!NativeBoostConstants class methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 4/14/2010 15:03'!linux32PlatformId	^ Linux32PlatformId! !!NativeBoostConstants class methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 9/10/2012 12:07'!mac32PlatformId	^ Mac32PlatformId! !!NativeBoostConstants class methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 4/9/2010 11:03'!win32PlatformId	^ Win32PlatformId! !"NativeBoost-Pools"!!NBExternalHandle commentStamp: 'IgorStasenko 2/24/2012 17:37' prior: 0!Usually, my instances representing an opaque object handle returned by external function. There's little what we can do with it, except from passing as argument to another function(s).I hold a byte array of a pointer size (typicaly 4 or 8 bytes). You can set the raw handle value with #value: and read it with #value.Note, do not subclass from me directly. If you want to represent some opaque C  data structure (handle, stucture, pointer to structure etc),subclass from NBExternalObject instead. Otherwise, if you insist, override #asNBExternalType: method on class side in own subclass to provide own marshalling for instances of your subclass(es) (but it makes even less sense since once you define own #asNBExternalType:, you free to use any base class for your subclasses,unless of course you want to reuse some of my methods)!!NBExternalAddress commentStamp: 'IgorStasenko 2/24/2012 17:10' prior: 50468553!My primary function is to represent a pointer (address) to memory, in cases, when a kind of data under given address does not having any special structure,which can be reflected more nicely in language. Usually i can be used to hold pointer(s) to buffers (void*), or to allocated memory region etc.I providing some basic interface for reading/writing data into memory where i pointing to, as well as some convenience methods.!!NBExternalHeapManager commentStamp: 'Igor.Stasenko 9/25/2010 10:04' prior: 0!This is a simplistic implementation of external heap manager.Using it , you can allocate or free external memory.- should not throw any exceptions.If allocation fails, should simply answer nil/0 !!NBExternalObject commentStamp: 'IgorStasenko 2/24/2012 17:40' prior: 50469362!I representing an external object of one kind, provided by some external library/function.My instance holds a handle, which is used to identify the external object when i am passed as an argument, or when i'm used as a return type in function signature.A typical usage of me is to create a subclass, and then use that subclass name directly in function signatures:NBExternalObject subclass: #MyExternalObjectnewObj := MyExternalObject newObject.MyExternalObject class>>newObject  <primitive: #primitiveNativeCall ...> ^ self nbCall: #(MyExternalObject someExternalFunction() )here, assume that someExternalFunction() returns some handle (or pointer) to some opaque external structure. By putting NBExternalObject subclass (MyExternalObject) as a return typeinto the function signature, we are telling the code generator to automatically convert the return value into an instance of a given class and initialize its handle to the value returned by the function.When used as argument type, the value, which is used to pass to the external function is value held in my handle instance variable:MyExternalObject>>compareWith: anotherExternalObject  <primitive: #primitiveNativeCall ...>   ^ self nbCall: #( void compare ( self , MyExternalObject anotherExternalObject))The main advantage of using NBExternalObject subclass as a type name for arguments is that it provides type safety by checking the incoming argument, that itis an instance of your class, and nothing else. If not, the primitive will fail without calling the external function.!!NBExternalResourceExecutor commentStamp: '<historical>' prior: 0!i am responsible for finalizing an external resource,registered using external resource manager.When object, registered as external resource being garbage collected,i telling an object's class to finalize it's associated data (by passing an object,received from #resourceData message sent to an object at registration time).I automatically keep tracking for session change (image save/boot), and ignore finalization of resources of old sessions (since they are not longer valid,and cannot be freed since session changed).Like that, a users of NBExternalResourceManager don't need to implement a session checking logic, and need only to:a) register object as external resource:     NBExternalResourceManager addResource: anObject.an object should understand the #resourceData message, which is remembered at registration point (it can be any external resource like, id, handle or memory pointer).Then, when object is garbage collected, its class will receive a message to finalize the resource data in #finalizeResourceData:The passed data is exactly same as previously returned by #resourceData method.An example:Imagine that you want to represent an external resource by keeping its handle.Object subclass: #MyExternalObject 	instanceVariableNames: 'handle'	classVariableNames: ''	poolDictionaries: ''	category: 'XYZ'	To let your object(s) to be managed by external resource manager, you need to register it.Usually you do it after successfully claiming an external resource:MyExternalObject>>initialize	handle := self createNewExternalResource.  "claim resource"	self assert: self handleIsValid. "etc..."		"Now, register receiver as external resource" 	NBExternalResourceManager addResource: self "Another form of use is: 	NBExternalResourceManager addResource: self data: handle."----  If you used #addResource: method for registration, you should provide an implementation of #resourceData method:MyExternalObject>>resourceData	^ handle "since we need only handle to identify external resource"----	Now, for properly finalizing the external resource we should implement:MyExternalObject class>> finalizeResourceData: aHandle	^ self destroyHandle: aHandle. "do whatever is needed to destroy the handle"Note that in #finalizeResourceData: you cannot access any other properties of your instance, since it is already garbage collected. You also don't need to do a session checking, since it is done automatically by resource manager. !!NBExternalResourceManager commentStamp: '<historical>' prior: 0!i am responsible for managing a finalization of external resources.When object, registered as external resource being garbage collected,i telling an object's class to finalize it's associated data (by passing an object,received from #resourceData message sent to an object at registration time).I automatically keep tracking for session change (image save/boot), and ignore finalization of resources of old sessions (since they are not longer valid,and cannot be freed since session changed).Like that, a users of NBExternalResourceManager don't need to implement a session checking logic, and need only to:a) register object as external resource:     NBExternalResourceManager addResource: anObject.b) an object should understand the #resourceData message, which is remembered at registration point (it can be any external resource like, id, handle or memory pointer).Then, when object is garbage collected, its class will receive a message to finalize the resource data in #finalizeResourceData:The passed data is exactly same as previously returned by #resourceData method.An example:Imagine that you want to represent an external resource by keeping its handle.Object subclass: #MyExternalObject 	instanceVariableNames: 'handle'	classVariableNames: ''	poolDictionaries: ''	category: 'XYZ'	To let your object(s) to be managed by external resource manager, you need to register it.Usually you do it after successfully claiming an external resource:MyExternalObject>>initialize	handle := self createNewExternalResource.  "claim resource"	self assert: self handleIsValid. "etc..."		"Now, register receiver as external resource" 	NBExternalResourceManager addResource: self "Another form of use is: 	NBExternalResourceManager addResource: self data: handle."----  If you used #addResource: method for registration, you should provide an implementation of #resourceData method:MyExternalObject>>resourceData	^ handle "since we need only handle to identify external resource"----	Now, for properly finalizing the external resource we should implement:MyExternalObject class>> finalizeResourceData: aHandle	^ self destroyHandle: aHandle. "do whatever is needed to destroy the handle"Note that in #finalizeResourceData: you cannot access any other properties of your instance, since it is already garbage collected. You also don't need to do a session checking, since it is done automatically by resource manager. !!NBExternalStructure commentStamp: 'JavierPimas 2/3/2012 22:35' prior: 50469649!I am used for transparent structures: that is, a structure is transparent if you know its fields and can modify them. This is in contrast of opaque structures, which you never manipulate directly but through functions.For each struct type, you define a subclass of me, and implement the fieldsDesc class method. After that you do a initializeAccessors for that class and voila, field accessors are generated automatically.Class Instance Variables:	initialized	<Boolean>	currentFields	<NBExternalStructureFields>!!NBExternalTypeValue commentStamp: '<historical>' prior: 50470445!I am a generic meta class for creating a subclasses, which instances will hold a single value of specified C type.To create a new class for some concrete C type use:myClass := NBExternalTypeValue getClassForType: 'float'.Then you can use instances of given anonymous class(es) as a value holders fortype you specified:float := myClass new....float value:  1.5float valueetc..By combining this with class/pool variables we have a convenient way of defining a values, which are passed by pointer to a function.For instance, imagine that we need to create a binding to a function:void getFoo( SomeType * value) which is not an unusual situation, when C function using pointer arguments for storing it's output there.And this is what NBExternalTypeValue is done for:To define a binding to this function you can:  - declare a pool/class variable, named SomeType  - initialize it:         SomeType := NBExternalTypeValue ofType: 'SomeType'and then use it in function signature:getFoo: value   <primitive .. >  ^ self nbcall: #(void getFoo ( SomeType *  value ))---and call it like: var := SomeType new.self getFoo: var.var value -> will read the value !!NBExternalUnion commentStamp: '' prior: 50470742!!!NBExternalStructureFields commentStamp: '' prior: 50470143!!!NBExternalType commentStamp: 'IgorStasenko 2/15/2012 19:41' prior: 0!I am an abstract class that primarily serves for generating a machine code which converting arguments and return typesbetween Smalltalk and C worlds. My subclasses implementing a marshalling for concrete type, which is then used by FFI. Instance Variables:	pointerArity	<Integer>		loader	<NBVariableLoader>: an instance of argument loader, which emits code to load the smalltalk argument into register.			When generating the marshalling code to push a variable, my instances need this helper which, depending on where the object is (inst var, method arg, etc) gets the object in question into a register.!!NBBootstrapUlong commentStamp: 'Igor.Stasenko 5/14/2010 18:01' prior: 0!A special hacky type, which storing a ulong function return value into existing byte array instance.A method, which using this type in callout should have an argument , named 'returnValueBuffer'and pass a byte array instance, big enough to store ulong there.This is essentially used during NativeBoost bootstrap, to generate & install thegall gate function, without calling any of interpreterProxy function which may cause GC.!!NBByteArraySize commentStamp: 'Igor.Stasenko 5/3/2010 13:56' prior: 0!A helper type, which takes a byte array argument and pushing its size!!NBCharacterType commentStamp: '<historical>' prior: 0!Character type. Represented as single byte on C side.Accepts Character/Smallint as argument, converts return value to Character instance!!NBExternalObjectType commentStamp: 'Igor.Stasenko 4/29/2010 09:17' prior: 0!I providing coercions forNBExternalObject and its subclasses!!NBFFICallbackType commentStamp: 'Igor.Stasenko 5/4/2010 05:15' prior: 0!Pushing a callback to stack!!NBFloatPtr commentStamp: 'IgorStasenko 12/21/2011 13:43' prior: 0!Use to pass a pointer to instance of Float, which is C (double *) equivalent.Can be used for functions which may modify the floating-point values at specified memory pointer.NOTE: always copy float objects before passing them to such callouts.!!NBFloatType commentStamp: 'Igor.Stasenko 4/28/2010 11:54' prior: 0!Abstract class for floating-point native types!!NBFloat16 commentStamp: '<historical>' prior: 0!not supported on x86 archs..!!NBIntegerExternalType commentStamp: 'Igor.Stasenko 4/28/2010 11:53' prior: 0!Abstract class for all integer external types!!NBSizeT commentStamp: '<historical>' prior: 0!i implement marshalling for the size_t type.size_t value size depends on a platform's word size.on 32-bit it will be 32 bit.on 64-bit it will be 64 bit !!NBUInt16 commentStamp: '<historical>' prior: 0!I responsible for marshalling 		unsigned 16-bit integer type values.!!NBInt16 commentStamp: '<historical>' prior: 0!I responsible for marshalling 		signed 16-bit integer type values.!!NBUInt32 commentStamp: '<historical>' prior: 0!I responsible for marshalling 		unsigned 32-bit integer type values.!!NBInt32 commentStamp: '<historical>' prior: 0!I responsible for marshalling 		signed 32-bit integer type values.!!NBUInt64 commentStamp: '<historical>' prior: 0!I responsible for marshalling 		unsigned 64-bit integer type values.!!NBInt64 commentStamp: '<historical>' prior: 0!I responsible for marshalling 		signed 64-bit integer type values.!!NBUInt8 commentStamp: '<historical>' prior: 0!I responsible for marshalling 		unsigned 8-bit integer type values.!!NBInt8 commentStamp: '<historical>' prior: 0!I responsible for marshalling 		signed 8-bit integer type values.!!NBOop commentStamp: '<historical>' prior: 0!i am special "type", doing no conversion of any sort, just passing an object oop as it is.!!NBExtraRootsRegistry commentStamp: 'Igor.Stasenko 4/29/2010 07:53' prior: 0!This registry serve for instantiating an external types by native code.My sole instance is always refreshing during fresh image startup.!!NBFFIConst commentStamp: 'Igor.Stasenko 5/3/2010 18:10' prior: 0!My instances can be used to push an arbitrary integer value to the stack.Could be useful for purposes, when some of the external function values is known beforehead,like size of structure etc.For emitting a constant as argument  for a function just put it into an argument list, like: apiCall: #( long 'IsBadWritePtr' (10) ) module: 'Kernel32.dll'here, 10 is a constant, which will be pushed on stack!!NBFinalizationRegistry commentStamp: '<historical>' prior: 0!i am a simplified implementation of WeakRegistry,and have same public protocol.The implementation is simpler and faster, because i rely on new finalization support in VM.!!NBFnArgument commentStamp: 'Igor.Stasenko 4/30/2010 12:12' prior: 0!I am abstract class, describing a function argument.My subclasses should know what code to emit in order to load an argument.!!NBSTIvarArgument commentStamp: 'Igor.Stasenko 4/30/2010 12:24' prior: 0!This guy knows how to load a receiver's ivar.!!NBSTMethodArgument commentStamp: 'Igor.Stasenko 4/30/2010 10:47' prior: 0!i know what to emit for loading a method's argument from VM stack into register!!NBFnSpec commentStamp: 'IgorStasenko 2/15/2012 19:46' prior: 0!I am used to hold a parsed function signature, describing a C function.Since all C functions having return type, arguments and name (unless it anonymous one), same structure can be used to hold an information about it in my instances.However, what objects used to represent types and arguments is up to code generator.Instance Variables:	returnType <Object>	functionName	<String>	arguments	<SequenceableCollection>!!NBObjectFormat commentStamp: 'Igor.Stasenko 5/19/2010 11:12' prior: 0!i am exposing an object format to ease accessing various object fields directly,without calling interpreter proxy functions, where it is appropriate!!NBExternalEnumeration commentStamp: 'CiprianTeodorov 12/12/2012 23:03' prior: 50469179!NBExternalEnumerationType reifies the enum declarations in C and offers a nice interface (especially in terms of debug/inspect).To use it just subclass the NBExternalEnumeration and add an #enumDecl method to the class side such as:NBExternalEnumeration subclass: #NBTestEnumeration	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'NativeBoost-Tests'NBTestEnumeration class>>enumDecl	^ {(#AAA -> 1).	(#BBB -> 2).	(#CCC -> 3).	(#DDD -> 2400)} asDictionary DO NOT FORGET to call the #initialize method on your class. The rest is automatically done ;)You can use your new enum in two ways:	- add it to a client class poolDictionaries list (see  #NBExternalEnumTests for an example), 		and then just write CCC in your code -- CCC here is an item of your enum	- send the name of an item to your class --- NBTestEnumeration DDDThe NBExternalEnumeration implements  (instance and class) some more API methods like:	#itemAt: retrieves the item having a specific value  --- NBTestEnumeration itemAt: 2	#includes: checks the existence of a specific item in the enum --- NBTestEnumeration includes: #AAA!!NBCodeGenRecursion commentStamp: '<historical>' prior: 0!I am used to SIGNAL recursion error during code generation..Do not confuse me with NBRecursionDetect  notification,which is used to detect recursion.A recursion usually happens when generating code for some method requires generating code for very same method, and so it enters infinite loop!!NBFFICalloutError commentStamp: 'IgorStasenko 2/20/2012 13:52' prior: 0!My instances indicating an error during execution of FFI callout.To get a description, i look up in NBFFICallout for custom error messages , in addition to my superclass.!!NBRecursionDetect commentStamp: '<historical>' prior: 0!i am used to detect recursion during code generation..use me like following:NBRecursionDetect in: someMethod during: [	... some block ..	].if recursion is detected, while evaluating the block, then NBCodeGenRecursion error will be signaled.A recursion usually happens when generating code for some method requires generating code for very same method, and so it enters infinite loop!!NBExternalArray commentStamp: '<historical>' prior: 50468747!I am abstract class which provides a convenient interface to work with arrays which elements are values of some external (C) type.In order to use me with concrete element type, you must create a subclass of me and initialize element type properly.Subclassing using public subclass: - if you want to create a public subclass of me, then you should make sure that in class-side #initialize method,you add self-send #initElementType:  and specify the element type name to use. (And of course, initialize the class before attempting to create any instances).Subclassing with anonymous subclass:To create an anonymous subclass of me,  use #ofType: protocol, i.e.:floatArrayClass := NBExternalArray ofType: 'float'.Please note that separate #at: / #at:put: methods will be automatically added in each and every subclass. Never remove them, despite they looking identical to superclass methods!!!!!!CAUTION!!!! Currently those methods do not perform any range checking for index. So, please make sure you using sane index values (1<= index <= size). Also, note, that class instance variables: elementType and elementSize, once initialized, is considered read-only. Changing them, once you created at least a single instance of your class may lead to funny consequences.Arrays in external memory vs object memory:My instances can work either with data held in object memory or in external memory. The difference is only at instantiation time: To create a new array in object memory, just use #new: protocol: 	myArray := floatArrayClass new:  10.   "create a new array with 10 floats".To allocate a new array in external memory, use #externalNew: protocol:   	myArray := floatArrayClass externalNew:  10.  	..	myArray free.  "and sure thing, do not forget to free external memory after use".To check whether array uses object memory or external memory , use #isExternal protocol.Also, you can convert any external address into NBExternalArray subclass instance, i.e. suppose some external function returns a pointer (instance of NBExternalAddress):	pointer := self callSomeFunc: 1. 	So, in order to access memory at given address as array of 100 elements of type 'int', you can use following: 	myArray := (NBExternalArray ofType: 'int') onAddress: pointer size: 100.	myArray at: 1.  "read first element"	myArray at: 2 put: 50.  "write second element" 	myArray do: [:each | ...  ] ... etc			 (sure thing, in the above example, the "NBExternalArray ofType: 'int' " expression is just to demonstrate the intent. It should be replaced with some variable, which you initialize only once and use many times, because creating an anonymous subclass each time would be highly ineffective )Supported protocols:   	Since NBExternalTypeArray inherits from ArrayedCollection, you're free to use any protocols defined there as well as in its superclasses.	There's only few additions comparing to ArrayedCollection, like #isExternal and #free .Copying:	a #copy behavior is special for external arrays: A copy will always use object memory, even if original used external memory.!!NBCallbackCodeGen commentStamp: '<historical>' prior: 0!The generated callback code does following:1. Trunk1.0. Each callback instance has unique trunk code, which is installed into external memory during callback initialization.1.1. An external function makes a call to trunk address.1.2. Trunk code sets the globally registered callback index to ECX register and jumps to callback entry code.2. Entering callback 2.1. saves the VM's execution state (stack/frame pointers, reenterInterpreter jump buffer). See #saveExecutionState.2.2. fetching the callback oop for index passed from trunk.2.3. coercing the callback function arguments to their smalltalk equivalent and creates an array with them. See #emitArgumentsCoercion.2.4. synthesizes a fresh method context which is an activation of #pvtEnter:stackPointer:primitiveMethod: 	and swaps the active context with synthesized context. See #activateCallbackContext: .2.5. increments a global callback counter value. See #incrementCallbackCounter.2.6. enters an interpreter loop by calling VM's #enterSmalltalkExecutiveImplementation function.3. Leaving callback.3.1. A leave procedure starts from method: #primLeave:stackPtr:contextOop:returnValue:primitiveMethod: , whichsimply jumps to provided leave address, a code, generated for leaving from given callback.3.2. Coerce the return value from smalltalk object to it's C equivalent. See #generateCallbackLeaveCodeFor:leaveAddr:.3.3. Swaps a currently active context with one which were before entering callback3.4. jumps to #returnToC label in callback entry code3.5. sets the current C stack frame back to callback enter procedure.3.6. restores the VM execution state (an opposite to 2.1) , see #restoreExecutionState.3.7. decrements global callback counter.3.8. returns to external function!!NBExternalString commentStamp: 'IgorStasenko 8/10/2011 18:46' prior: 0!NBExternalString type can be used to coerce squeak's String to char* back and forth.Use #String or #NBExternalString as type name.Some functions may accept null as a valid argument (if string is optional).You can set #optStringOrNull in callout options in that case.If type is used as return value type, then C string (char *) converted to ByteString instance.If return value is null, a nil will be answered instead.!!NBFFICallback commentStamp: '<historical>' prior: 50470992!My instances represent a callback function, which will be called by external function at some moment.To create a new callback, first, make a subclass of me and override #fnSpec method, which is an anonymous C function signature, l.e.  'int (int foo , float bar )'  , which tells that given callback class implements a callback for a function which takes two arguments (foo, bar),and returns integer.(Additionally you can override a #callType method which determines a callback function calling convention. A default calling convention for callbacks is #cdecl,and others is barely used on x86 platforms).To use callbacks, you must instantiate it first by passing block as an argument:mycallback := MyCallback on: someBlock.The block is the closure which will be evaluated when callback function get called, so the block must take same number of arguments as specified in #fnSpec method, and its evaluation result must yield a value which can be converted back C type value, which you speficied as a return type of callback function.For example, if callback signature is 'int (int foo , float bar )' , we can create a callback with following block closure:mycallback := MyCallback on: [:foo :bar |  (foo + bar ) asInteger ]. Passing callback as an argument to external function. For passing a callbacks as an argument to C function, you can use its class name for an argument type.For example:primStQSort: base len: size compare: qsortCallback	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self 		nbCall: #(void qsort (NBExternalAddress base, ulong size, 1, NBQSortCallback qsortCallback))		module: NativeBoost CLibrary 		options: #( optMayGC )as you can see , the third argument (qsortCallback) of function signature, has 'NBQSortCallback' type, which is a class name of existing NBFFICallback subclass. And, of course you are free to create any type aliases for the callback type to use different type names in signature. Just make sure that aliases are resolved correctly to an instance of NBFFICallbackType, during processing of the function signature by NBFFICallout class.!!!!Note!!!! A special care must be taken for all functions which may make callbacks!! In the above qsort() example, you can see an additional option for external call - #optMayGC, which tells a code generator to call an external function via call gate (a special stub which handling a code relocation caused by GC). Thats it, for any external functions, which may call the callback you must pass this option. Rationale: since most of external functions don't make any callbacks (and so has no chance to trigger GC), using this option by default will be an overkill, which will just spend extra CPU cycles for nothing. However, if you omit this option when calling the function(s) which may call back, expect a hard crash(es) to happen.   If you unsure which external library functions may call back, you can turn on this option by default for all methods in your class by implementing  #ffiCalloutOptions method at class side:MyClass class>>ffiCalloutOptions ^ #( optMayGC )Like that, for any code generated to make external calls in methods of your class, this option will take an effect.Callback lifetime. Each time you instantiating a new callback, it reserves a small amount of external memory , which must be freed once callback is no longer used.This is done automatically, using object finalization scheme, once system detects that there is no more strong references to callback left.So, you only need to make sure that an instance of callback, which you passed to some external function will be kept around in system, as long asan external library has a pointer to it and can perform calls to it.  If you lose the last reference to callback object before making sure that external library can no longer make calls to it, this will lead to an unpredictive behavior (segmentation fault, invalid instruction, memory corruption / pick your favorite).   Redefining callback signature. A callback uses a lazy-initialization scheme to generate a common marshalling code which will be used by all instances of specific callback class.So, changing a callback signature (by changing its #fnSpec method) will not have an immediate effect, if you already created at least a single instance of it. To make changes take effect, you must restart an image.!!NBInterpreterProxy commentStamp: '<historical>' prior: 0!I am an important part of a native code generation toolchain, which provides an access to all interpreterProxy functions.A native code, inevitably, needs to convert a method's arguments to their native representations, and access a different fields of oops. For this, we need to use interpreter proxy methods.Code generator options, used by proxy: 	#optNonMovable		- The code is a standalone routine, which 		a) will be placed into a non-movable memory region.		b) can be called by any other function, not by primitiveNativeCall, therefore		#optDirectProxyFnAddress		- call proxy functions directly, instead of loading 		their address indirectly via interpreterProxy struct	 #optUseStackPointer 		- use a direct ST stack pointer, initially retrieved using #getStackPointer!!NBCogInterpreterProxy commentStamp: '<historical>' prior: 0!I am a specialized interpreter proxy for the Cog family of intererpreters!!NBNativeCodeGen commentStamp: 'IgorStasenko 2/15/2012 19:49' prior: 0!I providing a basic interface for use a dynamically generated native code with NativeBoost plugin using #primitiveNativeCall.On my class side, you can find the interface to help managing native code, as well as basic functionality for dealing with it at run time. My instance serves as a helper to access common facilities used for code generation:  - assembler - interpreter proxyi do not provide anything beyond that, so you still basically on you own, and must use assembler and interpreter proxy for implementing a low-level funcitonalityin your code (like new primitive, new function etc)Instance Variables:	asm							: An object that is used to generate native code	proxy	<NBInterpreterProxy> : An object providing an access to public VM interface: like fetching a var from smalltalk stack, accessing object's internals, etc.	options	<Collection>   : A set of options which generated code may use 	method 	: a compiled method instance where native code will be installed to, (of course in case if my instance used for generating code to be installed there,		and if not, it can be ignored)		Usage:My most simple use is in a form: myMethod <primitive: #pritmiveNativeCall module: #NativeBoostPlugin>  ^ NBNativeCodeGen methodAssembly: [:gen |	 "here you put an instructions or provide own machine code.	a block should answer a bytearray, which should contain ready for use machine code"	]In case, if you want to use different top-level interface, like in order to write something like following:myMethod <primitive: #pritmiveNativeCall module: #NativeBoostPlugin>  ^ self myCode: [	 "here you put an instructions or provide own machine code"	]You can use #handleFailureIn:nativeCode: method , which takes care of handling primitive failure, dealing with errors and finally installing native code, which you providing, into corresponding method.!!NBFFICallout commentStamp: '<historical>' prior: 0!Callout arguments can be either:- an integer constant, boolean or nil- a type name (string or symbol)- a class name- a class variable- any other object, which responds to #asFFICalloutArgument:An object , answered by #asFFICalloutArgument: should implement a public protocol of NBExternalType Todo....Options:argument coercion options:	#coerceBoolToInt  - Boolean   -> C integer (0/1)	#coerceNilToInt  -  nil       -> C integer (0)	#coerceFloatToInt - Float     -> C integer	#coerceCharToInt -  Character -> C integer	#noTypeChecking - do not perform any type checking for pushed arguments 	  (dangerous, but sometimes can be useful)		return value coercion options:	#returnBoolAsInt  -  do not turn a bool(0/1) into Boolean (true/false)cdecl calling convention:   1.   Function parameters are pushed on the stack in a right-to-left order.   2. Any local variables declared by the callee are allocated on the stack by subtracting the number of bytes required from esp. That is (sub esp,NUMBER_OF_BYTES).   3. Registers eax, ecx, and edx are available for use in the subprogram.   4. Registers ebx, esi, edi, and ebp must not be modified by the callee. (In fact, they may be used, but their original values must be restored before exiting the callee).   5. When the callee terminates, any local variable must be released by restoring esp to its original value (mov esp,ebp).   6. Function return values are returned in the eax register (except for floating point values, which are returned in the st0 register).   7. After the callee is over, the parameters that were pushed on the stack by the caller must be removed by the caller itself once the callee is terminated. It can be done in two ways :          * pop ecx n times, where n is the number of parameters pushed (cons: a useless result is stored in ecx, and ecx's value changes)          * add esp,NUMBER_OF_BYTES_PREVIOUSLY_PUSHED (1 parameter pushed = 4 bytes on a 32 bit machine)!!NBNativeFunctionGen commentStamp: '<historical>' prior: 0!I'm a generator of native code. I can create C style functions, providing convenient syntactic sugar for accessing the function arguments in function body (but you still have to write the body of the function with the assembler).I can be used for implementing small helper routines, low-level callbacks or functions which will run in separate (to VM) thread.A function spec is used to help with fetching arguments from call stack by using #arg: method for that: NBNativeFunctionGen 		cdecl: #( int (byte* a, byte * b) )		emit: [:gen | | asm |			asm := gen asm.			"this will load argument from stack to register"			asm mov: (gen arg: #b) to: EAX;		].By invoking the expression above, I will generate a native code and keep it in my instance. Now to put this code in use, it must be installed  (see #install) into external memory. Then an address to the function can be passed to any other external function,or even called by FFI callout:	myFunction := NBNativeFunctionGen cdecl: #(..) emit: [...].	myFunction install.	address := myFunction address.After function is no longer needed, it must be uninstalled (to conserve the external memory):	myFunction uninstall.Note, that this must be done explicitly, since like everything which works with external resources, there's no any automatic resource management for external memory.!!NBObjectFormat32 commentStamp: 'Igor.Stasenko 5/19/2010 11:13' prior: 0!- an object format for 32-bit images!!NativeBoost commentStamp: '<historical>' prior: 0!i am a core class, which provides a common functionality, required by many NativeBoost facilities to function, including:- basic memory operations- external roots registry- call gate function- session managementEvery new session, i using an unique instance,which is platform specific (see my subclasses).To access a current session instance, you can issue:NativeBoost forCurrentPlatform!!TNBMemoryAccessors methodsFor: 'memory access +' stamp: 'IgorStasenko 11/24/2012 16:32'!nbFloat32AtOffset: zeroBasedOffset	"Read 32-bit float at ZERO-based index.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(float32 (self, ulong zeroBasedOffset)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			add: asm EAX with: asm ECX;			fld: asm EAX ptr32. "load a floating point value from memory, at base address, held in EAX register into fp(0) register,				we are using #ptr32, to indicate that memory operand size is 32bits long"	] ! !!TNBMemoryAccessors methodsFor: 'memory access +' stamp: 'IgorStasenko 11/24/2012 16:34'!nbFloat32AtOffset: zeroBasedOffset put: value	"Store 32-bit float at ZERO-based index.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(void (self, ulong zeroBasedOffset, float32 value)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			pop: asm EDX;			mov: asm EDX to: asm EAX ptr + asm ECX	] ! !!TNBMemoryAccessors methodsFor: 'memory access +' stamp: 'IgorStasenko 11/24/2012 16:50'!nbFloat64AtOffset: zeroBasedOffset	"Read 64-bit float at ZERO-based index.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(float64 (self, ulong zeroBasedOffset)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "index"			add: asm EAX with: asm ECX;			fld: asm EAX ptr64. "load a floating point value from memory, at base address, held in EAX register into fp(0) register,				we are using #ptr64, to indicate that memory operand size is 64bits long"	] ! !!TNBMemoryAccessors methodsFor: 'memory access +' stamp: 'IgorStasenko 11/24/2012 16:50'!nbFloat64AtOffset: zeroBasedOffset put: value	"Store 64-bit float at ZERO-based index.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(void (self, ulong zeroBasedOffset, float64 value)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			add: asm EAX with: asm ECX;						mov: asm ESP ptr to: asm ECX;			mov: asm ECX to: asm EAX ptr;			mov: asm ESP ptr +4 to: asm ECX;			mov: asm ECX to: asm EAX ptr +4 	] ! !!TNBMemoryAccessors methodsFor: 'memory access +' stamp: 'IgorStasenko 11/24/2012 16:50'!nbInt16AtOffset: zeroBasedOffset		"Reads signed 16-bit integer from memory at (receiver's address + ZERO-based offset) using native byte order.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(int16 (self, ulong zeroBasedOffset)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			mov: asm EAX ptr16 + asm ECX to: asm AX	]! !!TNBMemoryAccessors methodsFor: 'memory access +' stamp: 'IgorStasenko 11/24/2012 16:59'!nbInt16AtOffset: zeroBasedOffset  put: value		"Store signed 16-bit integer into memory at (receiver's address + ZERO-based offset) using native byte order.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(void (self, ulong zeroBasedOffset, int16 value)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			pop: asm EDX; "value"			mov: asm DX to: asm EAX ptr16 + asm ECX	]! !!TNBMemoryAccessors methodsFor: 'memory access +' stamp: 'IgorStasenko 11/24/2012 16:59'!nbInt32AtOffset: zeroBasedOffset		"Reads signed 32-bit integer from memory at (receiver's address + ZERO-based offset) using native byte order.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(int32 (self, ulong zeroBasedOffset)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			mov: asm EAX ptr32 + asm ECX to: asm EAX	]! !!TNBMemoryAccessors methodsFor: 'memory access +' stamp: 'IgorStasenko 11/24/2012 16:59'!nbInt32AtOffset: zeroBasedOffset  put: value		"Store signed 32-bit integer into memory at (receiver's address + ZERO-based offset) using native byte order.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(void (self, ulong zeroBasedOffset, int32 value)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			pop: asm EDX; "value"			mov: asm EDX to: asm EAX ptr32 + asm ECX	]! !!TNBMemoryAccessors methodsFor: 'memory access +' stamp: 'IgorStasenko 11/24/2012 16:59'!nbInt64AtOffset: zeroBasedOffset		"Reads signed 64-bit integer from memory at (receiver's address + ZERO-based offset) using native byte order.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(int64 (self, ulong zeroBasedOffset)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			mov: asm EAX ptr + asm ECX + 4 to: asm EDX;			mov: asm EAX ptr + asm ECX to: asm EAX	]! !!TNBMemoryAccessors methodsFor: 'memory access +' stamp: 'IgorStasenko 11/24/2012 17:00'!nbInt64AtOffset: zeroBasedOffset  put: value		"Store signed 64-bit integer into memory at (receiver's address + ZERO-based offset) using native byte order.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(void (self, ulong zeroBasedOffset, int64 value)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			pop: asm EDX; "value low word"			mov: asm EDX to: asm EAX ptr32 + asm ECX;			pop: asm EDX; "value high word"			mov: asm EDX to: asm EAX ptr32 + asm ECX + 4	]! !!TNBMemoryAccessors methodsFor: 'memory access +' stamp: 'IgorStasenko 11/24/2012 17:00'!nbInt8AtOffset: zeroBasedOffset		"Reads signed 8-bit integer from memory at (receiver's address + ZERO-based offset) using native byte order.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(int8 (self, ulong zeroBasedOffset)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			mov: asm EAX ptr8 + asm ECX to: asm AL	]! !!TNBMemoryAccessors methodsFor: 'memory access +' stamp: 'IgorStasenko 11/24/2012 17:00'!nbInt8AtOffset: zeroBasedOffset  put: value		"Store signed 8-bit integer into memory at (receiver's address + ZERO-based offset) using native byte order.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(void (self, ulong zeroBasedOffset, int8 value)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			pop: asm EDX; "value"			mov: asm DL to: asm EAX ptr8 + asm ECX	]! !!TNBMemoryAccessors methodsFor: 'memory access +' stamp: 'IgorStasenko 11/24/2012 17:00'!nbUInt16AtOffset: zeroBasedOffset		"Reads unsigned 16-bit integer from memory at (receiver's address + ZERO-based offset) using native byte order.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(uint16 (self, ulong zeroBasedOffset)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			mov: asm EAX ptr16 + asm ECX to: asm AX	]! !!TNBMemoryAccessors methodsFor: 'memory access +' stamp: 'IgorStasenko 11/24/2012 17:01'!nbUInt16AtOffset: zeroBasedOffset  put: value		"Store unsigned 16-bit integer into memory at (receiver's address + ZERO-based offset) using native byte order.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(void (self, ulong zeroBasedOffset, uint16 value)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			pop: asm EDX; "value"			mov: asm DX to: asm EAX ptr16 + asm ECX	] ! !!TNBMemoryAccessors methodsFor: 'memory access +' stamp: 'IgorStasenko 11/24/2012 17:01'!nbUInt32AtOffset: zeroBasedOffset		"Reads unsigned 32-bit integer from memory at (receiver's address + ZERO-based offset) using native byte order.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(uint32 (self, ulong zeroBasedOffset)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			mov: asm EAX ptr32 + asm ECX to: asm EAX	]! !!TNBMemoryAccessors methodsFor: 'memory access +' stamp: 'IgorStasenko 11/24/2012 17:01'!nbUInt32AtOffset: zeroBasedOffset  put: value		"Store unsigned 32-bit integer into memory at (receiver's address + ZERO-based offset) using native byte order.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(void (self, ulong zeroBasedOffset, uint32 value)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			pop: asm EDX; "value"			mov: asm EDX to: asm EAX ptr32 + asm ECX	]! !!TNBMemoryAccessors methodsFor: 'memory access +' stamp: 'IgorStasenko 11/24/2012 17:01'!nbUInt64AtOffset: zeroBasedOffset		"Reads unsigned 64-bit integer from memory at (receiver's address + ZERO-based offset) using native byte order.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(uint64 (self, ulong zeroBasedOffset)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			mov: asm EAX ptr + asm ECX + 4 to: asm EDX;			mov: asm EAX ptr + asm ECX to: asm EAX	]! !!TNBMemoryAccessors methodsFor: 'memory access +' stamp: 'IgorStasenko 11/24/2012 17:02'!nbUInt64AtOffset: zeroBasedOffset  put: value		"Store unsigned 64-bit integer into memory at (receiver's address + ZERO-based offset) using native byte order.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function:  #(void (self, ulong zeroBasedOffset, uint64 value)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			pop: asm EDX; "value low word"			mov: asm EDX to: asm EAX ptr32 + asm ECX;			pop: asm EDX; "value high word"			mov: asm EDX to: asm EAX ptr32 + asm ECX + 4	]! !!TNBMemoryAccessors methodsFor: 'memory access +' stamp: 'IgorStasenko 11/24/2012 17:02'!nbUInt8AtOffset: zeroBasedOffset		"Reads unsigned 8-bit integer from memory at (receiver's address + ZERO-based offset) using native byte order.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(uint8 (self, ulong zeroBasedOffset)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			mov: asm EAX ptr8 + asm ECX to: asm AL	]! !!TNBMemoryAccessors methodsFor: 'memory access +' stamp: 'IgorStasenko 11/24/2012 17:02'!nbUInt8AtOffset: zeroBasedOffset  put: value		"Store unsigned 8-bit integer into memory at (receiver's address + ZERO-based offset) using native byte order.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(void (self, ulong zeroBasedOffset, uint8 value)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			pop: asm EDX; "value"			mov: asm DL to: asm EAX ptr8 + asm ECX	] ! !!NBExternalAddress class methodsFor: 'instance creation' stamp: 'Igor.Stasenko 5/4/2010 01:15'!asNBExternalType: gen	^ NBExternalAddressType new ! !!NBExternalAddress class methodsFor: 'finalization' stamp: 'CamilloBruni 8/3/2012 15:32'!finalizeResourceData: anExternalAddressValue	"We use an intermediate interger for address value, 	otherwise we would hold on to the NBExternalAddress forever"	(self value: anExternalAddressValue) free! !!NBExternalAddress class methodsFor: 'instance creation' stamp: 'Igor.Stasenko 5/17/2010 14:53'!fromString: aString		| result |		result := NativeBoost allocate: aString size + 1.	(self assert: result notNil).	result writeString: aString.	^ result! !!NBExternalAddress class methodsFor: 'instance creation' stamp: 'Igor.Stasenko 5/18/2010 00:33'!null	^ self new! !!NBExternalAddress methodsFor: 'comparing' stamp: 'IgorStasenko 8/4/2011 08:25'!= anObject	^ anObject class == self class and: [ anObject value = self value]! !!NBExternalAddress methodsFor: 'finalization' stamp: 'CamilloBruni 8/3/2012 15:27'!finalize	self free! !!NBExternalAddress methodsFor: 'finalization' stamp: 'CamilloBruni 8/3/2012 15:27'!free	NativeBoost free: self! !!NBExternalAddress methodsFor: 'finalization' stamp: 'CamilloBruni 8/3/2012 15:30'!freeAfterUse	"add ourselves to finalization registry"	NBExternalResourceManager 		addResource: self 		data: self value.! !!NBExternalAddress methodsFor: 'testing' stamp: 'IgorStasenko 8/4/2011 07:06'!notNull	^ self value ~= 0! !!NBExternalAddress methodsFor: 'string access' stamp: 'IgorStasenko 11/24/2012 17:04'!readString	"sometimes we're just a pointer to string"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(String (self)) emit: [:gen |		gen asm pop: gen asm EAX ] ! !!NBExternalAddress methodsFor: 'string access' stamp: 'Igor.Stasenko 5/24/2010 16:09'!writeString: aString	"write a null-terminated byte string to receiver's address"		| str |	str := aString copyWith: (Character value: 0).	NativeBoost memCopy: str to: self size: str size.! !!NBExternalHandle class methodsFor: 'instance creation' stamp: 'IgorStasenko 2/24/2012 17:02'!asNBExternalType: gen	self error: 'use NBExternalObject instead'.		"Note, do not subclass from me directly. If you want to represent any opaque C structure (stucture, pointer to structure etc),	subclass from NBExternalObject instead. Otherwise, if you insist, override this method in own subclass to provide own marshalling 	for instances of your object(s)"! !!NBExternalHandle class methodsFor: 'fields description' stamp: 'IgorStasenko 5/26/2012 14:57'!instanceSize 	^ NBExternalType pointerSize ! !!NBExternalHandle class methodsFor: 'instance creation' stamp: 'IgorStasenko 5/26/2012 14:55'!new	^ self basicNew: self instanceSize ! !!NBExternalHandle class methodsFor: 'instance creation' stamp: 'Igor.Stasenko 5/2/2010 14:08'!value: aValue	^ self new value: aValue! !!NBExternalHandle methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/3/2010 13:25'!asUImm	^ self asUnsignedLong asUImm! !!NBExternalHandle methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/3/2010 13:32'!asUImm32	^ self asUnsignedLong asUImm32! !!NBExternalHandle methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/3/2010 02:41'!asUnsignedLong	"slow version"	^ (self at: 1)	+ ((self at: 2) << 8)	+ ((self at: 3) <<16)	+ ((self at: 4) << 24)! !!NBExternalHandle methodsFor: 'testing' stamp: 'IgorStasenko 6/2/2012 14:38'!isNull	^ self value = 0! !!NBExternalHandle methodsFor: 'printing' stamp: 'Igor.Stasenko 4/29/2010 12:28'!printOn: aStream	aStream nextPutAll: '@ 16r';		nextPutAll: (self value printStringBase: 16)! !!NBExternalHandle methodsFor: 'accessing' stamp: 'IgorStasenko 11/24/2012 16:20'!value	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>		^ self nbCallout function: #(size_t () ) emit: [:gen :proxy :asm | 		proxy receiver.		proxy varBytesFirstFieldOf: asm EAX.				self class instanceSize = 4 ifTrue: [			asm mov: asm EAX ptr to: asm EAX.		] ifFalse: [				"not implemented yet, sorry"			self notYetImplemented.		].	] ! !!NBExternalHandle methodsFor: 'accessing' stamp: 'IgorStasenko 11/24/2012 16:20'!value: aPositiveInteger	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>		^ self nbCallout function: #(oop (size_t aPositiveInteger)) emit: [:gen :proxy :asm |				self class instanceSize = 4 ifTrue: [ | temp |			proxy receiver.			proxy varBytesFirstFieldOf: asm EAX.						asm  				mov: asm ESP ptr to: asm EDX;				mov: asm EDX to: asm EAX ptr.							] ifFalse: [				"not implemented yet, sorry"			self notYetImplemented.		].			proxy receiver 	]! !!NBExternalHeapManager methodsFor: 'callbacks' stamp: 'Igor.Stasenko 9/25/2010 00:48'!addFreeBlock: aMemoryBlock	"Check if free block covers entire page.	and if it is, then free the page"		(self checkForFreePage: aMemoryBlock) ifFalse: [		freeBlocks add: aMemoryBlock		]! !!NBExternalHeapManager methodsFor: 'memory pages' stamp: 'Igor.Stasenko 9/25/2010 00:18'!alignToPageSize: requestedSize	" pages is 4kb wide"	| u align |	align := self pageAlignment.		^ (u := requestedSize \\ align) > 0 		ifTrue: [ requestedSize + align - u ] 		ifFalse: [ requestedSize ]! !!NBExternalHeapManager methodsFor: 'memory operations' stamp: 'Igor.Stasenko 9/25/2010 00:45'!allocate: numBytes	"Allocate a numBytes on heap, answer an address to first byte of allocated memory"			^ sema critical: [ 	| freeBlock page |		"yes, the free space search is implemented naively, by now"		freeBlock := freeBlocks 			detect: [:block | block length >= numBytes]			ifNone: [ page := self allocatePage: numBytes.  page firstBlock ].		freeBlock reserve: numBytes for: self.		reservedBlocks at: freeBlock address put: freeBlock.		freeBlock address	]! !!NBExternalHeapManager methodsFor: 'memory pages' stamp: 'Igor.Stasenko 9/25/2010 00:11'!allocatePage: requestedSize	| bytesToAllocate addr page |		bytesToAllocate := self alignToPageSize: (self minimumPageSize max: requestedSize).	addr := self primAllocatePage: bytesToAllocate.		page := NBMemoryPage address: addr length: bytesToAllocate.	pages at: addr put: page.	^ page ! !!NBExternalHeapManager methodsFor: 'callbacks' stamp: 'Igor.Stasenko 9/25/2010 00:47'!checkForFreePage: aMemoryBlock	"Check if free block covers entire page.	and if it is, then free the page"		pages at: aMemoryBlock address ifPresent: [:page |		page length = aMemoryBlock length ifTrue: [ self freePage: page. ^ true]		].		^ false! !!NBExternalHeapManager methodsFor: 'memory operations' stamp: 'Igor.Stasenko 9/24/2010 23:44'!free: address	sema critical: [	| block |		block := reservedBlocks removeKey: address ifAbsent: [			self error: 'Unable to find a memory block with given address' ].			block makeFreeFor: self ]	! !!NBExternalHeapManager methodsFor: 'memory pages' stamp: 'Igor.Stasenko 9/25/2010 00:50'!freePage: aMemoryPage	pages removeKey: aMemoryPage address.	freeBlocks remove: aMemoryPage firstBlock ifAbsent: [].		^ self primFreePage: aMemoryPage ! !!NBExternalHeapManager methodsFor: 'initialize-release' stamp: 'Igor.Stasenko 9/24/2010 23:57'!initialize	sema := Semaphore forMutualExclusion.	pages := Dictionary new.	freeBlocks := IdentitySet new.	reservedBlocks := Dictionary new.! !!NBExternalHeapManager methodsFor: 'testing' stamp: 'Igor.Stasenko 9/24/2010 23:51'!isValidAddress: anAddress	^ self isValidAddress: anAddress size: 1! !!NBExternalHeapManager methodsFor: 'testing' stamp: 'Igor.Stasenko 9/25/2010 00:20'!isValidAddress: anAddress size: numBytes	"check, if given memory range (at given address and numBytes size)	 is valid (currently allocated) using this heap manager "	^ sema critical: [		reservedBlocks anySatisfy: [:blk |			blk address <= anAddress and: [blk address + blk length >= (anAddress + numBytes)]]	]! !!NBExternalHeapManager methodsFor: 'memory pages' stamp: 'Igor.Stasenko 9/25/2010 00:35'!minimumPageSize	" lets grab minimum 32kb pages"		^ 32768! !!NBExternalHeapManager methodsFor: 'accessing' stamp: 'Igor.Stasenko 9/25/2010 00:36'!numAllocatedBlocks	^ reservedBlocks size! !!NBExternalHeapManager methodsFor: 'accessing' stamp: 'Igor.Stasenko 9/25/2010 00:22'!numBlocks	^ freeBlocks size + reservedBlocks size! !!NBExternalHeapManager methodsFor: 'accessing' stamp: 'Igor.Stasenko 9/25/2010 00:36'!numFreeBlocks	^ freeBlocks size! !!NBExternalHeapManager methodsFor: 'accessing' stamp: 'Igor.Stasenko 9/25/2010 00:22'!numPages	^ pages size! !!NBExternalHeapManager methodsFor: 'memory pages' stamp: 'Igor.Stasenko 9/25/2010 00:06'!pageAlignment	" x86 4kb pages"		^ 4096! !!NBExternalHeapManager methodsFor: 'abstract' stamp: 'Igor.Stasenko 9/25/2010 00:19'!primAllocatePage: numBytes	self subclassResponsibility ! !!NBExternalHeapManager methodsFor: 'abstract' stamp: 'Igor.Stasenko 9/25/2010 00:19'!primFreePage: aMemoryPage	self subclassResponsibility ! !!NBExternalHeapManager methodsFor: 'callbacks' stamp: 'Igor.Stasenko 9/24/2010 23:43'!removeFreeBlock: aMemoryBlock	freeBlocks remove: aMemoryBlock ifAbsent: []! !!NBExternalHeapManager methodsFor: 'accessing' stamp: 'Igor.Stasenko 9/24/2010 23:31'!totalAllocatedMemory	| total |		total := 0.	sema critical: [		reservedBlocks valuesDo: [:blk | total := total + blk length ]].	^ total! !!NBExternalLibraryWrapper class methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 11/24/2012 16:23'!createArrayedMethodFor: aSpec	^ String streamContents: [:str |		str 			nextPutAll: aSpec asMethodSelectorAndArrayOfArguments ;			crtab;			nextPutAll: '<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>';			cr;			crtab;			nextPutAll: 'argsArray size = ', aSpec arguments size printString, ' ifFalse:[^Error signal: ''Incorrect number of arguments''].';			crtab;			nextPutAll: '^ self call: ';			nextPutAll: aSpec asArraySpecArrayedArgs ;			cr	].		! !!NBExternalLibraryWrapper class methodsFor: 'as yet unclassified' stamp: 'cipt 10/21/2012 20:14'!createMethodFor: aCFunctionDefinition	"find the function name"	| typeAndName spec source cat |	"the parameter list follows the fn name "	spec := NBFnSpec namedFunctionFrom: aCFunctionDefinition.	spec arguments size > 15		ifTrue: [ 			source := self createArrayedMethodFor: spec.			cat := 'automatically generated arrayed' ]		ifFalse: [ 			source := self createSimpleMethodFor: spec.			cat := 'automatically generated' ].	self compile: source classified: cat! !!NBExternalLibraryWrapper class methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 11/24/2012 16:23'!createSimpleMethodFor: aSpec	^ String		streamContents: [ :str | 			str				nextPutAll: aSpec asMethodSelectorAndArguments;				crtab;				nextPutAll: '<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>';				cr;				crtab;				nextPutAll: '^ self call: ';				nextPutAll: aSpec asArraySpec;				cr ]! !!NBExternalLibraryWrapper methodsFor: 'utils' stamp: 'IgorStasenko 11/24/2012 16:22'!call: fnSpec	" you can override this method if you need to"	^ (self nbCalloutIn: thisContext sender)		cdecl;			function: fnSpec module: self libraryNameOrHandle! !!NBExternalLibraryWrapper methodsFor: 'utils' stamp: 'IgorStasenko 8/20/2011 13:27'!libraryNameOrHandle	"provide a handle to the receiver's library"	self subclassResponsibility 	! !!NBExternalObject class methodsFor: 'instance creation' stamp: 'Igor.Stasenko 4/29/2010 09:18'!asNBExternalType: gen	^ NBExternalObjectType objectClass: self! !!NBExternalObject class methodsFor: 'instance creation' stamp: 'Igor.Stasenko 5/17/2010 14:29'!null	^ self new! !!NBExternalObject methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/17/2010 05:03'!handle	^ handle value! !!NBExternalObject methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/17/2010 05:03'!handle: aUint	handle value: aUint! !!NBExternalObject methodsFor: 'initialize-release' stamp: 'Igor.Stasenko 4/29/2010 12:25'!initialize	handle := NBExternalHandle new! !!NBExternalObject methodsFor: 'testing' stamp: 'Igor.Stasenko 5/17/2010 14:33'!isNull	^ handle value = 0! !!NBExternalObject methodsFor: 'printing' stamp: 'Igor.Stasenko 4/29/2010 10:21'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: '( 0x';		nextPutAll: (handle value printStringBase: 16);		space;		nextPut: $)! !!NBExternalObject methodsFor: 'external resource management' stamp: 'IgorStasenko 6/11/2012 05:36'!registerAsExternalResource	"Note, subclasses should implement #resourceData	and #finalizeResourceData: on class side"	NBExternalResourceManager addResource: self.	! !!NBNativeFunction class methodsFor: 'instance creation' stamp: 'CamilloBruni 8/3/2012 16:18'!cdecl: fnSpec emit: aFunctionBodyBlock	^ (NBNativeFunctionGen cdecl: fnSpec emit: aFunctionBodyBlock) install.! !!NBNativeFunction class methodsFor: 'instance creation' stamp: 'CamilloBruni 8/3/2012 16:18'!cdecl: fnSpec emit: aFunctionBodyBlock options: anOptionArray	^ (NBNativeFunctionGen cdecl: fnSpec emit: aFunctionBodyBlock options: anOptionArray) install.! !!NBNativeFunction class methodsFor: 'instance creation' stamp: 'CamilloBruni 8/3/2012 15:53'!code: code fnSpec: fnSpec		^ self basicNew		initializeWithCode: code fnSpec: fnSpec! !!NBNativeFunction class methodsFor: 'finalization' stamp: 'CamilloBruni 8/3/2012 15:24'!finalizeResourceData: anExternalAddress	anExternalAddress free! !!NBNativeFunction class methodsFor: 'instance creation' stamp: 'CamilloBruni 8/3/2012 16:18'!stdCall: fnSpec emit: aFunctionBodyBlock	^ (NBNativeFunctionGen stdCall: fnSpec emit: aFunctionBodyBlock) install.! !!NBNativeFunction class methodsFor: 'instance creation' stamp: 'CamilloBruni 8/3/2012 16:18'!stdCall: fnSpec emit: aFunctionBodyBlock options: anOptionArray	^ (NBNativeFunctionGen stdCall: fnSpec emit: aFunctionBodyBlock options: anOptionArray) install.! !!NBNativeFunction methodsFor: 'accessing' stamp: 'IgorStasenko 8/23/2012 18:16'!address	^ handle! !!NBNativeFunction methodsFor: 'accessing' stamp: 'CamilloBruni 10/3/2012 14:41'!annotation	^ annotation! !!NBNativeFunction methodsFor: 'accessing' stamp: 'CamilloBruni 10/3/2012 14:41'!annotation: anObject	annotation := anObject! !!NBNativeFunction methodsFor: 'code generation' stamp: 'CamilloBruni 10/4/2012 19:32'!emitCall: asm	" emit the asm code for calling myself "	asm mov: (handle asUImm32 annotation: self annotation) to: asm EAX.	asm call: asm EAX.! !!NBNativeFunction methodsFor: 'initialize-release' stamp: 'CamilloBruni 8/3/2012 15:53'!initializeWithCode: code fnSpec: aFnSpec		| bytes |	super initialize.		fnSpec := aFnSpec.	bytes := code bytes.	handle := NativeBoost allocate: bytes size.	NativeBoost 		memCopy: bytes 		to: handle 		size: bytes size.! !!NBNativeFunction methodsFor: 'accessing' stamp: 'CamilloBruni 8/3/2012 15:22'!resourceData	^ handle! !!NBNativeFunction methodsFor: 'accessing' stamp: 'IgorStasenko 8/23/2012 18:30'!uninstall	handle ifNotNil: [		NativeBoost free: handle.		handle := nil.		]! !!NBNativeFunction methodsFor: 'code generation' stamp: 'CamilloBruni 8/3/2012 16:17'!valueWithArguments: anArray	"call this native function with the given arguments"	self shouldBeImplemented.! !!NBExternalResourceExecutor methodsFor: 'finalizing' stamp: 'IgorStasenko 5/28/2012 03:54'!finalize 	(NativeBoost sessionChanged: session) ifFalse: [		resourceClass finalizeResourceData: data	]! !!NBExternalResourceExecutor methodsFor: 'initialize' stamp: 'IgorStasenko 3/23/2012 13:06'!initialize 	session := NativeBoost uniqueSessionObject ! !!NBExternalResourceExecutor methodsFor: 'initialize-release' stamp: 'IgorStasenko 3/23/2012 13:04'!resourceClass: aResourceClass data: aData	resourceClass := aResourceClass.	data := aData! !!NBExternalResourceManager class methodsFor: 'resource management' stamp: 'IgorStasenko 3/23/2012 13:13'!addResource: anObject 	self soleInstance addResource: anObject ! !!NBExternalResourceManager class methodsFor: 'resource management' stamp: 'IgorStasenko 3/28/2012 18:42'!addResource: anObject data: aData	self soleInstance addResource: anObject data: aData! !!NBExternalResourceManager class methodsFor: 'instance creation' stamp: 'IgorStasenko 6/2/2012 14:37'!reset	soleInstance := self new.! !!NBExternalResourceManager class methodsFor: 'accessing' stamp: 'IgorStasenko 3/23/2012 13:08'!soleInstance 	^ soleInstance ifNil: [ soleInstance  := self new ]! !!NBExternalResourceManager methodsFor: 'external resource management' stamp: 'IgorStasenko 3/27/2012 19:11'!addResource: anObject 	^ self addResource: anObject data: anObject resourceData! !!NBExternalResourceManager methodsFor: 'external resource management' stamp: 'IgorStasenko 3/27/2012 19:11'!addResource: anObject data: resourceData	registry add: anObject executor: 		(NBExternalResourceExecutor new resourceClass: anObject class data: resourceData)! !!NBExternalResourceManager methodsFor: 'initialize-release' stamp: 'IgorStasenko 6/2/2012 14:43'!initialize 	registry := NBFinalizationRegistry new! !!NBExternalStructure class methodsFor: 'testing' stamp: 'Igor.Stasenko 4/29/2010 04:13'!allocateOnCHeap	^ false! !!NBExternalStructure class methodsFor: 'testing' stamp: 'Igor.Stasenko 4/29/2010 04:14'!allocateOnObjectMemory	^ self allocateOnCHeap not! !!NBExternalStructure class methodsFor: 'ffi type' stamp: 'Igor.Stasenko 5/17/2010 18:44'!asNBExternalType: gen	^ NBExternalStructureType objectClass: self! !!NBExternalStructure class methodsFor: 'alignment' stamp: 'IgorStasenko 5/26/2012 17:45'!byteAlignment		"default "	^ NativeBoost forCurrentPlatform pointerSize! !!NBExternalStructure class methodsFor: 'managing accessors' stamp: 'Igor.Stasenko 5/22/2010 12:04'!createAccessorsFor: fieldName 	"Define read/write accessors for the given field"	| code |	code := fieldName,'	"This method was automatically generated"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin >		^ self fieldAt: ' , fieldName printString.	self compile: code classified: '*auto-accessing'.		code := fieldName,': anObject	"This method was automatically generated"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin >		^ self fieldAt: ' , fieldName printString , ' put: anObject'.	self compile: code classified: '*auto-accessing'.! !!NBExternalStructure class methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/19/2010 08:45'!fields	^ currentFields ifNil: [		self rebuildFieldAccessors.		currentFields	].! !!NBExternalStructure class methodsFor: 'accessing' stamp: 'CiprianTeodorov 1/19/2013 17:14'!fieldsClass	^NBExternalStructureFields ! !!NBExternalStructure class methodsFor: 'fields description' stamp: 'Igor.Stasenko 5/19/2010 09:01'!fieldsDesc	"override this method in a subclass to get an automatically generated	field accessors.		The field description format is following:		#(  		type1 name1;		type2 name2;		....	)	"	^ #()! !!NBExternalStructure class methodsFor: 'managing accessors' stamp: 'Igor.Stasenko 4/29/2010 04:44'!flushNativeFieldAccessors	methodDict do: [:method |		NBNativeCodeGen removeNativeCodeFrom: method ]! !!NBExternalStructure class methodsFor: 'instance creation' stamp: 'IgorStasenko 8/4/2011 05:53'!fromPointer: externalAddress	| inst |		inst:= self new.	NativeBoost memCopy: externalAddress to: inst size: self instanceSize.	^ inst! !!NBExternalStructure class methodsFor: 'class initialization' stamp: 'IgorStasenko 8/5/2011 12:02'!initializeAccessors	initialized := true.	self rebuildFieldAccessors.! !!NBExternalStructure class methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/19/2010 08:56'!instanceSize 		^ self fields totalSize	! !!NBExternalStructure class methodsFor: 'testing' stamp: 'IgorStasenko 8/5/2011 12:00'!isInitialized	^ initialized == true! !!NBExternalStructure class methodsFor: 'instance creation' stamp: 'Igor.Stasenko 5/19/2010 08:56'!new	^ (self basicNew: self fields totalSize) initialize! !!NBExternalStructure class methodsFor: 'managing accessors' stamp: 'IgorStasenko 8/3/2011 19:15'!noteCompilationOf: aSelector meta: isMeta	initialized == true ifFalse: [ ^ self ].	isMeta ifTrue: [ 		"Compilation on a class side , lets get rid of native methods on instance side"		(aSelector == #fieldsDesc or: [ aSelector == #byteAlignment ]) ifTrue: [ 			self flushNativeFieldAccessors.			self rebuildFieldAccessors ].	].! !!NBExternalStructure class methodsFor: 'accessing' stamp: 'IgorStasenko 2/2/2012 18:53'!offsetOf: aFieldName	^ self fields offsetOf: aFieldName! !!NBExternalStructure class methodsFor: 'managing accessors' stamp: 'CiprianTeodorov 1/19/2013 17:14'!rebuildFieldAccessors	currentFields ifNotNil: [		currentFields fieldNamesDo: [:field |			self removeAccessor: field.			self removeAccessor: field asMutator ]].	currentFields := self fieldsClass new 		parseFields: self fieldsDesc byteAlignment: self byteAlignment structure: self.	self fields fieldNamesDo: [:fldName | self createAccessorsFor: fldName ].	^ currentFields! !!NBExternalStructure class methodsFor: 'managing accessors' stamp: 'Igor.Stasenko 5/2/2010 13:30'!removeAccessor: aSelector	methodDict at: aSelector ifAbsent: [ ^ self ].	self removeSelector: aSelector.		! !!NBExternalStructure methodsFor: 'dnu' stamp: 'IgorStasenko 8/5/2011 12:01'!doesNotUnderstand: aMessage	self class isInitialized ifFalse: [		"retry send after initialization"		self class initializeAccessors.		^ aMessage sentTo: self	].	^ super doesNotUnderstand: aMessage! !!NBExternalStructure methodsFor: 'private' stamp: 'Igor.Stasenko 5/19/2010 09:08'!emitRead: aFieldName generator: gen	| offset type asm mem |				gen requestor: self class.	type := self class fields typeOf: aFieldName.	offset := self class fields offsetOf: aFieldName.	asm := gen asm.				gen proxy stackValue: 0.  "receiver oop"	gen proxy firstIndexableField: asm EAX.	"load the value"	mem := asm EAX ptr + offset.		"read a value from given location and return oop"	type readOop: mem generator: gen.	gen epilogue.	gen emitFailureHandler.		^ gen! !!NBExternalStructure methodsFor: 'private' stamp: 'IgorStasenko 5/26/2012 17:30'!emitWrite: aFieldName generator: gen	| offset type asm size rcvr fieldAddr |				gen requestor: self class.	type := self class fields typeOf: aFieldName.	offset := self class fields offsetOf: aFieldName.	rcvr := gen reserveTemp.	fieldAddr := gen reserveTemp.	asm := gen asm.	type loader: (NBSTMethodArgument new stackIndex: 0).	type emitPush: gen. "push value on stack"			gen proxy stackValue: 1.  "receiver oop"	asm mov: asm EAX to: rcvr.	gen proxy firstIndexableField: asm EAX.	offset > 0 ifTrue: [	 	asm add: asm EAX with: offset ].		asm mov: asm EAX to: fieldAddr.	gen emitFailureTest. "important to check if everything ok, before we write value to receiver"		size := type typeSize.		"just copy the value from stack to the struct field"		asm 		mov: fieldAddr to: asm EAX.		offset := 0.	[ size >= 4 ] whileTrue: [		asm 			mov: asm ESP ptr + offset to: asm ECX;			mov: asm ECX to: asm EAX ptr + offset.		size := size - 4.		offset := offset + 4.	].	size >= 2  ifTrue: [		asm 			mov: asm ESP ptr16 + offset to: asm CX;			mov: asm CX to: asm EAX ptr16 + offset.		size := size - 2.		offset := offset + 2.	].	size > 0  ifTrue: [		" last byte "		asm 			mov: asm ESP ptr8 + offset to: asm CL;			mov: asm CL to: asm EAX ptr8 + offset.	].	"answer the receiver"	asm mov: rcvr to: asm EAX.	gen epilogue.	gen emitFailureHandler.		^ gen	! !!NBExternalStructure methodsFor: 'private' stamp: 'IgorStasenko 5/22/2012 18:06'!fieldAt: aFieldName		^ NBFFICallout handleFailureIn: thisContext sender		nativeCode: [:gen | self emitRead: aFieldName generator: gen. gen bytes ]! !!NBExternalStructure methodsFor: 'private' stamp: 'Igor.Stasenko 4/28/2010 19:11'!fieldAt: aFieldName put: value	^ NBFFICallout handleFailureIn: thisContext sender		nativeCode: [:gen | self emitWrite: aFieldName generator: gen. gen bytes ]! !!NBExternalStructure methodsFor: 'printing' stamp: 'IgorStasenko 5/27/2012 03:15'!printOn: aStream 	"Append to the argument, aStream, the names and values of all the record's variables."	Printing == true ifTrue: [ 		"since we use field accessors for printing values,		debugging the code with not-yet nativised accessors leads to infinite loop"		^ aStream nextPutAll: self class name; nextPutAll: '(...)'.			].		Printing := true.	[ 		aStream nextPutAll: self class name; nextPutAll: ' ( '; cr.		self class fields namesInDeclarationOrder do: [ :field |			aStream nextPutAll: field; nextPut: $:; space; tab.				(self perform: field ) printOn: aStream.				] separatedBy: [ aStream cr ].		aStream cr; nextPut: $). ]	ensure: [	Printing := false ].	! !!NBExternalTypeValue class methodsFor: 'fields description' stamp: 'IgorStasenko 7/25/2012 02:28'!fieldsDesc  	valueType ifNil: [ ^ #() ].		^ { valueType. #value }! !!NBExternalTypeValue class methodsFor: 'class factory' stamp: 'CiprianTeodorov 12/16/2012 15:47'!getClassForType: aTypeName	"Do not confuse.!! This method answers an anonymous class,  a subclass of NBExternalTypeValue,	which can be used for instantiation later i.e:		floatTypeClass := NBExternalTypeValue ofType: 'float'.		float  := floatTypeClass new.	float value: 1.5.	float value.		"	| newSubclass |	newSubclass := ClassBuilder new		newSubclassOf: NBExternalTypeValue		type: NBExternalTypeValue typeOfClass		instanceVariables: ''		from: nil.	"we're not using 'self' to avoid wrong subclassing from anonymous subclass "	newSubclass valueType: aTypeName.	^ newSubclass! !!NBExternalTypeValue class methodsFor: 'class factory' stamp: 'IgorStasenko 7/25/2012 02:49'!ofType: aTypeName	^ self getClassForType: aTypeName! !!NBExternalTypeValue class methodsFor: 'accessing' stamp: 'IgorStasenko 7/25/2012 02:58'!valueType	^ valueType! !!NBExternalTypeValue class methodsFor: 'private' stamp: 'IgorStasenko 7/25/2012 03:33'!valueType: aTypeName	valueType := aTypeName.	self rebuildFieldAccessors! !!NBExternalTypeValue methodsFor: 'printing' stamp: 'IgorStasenko 7/25/2012 02:59'!printOn: aStream 	"Append to the argument, aStream, the names and values of all the record's variables."	Printing == true ifTrue: [ 		"since we use field accessors for printing values,		debugging the code with not-yet nativised accessors leads to infinite loop"		^ aStream nextPutAll: self class name; nextPutAll: '(...)'.			].		Printing := true.	[ 		aStream 			nextPutAll: self class name; 			nextPutAll: ' ( '; 			nextPutAll: self class valueType;			nextPutAll: ') (';		 cr.		self value printOn: aStream.		aStream cr; nextPut: $). ]	ensure: [ Printing := false ].	! !!NBExternalUnion class methodsFor: 'accessing' stamp: 'CiprianTeodorov 1/19/2013 17:15'!fieldsClass	^ NBExternalUnionFields! !!NBExternalStructureFields methodsFor: 'parsing spec' stamp: 'CiprianTeodorov 1/19/2013 17:18'!addField: aName type: aType	fields		at: aName		put:			{aType.			(totalSize - aType typeSize)}! !!NBExternalStructureFields methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/19/2010 07:15'!fieldNames	^ fields keys! !!NBExternalStructureFields methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/19/2010 07:16'!fieldNamesDo: aBlock	^ fields keysDo: [:name | aBlock value: name ]! !!NBExternalStructureFields methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/19/2010 09:20'!namesInDeclarationOrder	| result |		result := SortedCollection sortBlock: [:a :b | a value second < b value second ].	fields associationsDo: [:each  | result add: each ].			^ result collect: [:each | each key ]! !!NBExternalStructureFields methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/19/2010 07:16'!offsetOf: fieldName	^ (fields at: fieldName) at: 2! !!NBExternalStructureFields methodsFor: 'parsing spec' stamp: 'CiprianTeodorov 1/19/2013 17:19'!parseFields: fieldSpec byteAlignment: byteAlign structure: structClass	| stream type name gen align |	stream := fieldSpec readStream.	gen := NBFFICallout new requestor: structClass.		fields := Dictionary new.	totalSize := 0.	[ stream atEnd ] whileFalse: [ | arity |		type := gen resolveType: stream next. 		arity := 0.		[stream peek = #* ] whileTrue: [			arity := arity + 1.			stream next		].		type pointerArity: arity.				name := stream next.		name isSymbol ifFalse: [ self error: 'invalid field name'].		fields at: name ifPresent: [ self error: 'duplicate field name' ].		align := type typeSize min: byteAlign. "if byte align == 1, struct is packed"		"add padding between fields, if needed"		self sizeAlignedTo: align with: type. 		self addField: name type: type. 			stream peek == #';' ifTrue: [ stream next ].	].! !!NBExternalStructureFields methodsFor: 'parsing spec' stamp: 'CiprianTeodorov 1/19/2013 17:18'!sizeAlignedTo: anAlign with: aType	totalSize := (totalSize alignedTo: anAlign) + aType typeSize! !!NBExternalStructureFields methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/19/2010 06:41'!totalSize	^ totalSize! !!NBExternalStructureFields methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/19/2010 07:16'!typeOf: fieldName	^ (fields at: fieldName) at: 1! !!NBExternalUnionFields methodsFor: 'parsing spec' stamp: 'CiprianTeodorov 1/19/2013 17:05'!addField: aName type: aType	fields		at: aName		put:			{aType.			(nbFields := nbFields + 1)}! !!NBExternalUnionFields methodsFor: 'initialize-release' stamp: 'CiprianTeodorov 1/19/2013 17:05'!initialize	super initialize.		nbFields := 0.! !!NBExternalUnionFields methodsFor: 'accessing' stamp: 'CiprianTeodorov 1/19/2013 16:55'!offsetOf: fieldName	^ 0! !!NBExternalUnionFields methodsFor: 'parsing spec' stamp: 'CiprianTeodorov 1/19/2013 16:59'!sizeAlignedTo: anAlign with: aType	totalSize := (totalSize alignedTo: anAlign ) max: (aType typeSize alignedTo: anAlign)! !!NBExternalUnionFields methodsFor: 'accessing' stamp: 'CiprianTeodorov 1/19/2013 16:55'!typeOf: fieldName	^ (fields at: fieldName) at: 1! !!NBBool methodsFor: 'emitting code' stamp: 'Igor.Stasenko 4/28/2010 16:10'!coerceReturnValue: gen	"convert C Bool to true or false"	| proxy asm lfalse done |	proxy := gen proxy.	asm := gen asm.	lfalse := asm uniqueLabelName: 'false'.	done := asm uniqueLabelName: 'done'.	asm 		or: asm EAX with: asm EAX;		je: lfalse.	proxy trueObject.	asm jmp: done.	asm label: lfalse.	proxy falseObject.	asm label: done.! !!NBBool methodsFor: 'emitting code' stamp: 'Igor.Stasenko 4/30/2010 13:55'!pushAsValue: gen	gen asm push: (gen proxy booleanValueOf: (loader emitLoad: gen)).! !!NBBool methodsFor: 'accessing' stamp: 'IgorStasenko 5/26/2012 17:05'!valueSize	"Answer a number of bytes, which takes a value of given type	(not a pointer to it)	"	^ 1! !!NBBootstrapUlong methodsFor: 'emitting code' stamp: 'Igor.Stasenko 5/3/2010 01:29'!coerceReturnValue: gen	| args result asm proxy |	asm := gen asm.	proxy := gen proxy.	args := gen methodArgs.		result := gen reserveTemp.	asm mov: asm EAX to: result.		"load a returnValueBuffer method argument oop"	(NBSTMethodArgument new stackIndex: (args size - (args indexOf: #returnValueBuffer)))		emitLoad: gen.	proxy firstIndexableField: asm EAX.  "EAX - address , where to store result "	asm mov: result to: asm ECX.	asm mov: asm ECX to: asm EAX ptr.		"primitive will return nil"	proxy nilObject! !!NBBootstrapUlong methodsFor: 'accessing' stamp: 'IgorStasenko 5/26/2012 17:05'!valueSize	"Answer a number of bytes, which takes a value of given type	(not a pointer to it)	"	^ 4! !!NBByteArrayPtr methodsFor: 'emitting code' stamp: 'IgorStasenko 8/3/2011 19:47'!pushAsPointer: gen	self error: 'ByteArrayPtr is already pointer'! !!NBByteArrayPtr methodsFor: 'emitting code' stamp: 'CamilloBruni 7/23/2012 13:29'!pushAsValue: gen	"push a pointer to first indexable field of ByteArray, 	which is always oop + BaseHeaderSize  	"	| asm proxy |	asm := gen asm.	proxy := gen proxy.	loader emitLoad: gen.	asm decorateWith: 'NBByteArrayPtr>>pushAsValue:' during: [  			asm 			add: asm EAX with: proxy objectFormat varBytesFirstField;			push: asm EAX ]! !!NBByteArrayPtr methodsFor: 'accessing' stamp: 'IgorStasenko 5/26/2012 17:04'!valueSize	"Answer a number of bytes, which takes a value of given type	(not a pointer to it)	"	^ self pointerSize ! !!NBByteArraySize methodsFor: 'emitting code' stamp: 'Igor.Stasenko 5/3/2010 14:00'!coerceReturn: gen	self error: 'Can''t use this type as a return value'! !!NBByteArraySize methodsFor: 'emitting code' stamp: 'Igor.Stasenko 5/3/2010 22:44'!pushAsPointer: gen	self shouldNotImplement ! !!NBByteArraySize methodsFor: 'emitting code' stamp: 'Igor.Stasenko 5/3/2010 22:40'!pushAsValue: gen	" push the array size "	gen proxy slotSizeOf: (loader emitLoad: gen).	gen asm push: gen asm EAX! !!NBByteArraySize methodsFor: 'accessing' stamp: 'IgorStasenko 5/26/2012 17:04'!valueSize	"Answer a number of bytes, which takes a value of given type	(not a pointer to it)	"	^ 4! !!NBCharacterType methodsFor: 'emitting code' stamp: 'IgorStasenko 9/2/2012 23:34'!coerceReturnValue: gen	| asm proxy val |	"convert unsigned Char to ST Character"	asm := gen asm.	proxy := gen proxy.		val := gen reserveTemp.	asm movzx: asm EAX with: asm AL.	asm mov: asm EAX to: val.		proxy fetchPointer: val ofObject: (proxy characterTable).		gen releaseTemps: 1! !!NBCharacterType methodsFor: 'emitting code' stamp: 'IgorStasenko 9/2/2012 23:34'!pushAsValue: gen	"oop is a Character or smallint"	| asm oop classChar reg proxy notSmi done |		asm := gen asm.	proxy := gen proxy.	notSmi := asm uniqueLabelName: 'notSmi'.	done := asm uniqueLabelName: 'done'.		oop := gen reserveTemp.	classChar := gen reserveTemp.	reg := loader emitLoad: gen.	asm mov: reg to: oop.		reg := proxy isIntegerObject: reg.		asm or: reg with: reg;		je: notSmi.		asm push: (proxy integerValueOf: oop);		jmp: done.	asm label: notSmi.	reg := proxy classCharacter.	asm mov: reg to: classChar.	reg := proxy fetchClassOf: oop.	asm 		cmp: reg with: classChar;		jne: gen failedLabel.	reg := proxy fetchInteger: 0 ofObject: oop.	asm push: reg;	label: done.		gen releaseTemps: 2! !!NBCharacterType methodsFor: 'accessing' stamp: 'IgorStasenko 9/2/2012 23:34'!valueSize	^ 1! !!NBExternalAddressType methodsFor: 'emitting code' stamp: 'Igor.Stasenko 5/19/2010 12:15'!coerceReturnValue: gen	"input: address is in EAX. 	output: ExternalAddress instance oop in EAX	creates an instance of NBExternalAddress and store the address there"	| asm proxy result |		proxy := gen proxy.	asm := gen asm.	result := gen reserveTemp.		asm mov: asm EAX to: result.	proxy createInstanceOf: NBExternalAddress size: NBExternalType pointerSize.	asm mov: result to: asm ECX.	proxy storePointer: asm ECX intoVarbytes: asm EAX at: 0.	"return the oop in EAX"		gen releaseTemps: 1.	! !!NBExternalAddressType methodsFor: 'emitting code' stamp: 'CamilloBruni 7/23/2012 13:29'!pushAsPointer: gen	"push a pointer to external address first indexable field (where address value held)"	| asm proxy oop |		proxy := gen proxy.	asm := gen asm.		oop := gen reserveTemp.	loader emitLoad: gen to: oop.	"we can skip class verification, if loader loads receiver, since nothing to fear there"	loader isReceiver ifFalse: [		self verifyClassOf: oop is: NBExternalAddress generator: gen.	].	asm decorateWith: 'NBExternalAddressType>>pushAsPointer:' during: [  			proxy varBytesFirstFieldOf: oop.		asm 			push: asm EAX ].		gen releaseTemps: 1.! !!NBExternalAddressType methodsFor: 'emitting code' stamp: 'IgorStasenko 5/28/2012 07:13'!pushAsValue: gen	"push handle value"	| asm proxy oop |		proxy := gen proxy.	asm := gen asm.		oop := gen reserveTemp.	loader emitLoad: gen to: oop.		"we can skip class verification, if loader loads receiver, since nothing to fear there"	loader isReceiver ifFalse: [		self verifyClassOf: oop is: NBExternalAddress generator: gen.	].	proxy varBytesFirstFieldOf: oop.		self valueSize = 4 ifTrue: [		asm push: asm EAX ptr.	] ifFalse: [ self notYetImplemented ].	gen releaseTemps: 1.! !!NBExternalAddressType methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/4/2010 00:56'!valueSize	^ self pointerSize! !!NBExternalEnumerationType class methodsFor: 'instance creation' stamp: 'CiprianTeodorov 12/25/2012 13:29'!objectClass: aClass	^ self objectClass: aClass representationType: NBUInt32 new! !!NBExternalEnumerationType class methodsFor: 'instance creation' stamp: 'CiprianTeodorov 12/25/2012 13:29'!objectClass: aClass representationType: anIntegerType	^ self new		objectClass: aClass;		representationType: anIntegerType! !!NBExternalEnumerationType methodsFor: 'emitting code' stamp: 'CiprianTeodorov 2/6/2013 21:51'!coerceOopToOperand: gen ifFailedJumpTo: aLabel	"coerce a object - oop , provided by loader and then put a result into an appropriate 	operand (memory/register), answer that operand"	| asm proxy oop class |	self assert: pointerArity = 0.	asm := gen asm.	proxy := gen proxy.	oop := gen reserveTemp.	class := gen reserveTemp.	asm mov: asm EAX to: oop.	gen proxy fetchClassOf: oop.	asm mov: asm EAX to: class.	gen emitFetchClass: self objectClass.	asm		cmp: asm EAX with: class;		jne: aLabel.	proxy fetchPointer: self valueIvarIndex ofObject: oop.	"value ivar"	self representationType coerceOopToOperand: gen ifFailedJumpTo: aLabel.	asm push: asm EAX.	gen releaseTemps: 2! !!NBExternalEnumerationType methodsFor: 'emitting code' stamp: 'CiprianTeodorov 2/6/2013 21:38'!coerceReturnValue: gen	"value is in EAX, get a ST Integer and place it in the value ivar"	| asm proxy  valueOop oop done |		proxy := gen proxy.	asm := gen asm.	valueOop := gen reserveTemp.	oop := gen reserveTemp.	self representationType coerceReturnValue: gen.	asm mov: asm EAX to: valueOop.	proxy pushRemappableOop: valueOop.		gen emitFetchClass: objectClass.		proxy instantiateClass: asm EAX indexableSize: 0.	"EAX <- our instance "	asm mov: asm EAX to: oop.	proxy popRemappableOop.	asm mov: asm EAX to: valueOop.		proxy storePointer: self valueIvarIndex ofObject: oop  withValue: valueOop.	asm mov: oop to: asm EAX.  "return the oop"	gen releaseTemps: 2.! !!NBExternalEnumerationType methodsFor: 'accessing' stamp: 'CiprianTeodorov 12/25/2012 13:29'!objectClass	^ objectClass! !!NBExternalEnumerationType methodsFor: 'accessing' stamp: 'CiprianTeodorov 12/25/2012 13:29'!objectClass: anObject	objectClass := anObject! !!NBExternalEnumerationType methodsFor: 'printing' stamp: 'CiprianTeodorov 12/25/2012 13:29'!printOn: aStream	aStream nextPutAll: 'External enum(' , objectClass name , ')'! !!NBExternalEnumerationType methodsFor: 'emitting code' stamp: 'CiprianTeodorov 12/25/2012 13:29'!pushAsPointer: gen	"push a pointer to handle value"	| asm proxy oop |		self assert: (pointerArity = 1).		proxy := gen proxy.	asm := gen asm.		oop := gen reserveTemp.	loader emitLoad: gen to: oop.		self verifyClassOf: oop is: objectClass generator: gen.		proxy fetchPointer: (self valueIvarIndex) ofObject: oop. "value ivar"	proxy firstIndexableField: asm EAX. "value ptr"	asm push: asm EAX.		gen releaseTemps: 1.! !!NBExternalEnumerationType methodsFor: 'emitting code' stamp: 'CiprianTeodorov 12/25/2012 13:29'!pushAsValue: gen	"push value"	|asm proxy oop|	proxy := gen proxy.	asm := gen asm.	oop := gen reserveTemp.	loader emitLoad: gen to: oop.		"Special case: do not emit type checking if argument is receiver"	(loader isReceiver and: [  gen requestor  includesBehavior: objectClass ])	ifFalse: [		self verifyClassOf: oop is: objectClass generator: gen.	].	proxy fetchPointer: (self valueIvarIndex) ofObject: oop. "value ivar"	proxy integerValueOf: asm EAX. "handle value"	asm push: asm EAX.		gen releaseTemps: 1.! !!NBExternalEnumerationType methodsFor: 'accessing' stamp: 'CiprianTeodorov 12/11/2012 19:19'!representationType	^ representationType! !!NBExternalEnumerationType methodsFor: 'accessing' stamp: 'CiprianTeodorov 12/11/2012 19:19'!representationType: anObject	representationType := anObject! !!NBExternalEnumerationType methodsFor: 'accessing' stamp: 'CiprianTeodorov 12/25/2012 13:29'!valueIvarIndex	" return a zero-based index "	^ ( objectClass instVarIndexFor: #value ifAbsent: [ self error: ' should not happen ' ] ) - 1! !!NBExternalEnumerationType methodsFor: 'accessing' stamp: 'CiprianTeodorov 12/11/2012 21:45'!valueSize	^4! !!NBExternalObjectType class methodsFor: 'instance creation' stamp: 'Igor.Stasenko 4/29/2010 09:16'!objectClass: aClass	^ self new objectClass: aClass! !!NBExternalObjectType methodsFor: 'emitting code' stamp: 'Igor.Stasenko 4/29/2010 09:15'!coerceReturnPointer: gen		self error: 'returning pointer to handle ?'	"super coerceReturnPointer: gen"! !!NBExternalObjectType methodsFor: 'emitting code' stamp: 'IgorStasenko 8/29/2012 14:54'!coerceReturnValue: gen	"handle is in EAX. 	first, create an instance of NBExternalHandle. Place the handle there ,	then create an instance of receiver and place handle oop in its handle ivar"	| asm proxy result handleOop oop done |		proxy := gen proxy.	asm := gen asm.	result := gen reserveTemp.	handleOop := gen reserveTemp.	oop := gen reserveTemp.	done := asm uniqueLabelName: 'done'.		asm mov: asm EAX to: result.	gen optReturnNullAsNil ifTrue: [ | notnil |		notnil := asm uniqueLabelName: 'notNil'.				asm 			or: asm EAX with: asm EAX;			jne: notnil.		proxy nilObject.		asm jmp: done.		asm label: notnil.	].		gen emitFetchClass: NBExternalHandle.		proxy instantiateClass: asm EAX indexableSize: 4.	asm mov: asm EAX to: handleOop.	proxy firstIndexableField: asm EAX.	asm mov: result to: asm ECX;		mov: asm ECX to: asm EAX ptr.		proxy pushRemappableOop: handleOop.		gen emitFetchClass: objectClass.		proxy instantiateClass: asm EAX indexableSize: 0.	"EAX <- our instance "	asm mov: asm EAX to: oop.	proxy popRemappableOop.	asm mov: asm EAX to: handleOop.		proxy storePointer: self handleIvarIndex ofObject: oop  withValue: handleOop.		asm mov: oop to: asm EAX.  "return the oop"	gen releaseTemps: 3.	asm label: done.	! !!NBExternalObjectType methodsFor: 'accessing' stamp: 'Igor.Stasenko 4/29/2010 09:22'!handleIvarIndex	" return a zero-based index "	^ ( objectClass instVarIndexFor: #handle ifAbsent: [ self error: ' should not happen ' ] ) - 1! !!NBExternalObjectType methodsFor: 'accessing' stamp: 'Igor.Stasenko 4/29/2010 09:18'!objectClass	^ objectClass! !!NBExternalObjectType methodsFor: 'accessing' stamp: 'Igor.Stasenko 4/29/2010 09:18'!objectClass: aClass	objectClass := aClass! !!NBExternalObjectType methodsFor: 'printing' stamp: 'Igor.Stasenko 5/18/2010 01:25'!printOn: aStream	aStream nextPutAll: 'External Object(' , objectClass name , ')'! !!NBExternalObjectType methodsFor: 'emitting code' stamp: 'Igor.Stasenko 5/18/2010 02:46'!pushAsPointer: gen	"push a pointer to handle value"	| asm proxy oop |		self assert: (pointerArity = 1).		proxy := gen proxy.	asm := gen asm.		oop := gen reserveTemp.	loader emitLoad: gen to: oop.		self verifyClassOf: oop is: objectClass generator: gen.		proxy fetchPointer: (self handleIvarIndex) ofObject: oop. "handle ivar"	proxy firstIndexableField: asm EAX. "handle value ptr"	asm push: asm EAX.		gen releaseTemps: 1.! !!NBExternalObjectType methodsFor: 'emitting code' stamp: 'JavierPimas 11/14/2011 15:17'!pushAsValue: gen	"push handle value"	| asm proxy oop |		proxy := gen proxy.	asm := gen asm.		oop := gen reserveTemp.	loader emitLoad: gen to: oop.		"Special case: do not emit type checking if argument is receiver"	(loader isReceiver and: [  gen requestor  includesBehavior: objectClass ])	ifFalse: [		self verifyClassOf: oop is: objectClass generator: gen.	].	proxy fetchPointer: (self handleIvarIndex) ofObject: oop. "handle ivar"	proxy firstIndexableField: asm EAX. "handle value ptr"	asm mov: asm EAX ptr to: asm EAX. "handle value"	asm push: asm EAX.		gen releaseTemps: 1.	! !!NBExternalObjectType methodsFor: 'accessing' stamp: 'Igor.Stasenko 4/29/2010 13:52'!valueSize	^ self pointerSize! !!NBExternalStructureType class methodsFor: 'instance creation' stamp: 'Igor.Stasenko 5/17/2010 18:42'!objectClass: aClass	^ self new objectClass: aClass! !!NBExternalStructureType methodsFor: 'emitting code' stamp: 'IgorStasenko 5/4/2012 19:17'!coerceReturnValue: gen	| asm proxy |		asm := gen asm.	proxy := gen proxy.		self returnViaRegisters ifTrue: [		| temp1 temp2 oop |		"save struct value(s) into temps"		temp1 := gen reserveTemp.		asm mov: asm EAX to: 	temp1.					objectClass instanceSize > 4 ifTrue: [			temp2 := gen reserveTemp.			asm mov: asm EDX to: temp2		].			"instantiate our struct"		oop := gen reserveTemp.		gen emitFetchClass: objectClass.		proxy instantiateClass: asm EAX indexableSize: objectClass instanceSize.		asm mov: asm EAX to: oop.		proxy firstIndexableField: asm EAX. "in EAX is pointer to first byte of struct"		"copy struct values into newly created instance"		asm mov: temp1 to: asm ECX.		asm mov: asm ECX to: asm EAX ptr.		objectClass instanceSize > 4 ifTrue: [			asm mov: temp2 to: asm ECX.			asm mov: asm ECX to: asm EAX ptr + 4.		].		"return an instance of objectClass as result"		asm mov: oop to: asm EAX 			] ifFalse: [				"just return a previously instantiated struct oop"				asm mov: returnOop to: asm EAX	]! !!NBExternalStructureType methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/17/2010 18:43'!objectClass	^objectClass! !!NBExternalStructureType methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/17/2010 18:43'!objectClass: anObject	objectClass := anObject! !!NBExternalStructureType methodsFor: 'emitting code' stamp: 'IgorStasenko 5/4/2012 19:16'!prepareReturnValue: gen for: callinfo	| asm proxy |		asm := gen asm.	proxy := gen proxy.		(pointerArity = 0 and: [ self returnViaRegisters not ]) ifTrue: [		"we should instantiate a new instance of struct 		and push a pointer to its first byte on a stack (so C function will know where to store return value(s))"		returnOop := gen reserveTemp.		gen emitFetchClass: objectClass.		proxy instantiateClass:  asm EAX indexableSize: objectClass instanceSize.		asm mov: asm EAX to: returnOop.		proxy firstIndexableField: asm EAX. "in EAX is pointer to first byte of struct"				asm noticePush: asm pointerSize forCall: callinfo.		asm push: asm EAX	]! !!NBExternalStructureType methodsFor: 'emitting code' stamp: 'IgorStasenko 5/26/2012 00:53'!pushAsPointer: gen	"push a pointer to structure (which should be a subinstance of NBExternalStructure)"	| asm proxy oop |		proxy := gen proxy.	asm := gen asm.		oop := gen reserveTemp annotation: 'oop'.	loader emitLoad: gen to: oop.	self verifyClassOf: oop is: objectClass generator: gen.		"do a shortcut, since we know that variable bytes first byte offset"	asm mov: oop to: asm EAX;		add: asm EAX with: 			(proxy objectFormat varBytesFirstField asUImm32 				annotation: 'variable-byte first field offset').	asm push: asm EAX.	gen releaseTemps: 1.	! !!NBExternalStructureType methodsFor: 'emitting code' stamp: 'IgorStasenko 5/26/2012 14:19'!pushAsValue: gen	"pass a structure by value on stack"	| asm proxy oop bytesToCopy offset |		proxy := gen proxy.	asm := gen asm.		oop := gen reserveTemp annotation: 'oop'.	loader emitLoad: gen to: oop.		loader isReceiver ifFalse: [		"do not check type if argument is receiver, since we know its class"		self verifyClassOf: oop is: objectClass generator: gen.	].	asm mov: oop to: asm EAX;		add: asm EAX with: 			(proxy objectFormat varBytesFirstField asUImm32 				annotation: 'variable-byte first field offset').		"struct size aligned to stack argument alignment"	asm sub: asm ESP with: self stackSize. 	"generate code to copy struct contents on a stack.	source is [EAX]	destination is [ESP]	"	bytesToCopy := self valueSize. 	offset := 0.		"we can afford to read past struct size, since all objects 	in obj memory are 4-byte aligned"	[ bytesToCopy > 0 ] whileTrue: [		asm 			mov: asm EAX ptr32 + offset to: asm EDX;			mov: asm EDX to: asm ESP ptr32 + offset.					bytesToCopy := bytesToCopy - 4.		offset := offset + 4. 	].	gen releaseTemps: 1.	! !!NBExternalStructureType methodsFor: 'emitting code' stamp: 'IgorStasenko 9/3/2012 01:03'!readOop: memoryOperand generator: gen	"emit code to read a value from given memory operand	and convert it to a corresponding ST object" 	| asm proxy size offset oop src |		asm := gen asm.	proxy := gen proxy.	pointerArity > 0 ifTrue: [		asm mov: memoryOperand to: asm EAX.		^ self coerceReturn: gen.		].		"read structure from given address, copy it to newly created instance of corresponding struct class"		asm lea: asm EAX with: memoryOperand.	src := gen reserveTemp.	asm mov: asm EAX to: src.		"instantiate our struct"	oop := gen reserveTemp.	gen emitFetchClass: objectClass.	proxy instantiateClass: asm EAX indexableSize: self valueSize.	asm mov: asm EAX to: oop.	proxy varBytesFirstFieldOf: asm EAX.	asm mov: src to: asm EDX.	"in EAX is pointer to first byte of struct"	size := self valueSize.	offset := 0.	[ size >= 4 ] whileTrue: [		asm 			mov: asm EDX ptr + offset to: asm ECX;			mov: asm ECX to: asm EAX ptr + offset.		size := size - 4.		offset := offset + 4.	].	size >= 2  ifTrue: [		asm 			mov: asm EDX ptr16 + offset to: asm CX;			mov: asm CX to: asm EAX ptr16 + offset.		size := size - 2.		offset := offset + 2.	].	size > 0  ifTrue: [		" last byte "		asm 			mov: asm EDX ptr8 + offset to: asm CL;			mov: asm CL to: asm EAX ptr8 + offset.	].	"return an instance of objectClass as result"	asm mov: oop to: asm EAX ! !!NBExternalStructureType methodsFor: 'testing' stamp: 'CiprianTeodorov 1/28/2013 23:42'!returnViaRegisters"answer true if return-by-value for given struct are returned in registers.1byte, 2 bytes, and 4 bytes structures are returned in EAX.8 byte structures are returned in EDX:EAXotherwise it is assumed that caller passing a hidden argument (a pointer to struct)which callee using for filling the data""Both Mac OS X x86 and Win32 x86 return structs of a power of two in sizeless than or equal to eight bytes in length in registers. Linux never does so. "	^NativeBoost platformId = NativeBoostConstants linux32PlatformId		ifTrue:[false]		ifFalse:[ #(1 2 4 8) includes: self valueSize]! !!NBExternalStructureType methodsFor: 'accessing' stamp: 'IgorStasenko 5/26/2012 14:12'!valueSize 	^ objectClass instanceSize ! !!NBExternalType class methodsFor: 'converting' stamp: 'Igor.Stasenko 4/28/2010 12:20'!asNBExternalType: gen	^ self new! !!NBExternalType class methodsFor: 'accessing' stamp: 'Igor.Stasenko 4/29/2010 05:49'!pointerSize	"Answer a number of bytes, which takes a pointer value"	self flag: #x64.	^ 4! !!NBExternalType class methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 4/28/2010 11:25'!prepareArgument: typeArgument generator: gen	"by default, do nothing"! !!NBExternalType class methodsFor: 'public' stamp: 'IgorStasenko 12/30/2011 12:55'!sizeOf: aTypeName	^ (NBFFICallout new resolveType: aTypeName) valueSize! !!NBExternalType methodsFor: 'accessing' stamp: 'IgorStasenko 5/26/2012 14:30'!baseTypeSize	"Answer a number of bytes, which takes a value of given type	(not a pointer to it)	"		self subclassResponsibility ! !!NBExternalType methodsFor: 'emitting code' stamp: 'Igor.Stasenko 5/11/2010 01:30'!coerceOopToOperand: gen ifFailedJumpTo: aLabel	"coerce a object - oop , provided by loader and then put a result into an appropriate 	operand (memory/register), answer that operand"		self subclassResponsibility ! !!NBExternalType methodsFor: 'emitting code' stamp: 'Igor.Stasenko 4/28/2010 17:42'!coerceReturn: gen	 pointerArity > 0 ifTrue: [ self coerceReturnPointer: gen ]			ifFalse: [ self coerceReturnValue: gen ].! !!NBExternalType methodsFor: 'emitting code' stamp: 'IgorStasenko 12/20/2011 14:21'!coerceReturnPointer: gen	"Return a pointer to receiver. 	lets just return its value"		| asm EAX cont done |	asm := gen asm.	EAX := asm EAX.	cont := asm uniqueLabelName: 'cont'.	done := asm uniqueLabelName: 'done'.		(gen optReturnNullAsNil or: [gen optFailOnReturnNull ]) ifTrue: [		asm or: EAX with: EAX.		gen optFailOnReturnNull 			ifTrue: [	asm jz: gen failedLabel. ]			ifFalse: [				asm jnz: cont.				gen proxy nilObject.				asm jmp: done 	]	].	asm label: cont.	gen optReturnPtrAsExternalAddress 		ifTrue: [ 			(NBExternalAddress asNBExternalType: gen) coerceReturnValue: gen ]		ifFalse: [ 			gen optReturnPtrAsInt ifFalse: [				self error: 'Function returns a pointer, but returning raw pointer value is prohibited by options' ].			gen proxy positive32BitIntegerFor: asm EAX ].	asm label: done	! !!NBExternalType methodsFor: 'emitting code' stamp: 'Igor.Stasenko 4/30/2010 08:10'!coerceReturnValue: generator	"emit code to coerce return value from external function call"		self subclassResponsibility ! !!NBExternalType methodsFor: 'testing' stamp: 'IgorStasenko 5/11/2011 17:26'!coercionMayFail	"answer true if argument coercion ST->C may fail due to passing incomatible argument type.	Some types could accept any ST object as argument and therefore never fail,	and we don't need to check a primitive failuer before making a call.	By default, asnwer true	"	^ true! !!NBExternalType methodsFor: 'emitting code' stamp: 'IgorStasenko 5/11/2011 17:24'!emitPush: generator	pointerArity > 0 ifTrue: [ ^ self pushAsPointer: generator ].	 	generator coercionMayFail: self coercionMayFail.    	^ self pushAsValue: generator.! !!NBExternalType methodsFor: 'initialize-release' stamp: 'Igor.Stasenko 4/28/2010 11:34'!initialize	pointerArity := 0.! !!NBExternalType methodsFor: 'testing' stamp: 'Igor.Stasenko 5/1/2010 16:05'!isCallback	^ false! !!NBExternalType methodsFor: 'emitting code' stamp: 'IgorStasenko 5/26/2012 18:21'!loadMem: memoryOperand generator: gen.	"load the value from memory operand into return value register"	gen asm mov: memoryOperand to: (gen asm reg: 0 size: self typeSize).! !!NBExternalType methodsFor: 'accessing' stamp: 'Igor.Stasenko 4/30/2010 09:50'!loader	^ loader! !!NBExternalType methodsFor: 'accessing' stamp: 'Igor.Stasenko 4/30/2010 09:51'!loader: aLoader	loader := aLoader! !!NBExternalType methodsFor: 'accessing' stamp: 'Igor.Stasenko 4/28/2010 11:35'!pointerArity	^ pointerArity! !!NBExternalType methodsFor: 'accessing' stamp: 'Igor.Stasenko 4/28/2010 11:35'!pointerArity: additionalArity	pointerArity := pointerArity + additionalArity.! !!NBExternalType methodsFor: 'accessing' stamp: 'Igor.Stasenko 4/29/2010 05:49'!pointerSize	"Answer a number of bytes, which takes a pointer value"	^ self class pointerSize! !!NBExternalType methodsFor: 'emitting code' stamp: 'Igor.Stasenko 4/28/2010 11:41'!prepareArgumentUsing: aNBFFICallout 	"by default, do nothing"! !!NBExternalType methodsFor: 'emitting code' stamp: 'IgorStasenko 5/4/2012 17:08'!prepareReturnValue: gen for: callinfo	"do some extra for preparing a function return value holder.	no-op for most of the types, except external structures " ! !!NBExternalType methodsFor: 'printing' stamp: 'Igor.Stasenko 4/30/2010 09:22'!printOn: aStream	super printOn: aStream.		pointerArity timesRepeat: [ aStream nextPut: $* ].! !!NBExternalType methodsFor: 'emitting code' stamp: 'Igor.Stasenko 5/20/2010 06:31'!pushAsPointer: gen 	"by default, push argument as a bytearray ptr"		"may accept:		- nil		- variable bytes oop		- external address "	| asm proxy notNil done oop  notExternalAddress |		asm := gen asm.	proxy := gen proxy.	done := asm uniqueLabelName: 'done'.	oop := gen reserveTemp.		"load argument oop"	loader emitLoad: gen to: oop.		"handle nils, if we care"	gen optCoerceNilToNull ifTrue: [		notNil := asm uniqueLabelName: 'notNil'.		proxy nilObject.		asm cmp: asm EAX with: oop;		jne: notNil;		xor: asm EAX with: asm EAX;		push: asm EAX;		jmp: done;		label: notNil.	].	"handle ExternalAddress, if we care"	gen optAllowExternalAddressPtr ifTrue: [ | oopClass |		oopClass := gen reserveTemp.		notExternalAddress := asm uniqueLabelName: 'notExternalAddress'.		proxy fetchClassOf: oop.		asm mov: asm EAX to: oopClass.		gen emitFetchClass: NBExternalAddress.		asm cmp: asm EAX with: oopClass.		asm jne: notExternalAddress.				proxy fetchPointer: 0 ofObject: oop.  		asm push: asm EAX.				asm jmp: done.		asm label: notExternalAddress.		gen releaseTemps: 1.	].	"the last case is a byte/word array, 	simply push a pointer to first indexable field of oop"	gen optAllowByteArraysPtr ifTrue: [		proxy isBytesOrWords: oop ifNotJumpTo: gen failedLabel.		proxy firstIndexableField: oop.		asm push: asm EAX.		asm jmp: done.	].	asm jmp: gen failedLabel.	asm label: done.	gen releaseTemps: 1.	! !!NBExternalType methodsFor: 'emitting code' stamp: 'IgorStasenko 9/3/2012 01:03'!readOop: memoryOperand generator: gen	"emit code to read a value from given memory operand	and convert it to a corresponding ST object" 		memoryOperand size: self typeSize.	pointerArity > 0 		ifTrue: [ gen asm mov: memoryOperand to: gen asm EAX ]		ifFalse: [ self loadMem: memoryOperand generator: gen ].		self coerceReturn: gen! !!NBExternalType methodsFor: 'accessing' stamp: 'IgorStasenko 5/26/2012 01:04'!stackArgumentAlignment	"a minimum number of bytes, which argument of any type	can have on stack, when pushed as argument"	^ 4! !!NBExternalType methodsFor: 'accessing' stamp: 'IgorStasenko 5/26/2012 14:33'!stackSize	"Answer a number of bytes, which takes a value of given type when pushed on stack"		^ self typeSize alignedTo: self stackArgumentAlignment ! !!NBExternalType methodsFor: 'accessing' stamp: 'IgorStasenko 5/26/2012 14:26'!storageSize	"Answer a number of bytes, which receiver type takes in memory"		pointerArity > 0 ifTrue: [ ^ self pointerSize ].	^ self valueSize! !!NBExternalType methodsFor: 'accessing' stamp: 'CiprianTeodorov 12/16/2012 15:34'!typeName	| tName |	tName := self class name.	pointerArity timesRepeat: [ tName , '*' ].	^ tName! !!NBExternalType methodsFor: 'accessing' stamp: 'IgorStasenko 5/26/2012 17:09'!typeSize		"Answer a number of bytes, which receiver type takes in memory"	pointerArity > 0 ifTrue: [ ^ self pointerSize ].	^ self valueSize ! !!NBExternalType methodsFor: 'accessing' stamp: 'IgorStasenko 5/26/2012 14:28'!valueSize	"Answer a number of bytes, which takes a value of given type	(not a pointer to it)	"		self subclassResponsibility ! !!NBExternalType methodsFor: 'emitting code' stamp: 'IgorStasenko 8/8/2011 19:54'!verifyClassOf: oop is: aClass generator: gen	| asm class okLabel |	asm := gen asm.	okLabel := asm uniqueLabelName: 'classIsOk'.		class := gen reserveTemp.		gen proxy fetchClassOf: oop.	asm mov:  asm EAX to: class.		gen emitFetchClass: aClass.		asm cmp: asm EAX with: class;		je: okLabel.		gen failWithMessage: 'An instance of ' , aClass name , ' expected'.	asm label: okLabel.		gen releaseTemps: 1.! !!NBFFICallbackType methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/13/2010 23:33'!callbackClass: aClass	callbackClass := aClass! !!NBFFICallbackType methodsFor: 'emitting code' stamp: 'cipt 11/28/2012 19:36'!coerceReturnValue: gen	"trunk is in EAX. 	first, create an instance of NBExternalHandle. Place the trunk there ,	then create an instance of receiver and place trunk oop in its trunk ivar"	| asm proxy result trunkOop oop done |		proxy := gen proxy.	asm := gen asm.	result := gen reserveTemp.	trunkOop := gen reserveTemp.	oop := gen reserveTemp.	done := asm uniqueLabelName: 'done'.		asm mov: asm EAX to: result.	gen optReturnNullAsNil ifTrue: [ | notnil |		notnil := asm uniqueLabelName: 'notNil'.				asm 			or: asm EAX with: asm EAX;			jne: notnil.		proxy nilObject.		asm jmp: done.		asm label: notnil.	].		gen emitFetchClass: NBExternalAddress.		proxy instantiateClass: asm EAX indexableSize: 4.	asm mov: asm EAX to: trunkOop.	proxy firstIndexableField: asm EAX.	asm mov: result to: asm ECX;		mov: asm ECX to: asm EAX ptr.		proxy pushRemappableOop: trunkOop.		gen emitFetchClass: callbackClass.		proxy instantiateClass: asm EAX indexableSize: 0.	"EAX <- our instance "	asm mov: asm EAX to: oop.	proxy popRemappableOop.	asm mov: asm EAX to: trunkOop.		proxy storePointer: self trunkIvarIndex ofObject: oop  withValue: trunkOop.		asm mov: oop to: asm EAX.  "return the oop"	gen releaseTemps: 3.	asm label: done.! !!NBFFICallbackType methodsFor: 'testing' stamp: 'Igor.Stasenko 5/13/2010 23:31'!isCallback	^ true! !!NBFFICallbackType methodsFor: 'emitting code' stamp: 'IgorStasenko 9/15/2012 14:22'!pushAsValue: gen	"push the callback trunk address"	| asm proxy oop |		proxy := gen proxy.	asm := gen asm.		oop := gen reserveTemp.	loader emitLoad: gen to: oop.	self verifyClassOf: oop is: callbackClass generator: gen.		asm mov: oop to: asm EAX.	asm mov: asm EAX ptr + (proxy ivar: #trunk in: callbackClass) to: asm EAX. 	proxy fetchPointer: 0 ofObject: asm EAX. "callback address"	asm push: asm EAX.! !!NBFFICallbackType methodsFor: 'accessing' stamp: 'cipt 11/28/2012 19:04'!trunkIvarIndex	" return a zero-based index "	^ ( callbackClass instVarIndexFor: #trunk ifAbsent: [ self error: ' should not happen ' ] ) - 1! !!NBFFICallbackType methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/4/2010 05:16'!valueSize	^ self pointerSize! !!NBFloatPtr methodsFor: 'emitting code' stamp: 'IgorStasenko 12/21/2011 13:40'!pushAsPointer: gen	self error: 'only value-type arguments allowed'! !!NBFloatPtr methodsFor: 'emitting code' stamp: 'IgorStasenko 12/21/2011 14:26'!pushAsValue: gen	"argument in ST(0) "	| proxy oop asm |		proxy := gen proxy.	asm := gen asm.		oop := loader emitLoad: gen.	proxy verifyCompactClassOf: oop is: Float.	asm 		add: asm EAX with: proxy baseHeaderSize;		push: asm EAX.	! !!NBFloatPtr methodsFor: 'accessing' stamp: 'IgorStasenko 12/21/2011 13:40'!valueSize	^ self pointerSize! !!NBFloat128 methodsFor: 'accessing' stamp: 'Igor.Stasenko 4/28/2010 15:53'!valueSize	^ 16! !!NBFloat16 methodsFor: 'accessing' stamp: 'Igor.Stasenko 4/28/2010 15:53'!valueSize	^ 2! !!NBFloat32 methodsFor: 'emitting code' stamp: 'Igor.Stasenko 4/28/2010 14:43'!coerceReturnValue: gen	"return value in ST(0)"		NBFloat64 new pushValue: gen.	gen proxy gatedCallFn: #floatObjectOf: .	! !!NBFloat32 methodsFor: 'emitting code' stamp: 'Igor.Stasenko 4/28/2010 18:32'!loadMem: memoryOperand generator: gen.	"floats get loaded into FP stack"		gen asm fld: memoryOperand.! !!NBFloat32 methodsFor: 'emitting code' stamp: 'Igor.Stasenko 5/20/2010 04:06'!pushAsValue: gen	gen proxy pushFloatOopAsFloat32: (loader emitLoad: gen).! !!NBFloat32 methodsFor: 'accessing' stamp: 'Igor.Stasenko 4/28/2010 15:52'!valueSize	^ 4! !!NBFloat64 methodsFor: 'emitting code' stamp: 'Igor.Stasenko 4/28/2010 14:43'!coerceReturnValue: gen	"return value in ST(0)"		self pushValue: gen.	gen proxy gatedCallFn: #floatObjectOf: .! !!NBFloat64 methodsFor: 'emitting code' stamp: 'Igor.Stasenko 4/28/2010 18:32'!loadMem: memoryOperand generator: gen.	"floats get loaded into FP stack"		gen asm fld: memoryOperand.! !!NBFloat64 methodsFor: 'emitting code' stamp: 'JavierPimas 11/17/2011 11:04'!pushAsValue: gen	| proxy asm oop EAX |	proxy := gen proxy.	asm := gen asm.	EAX := asm EAX.	oop := loader emitLoad: gen.		asm mov: oop to: EAX.		proxy oop: EAX 		ifSmallInt: [			asm sar: EAX with: 1;			push: EAX;			push: EAX; " extra push to reserve totally 8 bytes on stack"			fild: asm ESP ptr32;			fstp: asm ESP ptr64 ] 		ifNotSmallInt: [			proxy pushFloatOopAsFloat64: EAX.		].! !!NBFloat64 methodsFor: 'emitting code' stamp: 'Igor.Stasenko 5/2/2010 20:41'!pushValue: gen	"argument in ST(0) "	| asm |	asm := gen asm.		asm sub: (asm ESP) with: 8.	asm fstp: asm ESP ptr64		! !!NBFloat64 methodsFor: 'accessing' stamp: 'IgorStasenko 5/26/2012 14:01'!stackSize	"Answer a number of bytes, which takes a value of given type when pushed on stack"	pointerArity > 0 ifTrue: [ ^ self pointerSize ].	^ 8! !!NBFloat64 methodsFor: 'accessing' stamp: 'Igor.Stasenko 4/28/2010 15:52'!valueSize	^ 8! !!NBSizeT class methodsFor: 'converting' stamp: 'IgorStasenko 9/3/2012 00:10'!asNBExternalType: gen	self pointerSize = 4 ifTrue: [		^ (gen resolveType: #uint32 )		].		self pointerSize = 8 ifTrue: [		^  (gen resolveType: #uint64 )		].		self error: 'no clue'! !!NBInt16 methodsFor: 'emitting code' stamp: 'IgorStasenko 9/2/2012 23:14'!coerceReturnValue: gen	| asm |	"convert signed short to ST integer"	asm := gen asm.		asm movsx: asm EAX with: asm AX.	gen proxy integerObjectOf: asm EAX. 	! !!NBInt16 methodsFor: 'emitting code' stamp: 'IgorStasenko 9/2/2012 23:14'!pushAsValue: gen	gen asm push: (gen proxy integerValueOf: (loader emitLoad: gen))! !!NBUInt16 methodsFor: 'emitting code' stamp: 'IgorStasenko 9/2/2012 23:14'!coerceReturnValue: gen	| asm |		"convert signed short to ST integer"	asm := gen asm.		asm movzx: asm EAX with: asm AX.	gen proxy integerObjectOf: asm EAX. 	! !!NBUInt16 methodsFor: 'emitting code' stamp: 'IgorStasenko 9/2/2012 23:14'!pushAsValue: gen	gen asm push: (gen proxy positive32BitValueOf: (loader emitLoad: gen))! !!NBUInt16 methodsFor: 'accessing' stamp: 'IgorStasenko 9/2/2012 23:14'!valueSize	^ 2! !!NBInt32 methodsFor: 'emitting code' stamp: 'IgorStasenko 9/2/2012 23:17'!coerceOopToOperand: gen ifFailedJumpTo: aLabel	" input: 		EAX - oop	  output:	      EAX - result of coercion	"		self assert: (pointerArity = 0).	gen proxy signed32BitValueOf: gen asm EAX! !!NBInt32 methodsFor: 'emitting code' stamp: 'IgorStasenko 9/2/2012 23:17'!coerceReturnValue: gen		"convert int32 to ST integer"	gen proxy signed32BitIntegerFor: (gen returnValueRegister). 	! !!NBInt32 methodsFor: 'emitting code' stamp: 'IgorStasenko 9/2/2012 23:17'!pushAsValue: gen	gen asm push: (gen proxy signed32BitValueOf: (loader emitLoad: gen) )! !!NBUInt32 methodsFor: 'emitting code' stamp: 'CiprianTeodorov 12/11/2012 19:22'!coerceOopToOperand: gen ifFailedJumpTo: aLabel	" input: 		EAX - oop	  output:	      EAX - result of coercion	"		self assert: (pointerArity = 0).	gen proxy positive32BitValueOf: gen asm EAX! !!NBUInt32 methodsFor: 'emitting code' stamp: 'IgorStasenko 9/2/2012 23:17'!coerceReturnValue: gen	| asm |		"convert signed byte to ST integer"	asm := gen asm.		gen proxy positive32BitIntegerFor: asm EAX.! !!NBUInt32 methodsFor: 'emitting code' stamp: 'IgorStasenko 9/2/2012 23:17'!pushAsValue: gen	| asm |	asm := gen asm.	asm push:		(gen proxy positive32BitValueOf: (loader emitLoad: gen)).	gen optCheckFailOnEveryArgument ifTrue: [		gen proxy ifFailedEmit: [  gen failWithMessage: 'Argument coercion failed: positive 32-bit integer value expected' ].	].! !!NBUInt32 methodsFor: 'accessing' stamp: 'IgorStasenko 9/2/2012 23:17'!valueSize	^ 4! !!NBInt64 methodsFor: 'emitting code' stamp: 'IgorStasenko 9/3/2012 00:55'!coerceReturnValue: gen		"convert 64-bit unsigned value in EAX:EDX to ST integer"	gen proxy signed64BitIntegerFor		! !!NBInt64 methodsFor: 'emitting code' stamp: 'IgorStasenko 9/3/2012 00:24'!pushAsValue: gen	| asm |	asm := gen asm.	gen proxy signed64BitValueOf: (loader emitLoad: gen).	asm 		push: asm EDX;		push: asm EAX.	gen optCheckFailOnEveryArgument ifTrue: [		gen proxy ifFailedEmit: [  gen failWithMessage: 'Argument coercion failed: signed 64-bit integer value expected' ].	].! !!NBUInt64 methodsFor: 'emitting code' stamp: 'IgorStasenko 9/3/2012 00:57'!coerceReturnValue: gen		"convert 64-bit unsigned value in EAX:EDX to ST integer"	gen proxy positive64BitIntegerFor		! !!NBUInt64 methodsFor: 'emitting code' stamp: 'IgorStasenko 9/3/2012 01:10'!loadMem: memoryOperand generator: gen	self shouldNotImplement! !!NBUInt64 methodsFor: 'emitting code' stamp: 'IgorStasenko 9/3/2012 00:25'!pushAsValue: gen	| asm |	asm := gen asm.	gen proxy positive64BitValueOf: (loader emitLoad: gen).	asm 		push: asm EDX;		push: asm EAX.	gen optCheckFailOnEveryArgument ifTrue: [		gen proxy ifFailedEmit: [  gen failWithMessage: 'Argument coercion failed: unsigned 64-bit integer value expected' ].	].! !!NBUInt64 methodsFor: 'emitting code' stamp: 'IgorStasenko 9/3/2012 01:11'!readOop: memoryOperand generator: gen	"emit code to read a value from given memory operand	and convert it to a corresponding ST object" 	| asm |		pointerArity > 0 ifTrue: [		asm mov: memoryOperand to: asm EAX.		^ self coerceReturn: gen		].		asm := gen asm.		asm 		lea: asm EAX with: memoryOperand;		mov: asm EAX ptr + 4 to: asm EDX;		mov: asm EAX ptr to: asm EAX.  		self coerceReturn: gen	! !!NBUInt64 methodsFor: 'accessing' stamp: 'IgorStasenko 9/2/2012 23:22'!valueSize	^ 8! !!NBInt8 methodsFor: 'emitting code' stamp: 'IgorStasenko 9/2/2012 23:12'!coerceReturnValue: gen	| asm |		"convert signed byte to ST integer"	asm := gen asm.		asm movsx: asm EAX with: asm AL.	gen proxy integerObjectOf: asm EAX. 	! !!NBInt8 methodsFor: 'emitting code' stamp: 'IgorStasenko 9/2/2012 23:12'!pushAsValue: gen	"should we truncate it to 8bit value here?"	gen asm push: (gen proxy integerValueOf: (loader emitLoad: gen) )		! !!NBUInt8 methodsFor: 'emitting code' stamp: 'IgorStasenko 9/2/2012 23:12'!coerceReturnValue: gen	| asm |		"convert unsigned byte to ST integer"	asm := gen asm.		asm movzx: asm EAX with: asm AL.	gen proxy integerObjectOf: asm EAX. 	! !!NBUInt8 methodsFor: 'emitting code' stamp: 'IgorStasenko 9/2/2012 23:12'!pushAsValue: gen 	gen asm push: (	gen proxy positive32BitValueOf: (loader emitLoad: gen)).	! !!NBUInt8 methodsFor: 'accessing' stamp: 'IgorStasenko 9/2/2012 23:12'!valueSize	^ 1! !!NBOop methodsFor: 'emitting code' stamp: 'Igor.Stasenko 5/1/2010 12:04'!coerceReturnValue: generator	"oop is already in EAX, we don't need to do anything"! !!NBOop methodsFor: 'emitting code' stamp: 'Igor.Stasenko 4/29/2010 07:56'!pushAsPointer: gen	self error: 'oop is already a pointer. go away'.! !!NBOop methodsFor: 'emitting code' stamp: 'Igor.Stasenko 4/30/2010 13:55'!pushAsValue: gen	gen asm push: (loader emitLoad: gen) 	! !!NBOop methodsFor: 'accessing' stamp: 'IgorStasenko 5/28/2012 01:38'!valueSize	"Answer a number of bytes, which takes a value of given type	(not a pointer to it)	"		^ self pointerSize  ! !!NBVoid methodsFor: 'emitting code' stamp: 'Igor.Stasenko 5/11/2010 02:30'!coerceOopToOperand: gen ifFailedJumpTo: aLabel	"coerce a object - oop , provided by loader and then put a result into an appropriate 	operand (memory/register), answer that operand"		pointerArity = 0 ifTrue: [ ^ self .  "returning void, do nothing " ].		self shouldBeImplemented ! !!NBVoid methodsFor: 'emitting code' stamp: 'Igor.Stasenko 5/3/2010 14:00'!coerceReturnValue: gen	"just return nil"		gen proxy nilObject! !!NBVoid methodsFor: 'emitting code' stamp: 'IgorStasenko 9/3/2012 00:14'!pushAsValue: gen	self error: 'pushing void ... puff... done!!'! !!NBVoid methodsFor: 'accessing' stamp: 'CiprianTeodorov 12/15/2012 21:13'!valueSize 	pointerArity < 1 ifTrue: [^self error: 'void has unknown size'].	^self pointerSize ! !!NBExtraRootsRegistry class methodsFor: 'instance creation' stamp: 'Igor.Stasenko 5/2/2010 12:50'!new	self error: 'use #newWithCell:'! !!NBExtraRootsRegistry class methodsFor: 'instance creation' stamp: 'Igor.Stasenko 5/2/2010 12:50'!newWithCell: aMemoryCell	^ self basicNew initialize: aMemoryCell! !!NBExtraRootsRegistry methodsFor: 'accessing' stamp: 'Igor.Stasenko 4/29/2010 06:36'!at: aName	"Answer an object associated with given name."	| index |	index := pool at: aName.	^ array at: index! !!NBExtraRootsRegistry methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/14/2010 02:06'!at: aName ifAbsent: aBlock	"Answer an object associated with given name."	| index |	index := pool at: aName ifAbsent: [ ^ aBlock value ].	^ array at: index! !!NBExtraRootsRegistry methodsFor: 'accessing' stamp: 'CamilloBruni 7/23/2012 17:54'!at: aName ifAbsentPut: aBlock	^ self at: aName ifAbsent: [ self at: aName put: aBlock value ]! !!NBExtraRootsRegistry methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/2/2010 12:52'!at: aName put: anObject	"register an object under given name."	| sz index |	sz := array size.	index := sz + 1.	(pool includesKey: aName) 		ifTrue: [	index := pool at: aName ]		ifFalse: [ pool at: aName put: index ].			(index > array size) ifTrue: [		array := array copyWith: anObject.		self primAtMem: cell put: array.		].		array at: index put: anObject.	^ anObject.	! !!NBExtraRootsRegistry methodsFor: 'callbacks support' stamp: 'Igor.Stasenko 5/18/2010 02:48'!emitFetchCallback: index generator: gen	"index are one, returned from #registerCallback "	| reg temp |	index isMem 		ifTrue: [ temp := index ]		ifFalse: [ temp := gen reserveTemp. gen asm mov: index to: temp ].	pool at: #callbacks ifAbsent: [		self at: #callbacks put: WeakArray new ].		reg := self emitOopAt: #callbacks generator: gen.	reg := gen proxy fetchPointer: temp ofObject: reg.		index isMem ifFalse: [ gen releaseTemps: 1 ].	^ reg! !!NBExtraRootsRegistry methodsFor: 'code generation' stamp: 'Igor.Stasenko 5/1/2010 12:44'!emitFetchClass: aClass generator: gen	(self assert: aClass  isMeta not ).  " no metaclasses here"	"make sure we registered it"	self at: aClass name put: aClass.	^ self emitOopAt: aClass name	generator: gen! !!NBExtraRootsRegistry methodsFor: 'code generation' stamp: 'CamilloBruni 10/3/2012 14:42'!emitOopAt: aName generator: gen	"emit code for fetching an oop at given name from registry"		| asm proxy index |		proxy := gen proxy.	asm := gen asm.	index := pool at: aName.		asm decorateWith: 'NBExtraRootsRegistry at: ', aName printString , ' (' , index asString , ')' during: [  		asm mov: cell asUImm32 to: asm EAX.		asm mov: asm EAX ptr to: asm EAX.  "array oop -> EAX"			proxy fetchPointer: index-1 ofObject: asm EAX. ].	"EAX <- oop"	^ asm EAX! !!NBExtraRootsRegistry methodsFor: 'initialize-release' stamp: 'Igor.Stasenko 5/5/2010 13:46'!initialize: aMemoryCell	freeCallbackIndexes := OrderedCollection new.	pool := IdentityDictionary new.	array := Array new.		cell := aMemoryCell asUnsignedLong. 		self primAtMem: cell put: array.	self primAddGCRoot: cell.		self at: #'___seed' put: Seed.	self assert: array size = 1.	! !!NBExtraRootsRegistry methodsFor: 'primitives' stamp: 'IgorStasenko 11/24/2012 16:25'!primAddGCRoot: addr	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>	"add a given address as GC root"		^ self nbCallout function: #(void ( ulong addr ) ) emit: [:gen |		| proxy asm |		proxy := gen proxy.		asm := gen asm.				asm 			pop: asm EAX. "address"					proxy addGCRoot: asm EAX.	].	! !!NBExtraRootsRegistry methodsFor: 'primitives' stamp: 'IgorStasenko 11/24/2012 16:25'!primAtMem: addr put: anOop 	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>	"write an oop to given memory address"		^ self nbCallout function: #(void ( ulong addr, oop anOop )) emit: [:gen |		| proxy asm |		proxy := gen proxy.		asm := gen asm.				asm 			pop: asm EAX; "address"			pop: asm ECX; "oop"			mov: asm ECX to: asm EAX ptr	].	! !!NBExtraRootsRegistry methodsFor: 'callbacks support' stamp: 'Igor.Stasenko 5/5/2010 21:09'!registerCallback: aCallback	"answer a zero-based index of registered callback "	| index callbacks |		callbacks := pool at: #callbacks ifAbsent: [		self at: #callbacks put: (WeakArray with: aCallback).		^ 0.		].	callbacks := array at: callbacks.	freeCallbackIndexes ifEmpty: [				callbacks := callbacks copyWith: aCallback.		self at: #callbacks put: callbacks.		^ callbacks size - 1		].		index := freeCallbackIndexes removeLast.	callbacks at: index+1 put: aCallback.	^ index	! !!NBExtraRootsRegistry methodsFor: 'callbacks support' stamp: 'Igor.Stasenko 5/14/2010 02:07'!releaseCallbackIndex: anIndex	| callbacks |	"release a previously registered zero-based callback index"		callbacks := self at: #callbacks ifAbsent: [^ self ].		freeCallbackIndexes add: anIndex.	callbacks at: anIndex+1 put: nil.! !!NBFFICalloutAPI class methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 11/22/2012 14:24'!inContext: aContext	^ self new context: aContext! !!NBFFICalloutAPI methodsFor: 'call conventions' stamp: 'IgorStasenko 11/22/2012 18:11'!cdecl	conv := #cdecl! !!NBFFICalloutAPI methodsFor: 'accessing' stamp: 'IgorStasenko 11/22/2012 14:23'!context	^ context! !!NBFFICalloutAPI methodsFor: 'accessing' stamp: 'IgorStasenko 11/22/2012 14:23'!context: anObject	context := anObject! !!NBFFICalloutAPI methodsFor: 'accessing' stamp: 'IgorStasenko 11/23/2012 13:56'!convention: aCallConvention	conv := aCallConvention ! !!NBFFICalloutAPI methodsFor: 'action' stamp: 'IgorStasenko 11/25/2012 15:40'!function: functionSignature address: fnAddressBlock	^ NBFFICallout handleFailureIn: context nativeCode: [:gen |			gen				callType: conv;				sender: context;				parseOptions: options;				anonSpec: functionSignature;				generateCallToAddress: fnAddressBlock  		]! !!NBFFICalloutAPI methodsFor: 'action' stamp: 'IgorStasenko 11/24/2012 22:38'!function: functionSignature emit: aCallEmittingBlock	^ NBFFICallout handleFailureIn: context nativeCode: [:gen |			gen				useEmitCall;				callType: conv;				sender: context;				parseOptions: options;								anonSpec: functionSignature;				generate: aCallEmittingBlock  		]! !!NBFFICalloutAPI methodsFor: 'action' stamp: 'IgorStasenko 11/24/2012 22:38'!function: functionSignature module: moduleNameOrHandle	^ NBFFICallout		handleFailureIn: context nativeCode: [:gen |			gen 				callType: conv;				sender: context;				parseOptions: options;				generateCall: functionSignature module: moduleNameOrHandle 		]! !!NBFFICalloutAPI methodsFor: 'initialize-release' stamp: 'IgorStasenko 11/22/2012 18:18'!initialize	conv := #cdecl.	options := #().! !!NBFFICalloutAPI methodsFor: 'options' stamp: 'IgorStasenko 11/22/2012 18:12'!options: codeGenerationOptions	options := codeGenerationOptions! !!NBFFICalloutAPI methodsFor: 'call conventions' stamp: 'IgorStasenko 11/22/2012 18:11'!stdcall	conv := #stdcall! !!NBFFIConst class methodsFor: 'instance creation' stamp: 'Igor.Stasenko 4/15/2010 22:18'!value: aValue	^ self new value: aValue! !!NBFFIConst methodsFor: 'testing' stamp: 'IgorStasenko 5/11/2011 17:27'!coercionMayFail	"Constants are pushed as is, and there is no any coercion required, so it cannot fail anything"		^ false! !!NBFFIConst methodsFor: 'emitting code' stamp: 'Igor.Stasenko 4/15/2010 22:33'!emitPush: gen	gen asm push: ((gen asm imm: value) size: 4)! !!NBFFIConst methodsFor: 'testing' stamp: 'Igor.Stasenko 5/3/2010 00:53'!isCallback	^ false! !!NBFFIConst methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/18/2010 23:07'!loader	^ self! !!NBFFIConst methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 4/30/2010 11:46'!pointerArity: ptrArity	ptrArity > 0 ifTrue: [ self error: 'passing pointer to constant' ]! !!NBFFIConst methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 4/28/2010 13:54'!prepareArgumentUsing: gen	"do nothing"! !!NBFFIConst methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 4/26/2010 03:21'!prepareUsing: gen	"do nothing"	^ self! !!NBFFIConst methodsFor: 'accessing' stamp: 'IgorStasenko 8/2/2011 14:39'!stackSize	^ 4! !!NBFFIConst methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 5/18/2010 23:08'!usesSTStack	"Test, whether a receiver using an ST method's argument	for converting it into a corresponding C value for pushing on stack	"	^ false! !!NBFFIConst methodsFor: 'accessing' stamp: 'Igor.Stasenko 4/15/2010 22:17'!value	^ value! !!NBFFIConst methodsFor: 'accessing' stamp: 'Igor.Stasenko 4/15/2010 22:17'!value: aValue	value := aValue! !!NBFinalizationRegistry methodsFor: 'accessing' stamp: 'IgorStasenko 5/31/2012 02:59'!add: anObject	^ self add: anObject executor: anObject executor! !!NBFinalizationRegistry methodsFor: 'accessing' stamp: 'IgorStasenko 5/31/2012 14:55'!add: anObject executor: executor	| item |		"fool protection"	anObject ifNil: [ self error: 'nil cannot be finalized!!!!'].		sema critical: [		item := self getFreeItem.		item object: anObject executor: executor	].	^ item! !!NBFinalizationRegistry methodsFor: 'finalizing' stamp: 'IgorStasenko 8/24/2012 17:17'!finalizeValues 	"Finalize any values, which happen to be stocked in finalization list, due to some weak references become garbage"		sema critical: [ | item next |		item := list swapWithNil.		[ item notNil ]	whileTrue: [			next := item next.			[ item finalizeValues ] on: Exception fork: [:ex | ex pass ].						item markAsFree: nextFreeIndex.			nextFreeIndex := item index.			item := next.		]	].! !!NBFinalizationRegistry methodsFor: 'private' stamp: 'IgorStasenko 5/31/2012 03:57'!formatItems: startingIndex	startingIndex to: items size do: [:i | | item |		item := 			NBWeakFinalizerItem new				list: list index: i freeIndex: nextFreeIndex.		items at: i put: item.		nextFreeIndex := i.	].! !!NBFinalizationRegistry methodsFor: 'for tests only' stamp: 'IgorStasenko 5/31/2012 14:44'!freeItemsDo: aBlock	| free index |	sema critical: [		index := nextFreeIndex.				[ index notNil ] whileTrue: [  |next item|			item := items at: index.			next := item nextFreeIndex.			aBlock value: item.			index := next		]]! !!NBFinalizationRegistry methodsFor: 'private' stamp: 'IgorStasenko 5/31/2012 03:58'!getFreeItem	| item nextFree |	nextFreeIndex ifNil: [ self grow ].	item := items at: nextFreeIndex.	nextFreeIndex := item nextFreeIndex.	^ item! !!NBFinalizationRegistry methodsFor: 'private' stamp: 'IgorStasenko 5/31/2012 03:55'!grow	"double the items array size"	| oldSz |	oldSz := items size.	items := items grownBy: oldSz.		self formatItems: oldSz+1	! !!NBFinalizationRegistry methodsFor: 'accessing' stamp: 'IgorStasenko 5/31/2012 02:56'!initialSize	^ 100! !!NBFinalizationRegistry methodsFor: 'initialize-release' stamp: 'IgorStasenko 5/31/2012 14:51'!initialize	super initialize.	sema := Semaphore forMutualExclusion.	self reset.	WeakArray addWeakDependent: self! !!NBFinalizationRegistry methodsFor: 'for tests only' stamp: 'IgorStasenko 5/31/2012 14:41'!items	^ items! !!NBFinalizationRegistry methodsFor: 'private' stamp: 'IgorStasenko 5/31/2012 14:24'!reset	sema critical: [		nextFreeIndex := nil.		list := WeakFinalizationList new.		items := Array new: self initialSize.		self formatItems: 1.	]		! !!NBFnArgument methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 4/30/2010 10:46'!emitLoad: gen	"emit instructions to load a function argument into default register	(EAX for integral types, FP(0) for floating point)"		self subclassResponsibility ! !!NBFnArgument methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 4/30/2010 12:21'!emitLoad: gen to: operand	"emit instructions to load a function argument into given operand"		self subclassResponsibility ! !!NBFnArgument methodsFor: 'testing' stamp: 'IgorStasenko 8/5/2011 18:02'!isReceiver 	"answer true if loader loads a primitive method's receiver "	^ false! !!NBFnArgument methodsFor: 'testing' stamp: 'Igor.Stasenko 5/18/2010 02:21'!usesSTStack	^ false! !!NBNativeFunctionArgument methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 5/3/2010 18:58'!name	^ name! !!NBNativeFunctionArgument methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 5/3/2010 18:58'!name: aName	name := aName! !!NBNativeFunctionArgument methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/3/2010 19:13'!offset	^offset! !!NBNativeFunctionArgument methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/3/2010 19:13'!offset: anObject	offset := anObject! !!NBNativeFunctionArgument methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/3/2010 19:13'!type	^type! !!NBNativeFunctionArgument methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/3/2010 19:13'!type: anObject	type := anObject! !!NBSTIndirectArgument methodsFor: 'accessing' stamp: 'cipt 10/24/2012 20:34'!argumentLoader	^ argumentLoader! !!NBSTIndirectArgument methodsFor: 'accessing' stamp: 'cipt 10/24/2012 20:34'!argumentLoader: anObject	argumentLoader := anObject! !!NBSTIndirectArgument methodsFor: 'accessing' stamp: 'cipt 10/24/2012 20:34'!elementIndex	^ elementIndex! !!NBSTIndirectArgument methodsFor: 'accessing' stamp: 'cipt 10/24/2012 20:34'!elementIndex: anObject	elementIndex := anObject! !!NBSTIndirectArgument methodsFor: 'accessing' stamp: 'cipt 10/27/2012 12:34'!emitLoad: gen	| asm |	asm := gen asm.	argumentLoader emitLoad: gen to: asm EAX.	gen optCheckIndirectArgBounds		ifTrue: [ 			| typeOk boundsFailed endLabel oop |			typeOk := asm uniqueLabelName: 'typeOk'.			boundsFailed := asm uniqueLabelName: 'boundsFailed'.			endLabel := asm uniqueLabelName: 'end'.			oop := gen reserveTemp.			asm mov: asm EAX to: oop.				"type checking"			gen proxy isPointers: oop.			asm cmp: asm EAX with: 0 asImm.			asm jne: typeOk.			gen failWithMessage: 'Type checking failed on indirect argument loading'.			asm label: typeOk.			"bounds checking"			"bigger than 0"			asm mov: elementIndex asImm to: asm EAX.			asm cmp: asm EAX with: 0 asImm.			asm jle: boundsFailed.			"smaller than slot size"			gen proxy slotSizeOf: oop.			asm cmp: asm EAX with: elementIndex asImm.			asm jl: boundsFailed.			asm mov: oop to: asm EAX.			asm jmp: endLabel .			asm label: boundsFailed.			gen failWithMessage: 'Bound checking failed on indirect argument loading'.			asm label: endLabel .			 ].	gen proxy fetchPointer: elementIndex - 1 ofObject: asm EAX.	^ asm EAX! !!NBSTIndirectArgument methodsFor: 'accessing' stamp: 'cipt 10/24/2012 20:34'!emitLoad: gen to: operand	self emitLoad: gen.	operand = gen asm EAX ifFalse:[gen asm mov: gen asm EAX to: operand]! !!NBSTIndirectArgument methodsFor: 'accessing' stamp: 'cipt 10/24/2012 20:39'!usesSTStack	^ argumentLoader usesSTStack! !!NBSTIvarArgument methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 4/30/2010 14:33'!emitLoad: gen	"emit instructions to load a function argument into default register	(EAX for integral types, FP(0) for floating point)"	| index |	index := receiverClass allInstVarNames indexOf: ivarName.		gen receiverArgumentLoader emitLoad: gen to: gen asm EAX.		"receiver in EAX"	gen proxy fetchPointer: index-1 ofObject: gen asm EAX.		^ gen asm EAX! !!NBSTIvarArgument methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 4/30/2010 12:29'!emitLoad: gen to: operand	"emit instructions to load a function argument into given operand"		self emitLoad: gen.		operand = gen asm EAX ifFalse: [ gen asm mov: gen asm EAX to: operand ]! !!NBSTIvarArgument methodsFor: 'accessing' stamp: 'Igor.Stasenko 4/30/2010 12:24'!ivarName	^ivarName! !!NBSTIvarArgument methodsFor: 'accessing' stamp: 'Igor.Stasenko 4/30/2010 12:24'!ivarName: anObject	ivarName := anObject! !!NBSTIvarArgument methodsFor: 'accessing' stamp: 'Igor.Stasenko 4/30/2010 12:24'!receiverClass	^receiverClass! !!NBSTIvarArgument methodsFor: 'accessing' stamp: 'Igor.Stasenko 4/30/2010 12:24'!receiverClass: anObject	receiverClass := anObject! !!NBSTIvarArgument methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 5/18/2010 02:22'!usesSTStack	^ true " to fetch receiver we accessing the stack"! !!NBSTMethodArgument class methodsFor: 'errors' stamp: 'IgorStasenko 8/6/2011 18:20'!lastError	<primitive: #primitiveLastNativeCodeError module: #NativeBoostPlugin>	^ self error: 'NativeBoost plugin is missing?'! !!NBSTMethodArgument methodsFor: 'emitting the code' stamp: 'Igor.Stasenko 4/30/2010 07:25'!emitLoad: gen	gen proxy stackValue: stackIndex.		^ gen asm EAX! !!NBSTMethodArgument methodsFor: 'emitting the code' stamp: 'Igor.Stasenko 4/30/2010 12:22'!emitLoad: gen to: operand	"emit instructions to load a function argument into given operand"		gen proxy stackValue: stackIndex.		operand = gen asm EAX ifFalse: [ gen asm mov: gen asm EAX to: operand ]! !!NBSTMethodArgument methodsFor: 'initialize-release' stamp: 'IgorStasenko 8/5/2011 18:00'!initialize 	isReceiver := false! !!NBSTMethodArgument methodsFor: 'accessing' stamp: 'IgorStasenko 8/5/2011 18:00'!isReceiver 	^ isReceiver ! !!NBSTMethodArgument methodsFor: 'accessing' stamp: 'IgorStasenko 8/5/2011 18:00'!isReceiver: aBool	isReceiver := aBool ! !!NBSTMethodArgument methodsFor: 'accessing' stamp: 'Igor.Stasenko 4/30/2010 07:23'!stackIndex	^stackIndex! !!NBSTMethodArgument methodsFor: 'accessing' stamp: 'Igor.Stasenko 4/30/2010 07:23'!stackIndex: anObject	stackIndex := anObject! !!NBSTMethodArgument methodsFor: 'testing' stamp: 'Igor.Stasenko 5/18/2010 02:22'!usesSTStack	^ true " to fetch receiver we accessing the stack"! !!NBFnSpec class methodsFor: 'instance creation' stamp: 'IgorStasenko 8/21/2011 11:07'!namedFunctionFrom: anArrayWithDefinition	"Create an instance of receiver by parsing an array in a form like C function definition: 	#( void foo (int * x, float y ) ) 	"	^ NBFnSpecParser new parseNamedFunction: anArrayWithDefinition ! !!NBFnSpec methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 8/21/2011 02:49'!addArgument: anArgument	^ arguments add: anArgument! !!NBFnSpec methodsFor: 'accessing' stamp: 'IgorStasenko 8/19/2011 17:44'!arguments	^ arguments! !!NBFnSpec methodsFor: 'accessing' stamp: 'IgorStasenko 8/19/2011 17:44'!arguments: anObject	arguments := anObject! !!NBFnSpec methodsFor: 'converting' stamp: 'IgorStasenko 8/21/2011 11:35'!asArraySpec	^ String streamContents: [:str | 		str 			nextPutAll: '#( '.				self printType: returnType on: str.		str space.				functionName ifNotNil: [			str nextPutAll: functionName; space ].				str nextPutAll: '( '.				arguments do: [:arg | 						str nextPutAll: arg second. "type name"			arg third timesRepeat: [				str nextPut: $* ].			str space;				nextPutAll: arg first;				space		] separatedBy: [ str nextPutAll: ', ' ].			str nextPutAll: '))'.			]! !!NBFnSpec methodsFor: 'converting' stamp: 'cipt 10/21/2012 19:33'!asArraySpecArrayedArgs	^ String streamContents: [:str | |idx|		str 			nextPutAll: '#( '.				self printType: returnType on: str.		str space.				functionName ifNotNil: [			str nextPutAll: functionName; space ].				str nextPutAll: '( '.		idx := 1.		arguments do: [:arg | 						str nextPutAll: arg second. "type name"			arg third timesRepeat: [				str nextPut: $* ].			str space;				nextPutAll: 'argsArray@', idx printString;				space.			idx := idx + 1.		] separatedBy: [ str nextPutAll: ', ' ].			str nextPutAll: '))'.			]! !!NBFnSpec methodsFor: 'converting' stamp: 'IgorStasenko 8/19/2011 19:01'!asMethodSelectorAndArguments	^ String streamContents: [:str | 		str 			nextPutAll: functionName.					arguments isEmpty ifFalse: [			arguments size = 1 ifFalse: [				str					nextPut: $_;					nextPutAll: arguments first first.				].			str				nextPut: $: ; space;				nextPutAll: arguments first first.							arguments allButFirst do: [:arg | 				str 					space;					nextPutAll: arg first; 					nextPut: $: ;					space;					nextPutAll: arg first								]			]	]! !!NBFnSpec methodsFor: 'converting' stamp: 'cipt 10/21/2012 19:38'!asMethodSelectorAndArrayOfArguments	^ String		streamContents: [ :str | 			str				nextPutAll: functionName;				nextPutAll: ': argsArray';				cr;				nextPut: $".			arguments do: [ :arg | str nextPutAll: arg first ] separatedBy: [ str nextPutAll: ', ' ].			str nextPut: $" ]! !!NBFnSpec methodsFor: 'accessing' stamp: 'IgorStasenko 8/19/2011 17:44'!functionName	^ functionName! !!NBFnSpec methodsFor: 'accessing' stamp: 'IgorStasenko 8/19/2011 17:44'!functionName: anObject	functionName := anObject! !!NBFnSpec methodsFor: 'initialize-release' stamp: 'IgorStasenko 8/19/2011 17:53'!initialize	arguments := OrderedCollection new! !!NBFnSpec methodsFor: 'converting' stamp: 'IgorStasenko 8/19/2011 18:39'!printType: typeAndArity on: str	str nextPutAll: typeAndArity first.	typeAndArity second timesRepeat: [ str nextPut: $* ].! !!NBFnSpec methodsFor: 'accessing' stamp: 'IgorStasenko 8/19/2011 17:44'!returnType	^ returnType! !!NBFnSpec methodsFor: 'accessing' stamp: 'IgorStasenko 8/19/2011 17:44'!returnType: anObject	returnType := anObject! !!NBFnSpecParser methodsFor: 'requestor callbacks' stamp: 'cipt 10/24/2012 20:19'!argName: aName indirectIndex: anIndex type: aTypeName ptrArity: arity		^ { aName. anIndex. aTypeName. arity }! !!NBFnSpecParser methodsFor: 'initialize-release' stamp: 'IgorStasenko 8/21/2011 02:50'!initialize	requestor := self. ! !!NBFnSpecParser methodsFor: 'requestor callbacks' stamp: 'IgorStasenko 8/21/2011 10:57'!integerConstantArgument: aValue	^ aValue! !!NBFnSpecParser methodsFor: 'public interface' stamp: 'IgorStasenko 2/9/2012 12:42'!parseAnonFunction: aFunctionDefinition"Parse a function definition in a form of: #( returnType (arguments) )or'returnType (arguments)'Answer an instance of NBFnSpec class"	| argsSpec retType |		fnSpec := NBFnSpec new.		aFunctionDefinition isString ifTrue: [		retType :=  (aFunctionDefinition copyUpTo: $( ) trimBoth.		argsSpec := ((aFunctionDefinition copyAfter: $( ) copyUpTo: $)) trimBoth.		] ifFalse: [		argsSpec := aFunctionDefinition last gather: [:ea | ea asString, ' ' ].		retType := aFunctionDefinition allButLast  gather: [:ea | ea asString, ' ' ].	].		stream := retType readStream.	fnSpec returnType: (requestor returnType: self parseType).	stream atEnd ifFalse: [ self error: 'Nothing more expected after function type'].			stream := argsSpec readStream.	self parseArguments.	^ fnSpec! !!NBFnSpecParser methodsFor: 'parsing' stamp: 'cipt 10/26/2012 19:21'!parseArgument	| argName indirectIndex typeAndPtrArity char |	" An argument can be: - nil , true , false - a class/pool variable name - integer literal - self , with optional ** - type name *** arg name"	char := stream peek.	(char isDigit or: [ char = $- ])		ifTrue: [ ^ requestor integerConstantArgument: self parseInt ].	typeAndPtrArity := self parseType.	self skipSpace.	argName := self parseWord.	self skipSpace.	char := stream peek.	char = $@		ifTrue: [ 			stream next.			self skipSpace.			argName := argName.			indirectIndex := self parseInt ].		"for sole 'void' fake argument "	(typeAndPtrArity = #('void' 0) and: [ argName isNil ])		ifTrue: [ ^ nil ].	^ requestor		argName: argName		indirectIndex: indirectIndex		type: typeAndPtrArity first		ptrArity: typeAndPtrArity second ! !!NBFnSpecParser methodsFor: 'parsing' stamp: 'IgorStasenko 12/18/2011 19:28'!parseArguments"Parse a arguments spec in a form of: #( type1 name1 , type2 name2 , nil, true, false , 100 )"	[ stream atEnd ] whileFalse: [		self parseArgument ifNotNil: [:arg | 			fnSpec addArgument: arg].				self skipSpace.				stream atEnd ifFalse: [ stream peek = $, ifFalse: [ self error: 'comma expected' ].			stream next. self skipSpace. ]	].! !!NBFnSpecParser methodsFor: 'parsing' stamp: 'Igor.Stasenko 4/30/2010 06:03'!parseInt	| negate num |	negate := false.	stream peek = $- ifTrue: [ negate := true. stream next.  self skipSpace ].	num := String new writeStream.		[ stream atEnd not and: [stream peek isDigit ] ] whileTrue: [ num nextPut: stream next ].	num := num contents asInteger.	negate ifTrue: [ num := num negated ].		^ num! !!NBFnSpecParser methodsFor: 'public interface' stamp: 'IgorStasenko 2/9/2012 12:47'!parseNamedFunction: aFunctionDefinition"Parse a function definition in a form of: #( returnType functionName (arguments) )or'returnType functionName (arguments)'Answer an instance of NBFnSpec class"	| argsSpec typeAndName fnName |		fnSpec := NBFnSpec new.		aFunctionDefinition isString ifTrue: [		typeAndName :=  (aFunctionDefinition copyUpTo: $( ) trimBoth.		argsSpec := ((aFunctionDefinition copyAfter: $( ) copyUpTo: $)) trimBoth.		] ifFalse: [		argsSpec := aFunctionDefinition last gather: [:ea | ea asString, ' ' ].		typeAndName := aFunctionDefinition allButLast  gather: [:ea | ea asString, ' ' ].	].		stream := typeAndName readStream.	fnSpec returnType: (requestor returnType: self parseType).		fnName := self parseWord.	fnName ifNil: [ self error: 'function name expected' ].	fnSpec functionName: fnName.		stream := argsSpec readStream.	self parseArguments.	^ fnSpec! !!NBFnSpecParser methodsFor: 'parsing' stamp: 'IgorStasenko 8/19/2011 17:59'!parseType	" parse type name and optional number of asterisks, following it"	| typeName ptrArity |	typeName := self parseWord.	typeName isNil ifTrue: [ ^ self error: 'type name expected' ].	"skip 'const' , which is often used but has no any use for us "		typeName = 'const' ifTrue: [		self skipSpace.		typeName := self parseWord.		typeName isNil ifTrue: [ ^ self error: 'type name expected' ].	].		ptrArity := 0.	[ self skipSpace. stream peek = $* ] whileTrue: [ 		ptrArity := ptrArity + 1.		stream next ].	^ Array with: typeName with: ptrArity! !!NBFnSpecParser methodsFor: 'parsing' stamp: 'IgorStasenko 6/1/2012 18:37'!parseWord	^ String streamContents: [:st |  | ch |			"first char must be letter or underscore"		ch := stream peek.			(ch notNil and: [ ch isLetter or: [ '_$' includes: ch ]]) ifFalse: [ ^ nil ].				[ ch := stream peek. ch notNil and: [ch isLetter or: [ ('_$' includes: ch)  or: [ch isDigit] ] ] ] 				whileTrue: [ st nextPut: stream next].	]! !!NBFnSpecParser methodsFor: 'accessing' stamp: 'Igor.Stasenko 4/30/2010 05:31'!requestor: aRequestor	requestor := aRequestor.! !!NBFnSpecParser methodsFor: 'requestor callbacks' stamp: 'IgorStasenko 8/21/2011 10:55'!returnType: aType		^ aType! !!NBFnSpecParser methodsFor: 'parsing' stamp: 'cipt 10/21/2012 01:27'!skipSpace	| ch |	[ 	ch := stream peek.	ch ifNil: [ ^ self ].	ch isSeparator ] whileTrue: [ stream next ]! !!NBMemoryBlock methodsFor: 'accessing' stamp: 'Igor.Stasenko 9/22/2010 04:43'!address	^address! !!NBMemoryBlock methodsFor: 'accessing' stamp: 'Igor.Stasenko 9/22/2010 04:43'!address: anObject	address := anObject! !!NBMemoryBlock methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 9/22/2010 04:38'!initialize	free := true! !!NBMemoryBlock methodsFor: 'accessing' stamp: 'Igor.Stasenko 9/22/2010 04:17'!isFree	^ free! !!NBMemoryBlock methodsFor: 'accessing' stamp: 'Igor.Stasenko 9/22/2010 04:43'!left	^left! !!NBMemoryBlock methodsFor: 'accessing' stamp: 'Igor.Stasenko 9/22/2010 04:43'!left: anObject	left := anObject! !!NBMemoryBlock methodsFor: 'accessing' stamp: 'Igor.Stasenko 9/22/2010 04:43'!length	^length! !!NBMemoryBlock methodsFor: 'accessing' stamp: 'Igor.Stasenko 9/24/2010 04:29'!length: aValue	length := aValue! !!NBMemoryBlock methodsFor: 'accessing' stamp: 'Igor.Stasenko 9/25/2010 00:46'!makeFreeFor: heapManager	"mark receiver as free and merge with adjusted blocks, if they also free"	free := true.		(right notNil and: [right isFree]) ifTrue: [		length := length + right length.		heapManager removeFreeBlock: right.		right := right right.		].		(left notNil and: [ left isFree ]) 		ifTrue: [ left length: (left length + length). left right: right.			heapManager checkForFreePage: left			 ]		ifFalse: [ heapManager addFreeBlock: self ].! !!NBMemoryBlock methodsFor: 'printing' stamp: 'Igor.Stasenko 9/26/2010 03:59'!printOn: aStream	super printOn: aStream.		aStream 		nextPutAll: '( @ 16r';		nextPutAll: (address printStringBase: 16);		nextPutAll: ', ';		print: length.			free ifTrue: [ aStream nextPutAll: ', free' ].		aStream nextPut: $)! !!NBMemoryBlock methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 9/24/2010 23:20'!reserve: numBytes for: heapManager	"reserve a given number of bytes of memory	if numBytes < length, then create a smaller block with free memory"	| leftover |	self assert: free.	numBytes > length ifTrue: [ self error: 'can''t reserve more than length of block' ].	heapManager removeFreeBlock: self.	numBytes = length ifTrue: [ free := false. ^ self ].		leftover := 		NBMemoryBlock new			address: address + numBytes;			length: length - numBytes;			left: self; 			right: right.	right := leftover.	length := numBytes.	free := false.	heapManager addFreeBlock: leftover.! !!NBMemoryBlock methodsFor: 'accessing' stamp: 'Igor.Stasenko 9/22/2010 04:43'!right	^right! !!NBMemoryBlock methodsFor: 'accessing' stamp: 'Igor.Stasenko 9/22/2010 04:43'!right: anObject	right := anObject! !!NBMemoryPage class methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 9/24/2010 23:42'!address: addr length: len	^ self basicNew address: addr length: len! !!NBMemoryPage methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 9/25/2010 00:32'!address	^ address! !!NBMemoryPage methodsFor: 'initialize-release' stamp: 'Igor.Stasenko 9/24/2010 23:41'!address: addr length: len	address := addr.	length := len.	initialBlock := NBMemoryBlock new address: addr; length: len! !!NBMemoryPage methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 9/25/2010 00:08'!firstBlock	^ initialBlock! !!NBMemoryPage methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 9/25/2010 00:21'!length	^ length! !!NBMemoryPage methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 9/24/2010 23:19'!totalAllocatedMemory	| blk total |		blk := initialBlock.	total := 0.	[ blk notNil ] whileTrue: [		blk isFree ifFalse: [ total := total + blk length ].		blk := blk right.		].	^ total! !!NBObjectFormat class methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 12/21/2011 14:20'!current	"answer an new instance of object format representing an object format of currently running system"	^ NBObjectFormat32 new! !!NBObjectFormat methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 5/20/2010 05:54'!asm: anAsm	asm := anAsm! !!NBObjectFormat methodsFor: 'sizes' stamp: 'HenrikSperreJohansen 8/23/2011 21:44'!baseHeaderSize	^ self oopSize! !!NBObjectFormat methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 5/20/2010 05:52'!indexableWordsFormat	self subclassResponsibility ! !!NBObjectFormat methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 5/19/2010 11:53'!instVarOffsetAt: ivarIndex	"answer an offset of instance variable with given 1-based index,	relative to some oop"	self subclassResponsibility ! !!NBObjectFormat methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 11/23/2011 10:44'!isCogVM	^ (Smalltalk vm version beginsWith: 'Squeak') not! !!NBObjectFormat methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 5/19/2010 11:27'!oopSize	self subclassResponsibility ! !!NBObjectFormat methodsFor: 'sizes' stamp: 'HenrikSperreJohansen 8/23/2011 21:51'!stackArgumentSize	"a default number of bytes on stack used by a single argument,	for calling proxy functions"	"In most cases, this will the same as oopSize, but not necessarily"	^self subclassResponsibility! !!NBObjectFormat methodsFor: 'sizes' stamp: 'HenrikSperreJohansen 8/23/2011 21:47'!varBytesFirstField	" answer an offset of first byte of variable-bytes oop, relative to object pointer"	"In object formats where additional header fields are stored before the base header, this is just the size of the header"	^ self baseHeaderSize! !!NBProxyFunction methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 4/9/2010 07:14'!= object	^ self class == object class and: [ selector == object selector ]! !!NBProxyFunction methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 4/29/2010 03:34'!address	self assert: (index < NBInterpreterProxy functions size).		self checkVersion.	^ NBInterpreterProxy fnAddressAt: index! !!NBProxyFunction methodsFor: 'accessing' stamp: 'Igor.Stasenko 4/29/2010 03:29'!arguments	^arguments! !!NBProxyFunction methodsFor: 'accessing' stamp: 'Igor.Stasenko 4/29/2010 03:29'!arguments: anObject	arguments := anObject! !!NBProxyFunction methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 4/29/2010 07:36'!checkVersion	"exclude basic functions, otherwise we enter an endless chicken and egg loop"	minorVersion = 0 ifTrue:  [ ^ self ].			self assert: (NBInterpreterProxy majorVersion = majorVersion		and: [ NBInterpreterProxy minorVersion >= minorVersion]).! !!NBProxyFunction methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 4/9/2010 07:13'!hash	^ selector hash! !!NBProxyFunction methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 4/9/2010 07:35'!index	^ index! !!NBProxyFunction methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 4/9/2010 07:34'!index: anIndex	index := anIndex! !!NBProxyFunction methodsFor: 'accessing' stamp: 'Igor.Stasenko 4/29/2010 03:29'!majorVersion	^majorVersion! !!NBProxyFunction methodsFor: 'accessing' stamp: 'Igor.Stasenko 4/29/2010 03:29'!majorVersion: anObject	majorVersion := anObject! !!NBProxyFunction methodsFor: 'accessing' stamp: 'Igor.Stasenko 4/29/2010 03:29'!minorVersion	^minorVersion! !!NBProxyFunction methodsFor: 'accessing' stamp: 'Igor.Stasenko 4/29/2010 03:29'!minorVersion: anObject	minorVersion := anObject! !!NBProxyFunction methodsFor: 'accessing' stamp: 'IgorStasenko 5/11/2011 16:50'!name	^ selector ! !!NBProxyFunction methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 9/29/2010 09:24'!parseArguments: args 	" not userful, lets ignore it""	(args size = 1 and: [ args first == #void ]) ifTrue: [ arguments := #(). ^ self ].		arguments := args collect: [:type |		( #(sqInt sqIntPtr sqLong double charPtr voidPtr) includes: type ) ifFalse: [			self error: 'invalid argument type'		].			type	]"! !!NBProxyFunction methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 5/11/2011 16:47'!printOn: aStream	aStream print: selector.	arguments ifNotNil: [ 		aStream  		space;		print: arguments ]! !!NBProxyFunction methodsFor: 'accessing' stamp: 'IgorStasenko 8/3/2011 07:32'!requiresAlignment 	^ requiresAlignment ~~ false! !!NBProxyFunction methodsFor: 'accessing' stamp: 'IgorStasenko 8/3/2011 07:36'!requiresAlignment: aBool	requiresAlignment := aBool! !!NBProxyFunction methodsFor: 'accessing' stamp: 'Igor.Stasenko 4/29/2010 03:29'!retType	^retType! !!NBProxyFunction methodsFor: 'accessing' stamp: 'Igor.Stasenko 4/29/2010 03:29'!retType: anObject	retType := anObject! !!NBProxyFunction methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 4/9/2010 07:14'!selector	^ selector! !!NBProxyFunction methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 4/9/2010 07:22'!selector: aSelector	selector := aSelector! !!Object methodsFor: '*NativeBoost-core' stamp: 'IgorStasenko 11/22/2012 18:32'!nbAddress	"Return the native address"	<primitive: 'primitiveNativeCall' module: 'NativeBoostPlugin'>	^ self nbCallout  		function: #( int ( void ) )  		emit: [:gen :proxy :asm | proxy receiver ]! !!Object methodsFor: '*NativeBoost-core' stamp: 'IgorStasenko 11/24/2012 16:07' prior: 51782899!nbCall: fnSpec	" you can override this method if you need to"		^ (self nbCalloutIn: thisContext sender)		convention: self nbCallingConvention;		function: fnSpec module: self nbLibraryNameOrHandle ! !!Object methodsFor: '*NativeBoost-core' stamp: 'IgorStasenko 11/24/2012 16:07' prior: 51756360!nbCall: fnSpec module: aModuleNameOrHandle	" you can override this method if you need to"	^ (self nbCalloutIn: thisContext sender)		convention: self nbCallingConvention;		function: fnSpec module: aModuleNameOrHandle ! !!Object methodsFor: '*NativeBoost-core' stamp: 'IgorStasenko 11/24/2012 16:07' prior: 51779183!nbCall: fnSpec module: aModuleNameOrHandle options: callOptions	" you can override this method if you need to"	^ (self nbCalloutIn: thisContext sender)		convention: self nbCallingConvention;		options: callOptions;		function: fnSpec module: aModuleNameOrHandle ! !!Object methodsFor: '*NativeBoost-core' stamp: 'IgorStasenko 11/24/2012 16:07' prior: 51749152!nbCall: fnSpec options: callOptions	" you can override this method if you need to"	^ (self nbCalloutIn: thisContext sender)		convention: self nbCallingConvention;		options: callOptions;		function: fnSpec module: self nbLibraryNameOrHandle ! !!Object methodsFor: '*NativeBoost-core' stamp: 'JavierPimas 11/17/2011 11:12'!nbCallingConvention	^#cdecl! !!Object methodsFor: '*NativeBoost-core' stamp: 'IgorStasenko 11/22/2012 14:25'!nbCallout	^ NBFFICalloutAPI inContext: thisContext sender! !!Object methodsFor: '*NativeBoost-core' stamp: 'IgorStasenko 11/22/2012 14:25'!nbCalloutIn: aContext	^ NBFFICalloutAPI inContext: aContext! !!Object methodsFor: '*NativeBoost-core' stamp: 'IgorStasenko 1/17/2012 16:04'!nbGetSymbolAddress: aName module: aModuleNameOrHandle	"Lookup for given symbol in external module and answer its address	(an instance of NBExternalAddress), or nil if not found.		A default implementation,	first we try to use OS-specific symbol lookup mechanism,	and if not found, we try to lookup a symbol from VM registered plugin(s)"		| addr |		addr := NativeBoost loadSymbol: aName fromModule: aModuleNameOrHandle.	^ addr ifNil: [ 		"loadfunction takes only names, not handles"		aModuleNameOrHandle isString 			ifFalse: [ nil ] 			ifTrue: [ NativeBoost loadFunction: aName from: aModuleNameOrHandle ]]! !!Object methodsFor: '*NativeBoost-core' stamp: 'CamilloBruni 1/13/2013 18:20'!nbLibraryNameOrHandle	self flag: 'HACK: avoid direct subclassResponsibility to not break RB test cases..'.	^ SubclassResponsibility signalFor: thisContext selector! !!NBExternalEnumeration class methodsFor: 'converting' stamp: 'CiprianTeodorov 2/6/2013 21:34'!asNBExternalType: aTypeName	^ NBExternalEnumerationType objectClass: self representationType: self representationType! !!NBExternalEnumeration class methodsFor: 'accessing' stamp: 'CiprianTeodorov 12/10/2012 20:20'!at: anItem	^ self classPool at: anItem ifAbsent: [ nil ]! !!NBExternalEnumeration class methodsFor: 'error handling' stamp: 'CiprianTeodorov 12/10/2012 20:01'!doesNotUnderstand: aMessage	| v |	^ (v := self at: aMessage selector) ifNil: [ super doesNotUnderstand: aMessage ] ifNotNil: [ v ]! !!NBExternalEnumeration class methodsFor: 'enum declaration' stamp: 'CiprianTeodorov 12/15/2012 15:19'!enumDecl	^#()! !!NBExternalEnumeration class methodsFor: 'accessing' stamp: 'CiprianTeodorov 12/13/2012 19:57'!fromInteger: anIntegerValue	| theItem |	theItem := self itemAt: anIntegerValue.	theItem ifNil: [ self error: 'Invalid value for ' , self name , ' enumeration' ].	^ self at: theItem! !!NBExternalEnumeration class methodsFor: 'testing' stamp: 'CiprianTeodorov 12/10/2012 19:47'!includes: aSymbol	^self classPool includesKey: aSymbol ! !!NBExternalEnumeration class methodsFor: 'class initialization' stamp: 'CiprianTeodorov 2/6/2013 21:33'!initialize	| unsigned |	unsigned := true.	self		classPool:			(self initializeEnum associations				collect: [ :assoc | 					(unsigned and: [ assoc value < 0 ])						ifTrue: [ unsigned := false ].					assoc key -> (self basicNew value: assoc value) ]) asDictionary.	representationType := unsigned		ifTrue: [ NBUInt32 new ]		ifFalse: [ NBInt32 new ]! !!NBExternalEnumeration class methodsFor: 'class initialization' stamp: 'CiprianTeodorov 12/13/2012 08:20'!initializeEnum	| decl |	decl := self enumDecl.	decl isDictionary		ifTrue: [ ^ decl ].	decl := Dictionary newFromPairs: decl.	^ decl! !!NBExternalEnumeration class methodsFor: 'accessing' stamp: 'CiprianTeodorov 12/10/2012 20:17'!itemAt: aValue	^ self itemAt: aValue ifAbsent: [ nil ]! !!NBExternalEnumeration class methodsFor: 'accessing' stamp: 'CiprianTeodorov 12/10/2012 20:17'!itemAt: aValue ifAbsent: exceptionBlock	self classPool		associationsDo: [ :assoc | 			aValue = assoc value value				ifTrue: [ ^ assoc key ] ].	^ exceptionBlock value! !!NBExternalEnumeration class methodsFor: 'instance creation' stamp: 'CiprianTeodorov 12/10/2012 19:59'!new	^self shouldNotImplement ! !!NBExternalEnumeration class methodsFor: 'accessing' stamp: 'CiprianTeodorov 2/6/2013 21:34'!representationType	^representationType! !!NBExternalEnumeration methodsFor: 'comparing' stamp: 'CiprianTeodorov 12/10/2012 19:53'!= anEnumInst	^ self class == anEnumInst class and: [ self value = anEnumInst value ]! !!NBExternalEnumeration methodsFor: 'accessing' stamp: 'CiprianTeodorov 12/10/2012 19:54'!item	^ self class itemAt: value! !!NBExternalEnumeration methodsFor: 'printing' stamp: 'CiprianTeodorov 12/10/2012 20:08'!printOn: t1 	super printOn: t1.	t1 nextPut: $(;		 nextPutAll: self item printString;		 nextPut: $)! !!NBExternalEnumeration methodsFor: 'accessing' stamp: 'CiprianTeodorov 12/10/2012 19:55'!value	^value! !!NBExternalEnumeration methodsFor: 'accessing' stamp: 'CiprianTeodorov 12/10/2012 19:56'!value: anObject	value := anObject ! !!NBWeakFinalizerItem methodsFor: 'public API' stamp: 'IgorStasenko 6/2/2012 15:23'!doNotFinalize	"send this message to avoid triggering finalization, once weakly-referenced object is dead"		executor := nil.! !!NBWeakFinalizerItem methodsFor: 'accessing' stamp: 'IgorStasenko 5/31/2012 03:15'!index	^ index! !!NBWeakFinalizerItem methodsFor: 'accessing' stamp: 'IgorStasenko 5/31/2012 03:15'!index: aNumber	index := aNumber! !!NBWeakFinalizerItem methodsFor: 'accessing' stamp: 'IgorStasenko 5/31/2012 03:56'!list: aList index: i freeIndex: nextFreeIndex	list := aList.	index := i.	next := nextFreeIndex ! !!NBWeakFinalizerItem methodsFor: 'accessing' stamp: 'IgorStasenko 5/31/2012 03:49'!markAsFree: oldFreeIndex	next := oldFreeIndex.	executor := nil.	"to make sure"	self basicAt: 1 put: nil.! !!NBWeakFinalizerItem methodsFor: 'accessing' stamp: 'IgorStasenko 5/31/2012 03:48'!nextFreeIndex	^ next! !!NBWeakFinalizerItem methodsFor: 'accessing' stamp: 'IgorStasenko 5/31/2012 04:00'!object: anObject executor: ex	executor := ex.	self basicAt: 1 put: anObject! !!String class methodsFor: '*NativeBoost-Core' stamp: 'Igor.Stasenko 4/28/2010 16:56'!asNBExternalType: gen	^ gen resolveType: #NBExternalString! !!String methodsFor: '*NativeBoost-Core' stamp: 'Igor.Stasenko 5/19/2010 13:19'!asNBExternalString	^ NBExternalAddress fromString: self! !!String methodsFor: '*NativeBoost-Core' stamp: 'IgorStasenko 12/20/2011 14:53'!asNBExternalType: gen	"a string or symbol in argument description array defines a type i.e.		#( long argument )  - whereas 'long'  is type name	"	^ gen resolveType: self! !!Boolean methodsFor: '*NativeBoost-Core' stamp: 'Igor.Stasenko 4/28/2010 12:19'!asNBExternalType: gen	"boolean value in argument description array defines a simple 0 or 1 constant		#( true false )  - turned into a 1 and 0	"	^ NBFFIConst value: (self ifTrue: [1] ifFalse:[0])! !!NBFFICalloutError methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 2/20/2012 13:47'!description	^ NBErrorDescriptions at: errorCode ifAbsent: [		(NBFFICallout messageForCode: errorCode) ifNil: [		'Error during FFI call: ' , errorCode asString]].	! !!NBNativeCodeError class methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 8/6/2011 17:48'!signalError: error	^ self new signalError: error! !!NBNativeCodeError methodsFor: 'accessing' stamp: 'IgorStasenko 2/20/2012 13:46'!description	^ NBErrorDescriptions at: errorCode ifAbsent: [		'Error during execution of native code: ' , errorCode asString].	! !!NBNativeCodeError methodsFor: 'accessing' stamp: 'IgorStasenko 8/6/2011 18:17'!errorCode	^ errorCode! !!NBNativeCodeError methodsFor: 'accessing' stamp: 'IgorStasenko 2/20/2012 13:04'!signalError: error	"set error/code and signal it"	(errorCode := error) isSymbol 		ifTrue: [			" some errors produced by VM translated to symbols. we unifying it here to draw better description from our pool (see			NativeBoostConstants class>> #initErrorDescriptions )"			errorCode := ((Smalltalk specialObjectsArray at: 52) indexOf: error ifAbsent: [ ^self signal: self description ]) -1		].		^ self signal: self description! !!ByteArray class methodsFor: '*NativeBoost-Core' stamp: 'IgorStasenko 8/3/2011 19:55'!asNBExternalType: gen	^ NBByteArrayPtr new! !!ByteArray methodsFor: '*NativeBoost-Core' stamp: 'IgorStasenko 11/23/2012 18:03' prior: 18574028!nbFloat32AtOffset: zeroBasedOffset	"Read 32-bit float at ZERO-based index.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(float32 (self, ulong zeroBasedOffset)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			add: asm EAX with: asm ECX;			fld: asm EAX ptr32. "load a floating point value from memory, at base address, held in EAX register into fp(0) register,				we are using #ptr32, to indicate that memory operand size is 32bits long"	] ! !!ByteArray methodsFor: '*NativeBoost-Core' stamp: 'IgorStasenko 11/23/2012 18:03' prior: 18589325!nbFloat32AtOffset: zeroBasedOffset put: value	"Store 32-bit float at ZERO-based index.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function:#(void (self, ulong zeroBasedOffset, float32 value)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			pop: asm EDX;			mov: asm EDX to: asm EAX ptr + asm ECX	] ! !!ByteArray methodsFor: '*NativeBoost-Core' stamp: 'IgorStasenko 11/23/2012 18:04' prior: 18562802!nbFloat64AtOffset: zeroBasedOffset	"Read 64-bit float at ZERO-based index.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^self nbCallout function: #(float64 (self, ulong zeroBasedOffset)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "index"			add: asm EAX with: asm ECX;			fld: asm EAX ptr64. "load a floating point value from memory, at base address, held in EAX register into fp(0) register,				we are using #ptr64, to indicate that memory operand size is 64bits long"	] ! !!ByteArray methodsFor: '*NativeBoost-Core' stamp: 'IgorStasenko 11/23/2012 18:04' prior: 18571990!nbFloat64AtOffset: zeroBasedOffset put: value	"Store 64-bit float at ZERO-based index.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^self nbCallout function: #(void (self, ulong zeroBasedOffset, float64 value)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			add: asm EAX with: asm ECX;						mov: asm ESP ptr to: asm ECX;			mov: asm ECX to: asm EAX ptr;			mov: asm ESP ptr +4 to: asm ECX;			mov: asm ECX to: asm EAX ptr +4 	] ! !!ByteArray methodsFor: '*NativeBoost-Core' stamp: 'IgorStasenko 11/23/2012 18:04' prior: 18567516!nbInt16AtOffset: zeroBasedOffset		"Reads signed 16-bit integer from memory at (receiver's address + ZERO-based offset) using native byte order.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(int16 (self, ulong zeroBasedOffset)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			mov: asm EAX ptr16 + asm ECX to: asm AX	]! !!ByteArray methodsFor: '*NativeBoost-Core' stamp: 'IgorStasenko 11/23/2012 18:04' prior: 18557668!nbInt16AtOffset: zeroBasedOffset  put: value		"Store signed 16-bit integer into memory at (receiver's address + ZERO-based offset) using native byte order.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(void (self, ulong zeroBasedOffset, int16 value)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			pop: asm EDX; "value"			mov: asm DX to: asm EAX ptr16 + asm ECX	]! !!ByteArray methodsFor: '*NativeBoost-Core' stamp: 'IgorStasenko 11/23/2012 18:04' prior: 18557390!nbInt32AtOffset: zeroBasedOffset		"Reads signed 32-bit integer from memory at (receiver's address + ZERO-based offset) using native byte order.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(int32 (self, ulong zeroBasedOffset)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			mov: asm EAX ptr32 + asm ECX to: asm EAX	]! !!ByteArray methodsFor: '*NativeBoost-Core' stamp: 'IgorStasenko 11/23/2012 18:05' prior: 18561906!nbInt32AtOffset: zeroBasedOffset  put: value		"Store signed 32-bit integer into memory at (receiver's address + ZERO-based offset) using native byte order.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(void (self, ulong zeroBasedOffset, int32 value)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			pop: asm EDX; "value"			mov: asm EDX to: asm EAX ptr32 + asm ECX	]! !!ByteArray methodsFor: '*NativeBoost-Core' stamp: 'IgorStasenko 11/23/2012 18:05' prior: 18561628!nbInt64AtOffset: zeroBasedOffset		"Reads signed 64-bit integer from memory at (receiver's address + ZERO-based offset) using native byte order.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(int64 (self, ulong zeroBasedOffset)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			mov: asm EAX ptr + asm ECX + 4 to: asm EDX;			mov: asm EAX ptr + asm ECX to: asm EAX	]! !!ByteArray methodsFor: '*NativeBoost-Core' stamp: 'IgorStasenko 11/23/2012 18:05' prior: 18586008!nbInt64AtOffset: zeroBasedOffset  put: value		"Store signed 64-bit integer into memory at (receiver's address + ZERO-based offset) using native byte order.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(void (self, ulong zeroBasedOffset, int64 value)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			pop: asm EDX; "value low word"			mov: asm EDX to: asm EAX ptr32 + asm ECX;			pop: asm EDX; "value high word"			mov: asm EDX to: asm EAX ptr32 + asm ECX + 4	]! !!ByteArray methodsFor: '*NativeBoost-Core' stamp: 'IgorStasenko 11/23/2012 18:05' prior: 18588554!nbInt8AtOffset: zeroBasedOffset		"Reads signed 8-bit integer from memory at (receiver's address + ZERO-based offset) using native byte order.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(int8 (self, ulong zeroBasedOffset)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			mov: asm EAX ptr8 + asm ECX to: asm AL	]! !!ByteArray methodsFor: '*NativeBoost-Core' stamp: 'IgorStasenko 11/23/2012 18:05' prior: 18579618!nbInt8AtOffset: zeroBasedOffset  put: value		"Store signed 8-bit integer into memory at (receiver's address + ZERO-based offset) using native byte order.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(void (self, ulong zeroBasedOffset, int8 value)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			pop: asm EDX; "value"			mov: asm DL to: asm EAX ptr8 + asm ECX	]! !!ByteArray methodsFor: '*NativeBoost-Core' stamp: 'IgorStasenko 11/23/2012 18:06' prior: 18566148!nbLongAt: index	"Read signed long at one-based index.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout 		options: #( optCheckFailOnEveryArgument );		function: #(long (self, ulong index)) emit: [:gen |			| asm |						asm := gen asm.			asm 				pop: asm EAX;  "pointer to receiver's first byte"				pop: asm ECX; "index"				mov: asm EAX ptr + asm ECX -1 to: asm EAX.		] ! !!ByteArray methodsFor: '*NativeBoost-Core' stamp: 'IgorStasenko 11/23/2012 18:06' prior: 18573267!nbLongAt: index put: value	"Store signed long at one-based index.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(void (self, ulong index, long value)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "index"			add: asm EAX with: asm ECX;			pop: asm ECX; "value"			mov: asm ECX to: asm EAX ptr -1	] ! !!ByteArray methodsFor: '*NativeBoost-Core' stamp: 'IgorStasenko 11/23/2012 18:07' prior: 18563496!nbUInt16AtOffset: zeroBasedOffset		"Reads unsigned 16-bit integer from memory at (receiver's address + ZERO-based offset) using native byte order.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(uint16 (self, ulong zeroBasedOffset)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			mov: asm EAX ptr16 + asm ECX to: asm AX	]! !!ByteArray methodsFor: '*NativeBoost-Core' stamp: 'IgorStasenko 11/23/2012 18:07' prior: 18563008!nbUInt16AtOffset: zeroBasedOffset  put: value		"Store unsigned 16-bit integer into memory at (receiver's address + ZERO-based offset) using native byte order.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^self nbCallout function: #(void (self, ulong zeroBasedOffset, uint16 value)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			pop: asm EDX; "value"			mov: asm DX to: asm EAX ptr16 + asm ECX	] ! !!ByteArray methodsFor: '*NativeBoost-Core' stamp: 'IgorStasenko 11/23/2012 18:07' prior: 18557969!nbUInt32AtOffset: zeroBasedOffset		"Reads unsigned 32-bit integer from memory at (receiver's address + ZERO-based offset) using native byte order.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(uint32 (self, ulong zeroBasedOffset)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			mov: asm EAX ptr32 + asm ECX to: asm EAX	]! !!ByteArray methodsFor: '*NativeBoost-Core' stamp: 'IgorStasenko 11/23/2012 18:07' prior: 18572456!nbUInt32AtOffset: zeroBasedOffset  put: value		"Store unsigned 32-bit integer into memory at (receiver's address + ZERO-based offset) using native byte order.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(void (self, ulong zeroBasedOffset, uint32 value)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			pop: asm EDX; "value"			mov: asm EDX to: asm EAX ptr32 + asm ECX	]! !!ByteArray methodsFor: '*NativeBoost-Core' stamp: 'IgorStasenko 11/23/2012 18:07' prior: 18576393!nbUInt64AtOffset: zeroBasedOffset		"Reads unsigned 64-bit integer from memory at (receiver's address + ZERO-based offset) using native byte order.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(uint64 (self, ulong zeroBasedOffset)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			mov: asm EAX ptr + asm ECX + 4 to: asm EDX;			mov: asm EAX ptr + asm ECX to: asm EAX	]! !!ByteArray methodsFor: '*NativeBoost-Core' stamp: 'IgorStasenko 11/23/2012 18:07' prior: 18561176!nbUInt64AtOffset: zeroBasedOffset  put: value		"Store unsigned 64-bit integer into memory at (receiver's address + ZERO-based offset) using native byte order.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(void (self, ulong zeroBasedOffset, uint64 value)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			pop: asm EDX; "value low word"			mov: asm EDX to: asm EAX ptr32 + asm ECX;			pop: asm EDX; "value high word"			mov: asm EDX to: asm EAX ptr32 + asm ECX + 4	]! !!ByteArray methodsFor: '*NativeBoost-Core' stamp: 'IgorStasenko 11/23/2012 18:08' prior: 18576112!nbUInt8AtOffset: zeroBasedOffset		"Reads unsigned 8-bit integer from memory at (receiver's address + ZERO-based offset) using native byte order.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(uint8 (self, ulong zeroBasedOffset)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			mov: asm EAX ptr8 + asm ECX to: asm AL	]! !!ByteArray methodsFor: '*NativeBoost-Core' stamp: 'IgorStasenko 11/23/2012 18:08' prior: 18574447!nbUInt8AtOffset: zeroBasedOffset  put: value		"Store unsigned 8-bit integer into memory at (receiver's address + ZERO-based offset) using native byte order.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(void (self, ulong zeroBasedOffset, uint8 value)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			pop: asm EDX; "value"			mov: asm DL to: asm EAX ptr8 + asm ECX	] ! !!ByteArray methodsFor: '*NativeBoost-Core' stamp: 'IgorStasenko 11/23/2012 18:08' prior: 18565070!nbUlongAt: index	"Read unsigned long at one-based index.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout 		options: #( optCheckFailOnEveryArgument );			function: #(ulong (self, ulong index)) emit: [:gen |			| asm |						asm := gen asm.			asm 				pop: asm EAX;  "pointer to receiver's first byte"				pop: asm ECX; "index"				mov: asm EAX ptr + asm ECX -1 to: asm EAX. ]! !!ByteArray methodsFor: '*NativeBoost-Core' stamp: 'IgorStasenko 11/23/2012 18:09' prior: 18575091!nbUlongAt: index put: value	"Store unsigned long at one-based index.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^  self nbCallout function: #(void (self, ulong index, ulong value)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "index"			add: asm EAX with: asm ECX;			pop: asm ECX; "value"			mov: asm ECX to: asm EAX ptr -1	] ! !!Integer methodsFor: '*NativeBoost-Core' stamp: 'Igor.Stasenko 4/28/2010 12:19'!asNBExternalType: gen	"integer value in callout argument description aray are pushed directly on stack		#( 100 )  - an integer value argument = 100	"	^ NBFFIConst value: (self )! !!NBRecursionDetect class methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 5/28/2012 07:02'!in: aMethod during: aBlock	(self signalForMethod: aMethod) ifTrue: [		^ NBCodeGenRecursion signal: aMethod printString		].	^ aBlock on: self do: [:ex | ex check: aMethod ].! !!NBRecursionDetect class methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 5/28/2012 05:41'!signalForMethod: aMethod	^ self new signalForMethod: aMethod! !!NBRecursionDetect methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 5/28/2012 06:46'!check: aMethod	method == aMethod 		ifTrue: [			self resume: true "recursion detected"			  ] 		ifFalse: [ self pass ]! !!NBRecursionDetect methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 5/28/2012 06:01'!defaultAction 	^ false "false indicate no recursion"! !!NBRecursionDetect methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 5/28/2012 05:40'!method	^ method! !!NBRecursionDetect methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 5/28/2012 05:35'!signalForMethod: aMethod	method := aMethod.	^ self signal! !!CompiledMethod methodsFor: '*NativeBoost-Core' stamp: 'IgorStasenko 11/9/2012 04:13'!forceJIT	<primitive: 'primitiveForceJIT' module: '' error: errorCode >	^ self primitiveFailed! !!CompiledMethod methodsFor: '*NativeBoost-Core' stamp: 'Igor.Stasenko 5/18/2010 08:20'!hasNativeCode	^ self trailerKind == #NativeCodeTrailer! !!CompiledMethod methodsFor: '*NativeBoost-Core' stamp: 'Igor.Stasenko 5/18/2010 08:19'!trailerKind	"a shortcut accessor to check the trailer kind, without instantiating the trailer"	| flagByte index |	flagByte := self at: self size.	index := flagByte >> 2 + 1.	^ CompiledMethodTrailer trailerKinds at: index.! !!ArrayedCollection methodsFor: '*NativeBoost-Core' stamp: 'Igor.Stasenko 5/2/2010 20:32'!hexDump	"Utility method, for inspecting the native code"	^ String streamContents: [:str |				self do: [:each |			str nextPutAll: (each printStringBase: 16) ] separatedBy: [ str space ] ]! !!NBExternalArray class methodsFor: 'private' stamp: 'CiprianTeodorov 12/16/2012 15:49'!anonymousSubclassInitElementType: aTypeName	"create and initialize the anonymous subclass of me"	| newSubclass |	newSubclass := ClassBuilder new		newSubclassOf: NBExternalArray		type: NBExternalArray typeOfClass		instanceVariables: ''		from: nil.	"we're not using 'self' to avoid wrong subclassing from anonymous subclass "	newSubclass initElementType: aTypeName.	^ newSubclass! !!NBExternalArray class methodsFor: 'accessing' stamp: 'IgorStasenko 12/7/2012 16:45'!elementSize	^ elementSize! !!NBExternalArray class methodsFor: 'accessing' stamp: 'IgorStasenko 12/7/2012 16:45'!elementType	^ elementType! !!NBExternalArray class methodsFor: 'instance creation' stamp: 'IgorStasenko 12/7/2012 16:45'!externalNew: numberOfElements	"answer a fresh instance of receiver, allocated on external memory "		^ self onAddress: (NativeBoost allocate: elementSize * numberOfElements) size: numberOfElements! !!NBExternalArray class methodsFor: 'class initialization' stamp: 'IgorStasenko 12/7/2012 16:46'!initElementType:  aTypeName	"Initialize the element type and size.		If you want to use a public subclass of me, then make sure you call this method	in your class #initialize method.	" 	elementType := aTypeName.	elementSize := (NBFFICallout new requestor: self; resolveType: elementType) valueSize .	self installAccessors.! !!NBExternalArray class methodsFor: 'private' stamp: 'IgorStasenko 12/7/2012 16:08'!installAccessors	"Copy superclass methods, which serve as a template where generated code will be installed.	Each subclass of NBExternalArray should implement (override) these key methods "	self basicAddSelector: #at: withMethod: (NBExternalArray >> #at: ) copy.	self basicAddSelector: #at:put: withMethod: (NBExternalArray >> #at:put: ) copy.	! !!NBExternalArray class methodsFor: 'instance creation' stamp: 'IgorStasenko 12/7/2012 16:45'!new: numberOfElements	^ self basicNew initializeWithSize: numberOfElements! !!NBExternalArray class methodsFor: 'class factory' stamp: 'CiprianTeodorov 12/16/2012 15:50'!ofType: aTypeName	"Answer an anonymous subclass of receiver, ready for use for creating array(s) with given element type."	^ self anonymousSubclassInitElementType: aTypeName! !!NBExternalArray class methodsFor: 'instance creation' stamp: 'IgorStasenko 12/7/2012 16:45'!onAddress: anNBExternalAddress size: desiredSize		^ self basicNew initializeWithAddress: anNBExternalAddress Size: desiredSize! !!NBExternalArray methodsFor: 'accessing' stamp: 'IgorStasenko 12/7/2012 16:42'!address	"For external memory arrays, sometimes we may need to get an address"	^ data! !!NBExternalArray methodsFor: 'accessing' stamp: 'IgorStasenko 12/7/2012 16:42'!at: index	"Answer an element using 1-based index.	Note, this method used as a template for my anonymous subclasses. "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>		^ self emitRead! !!NBExternalArray methodsFor: 'accessing' stamp: 'IgorStasenko 12/7/2012 16:42'!at: index put: value	"Set value at 1-based index.	Note, this method used as a template for my anonymous subclasses. "		<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>		^ self emitWrite ! !!NBExternalArray methodsFor: 'private (code generation)' stamp: 'IgorStasenko 12/7/2012 16:44'!emitCopy: asm 	"Emit code to copy elementSize bytes from ESP ptr -> EAX ptr "	| toCopy offset |		toCopy := self class elementSize.		toCopy > 8 ifTrue: [ ^ self emitCopyUsingLoop: asm ].		offset := 0.	[ toCopy >= 4 ] whileTrue: [		asm 			mov: asm ESP ptr + offset to: asm ECX;			mov: asm ECX to: asm EAX ptr + offset.			toCopy := toCopy - 4.			offset := offset + 4.	].	toCopy >= 2  ifTrue: [		asm 			mov: asm ESP ptr16 + offset to: asm CX;			mov: asm CX to: asm EAX ptr16 + offset.		toCopy := toCopy - 2.		offset := offset + 2.	].	toCopy > 0  ifTrue: [		" last byte "		asm 			mov: asm ESP ptr8 + offset to: asm CL;			mov: asm CL to: asm EAX ptr8 + offset.	].! !!NBExternalArray methodsFor: 'private (code generation)' stamp: 'IgorStasenko 12/7/2012 16:44'!emitCopyUsingLoop: asm	| ssi sdi |	"copy the value using loop "	ssi := asm reserveTemp.	sdi := asm reserveTemp.	asm 		mov: asm ESI to: ssi;		mov: asm EDI to: sdi;		cld;		mov: asm ESP to: asm ESI;		mov: asm EAX to: asm EDI;		mov: self class elementSize to: asm ECX;		rep;movsb;		mov: ssi to: asm ESI;		mov: sdi to: asm EDI;		releaseTemps: 2.! !!NBExternalArray methodsFor: 'private (code generation)' stamp: 'IgorStasenko 12/7/2012 16:44'!emitRead	"	This method generates a native code for #at: method	the primitive will read a single element at given index in array.	the value type (elementType) and its size (elementSize) controlled by class side.		Note, data (instance variable) can hold either variable-byte object (holding data in object memory), or	instance of NBExternalAddress s		!!!!!!Note: no range checking for index!!!!!!	"	^ (self nbCalloutIn: thisContext sender) 		function: 'oop ( uint32 index , void * data )'		emit: [:gen :proxy :asm |			" index "			asm 				pop: asm EAX;				dec: asm EAX;				mov: self class elementSize to: asm ECX;				mul: asm ECX;								pop: asm ECX; "pointer to array first element -> ECX " 				add: asm EAX with: asm ECX.  										" EAX <- @data + (elementSize * (index - 1 ) ) "							"Emit code to read a value from given address and return oop"			(gen resolveType: self class elementType) readOop: asm EAX ptr generator: gen.		]! !!NBExternalArray methodsFor: 'private (code generation)' stamp: 'IgorStasenko 12/7/2012 16:44'!emitWrite	"	This method generates a native code for #at:put: method.	The primitive will store a single value at given index in array.	The value type (elementType) and its size (elementSize) controlled by class side.		Note, data can be either variable-byte object (holding data in object memory), or	instance of NBExternalAddress (holding data in external memory).		To conform with common #at:put: behavior for collections, answer the value we're just put. 		!!!!!!Note: no range checking for index!!!!!!		"		^ (self nbCalloutIn: thisContext sender)		function: ' oop ( oop value , uint32 index , void * data , ' , self class elementType , ' value )'		emit: [:gen :proxy :asm | | oop |						oop := gen reserveTemp.			"save value oop into temp to answer it when we done"			asm pop: asm EAX;				mov: asm EAX to: oop.							" index "			asm 				pop: asm EAX;				dec: asm EAX;				mov: self class elementSize to: asm ECX;				mul: asm ECX;								pop: asm ECX; "pointer to array first element " 				add: asm EAX with: asm ECX.  										" EAX now = @data + (elementSize * (index - 1 ) ) "							self emitCopy: asm.			"and finally, return original object "			asm mov: oop to: asm EAX .		].	! !!NBExternalArray methodsFor: 'initialize-release' stamp: 'IgorStasenko 12/7/2012 16:43'!free	"A convenience method, to explicitly free external memory, symmetrical when using	#externalNew: protocol for creating receiver.	Do nothing if receiver is not external array. 	" 	self isExternal ifTrue: [		data free.	].! !!NBExternalArray methodsFor: 'initialize-release' stamp: 'IgorStasenko 12/7/2012 16:43'!initializeWithAddress: anExternalAddress Size: aSize	"initialize an instance of receiver with data held in external memory"	size := aSize.	data := anExternalAddress.		! !!NBExternalArray methodsFor: 'initialize-release' stamp: 'IgorStasenko 12/7/2012 16:43'!initializeWithSize: aSize	"initialize an instance of receiver with data held in object memory heap "	size := aSize.	data := ByteArray new: size * self class elementSize.		! !!NBExternalArray methodsFor: 'testing' stamp: 'IgorStasenko 12/7/2012 16:44'!isExternal	"answer true if data referenced by receiver located in external heap, or just in object memory "	^ data class ~= ByteArray ! !!NBExternalArray methodsFor: 'copying' stamp: 'IgorStasenko 12/7/2012 16:43'!postCopy		self isExternal ifTrue: [		"copy the data from external memory into newly allocated byte array "		| newData sz |		sz := self class elementSize * size.		newData := ByteArray new: sz.		NativeBoost memCopy: data to: newData size: sz.		data := newData.	] ifFalse: [		data := data copy.	]! !!NBExternalArray methodsFor: 'accessing' stamp: 'IgorStasenko 12/7/2012 16:42'!size	^ size! !!Metaclass methodsFor: '*NativeBoost-Core' stamp: 'Igor.Stasenko 9/28/2010 08:00'!externalTypeAlias: aName	"redirect request to my instance side"	^ self instanceSide externalTypeAlias: aName! !!NBCallbackCodeGen methodsFor: 'global addresses' stamp: 'EstebanLorenzano 2/13/2013 16:27'!CFramePointerAddress	^ NativeBoost loadSymbol: 'CFramePointer' fromModule: NativeBoost VMModule! !!NBCallbackCodeGen methodsFor: 'global addresses' stamp: 'IgorStasenko 5/7/2012 12:36'!CStackPointerAddress	^ NativeBoost loadSymbol: 'CStackPointer' fromModule: NativeBoost VMModule! !!NBCallbackCodeGen methodsFor: 'callback entry code' stamp: 'IgorStasenko 9/15/2012 14:36'!activateCallbackContext: callbackClass	"Activate a callback context, which is a 		MethodContext sender: s receiver: r method: m arguments: args 	"		| ctx method fld |				method := callbackClass callbackEnterMethod.		ctx := gen reserveTemp.		fld := gen reserveTemp.				proxy positive32BitIntegerFor: EBP.				proxy pushRemappableOop: EAX.  "push EBP -> remappable oops stack"			proxy createInstanceOf: MethodContext size: method frameSize.		asm mov: EAX to: ctx.				"Fill the context state, which is #('sender' 'pc' 'stackp' 'method' 'closureOrNil' 'receiver')"			proxy integerObjectOf: method initialPC.		asm mov: ctx to: ECX;			mov: EAX to: ECX ptr + (proxy ivar: #pc in: MethodContext).			proxy integerObjectOf: method numTemps.		asm mov: ctx to: ECX;			mov: EAX to: ECX ptr + (proxy ivar: #stackp in: MethodContext).				NativeBoost extraRootsRegistry emitFetchCallback: cbIndex generator: gen.		"EAX - callback oop"			asm mov: ctx to: ECX;			mov: EAX to: ECX ptr + (proxy ivar: #receiver in: MethodContext);			mov: EAX ptr + (proxy ivar: #enterMethod in: NBFFICallback) to: EDX;			mov: EDX to: ECX ptr + (proxy ivar: #method in: MethodContext).							proxy firstIndexableField: ECX.		asm mov: EAX to: fld.		proxy popRemappableOop. "pop EBP from remappable oops stack"		asm mov: fld to: ECX;		mov: EAX to: ECX ptr + proxy oopSize. "put stackp as 1st method argument"		proxy popRemappableOop. "saved arguments array (see #emitArgumentsCoercion)"		asm mov: fld to: ECX;		mov: EAX to: ECX ptr.				proxy primitiveMethod.		asm mov: fld to: ECX;		mov: EAX to: ECX ptr + (2*proxy oopSize). "save current primitive method oop"		"Now we swapping the currently active VM context with the context we're just created"		 		proxy pushRemappableOop: ctx.		proxy swapActiveContext: [ ctx ] restoreMethod: [ 0 ]. " EAX <- activeContext"		asm mov: EAX to: ctx.		proxy popRemappableOop.				"set a sender in new context to be the old context		ctx - old context, EAX - new context"		asm mov: ctx to: ECX.		asm mov: ECX to: EAX ptr + (proxy ivar: #sender in: MethodContext).! !!NBCallbackCodeGen methodsFor: 'callback leave code' stamp: 'IgorStasenko 5/7/2012 12:48'!decrementCallbackCounter	"increment callback counter value"	asm mov: NativeBoost forCurrentPlatform callbackCounterAddress asUImm32 to: EAX.	asm dec: EAX ptr32.	! !!NBCallbackCodeGen methodsFor: 'callback entry code' stamp: 'IgorStasenko 9/15/2012 19:53'!emitArgumentsCoercion	" input - none,	output - an arguments array in remmappable oops stack top"	| args argOop i |	args := gen reserveTemp.	argOop := gen reserveTemp.		asm decorateWith:  'emitArgumentsCoercion' during: [			proxy createInstanceOf: Array size: (gen fnSpec arguments size).		proxy pushRemappableOop: EAX.			i := 0.		gen fnSpec arguments do: [:arg |			arg type readOop: (EBP ptr + arg offset) generator: gen.			asm mov: EAX to: argOop.			proxy popRemappableOop.			asm mov: EAX to: args.			proxy storePointer: i ofObject: args withValue: argOop.			i := i+1.			proxy pushRemappableOop: args.		].		gen releaseTemps: 2.	]! !!NBCallbackCodeGen methodsFor: 'callback entry code' stamp: 'IgorStasenko 5/7/2012 18:29'!enterSmalltalkExecutiveImplementation	"call #enterSmalltalkExecutiveImplementation"		| addr |		addr := NativeBoost loadSymbol: 'enterSmalltalkExecutiveImplementation' fromModule: NativeBoost VMModule.		asm cdeclCall: [:callInfo |		asm 			mov: addr asUImm32 to: EAX;			call: EAX. 	] alignment: NativeBoost forCurrentPlatform stackAlignment ! !!NBCallbackCodeGen methodsFor: 'callback entry code' stamp: 'IgorStasenko 5/8/2012 16:48'!generateCallbackEnterCodeFor: callbackClass	gen := (NBNativeFunctionGen new		callType: callbackClass callType;		fnSpec: callbackClass fnSpec;		yourself).	callbackClass numArgs: gen fnSpec arguments size.		"optUseStackPointer should be turned off!!!!!!"	gen parseOptions: #( + optProxyLabels - optUseStackPointer +optReserveCallgateSpace  "+optDebug" ).				^ gen generate: [:g |  					asm := gen asm.		proxy := gen proxy.		"		Callback entry , jumped directly from trunk.		ECX == callback index		"		cbIndex := gen reserveTemp.		asm 			mov: ECX to: cbIndex. 		self 			saveExecutionState;			emitArgumentsCoercion;			activateCallbackContext: callbackClass. 				"increment callback counter value"		self incrementCallbackCounter.								asm label: #safetyLoop.		self enterSmalltalkExecutiveImplementation.		" we never reach here"		asm jmp: #safetyLoop."========================================================""Callback return entry point. We jump here from #generateCallbackLeaveCodeFor:leaveAddr: The stack must contain:  - saved EBP  - EAX  - EDX"		asm label: #returnToC;			pop: EBP.		self restoreExecutionState.		self decrementCallbackCounter.				asm			pop: EAX;			pop: EDX.	].! !!NBCallbackCodeGen methodsFor: 'callback leave code' stamp: 'CiprianTeodorov 12/11/2012 19:00'!generateCallbackLeaveCodeFor: callbackClass leaveAddr: leaveAddress	gen := (NBNativeFunctionGen new		callType: callbackClass callType;		fnSpec: callbackClass fnSpec;		yourself).	callbackClass numArgs: gen fnSpec arguments size.		"optUseStackPointer should be turned off!!!!!!"	gen parseOptions: #( + optProxyLabels - optUseStackPointer +optReserveCallgateSpace  "+optDebug" ).				^ gen generate: [:g |					asm := gen asm.		proxy := gen proxy."see #primLeave:stackPtr:contextOop:returnValue:primitiveMethod: for arguments stack order"		"coerce the oop to return type"		proxy stackValue: 1."******** currently only return types returned via EAX supported *********"		gen fnSpec returnType coerceOopToOperand: gen ifFailedJumpTo: #failed.	"keep return value(s) on stack"		asm			push: EDX; 			push: EAX.		proxy stackValue: 3. "saved EBP"		proxy positive32BitValueOf: EAX.		asm push: EAX.		proxy ifFailedJumpTo: #failed.		proxy swapActiveContext: [ proxy stackValue: 2 ] restoreMethod: [ proxy stackValue: 0 ].			"swapactivecontext returns 0 on failure"		asm 			cmp: EAX with: 0;			je: #failed. 					asm 			mov: leaveAddress asUImm to: EAX;			jmp: EAX. "jump to callback leave-to-C code. see #generateCallbackEnterCodeFor:  " 					asm label: #failed."asm int3."				proxy primitiveFail.				asm 			leave;			leave;  " on failure, we do leave twice, because 		#primLeave:stackPtr:contextOop:returnValue:primitiveMethod:		creates own stack frame, and jumps to callback leave entry point		but we want to return straight to VM" 			ret.	].! !!NBCallbackCodeGen methodsFor: 'misc' stamp: 'IgorStasenko 5/7/2012 22:31'!generator: agen	gen := agen.	asm := gen asm.	proxy := gen proxy.! !!NBCallbackCodeGen methodsFor: 'callback entry code' stamp: 'IgorStasenko 5/7/2012 12:48'!incrementCallbackCounter	"increment callback counter value"	asm mov: NativeBoost forCurrentPlatform callbackCounterAddress asUImm32 to: EAX.	asm inc: EAX ptr32.	! !!NBCallbackCodeGen methodsFor: 'misc' stamp: 'IgorStasenko 9/10/2012 13:26'!memCopy: src to: dst size: sz	asm 		mov: src to: asm ESI;		mov: dst to: asm EDI;		mov: sz to: asm ECX;		rep;		movsb! !!NBCallbackCodeGen methodsFor: 'primitives' stamp: 'IgorStasenko 9/10/2012 12:23'!primJumpBufSize	<primitive: #primJumpBufSize module: #NativeBoostPlugin>		self error: 'a primitive failed. (seems like you using outdated VM)'! !!NBCallbackCodeGen methodsFor: 'global addresses' stamp: 'IgorStasenko 9/10/2012 12:49'!reenterInterpreterAddress	^ (NativeBoost loadSymbol: 'reenterInterpreter' fromModule: NativeBoost VMModule) value asUImm32 ! !!NBCallbackCodeGen methodsFor: 'callback leave code' stamp: 'IgorStasenko 9/15/2012 19:54'!restoreExecutionState	"emit code to restore execution state"		asm decorateWith: 'restoreExecutionState' during: [	"restore registers & other , see corresponding #saveExecutionState"	self memCopy: savedReenterInterpreter to: self reenterInterpreterAddress  size: self primJumpBufSize.	asm 		mov: savedEBX to: EBX;		mov: savedESI to: ESI;		mov: savedEDI to: EDI;		mov: savedCStackPointer to: EAX;		mov: EAX to: self CStackPointerAddress asUImm ptr;						mov: savedCFramePointer to: EAX;		mov: EAX to: self CFramePointerAddress asUImm ptr.			]! !!NBCallbackCodeGen methodsFor: 'callback entry code' stamp: 'IgorStasenko 9/15/2012 19:50'!saveExecutionState	"emit code to save execution state"		asm decorateWith: 'saveExecutionState' during: [	"save registers"	savedEBX := gen reserveTemp.	savedESI := gen reserveTemp.	savedEDI := gen reserveTemp.	savedCStackPointer := gen reserveTemp.	savedCFramePointer := gen reserveTemp.	savedReenterInterpreter := gen reserveTemp.		asm 		mov: EBX to: savedEBX;		mov: ESI to: savedESI;		mov: EDI to: savedEDI;		mov: self CStackPointerAddress asUImm ptr to: EAX;		mov: EAX to: savedCStackPointer;		mov: self CFramePointerAddress asUImm ptr to: EAX;		mov: EAX to: savedCFramePointer;				sub: asm ESP with: self primJumpBufSize;		mov: ESP to: savedReenterInterpreter.			self memCopy: self reenterInterpreterAddress to: savedReenterInterpreter  size: self primJumpBufSize	]! !!NBExternalString methodsFor: 'emitting code' stamp: 'IgorStasenko 8/10/2011 18:41'!coerceReturnValue: gen	"	Copy a null-terminated C string into a newly created instance of ByteString	input - char* string in EAX	output - String oop in EAX "		| cPtr strLen oop asm proxy notNull done |	asm := gen asm.	proxy := gen proxy.		cPtr := gen reserveTemp.	strLen := gen reserveTemp.	oop := gen reserveTemp.	notNull := asm uniqueLabelName: 'notNull'.	done := asm uniqueLabelName: 'done'.			asm mov: EAX to: cPtr.	"check if return value is NULL, then answer nil instead" 	asm 		or: EAX with: EAX;		jnz: notNull.	proxy nilObject.	asm jmp: done.			asm label: notNull.		"count a number of characters"	asm mov: (self strLen: gen) to: strLen.	proxy classString.	proxy instantiateClass: EAX indexableSize: strLen.		asm mov: EAX to: oop. "oop"		"copy the string"	proxy firstIndexableField: EAX.	asm 		push: ESI;		push: EDI;		mov: cPtr to: ESI;		mov: EAX to: EDI;		mov: strLen to: ECX;		rep; movsb; 		pop: EDI;		pop: ESI;		mov: oop to: EAX.	asm label: done.			gen releaseTemps: 3.! !!NBExternalString methodsFor: 'emitting code' stamp: 'CamilloBruni 7/23/2012 13:29'!prepareArgumentUsing: gen	"prepare the ByteString argument.	Allocate a space for string on stack, then copy string contents there	and add terminating null character "		| asm stringOop len loop done donePreparing notNil |		asm := gen asm.		loop := asm uniqueLabelName: 'loop'.	done := asm uniqueLabelName: 'done'.	notNil  := asm uniqueLabelName: 'notNil'.	donePreparing := asm uniqueLabelName: 'donePreparing'.	    	loader emitLoad: gen.	"reserve after emitting load, otherwise, if proxy using stackpointer temp, it will be clobbered"	address := gen reserveTemp.  	stringOop := gen reserveTemp.	len := gen reserveTemp.	asm mov: EAX to: stringOop.		gen optStringOrNull ifTrue: [		"allow passing nil as string, effectively will push null pointer as argument"		gen proxy nilObject.		asm 			cmp: EAX with: stringOop;			jne: notNil;			mov: 0 to: address;  "null pointer"			jmp: donePreparing.	].	asm label: notNil.	gen proxy isBytes: stringOop.		asm or: EAX with: EAX.	asm jz: gen failedLabel.		gen proxy byteSizeOf: stringOop.	asm mov: EAX to: len.	asm inc: EAX. "add 1 byte for terminating null character"	gen reserveStackBytes: EAX andStoreAddrTo: address.	gen proxy firstIndexableField: stringOop.	asm decorateWith: ' copy string contents to the stack ' during: [	asm 		push: ESI;		push: EDI;		mov: EAX to: ESI;		mov: address to: EDI;		mov: len to: ECX;"		rep; movsb;  -- is flat memory model has ES=DS ? "	label: loop;		dec: ECX;		jl: done;		mov: ESI ptr to: AL;		mov: AL to: EDI ptr;		inc: ESI;		inc: EDI;		jmp: loop;	label: done;		mov: 0 to: EDI ptr8;  "store null-terminating character"		pop: EDI;		pop: ESI.	].	gen releaseTemps: 2.  "keep the address reserved, otherwise it will be clobbered"	asm label: donePreparing   ! !!NBExternalString methodsFor: 'emitting code' stamp: 'Igor.Stasenko 4/28/2010 20:26'!pushAsPointer: gen 	self error: 'Strings already passed as a pointer'.! !!NBExternalString methodsFor: 'emitting code' stamp: 'Igor.Stasenko 4/28/2010 13:44'!pushAsValue: gen	gen asm push: address.! !!NBExternalString methodsFor: 'emitting code' stamp: 'Igor.Stasenko 5/2/2010 20:38'!strLen: gen	" input: EAX - pointer to char* string	 output: ECX - string length "	| loop end asm |	asm := gen asm.		loop := asm uniqueLabelName: 'loop'.	end := asm uniqueLabelName: 'end'.	asm 		mov: EAX to: ECX;	label: loop;		cmp: ECX ptr8 with: 0;		je: end;		inc: ECX;		jmp: loop;	label: end;		sub: ECX with: EAX.			^ ECX! !!NBExternalString methodsFor: 'accessing' stamp: 'Igor.Stasenko 4/28/2010 15:56'!valueSize	^ self pointerSize "i am live and die as a pointer"! !!NBFFICallback class methodsFor: 'callback spec' stamp: 'Igor.Stasenko 5/13/2010 23:33'!asNBExternalType: gen	^ NBFFICallbackType new callbackClass: self! !!NBFFICallback class methodsFor: 'callback spec' stamp: 'IgorStasenko 9/15/2012 14:24'!callType	"Answer a callback function calling convention	#cdecl or #stdcall	"		"By default, use cdecl convention"		^ #cdecl! !!NBFFICallback class methodsFor: 'accessing' stamp: 'IgorStasenko 5/8/2012 16:04'!callbackEnterAddress	self checkSession.		cbEnter ifNil: [ self installCallbackCode ].		^ cbEnter address! !!NBFFICallback class methodsFor: 'accessing' stamp: 'IgorStasenko 5/7/2012 13:47'!callbackEnterMethod	"do not override"	^ NBFFICallback compiledMethodAt: #pvtEnter:stackPointer:primitiveMethod:  .! !!NBFFICallback class methodsFor: 'accessing' stamp: 'IgorStasenko 5/8/2012 16:05'!callbackLeaveAddress	self checkSession.		cbLeave ifNil: [ self installCallbackCode ].		^ cbLeave address! !!NBFFICallback class methodsFor: 'private' stamp: 'IgorStasenko 5/8/2012 16:06'!checkSession	session == NativeBoost uniqueSessionObject ifFalse: [		numArgs := cbEnter := cbLeave := trunkCode := nil.		session := NativeBoost uniqueSessionObject.	].! !!NBFFICallback class methodsFor: 'finalization' stamp: 'IgorStasenko 9/15/2012 14:18'!finalizeResourceData: trunkAndIndex		NativeBoost free: trunkAndIndex first.	NativeBoost extraRootsRegistry releaseCallbackIndex: trunkAndIndex second.! !!NBFFICallback class methodsFor: 'callback spec' stamp: 'IgorStasenko 9/16/2012 17:20'!fnSpec	"answer an anonymous C function signature for a given callback,	like #( long ( int a, int* b) )"	self subclassResponsibility .! !!NBFFICallback class methodsFor: 'code generation' stamp: 'IgorStasenko 5/8/2012 16:53'!installCallbackCode	| enterCodeFn leaveCodeFn leaveOffset returnAddr |		cbEnter := NBCallbackCodeGen new generateCallbackEnterCodeFor: self.		cbEnter install.				returnAddr := cbEnter address value + (cbEnter code offsetAt: #returnToC).		cbLeave := NBCallbackCodeGen new generateCallbackLeaveCodeFor: self leaveAddr: returnAddr.				cbLeave install.! !!NBFFICallback class methodsFor: 'instance creation' stamp: 'Igor.Stasenko 5/13/2010 22:40'!new	self error: 'use #on: instead'.! !!NBFFICallback class methodsFor: 'private' stamp: 'IgorStasenko 5/7/2012 13:40'!numArgs: int	numArgs := int! !!NBFFICallback class methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/11/2010 02:35'!numberOfArguments	^ numArgs! !!NBFFICallback class methodsFor: 'instance creation' stamp: 'Igor.Stasenko 5/13/2010 22:43'!on: aBlock	^ self basicNew initialize block: aBlock! !!NBFFICallback class methodsFor: 'private' stamp: 'IgorStasenko 5/8/2012 16:06'!reset 	self checkSession.		cbEnter ifNotNil: [				cbEnter uninstall.		cbLeave uninstall.		numArgs := cbEnter := cbLeave := trunkCode := nil.	].! !!NBFFICallback class methodsFor: 'accessing' stamp: 'IgorStasenko 5/8/2012 03:04'!trunkCode	self checkSession.	^ trunkCode ifNil: [ | asm |		asm := NativeBoost newAssembler noStackFrame.  "NO STACK FRAME, since we just jump to common entry point"		asm			mov: (0 asUImm32 label: (asm labelNamed: #index)) to: ECX; " callback index "			mov: ((self callbackEnterAddress asUImm32) label: (asm labelNamed: #cbEnterAddress)) to: EAX;			jmp: EAX.				trunkCode := asm generatedCode.	]! !!NBFFICallback methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/13/2010 22:38'!block: aBlock	self class numberOfArguments = aBlock numArgs ifFalse: [		self error: 'Invalid number of arguments' ].		block := aBlock! !!NBFFICallback methodsFor: 'initialize-release' stamp: 'IgorStasenko 9/15/2012 20:07'!initialize	enterMethod := self class callbackEnterMethod.	index := NativeBoost extraRootsRegistry registerCallback: self.	self installTrunk.		NBExternalResourceManager addResource: self data: {trunk. index }.! !!NBFFICallback methodsFor: 'trunk management' stamp: 'IgorStasenko 11/24/2012 15:44'!installTrunk	| code bytes |	code := self class trunkCode.	bytes := code bytes.		trunk := NativeBoost allocate: bytes size.	NativeBoost memCopy: bytes to: trunk size: bytes size.		trunk nbUInt32AtOffset: (code offsetAt: #index) put: index! !!NBFFICallback methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 9/15/2012 14:21'!primLeave: leaveAddr stackPtr: saveStackPtr contextOop: senderContext 	returnValue: oop primitiveMethod: aMethod	"simply jump to the address, provided in leaveAddr parameter,	which should be an unsigned integer value"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ NBNativeCodeGen methodAssembly: [:gen | | proxy asm |		proxy := gen proxy.		asm := gen asm.		proxy stackValue: 4. "leaveAddr"		proxy positive32BitValueOf: EAX.		asm push: EAX.		proxy ifFailedJumpTo: #failed.		asm pop: EAX;			jmp: EAX.  " jump to callback leave address "		asm label: #failed.		gen epilogue.	]! !!NBFFICallback methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 5/8/2012 16:09'!pvtEnter: arguments stackPointer: savedStackPtr primitiveMethod: aMethod	"Note, this is for internal use only!!!!!! do not touch this method ever!! "	| result theSender |	result := 0.	theSender := thisContext sender.	[ 	result := block valueWithArguments: arguments ]	ensure: [		self 			primLeave: self class callbackLeaveAddress asUnsignedLong 			stackPtr: savedStackPtr 			contextOop: theSender 			returnValue: result			primitiveMethod: aMethod		]! !!NBQSortCallback class methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/8/2010 19:17'!callType	^ #cdecl! !!NBQSortCallback class methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/13/2010 22:54'!fnSpec	^ #(int ( NBExternalAddress a, NBExternalAddress b))! !!NBQSortCallback methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 11/24/2012 15:30'!index	^ index! !!NBQSortCallback methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 11/24/2012 15:30'!trunk	^ trunk! !!NBInterpreterProxy class methodsFor: 'class initialization' stamp: 'CamilloBruni 7/18/2012 14:41'!CogProxyFunctionsData	"taken from sqVirtualMachine.h"	^ #(		#minorVersion (void)		#majorVersion (void)		" InterpreterProxy methodsFor: 'stack access' "		#pop: (sqInt)		#pop:thenPush: (sqInt sqInt)		#push: (sqInt)		#pushBool: (sqInt)		#pushFloat: (double)		#pushInteger: (sqInt)		#stackFloatValue: (sqInt )		#stackIntegerValue: (sqInt)		#stackObjectValue: (sqInt)		#stackValue: (sqInt)		" InterpreterProxy methodsFor: 'object access'  "		#argumentCountOf: (sqInt)		#arrayValueOf: (sqInt)		#byteSizeOf: (sqInt)		#fetchArray:ofObject: (sqInt sqInt)		#fetchClassOf: (sqInt)		#fetchFloat:ofObject: (sqInt sqInt)		#fetchInteger:ofObject: (sqInt sqInt)		#fetchPointer:ofObject: (sqInt sqInt)		#obsoleteDontUseThisFetchWord:ofObject: (sqInt sqInt)		#firstFixedField: (sqInt)		#firstIndexableField: (sqInt)		#literal:ofMethod: (sqInt  sqInt)		#literalCountOf: (sqInt )		#methodArgumentCount (void)		#methodPrimitiveIndex (void)		#primitiveIndexOf: (sqInt )		#sizeOfSTArrayFromCPrimitive: (voidPtr)		#slotSizeOf: (sqInt )		#stObject:at: (sqInt   sqInt )		#stObject:at:put: (sqInt   sqInt   sqInt)		#stSizeOf: (sqInt)		#storeInteger:ofObject:withValue: (sqInt   sqInt   sqInt )		#storePointer:ofObject:withValue: (sqInt   sqInt   sqInt )		" InterpreterProxy methodsFor: 'testing' "		#is:KindOf: (sqInt   charPtr)		#is:MemberOf: (sqInt charPtr)		#isBytes: (sqInt )		#isFloatObject: (sqInt )		#isIndexable: (sqInt )		#isIntegerObject: (sqInt )		#isIntegerValue: (sqInt )		#isPointers: (sqInt )		#isWeak: (sqInt )		#isWords: (sqInt )		#isWordsOrBytes: (sqInt )		" InterpreterProxy methodsFor: 'converting' "		#booleanValueOf: (sqInt )		#checkedIntegerValueOf: (sqInt )		#floatObjectOf: (double )		#floatValueOf: (sqInt )		#integerObjectOf: (sqInt )		#integerValueOf: (sqInt )		#positive32BitIntegerFor: (sqInt )		#positive32BitValueOf: (sqInt )		" InterpreterProxy methodsFor: 'special objects' "		#characterTable (void)		#displayObject (void)		#falseObject (void)		#nilObject (void)		#trueObject (void)		" InterpreterProxy methodsFor: 'special classes' "		#classArray (void)		#classBitmap (void)		#classByteArray (void)		#classCharacter (void)		#classFloat (void)		#classLargePositiveInteger (void)		#classPoint (void)		#classSemaphore (void)		#classSmallInteger (void)		#classString (void)		" InterpreterProxy methodsFor: 'instance creation' "		#clone: (sqInt )		#instantiateClass:indexableSize: (sqInt   sqInt )		#makePointwithxValue:yValue: (sqInt   sqInt )		#popRemappableOop (void)		#pushRemappableOop: (sqInt )		" InterpreterProxy methodsFor: 'other' "		#become:with: (sqInt   sqInt )		#byteSwapped: (sqInt)		#failed (void)		#fullDisplayUpdate (void)		#fullGC (void)		#incrementalGC (void)		#primitiveFail (void)		#showDisplayBits:Left:Top:Right:Bottom: (sqInt   sqInt  sqInt  sqInt  sqInt)		#signalSemaphoreWithIndex: (sqInt)		#success: (sqInt )		#superclassOf: (sqInt )		" InterpreterProxy methodsFor: 'compiler' "		#compilerHookVector (void)		#setCompilerInitialized: (sqInt )		" VM_PROXY_MINOR > 1 "		2		" InterpreterProxy methodsFor: 'BitBlt support' "		#loadBitBltFrom: (sqInt )		#copyBits (void)		#copyBitsFrom:to:at: (sqInt   sqInt   sqInt )		" VM_PROXY_MINOR > 2 "		3		#classLargeNegativeInteger (void)		#signed32BitIntegerFor: (sqInt )		#signed32BitValueOf: (sqInt )		#includesBehavior:ThatOf: (sqInt   sqInt )		#primitiveMethod (void)		" InterpreterProxy methodsFor: 'FFI support' "		#classExternalAddress (void)		#classExternalData (void)		#classExternalFunction (void)		#classExternalLibrary (void)		#classExternalStructure (void)		#ioLoadModule:OfLength: (sqInt sqInt)		#ioLoadSymbol:OfLength:FromModule: (sqInt   sqInt   sqInt )		#isInMemory: (sqInt )		" VM_PROXY_MINOR > 3 "		4		#ioLoadFunction:From: (charPtr charPtr)		#ioMicroMSecs (void)		" VM_PROXY_MINOR > 4 "		5		#positive64BitIntegerFor: (sqLong)		#positive64BitValueOf: (sqInt)		#signed64BitIntegerFor: (sqLong)		#signed64BitValueOf: (sqInt)		" VM_PROXY_MINOR > 5 "		6		#isArray: (sqInt )		#forceInterruptCheck (void)		" VM_PROXY_MINOR > 6 "		7		#fetchLong32:ofObject: (sqInt  sqInt)		#getThisSessionID (void)		#ioFilename:fromString:ofLength:resolveAliases: (charPtr charPtr sqInt sqInt)		#vmEndianness (void)		8		" New methods for proxy version 1.8 "					callbackEnter: (sqIntPtr)		callbackLeave: (sqInt)		addGCRoot: (sqIntPtr)		removeGCRoot: (sqIntPtr)		9		primitiveFailFor: (sqInt code)		setInterruptCheckChain: (void * aFunction )		classAlien (void)		classUnsafeAlien (void)		sendInvokeCallback:Stack:Registers:Jmpbuf: (sqInt thunkPtrAsInt, sqInt stackPtrAsInt, sqInt regsPtrAsInt, sqInt jmpBufPtrAsInt)		reestablishContextPriorToCallback: (sqInt callbackContext)		getStackPointer (void)		internalIsImmutable: (sqInt oop)		internalIsMutable: (sqInt oop)		10		methodArg:  (sqInt index)		objectArg:  (sqInt index)		integerArg: (sqInt index)		floatArg:   (sqInt index)		methodReturnValue: (sqInt oop)		topRemappableOop  (void)		11		disownVM: (sqInt flags)		ownVM:   (sqInt threadIdAndFlags)		addHighPriorityTickee:period: (void ticker (void), unsigned periodms)		addSynchronousTickee:period:round: (void ticker (void), unsigned periodms, unsigned roundms)		utcMicroseconds (void)		tenuringIncrementalGC (void)		isYoung: (sqInt anOop)		isKindOf:Class: (sqInt oop, sqInt aClass)		primitiveErrorTable (void)		primitiveFailureCode (void)		instanceSizeOf: (sqInt aClass)	)! !!NBInterpreterProxy class methodsFor: 'accessing functions' stamp: 'CamilloBruni 8/3/2012 18:26'!cFramePointerAddress	"to prevent recursion, we prohibit using stack pointer address when bootstrapping"	NativeBoost forCurrentPlatform isBootstrapping ifTrue: [ ^ nil ].		^ NativeBoost loadSymbol: #CFramePointer ! !!NBInterpreterProxy class methodsFor: 'accessing functions' stamp: 'CamilloBruni 8/3/2012 18:26'!cStackPointerAddress	"to prevent recursion, we prohibit using stack pointer address when bootstrapping"	NativeBoost forCurrentPlatform isBootstrapping ifTrue: [ ^ nil ].		^ NativeBoost loadSymbol: #CStackPointer! !!NBInterpreterProxy class methodsFor: 'options' stamp: 'Igor.Stasenko 5/19/2010 13:02'!defaultOptions	"Default options for proxy.	Proxy options is applied before default options of generator,	so generator can override them"	^ #(	"call proxy functions directly, instead of loading their address indirectly via interpreterProxy struct"	#optDirectProxyFnAddress			"use a direct ST stack pointer, initially retrieved using #getStackPointer"		 #optUseStackPointer 		)! !!NBInterpreterProxy class methodsFor: 'accessing functions' stamp: 'Igor.Stasenko 5/3/2010 10:36'!fnAddressAt: index	"retrieve an interpreter proxy function address	at given zero-based index.		(self functions at: #minorVersion) address	"	index isString ifTrue: [ ^ self fnAddressAt: (self functions at: index) index ].	^ NativeBoost ulongAt: self interpreterProxyAddress + (4 * index)	! !!NBInterpreterProxy class methodsFor: 'debugging' stamp: 'Igor.Stasenko 4/16/2010 03:31'!fnSelectorAt: offset" NBInterpreterProxy fnSelectorAt: 16r130 "	^ (self functionAtOffset: offset) selector! !!NBInterpreterProxy class methodsFor: 'instance creation' stamp: 'Igor.Stasenko 5/1/2010 11:46'!forGenerator: aNativeCodeGenerator	^ self basicNew initialize generator: aNativeCodeGenerator! !!NBInterpreterProxy class methodsFor: 'accessing functions' stamp: 'CamilloBruni 8/3/2012 17:21'!framePointerAddress	"to prevent recursion, we prohibit using stack pointer address when bootstrapping"	NativeBoost forCurrentPlatform isBootstrapping ifTrue: [ ^ nil ].		^ self primFramePointerAddress ! !!NBInterpreterProxy class methodsFor: 'debugging' stamp: 'Igor.Stasenko 9/29/2010 09:26'!functionAtOffset: offset	| index |	index := offset / 4.	^ self functions detect: [:fn | fn index = index ]! !!NBInterpreterProxy class methodsFor: 'accessing' stamp: 'IgorStasenko 11/23/2011 10:44'!functions	" choose a set of interprterProxy functions, depending on VM we're currently running on"	^ (Smalltalk vm version beginsWith: 'Squeak') 		ifTrue: [	Functions ]		ifFalse: [ CogFunctions ]! !!NBInterpreterProxy class methodsFor: 'class initialization' stamp: 'Igor.Stasenko 9/29/2010 09:22'!generateFunctions	" self generateFunctions   "		Functions := self generateFunctionsFrom: self proxyFunctionsData.	"checked using compiler on 32bits"	self assert: (Functions at: #vmEndianness) index * 4 = 456.		CogFunctions := self generateFunctionsFrom: self CogProxyFunctionsData.! !!NBInterpreterProxy class methodsFor: 'class initialization' stamp: 'IgorStasenko 8/3/2011 07:36'!generateFunctionsFrom: data	| i stream minorV functions |		functions := IdentityDictionary new.		i := 0.	stream := data readStream.	minorV := 0.	[ stream atEnd ] whileFalse: [ | val |		val := stream next.		val isInteger ifTrue: [ minorV := val ]			ifFalse: [				(functions includesKey: val) ifTrue: [ self error: 'duplicated function!!!!' ].				functions at: val put: (					NBProxyFunction new selector: val; parseArguments: stream next; index: i; 					majorVersion: 1; minorVersion: minorV;	requiresAlignment: (self safeNoAlignFunctions includes: val) not; yourself ).				i := i + 1. ]	].	^ functions! !!NBInterpreterProxy class methodsFor: 'class initialization' stamp: 'IgorStasenko 8/3/2011 09:08'!initialize	"self initialize"	self generateFunctions! !!NBInterpreterProxy class methodsFor: 'accessing functions' stamp: 'Igor.Stasenko 5/2/2010 08:34'!interpreterProxyAddress	<primitive: #primitiveGetInterpreterProxy module: #NativeBoostPlugin> 	^ self primitiveFailed! !!NBInterpreterProxy class methodsFor: 'accessing functions' stamp: 'IgorStasenko 11/24/2012 17:19'!majorVersion	"retrieve an interpreter proxy structure major version value"	<primitive: 'primitiveNativeCall' module: 'NativeBoostPlugin'>	^ self nbCallout		options: #(			"do not use interpreterProxy address directly"			 - optDirectProxyFnAddress 			"do not align stack for FFI call"			+ optNoAlignment );			 		function: #(short ()) emit: [:gen | 			gen proxy majorVersion		] ! !!NBInterpreterProxy class methodsFor: 'accessing functions' stamp: 'IgorStasenko 11/24/2012 17:19'!minorVersion	"retrieve an interpreter proxy structure minor version value"	<primitive: 'primitiveNativeCall' module: 'NativeBoostPlugin'>	^ self nbCallout		options: #(			"do not use interpreterProxy address directly"			 - optDirectProxyFnAddress 			"do not align stack for FFI call"			+ optNoAlignment ); 		function: #(short ()) emit: [:gen | 			gen proxy minorVersion		] ! !!NBInterpreterProxy class methodsFor: 'instance creation' stamp: 'Igor.Stasenko 5/1/2010 11:46'!new	self error: 'Use #forGenerator: '! !!NBInterpreterProxy class methodsFor: 'accessing functions' stamp: 'IgorStasenko 11/24/2012 17:20'!primFramePointerAddress	"retrieve a stack pointer address"	<primitive: 'primitiveNativeCall' module: 'NativeBoostPlugin' error: errorCode>	^ self nbCallout function: #(uint ()) emit: [:gen :proxy :asm | | fn | 			fn :=  [ (NativeBoost forCurrentPlatform 						loadSymbol: 'framePointerAddress' fromModule: '') ] ifError: [ nil ].			fn ifNil: [ ^ nil ]. "just for safety" 			asm 				mov: fn asUImm32 to: asm EAX;							call: EAX.		].! !!NBInterpreterProxy class methodsFor: 'accessing functions' stamp: 'IgorStasenko 2/8/2013 12:59'!primStackPointerAddress	"retrieve a stack pointer address"	<primitive: 'primitiveNativeCall' module: 'NativeBoostPlugin' error: errorCode>	^ self nbCallout function: #(uint ()) emit: [:gen :proxy :asm | | fn | 			fn :=  [ (NativeBoost loadSymbol: 'stackPointerAddress' fromModule: NativeBoost VMModule) ] ifError: [ nil ].			fn ifNil: [ ^ nil ]. "just for safety" 			asm 				mov: fn asUImm32 to: asm EAX;							call: EAX.		].! !!NBInterpreterProxy class methodsFor: 'class initialization' stamp: 'CamilloBruni 7/19/2012 11:54'!proxyFunctionsData	"taken from sqVirtualMachine.h"	^ #(		#minorVersion (void)		#majorVersion (void)		" InterpreterProxy methodsFor: 'stack access' "		#pop: (sqInt)		#pop:thenPush: (sqInt sqInt)		#push: (sqInt)		#pushBool: (sqInt)		#pushFloat: (double)		#pushInteger: (sqInt)		#stackFloatValue: (sqInt )		#stackIntegerValue: (sqInt)		#stackObjectValue: (sqInt)		#stackValue: (sqInt)		" InterpreterProxy methodsFor: 'object access'  "		#argumentCountOf: (sqInt)		#arrayValueOf: (sqInt)		#byteSizeOf: (sqInt)		#fetchArray:ofObject: (sqInt sqInt)		#fetchClassOf: (sqInt)		#fetchFloat:ofObject: (sqInt sqInt)		#fetchInteger:ofObject: (sqInt sqInt)		#fetchPointer:ofObject: (sqInt sqInt)		#obsoleteDontUseThisFetchWord:ofObject: (sqInt sqInt)		#firstFixedField: (sqInt)		#firstIndexableField: (sqInt)		#literal:ofMethod: (sqInt  sqInt)		#literalCountOf: (sqInt )		#methodArgumentCount (void)		#methodPrimitiveIndex (void)		#primitiveIndexOf: (sqInt )		#sizeOfSTArrayFromCPrimitive: (voidPtr)		#slotSizeOf: (sqInt )		#stObject:at: (sqInt   sqInt )		#stObject:at:put: (sqInt   sqInt   sqInt)		#stSizeOf: (sqInt)		#storeInteger:ofObject:withValue: (sqInt   sqInt   sqInt )		#storePointer:ofObject:withValue: (sqInt   sqInt   sqInt )		" InterpreterProxy methodsFor: 'testing' "		#is:KindOf: (sqInt   charPtr)		#is:MemberOf: (sqInt charPtr)		#isBytes: (sqInt )		#isFloatObject: (sqInt )		#isIndexable: (sqInt )		#isIntegerObject: (sqInt )		#isIntegerValue: (sqInt )		#isPointers: (sqInt )		#isWeak: (sqInt )		#isWords: (sqInt )		#isWordsOrBytes: (sqInt )		" InterpreterProxy methodsFor: 'converting' "		#booleanValueOf: (sqInt )		#checkedIntegerValueOf: (sqInt )		#floatObjectOf: (double )		#floatValueOf: (sqInt )		#integerObjectOf: (sqInt )		#integerValueOf: (sqInt )		#positive32BitIntegerFor: (sqInt )		#positive32BitValueOf: (sqInt )		" InterpreterProxy methodsFor: 'special objects' "		#characterTable (void)		#displayObject (void)		#falseObject (void)		#nilObject (void)		#trueObject (void)		" InterpreterProxy methodsFor: 'special classes' "		#classArray (void)		#classBitmap (void)		#classByteArray (void)		#classCharacter (void)		#classFloat (void)		#classLargePositiveInteger (void)		#classPoint (void)		#classSemaphore (void)		#classSmallInteger (void)		#classString (void)		" InterpreterProxy methodsFor: 'instance creation' "		#clone: (sqInt )		#instantiateClass:indexableSize: (sqInt   sqInt )		#makePointwithxValue:yValue: (sqInt   sqInt )		#popRemappableOop (void)		#pushRemappableOop: (sqInt )		" InterpreterProxy methodsFor: 'other' "		#become:with: (sqInt   sqInt )		#byteSwapped: (sqInt)		#failed (void)		#fullDisplayUpdate (void)		#fullGC (void)		#incrementalGC (void)		#primitiveFail (void)		#showDisplayBits:Left:Top:Right:Bottom: (sqInt   sqInt  sqInt  sqInt  sqInt)		#signalSemaphoreWithIndex: (sqInt)		#success: (sqInt )		#superclassOf: (sqInt )		" InterpreterProxy methodsFor: 'compiler' "		#compilerHookVector (void)		#setCompilerInitialized: (sqInt )		" VM_PROXY_MINOR > 1 "		2		" InterpreterProxy methodsFor: 'BitBlt support' "		#loadBitBltFrom: (sqInt )		#copyBits (void)		#copyBitsFrom:to:at: (sqInt   sqInt   sqInt )		" VM_PROXY_MINOR > 2 "		3		#classLargeNegativeInteger (void)		#signed32BitIntegerFor: (sqInt )		#signed32BitValueOf: (sqInt )		#includesBehavior:ThatOf: (sqInt   sqInt )		#primitiveMethod (void)		" InterpreterProxy methodsFor: 'FFI support' "		#classExternalAddress (void)		#classExternalData (void)		#classExternalFunction (void)		#classExternalLibrary (void)		#classExternalStructure (void)		#ioLoadModule:OfLength: (sqInt sqInt)		#ioLoadSymbol:OfLength:FromModule: (sqInt   sqInt   sqInt )		#isInMemory: (sqInt )		" VM_PROXY_MINOR > 3 "		4		#ioLoadFunction:From: (charPtr charPtr)		#ioMicroMSecs (void)		" VM_PROXY_MINOR > 4 "		5		#positive64BitIntegerFor: (sqLong)		#positive64BitValueOf: (sqInt)		#signed64BitIntegerFor: (sqLong)		#signed64BitValueOf: (sqInt)		" VM_PROXY_MINOR > 5 "		6		#isArray: (sqInt )		#forceInterruptCheck (void)		" VM_PROXY_MINOR > 6 "		7		#fetchLong32:ofObject: (sqInt  sqInt)		#getThisSessionID (void)		#ioFilename:fromString:ofLength:resolveAliases: (charPtr charPtr sqInt sqInt)		#vmEndianness (void)		8		#internalIsImmutable: (sqInt)		#internalIsMutable: (sqInt)		#primitiveFailFor: (sqInt)		#classAlien (void)		#getStackPointer (void)		#sendInvokeCallback:Stack:Registers:Jmpbuf: (sqInt sqInt sqInt sqInt)		#reestablishContextPriorToCallback: (sqInt)		#classUnsafeAlien (void)		" New methods for proxy version 1.8 "					" callbackEnter: Re-enter the interpreter loop for a callback.			Arguments:			callbackID: Pointer to a location receiving the callback ID			used in callbackLeave			Returns: True if successful, false otherwise  "		callbackEnter: (sqIntPtr)					" callbackLeave: Leave the interpreter from a previous callback			Arguments:			callbackID: The ID of the callback received from callbackEnter()			Returns: True if succcessful, false otherwise. "		callbackLeave: (sqInt)					" addGCRoot: Add a variable location to the garbage collector.			The contents of the variable location will be updated accordingly.			Arguments:			varLoc: Pointer to the variable location			Returns: True if successful, false otherwise. "		addGCRoot: (sqIntPtr)					"  removeGCRoot: Remove a variable location from the garbage collector.			Arguments:			varLoc: Pointer to the variable location			Returns: True if successful, false otherwise. "		removeGCRoot: (sqIntPtr)	)! !!NBInterpreterProxy class methodsFor: 'class initialization' stamp: 'CamilloBruni 7/18/2012 14:41'!safeNoAlignFunctions	"list of functions which is safe to call without stack alignment"		^ #(		minorVersion		majorVersion		failed		primitiveMethod		getStackPointer		stackValue:		primitiveFail		nilObject		trueObject		falseObject		methodArgumentCount	)! !!NBInterpreterProxy class methodsFor: 'accessing functions' stamp: 'IgorStasenko 5/28/2012 05:18'!stackPointerAddress	"to prevent recursion, we prohibit using stack pointer address when bootstrapping"	NativeBoost forCurrentPlatform isBootstrapping ifTrue: [ ^ nil ].		^ self primStackPointerAddress ! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/29/2010 06:20'!addGCRoot: sqIntPtr		^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy functions Cog' stamp: 'CamilloBruni 7/19/2012 12:07'!addHighPriorityTickee: thickeeFnAddr period: periodms	self shouldBeImplemented ! !!NBInterpreterProxy methodsFor: 'proxy functions Cog' stamp: 'CamilloBruni 7/19/2012 12:07'!addSynchronousTickee: tickerFnAddr period: periodms round: roundms	self shouldBeImplemented ! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 15:26'!argumentCountOf: methodOop	"return a number of arguments for given method oop"	^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 15:27'!arrayValueOf: oop	"Return the address of first indexable field of resulting array object, or fail if the instance variable does not contain an indexable bytes or words object."	^ self simpleCall! !!NBInterpreterProxy methodsFor: 'helpers' stamp: 'Igor.Stasenko 5/19/2010 11:56'!baseHeaderSize	^ objectFormat baseHeaderSize! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 16:21'!become: array1 with: array2	^ self gatedCall! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'CamilloBruni 7/16/2012 09:50'!booleanValueOf: oop	"convert true and false (Smalltalk) to true or false(C).	Fails if oop is not a boolean object"		^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 15:28'!byteSizeOf: oop	"Return the size of the receiver in bytes"	^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 16:22'!byteSwapped: w	"Answer the given integer with its bytes in the reverse order."	^ self simpleCall! !!NBInterpreterProxy methodsFor: 'helpers' stamp: 'CamilloBruni 8/3/2012 18:23'!cFramePointer	(self canUseStackPointer not	or: [stackPtrAddress isNil]) ifTrue: [ 		self error: 'cannot use c stack pointer directly' ].	"answer a memory operand "		^ cFramePtrAddress asUImm32 ptr32! !!NBInterpreterProxy methodsFor: 'helpers' stamp: 'CamilloBruni 8/3/2012 18:23'!cStackPointer	(self canUseStackPointer not	or: [stackPtrAddress isNil]) ifTrue: [ 		self error: 'cannot use c stack pointer directly' ].	"answer a memory operand "		^ cStackPtrAddress asUImm32 ptr32! !!NBInterpreterProxy methodsFor: 'call' stamp: 'Igor.Stasenko 4/9/2010 07:57'!call: aFunction	^ self call: aFunction arguments: #()! !!NBInterpreterProxy methodsFor: 'call' stamp: 'CamilloBruni 7/23/2012 13:29'!call: aFunction arguments: args		| align |		asm decorateWith: 'InterpreterProxy >> ' , aFunction name during: [ 		align := gen stackAlignment.	aFunction requiresAlignment ifFalse: [ align := 1 ].		asm cdeclCall: [ :call |		args reverseDo: [:arg | call push: arg value ].		self callFn: aFunction.	] alignment: align ].		^ EAX! !!NBInterpreterProxy methodsFor: 'call' stamp: 'CamilloBruni 7/19/2012 12:04'!callFn: aFunctionOrName		| fn |	fn := aFunctionOrName.	aFunctionOrName isString ifTrue: [ fn := self functions at: aFunctionOrName ].	fn checkVersion. 	gen optProxyLabels ifTrue: [		asm label: (asm uniqueLabelName: fn name).		].	self canUseDirectProxyFnAddress ifTrue: [				asm 			mov: (fn address asUImm32 annotation: fn name )   to: EAX;			call: EAX		] ifFalse: [		asm			mov: (self class interpreterProxyAddress asUImm32 annotation: 'interpreterProxy address')   to: EAX;			mov: ((EAX ptr + (fn index * self pointerSize)) annotation: fn name) to: EAX;			call: EAX	]! !!NBInterpreterProxy methodsFor: 'call' stamp: 'CamilloBruni 7/23/2012 13:29'!callGated: aFunction arguments: args	"Call an interpreter proxy function through special gate function,	ensuring that if it triggers GC and native code could be relocated, 	then gate will return to correct native code address after relocation"	| align |	asm decorateWith: 'InterpreterProxy >> ' , aFunction name during: [ 	align := gen stackAlignment.	aFunction requiresAlignment ifFalse: [ align := 1 ].		asm cdeclCall: [ :call |		args reverseDo: [:arg | call push: arg value ].		self gatedCallFn: aFunction.	] alignment: align ].		^ EAX! !!NBInterpreterProxy methodsFor: 'VM-extras' stamp: 'IgorStasenko 3/24/2011 21:28'!callInterpreter	"call the 'callInterpreter' VM function "		| fn |		fn := NativeBoost loadFunction: #callInterpret from: ''.	self assert: (fn ~= 0).	asm mov: fn asUImm to: EAX.	asm call: EAX.! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/30/2010 20:38'!callbackEnter: callbackIDPtr	" sqInt * callbackIDPtr 	should point to a memory where jumpbuf will be stored "		^ self gatedCall! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/30/2010 20:11'!callbackLeave:  callbackId	"Leave from a previous callback"	^ self gatedCall! !!NBInterpreterProxy methodsFor: 'testing' stamp: 'Igor.Stasenko 9/29/2010 10:48'!canUseDirectProxyFnAddress	"Answer true if code generation routines can use interpreterProxy	function addresses directly (available after bootstrap) "		^ NativeBoost forCurrentPlatform isBootstrapping not		and: [ gen optDirectProxyFnAddress ]! !!NBInterpreterProxy methodsFor: 'testing' stamp: 'IgorStasenko 5/28/2012 05:25'!canUseStackPointer		gen optUseStackPointer ifFalse: [ ^ false ].	^ stackPtrAddress notNil	! !!NBInterpreterProxy methodsFor: 'proxy objects' stamp: 'Igor.Stasenko 4/11/2010 16:15'!characterTable	"return a character table special object (array of 256 characters)"		^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 16:03'!checkedIntegerValueOf: oop	"convert smallinteger into integer value. fails if oop is not a smallinteger"		^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy classes' stamp: 'Igor.Stasenko 4/30/2010 20:29'!classAlien	^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy classes' stamp: 'Igor.Stasenko 4/11/2010 16:15'!classArray		^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy classes' stamp: 'Igor.Stasenko 4/11/2010 16:15'!classBitmap		^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy classes' stamp: 'Igor.Stasenko 4/11/2010 16:15'!classByteArray		^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy classes' stamp: 'Igor.Stasenko 4/11/2010 16:15'!classCharacter		^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy classes' stamp: 'Igor.Stasenko 4/11/2010 16:40'!classExternalAddress	^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy classes' stamp: 'Igor.Stasenko 4/11/2010 16:40'!classExternalData	^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy classes' stamp: 'Igor.Stasenko 4/11/2010 16:40'!classExternalFunction	^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy classes' stamp: 'Igor.Stasenko 4/11/2010 16:40'!classExternalLibrary	^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy classes' stamp: 'Igor.Stasenko 4/11/2010 16:40'!classExternalStructure	^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy classes' stamp: 'Igor.Stasenko 4/11/2010 16:16'!classFloat		^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy classes' stamp: 'Igor.Stasenko 4/11/2010 16:38'!classLargeNegativeInteger	^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy classes' stamp: 'Igor.Stasenko 4/11/2010 16:16'!classLargePositiveInteger		^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy classes' stamp: 'Igor.Stasenko 4/11/2010 16:16'!classPoint		^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy classes' stamp: 'Igor.Stasenko 4/11/2010 16:16'!classSemaphore		^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy classes' stamp: 'Igor.Stasenko 4/11/2010 16:16'!classSmallInteger		^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy classes' stamp: 'Igor.Stasenko 4/11/2010 16:16'!classString		^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy classes' stamp: 'Igor.Stasenko 4/30/2010 20:29'!classUnsafeAlien	^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 16:17'!clone: oop	"Return a shallow copy of the given object. May cause GC"	"Assume: Oop is a real object, not a small integer."		^ self gatedCall! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 16:36'!compilerHookVector		^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 16:38'!copyBits	"This entry point needs to be implemented for the interpreter proxy.	Since BitBlt is now a plugin we need to look up BitBltPlugin:=copyBits	and call it. This entire mechanism should eventually go away and be	replaced with a dynamic lookup from BitBltPlugin itself but for backward	compatibility this stub is provided"		self shouldNotImplement ! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 16:38'!copyBitsFrom: x0 to: x1 at: y	"This entry point needs to be implemented for the interpreter proxy.	Since BitBlt is now a plugin we need to look up BitBltPlugin:=copyBitsFrom:to:at:	and call it. This entire mechanism should eventually go away and be	replaced with a dynamic lookup from BitBltPlugin itself but for backward	compatibility this stub is provided"	self shouldNotImplement ! !!NBInterpreterProxy methodsFor: 'helpers' stamp: 'Igor.Stasenko 5/3/2010 14:29'!createInstanceOf: aClass	^ self createInstanceOf: aClass size: 0! !!NBInterpreterProxy methodsFor: 'helpers' stamp: 'Igor.Stasenko 5/3/2010 14:28'!createInstanceOf: aClass size: indexableSize	^ self instantiateClass: [ gen emitFetchClass: aClass ] indexableSize: indexableSize! !!NBInterpreterProxy methodsFor: 'proxy functions Cog' stamp: 'CamilloBruni 7/19/2012 12:07'!disownVM: flags	self shouldBeImplemented ! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 16:15'!displayObject		^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 14:57'!failed	^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy objects' stamp: 'Igor.Stasenko 4/11/2010 16:15'!falseObject		^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 15:30'!fetchArray: index ofObject: oop	"Fetch the instance variable at the given index of the given object. Return the address of first indexable field of resulting array object, or fail if the instance variable does not contain an indexable bytes or words object."			^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 15:31'!fetchClassOf: oop	"Fetch the class of given oop"			^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/30/2010 20:10'!fetchFloat: fieldIndex ofObject: objectPointer	"Fetch the instance variable at the given index of the given object. Return the C double precision floating point value of that instance variable, or fail if it is not a Float."	"Note: May be called by translated primitive code."		^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/28/2010 13:32'!fetchInteger: index ofObject: oop	"Fetch the instance variable at the given index of the given object. Return the C integer value of that instance variable, or fail if it is not an integer."	^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 16:49'!fetchLong32: index ofObject: oop		^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'IgorStasenko 5/4/2012 16:41'!fetchPointer: index ofObject: oop	"Answer an instance variable value at given index for given oop.	No range checking performed.		Output: EAX"	| reg mem |	(index isBlock or: [ oop isBlock]) ifTrue: [ ^ self simpleCall ].	"shortcut if arguments are not blocks"	reg := oop.	reg isMem ifTrue: [ asm mov: oop to: EAX. reg := EAX ].	mem := reg ptr32.	index isInteger ifTrue: [		mem displacement: (self baseHeaderSize+ (index*self oopSize)) asImm ]	ifFalse: [ | idx  |		idx := index.		index isMem ifTrue: [ 			"index stored at pointer" 			asm mov: index to: ECX.			idx := ECX.			].		mem index: idx; 			scale: self oopSize;			displacement: self baseHeaderSize asImm ].		asm mov: mem to: EAX.	^ EAX! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 15:37'!firstFixedField: oop	"Answer an address of first fixed field for given oop"	^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 15:37'!firstIndexableField: oop	"Answer an address of first indexable field for given oop"	^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy functions Cog' stamp: 'CamilloBruni 7/19/2012 12:07'!floatArg: index	self shouldBeImplemented ! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/30/2010 19:02'!floatObjectOf: floatValue	"istantiate a floating point object and put a floating point value to it.	answer that object "		"we can't pass the floating point value in general purpose register,	see the NBFloat64>>coerceReturnValue: how to do that."		self shouldNotImplement.	" ^ self gatedCall "! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/30/2010 20:12'!floatValueOf: oop	"Return a double value of given floating point object.	fails if oop is not a Float class instance"		"note, result is floating point value"	self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 16:49'!forceInterruptCheck		^ self gatedCall! !!NBInterpreterProxy methodsFor: 'helpers' stamp: 'CamilloBruni 8/3/2012 17:19'!framePointer	(self canUseStackPointer not	or: [framePtrAddress isNil]) ifTrue: [ 		self error: 'cannot use frame pointer directly' ].	"answer a memory operand "		^ framePtrAddress asUImm32 ptr32! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 16:23'!fullDisplayUpdate	"Repaint the entire smalltalk screen, ignoring the affected rectangle. Used in some platform's code when the Smalltalk window is brought to the front or uncovered."	^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 16:23'!fullGC	"Do a mark/sweep garbage collection of the entire object memory. Free inaccessible objects but do not move them."	^ self gatedCall! !!NBInterpreterProxy methodsFor: 'accessing' stamp: 'Igor.Stasenko 9/29/2010 09:27'!functions	^ self class functions! !!NBInterpreterProxy methodsFor: 'call' stamp: 'Igor.Stasenko 9/29/2010 09:27'!gatedCall	| sender fn args |	sender := thisContext sender.	fn := self functions at: (sender method selector).	args := Array new: sender method numArgs.	1 to: args size do: [:i |  args at: i put: (sender tempAt: i ) ].		^ self callGated: fn arguments: args! !!NBInterpreterProxy methodsFor: 'call' stamp: 'IgorStasenko 8/3/2011 05:57'!gatedCallFn: aFunctionOrName		| fn gate |	gen optNonMovable ifTrue: [		"a non-movable code don't needs to use gate"		^ self callFn: aFunctionOrName		].		fn := aFunctionOrName.	aFunctionOrName isString  ifTrue: [ fn := self functions at: aFunctionOrName ].	gate := NativeBoost callgateFunctionAddress.	fn checkVersion.	gen optProxyLabels ifTrue: [		asm label: (asm uniqueLabelName: 'gated_', fn name).		].	"push an address of function to call"		self canUseDirectProxyFnAddress ifTrue: [ 		asm 			push: (fn address asUImm32 annotation: fn name).	] ifFalse: [		asm			mov: (self class interpreterProxyAddress asUImm32 annotation: 'interpreterProxy address') to: EAX;			mov: ((EAX ptr + (fn index * self pointerSize)) annotation: fn name) to: EAX;			push: EAX	].	asm 		mov: (gate asUImm32 annotation: 'Call gate')  to: EAX;		call: EAX.	usedGate := true.! !!NBInterpreterProxy methodsFor: 'accessing' stamp: 'IgorStasenko 12/21/2011 14:20'!generator: aGenerator	gen := aGenerator.	asm := aGenerator asm.	objectFormat := NBObjectFormat current asm: asm.	gen parseOptions: self class defaultOptions! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/30/2010 20:12'!getStackPointer	"return a ST stack pointer"	^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 16:49'!getThisSessionID		^ self simpleCall! !!NBInterpreterProxy methodsFor: 'helpers' stamp: 'IgorStasenko 8/7/2011 04:24'!ifFailedEmit: aBlock	| lbl |	lbl := asm uniqueLabelName: 'notFailed'.		self failed.	asm or: EAX with: EAX.	asm jz: lbl.			aBlock value.		asm label: lbl! !!NBInterpreterProxy methodsFor: 'helpers' stamp: 'Igor.Stasenko 4/11/2010 23:04'!ifFailedJumpTo: label	self failed.	asm or: EAX with: EAX.	asm jnz: label.		! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 16:39'!includesBehavior: aClass ThatOf: aSuperclass	"Return the equivalent of 		aClass includesBehavior: aSuperclass.	Note: written for efficiency and better inlining (only 1 temp)"	^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 16:32'!incrementalGC	"Do a mark/sweep garbage collection of just the young object 	area of object memory (i.e., objects above youngStart), using 	the root table to identify objects containing pointers to 	young objects from the old object area."		^ self gatedCall! !!NBInterpreterProxy methodsFor: 'helpers' stamp: 'Igor.Stasenko 5/5/2010 20:11'!indexOf: ivarName in: aClass	^ aClass instVarIndexFor: ivarName ifAbsent: [nil]! !!NBInterpreterProxy methodsFor: 'initialize-release' stamp: 'CamilloBruni 8/3/2012 18:24'!initialize		"actually, this should be determined by querying NativeBoost platformId"	objectFormat := NBObjectFormat32 new.	"set it to nil, if there is recursion"	stackPtrAddress := [self class stackPointerAddress] on: NBCodeGenRecursion do: [ nil ].	framePtrAddress := [self class framePointerAddress] on: NBCodeGenRecursion do: [ nil ].	cStackPtrAddress := [self class cStackPointerAddress] on: NBCodeGenRecursion do: [ nil ].	cFramePtrAddress := [self class cFramePointerAddress] on: NBCodeGenRecursion do: [ nil ].! !!NBInterpreterProxy methodsFor: 'proxy functions Cog' stamp: 'CamilloBruni 7/19/2012 12:07'!instanceSizeOf: aClass	self shouldBeImplemented ! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 16:19'!instantiateClass: classOop indexableSize: sz	^ self gatedCall! !!NBInterpreterProxy methodsFor: 'proxy functions Cog' stamp: 'CamilloBruni 7/19/2012 12:07'!integerArg: index	self shouldBeImplemented ! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 5/5/2010 18:00'!integerObjectOf:  value	"Convert C integer value to smallinteger object.	no range checking performed. "	"lets not do call, but just do a shortcut (value << 1) + 1 "	| tmp |	tmp := value.	value isBlock ifTrue: [ tmp := value value ].	tmp = EAX ifFalse: [ asm mov: tmp to: EAX ].	asm shl: EAX with: 1;		inc: EAX	.		^ EAX		" ^ self simpleCall "! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 16:09'!integerValueOf: oop	"Convert smallinteger oop to C integer value.	No type checking performed.	"		^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/30/2010 20:28'!internalIsImmutable: oop	^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/30/2010 20:11'!internalIsMutable: oop	"return a ST stack pointer"	^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 16:51'!ioFilename: aCharBuffer fromString: aFilenameString ofLength: filenameLength resolveAliases: bool"the vm has to convert aFilenameString via any canonicalization and char-mapping and put the result in aCharBuffer.Note the resolveAliases flag - this is an awful artefact of OSX and Apples demented alias handling. When opening a file, the flag must be  true, when closing or renaming it must be false. Sigh."		^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 16:44'!ioLoadFunction: fnName From: moduleName	"Load and return the requested function from a module"		^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/30/2010 20:14'!ioLoadModule: m OfLength: l	"implemented , see NBUtils class>>ioLoadModule: "	self shouldNotImplement ! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/30/2010 20:13'!ioLoadSymbol: sym OfLength: len FromModule: handle	"implemented , see NBUtils class>>ioLoadSymbol:fromModule: "	self shouldNotImplement ! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 16:44'!ioMicroMSecs		^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy testing' stamp: 'Igor.Stasenko 4/11/2010 15:58'!is: oop KindOf: stringPtr "char *"	^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy testing' stamp: 'Igor.Stasenko 4/11/2010 15:58'!is: oop MemberOf: stringPtr "char *"	^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy testing' stamp: 'Igor.Stasenko 4/11/2010 16:48'!isArray: oop		^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy testing' stamp: 'Igor.Stasenko 4/11/2010 09:33'!isBytes: oop	 	^ self simpleCall! !!NBInterpreterProxy methodsFor: 'helpers' stamp: 'Igor.Stasenko 5/20/2010 06:02'!isBytes: oop ifNotJumpTo: label	^ objectFormat isBytes: oop ifNotJumpTo: label! !!NBInterpreterProxy methodsFor: 'helpers' stamp: 'Igor.Stasenko 5/20/2010 06:02'!isBytesOrWords: oop ifNotJumpTo: label	^ objectFormat isBytesOrWords: oop ifNotJumpTo: label! !!NBInterpreterProxy methodsFor: 'proxy testing' stamp: 'Igor.Stasenko 4/11/2010 15:58'!isFloatObject: oop	 	^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy testing' stamp: 'Igor.Stasenko 4/11/2010 16:42'!isInMemory: oop	"Return true if the given address is in ST object memory"		^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy testing' stamp: 'Igor.Stasenko 4/11/2010 15:58'!isIndexable: oop	 	^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy testing' stamp: 'Igor.Stasenko 4/11/2010 15:59'!isIntegerObject: oop	 " return true (1) only if oop is smallInteger (not big integer or any other object !!!!) "	^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy testing' stamp: 'Igor.Stasenko 4/11/2010 16:00'!isIntegerValue: value	 " return true (1) only if given integer value fits in ST smallinteger immediate oop"	^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy functions Cog' stamp: 'CamilloBruni 7/19/2012 12:07'!isKindOf: oop Class: aClass	self shouldBeImplemented ! !!NBInterpreterProxy methodsFor: 'proxy testing' stamp: 'Igor.Stasenko 4/11/2010 16:01'!isPointers: value	"Answer true if the argument has only fields that can hold oops. See comment in formatOf:"	^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy testing' stamp: 'Igor.Stasenko 4/11/2010 16:01'!isWeak: oop	"Answer true if the argument has only weak fields that can hold oops. See comment in formatOf:"		^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy testing' stamp: 'Igor.Stasenko 4/11/2010 16:01'!isWords: oop	"Answer true if the argument contains only indexable words (no oops). See comment in formatOf:"		^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy testing' stamp: 'Igor.Stasenko 4/11/2010 16:02'!isWordsOrBytes: oop	"Answer true if the contains only indexable words or bytes (no oops). See comment in formatOf:"	"Note: Excludes CompiledMethods."		^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy functions Cog' stamp: 'CamilloBruni 7/19/2012 12:07'!isYoung: anOop	self shouldBeImplemented ! !!NBInterpreterProxy methodsFor: 'helpers' stamp: 'Igor.Stasenko 5/19/2010 11:54'!ivar: ivarName in: aClass	"answer an offset of ivar relative to oop"	| index |	index := aClass instVarIndexFor: ivarName ifAbsent: [nil].	^ objectFormat instVarOffsetAt: index.! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 15:39'!literal: index ofMethod: methodOop	"Answer a method's literal at given zero-based index"	^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 15:39'!literalCountOf: methodOop	"Answer a total number of literals for given method"	^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 16:37'!loadBitBltFrom: bbOop	"This entry point needs to be implemented for the interpreter proxy.	Since BitBlt is now a plugin we need to look up BitBltPlugin:=loadBitBltFrom	and call it. This entire mechanism should eventually go away and be	replaced with a dynamic lookup from BitBltPlugin itself but for backward	compatibility this stub is provided"	self shouldNotImplement ! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 15:19'!majorVersion	^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 16:19'!makePointwithxValue: xval yValue: yval"make a Point xValue@yValue.We know both will be integers so no value nor root checking is needed"	^ self gatedCall! !!NBInterpreterProxy methodsFor: 'proxy functions Cog' stamp: 'CamilloBruni 7/19/2012 12:07'!methodArg: index	self shouldBeImplemented ! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'HenrikSperreJohansen 8/25/2011 00:58'!methodArgumentCount	"Answer a total number of arguments of primitive method"	^ gen method numArgs! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 15:41'!methodPrimitiveIndex	"Answer a primitive index of currently activated method"	^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy functions Cog' stamp: 'CamilloBruni 7/19/2012 12:07'!methodReturnValue: oop	self shouldBeImplemented ! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 15:19'!minorVersion	^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy objects' stamp: 'Igor.Stasenko 4/11/2010 16:15'!nilObject		^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy functions Cog' stamp: 'CamilloBruni 7/19/2012 12:07'!objectArg: index	self shouldBeImplemented ! !!NBInterpreterProxy methodsFor: 'accessing' stamp: 'IgorStasenko 8/3/2011 19:50'!objectFormat 	^ objectFormat ! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/30/2010 20:08'!obsoleteDontUseThisFetchWord: index ofObject: zap	self shouldNotImplement! !!NBInterpreterProxy methodsFor: 'helpers' stamp: 'Igor.Stasenko 5/20/2010 07:25'!oop: anOop ifSmallInt: aBlock ifNotSmallInt: notSmallIntBlock	" emit code to check if argument, oop is smallInteger 	squeak smallints having a least significant bit set"	| lbl1 lbl2 |		lbl1 := asm uniqueLabelName: 'notSmallInt'.	asm 		mov: anOop to: EAX;		test: AL with: 1;		je: lbl1.	aBlock value.	notSmallIntBlock ifNil: [ asm label: lbl1. ^ self ].		lbl2 := asm uniqueLabelName: 'smallIntTestEnd'.	asm jmp: lbl2.		asm label: lbl1.	notSmallIntBlock value.	asm label: lbl2.! !!NBInterpreterProxy methodsFor: 'helpers' stamp: 'Igor.Stasenko 5/19/2010 11:54'!oopSize	^ objectFormat oopSize! !!NBInterpreterProxy methodsFor: 'proxy functions Cog' stamp: 'CamilloBruni 7/19/2012 12:07'!ownVM: threadIdAndFlags	self shouldBeImplemented ! !!NBInterpreterProxy methodsFor: 'helpers' stamp: 'Igor.Stasenko 5/19/2010 11:54'!pointerSize	^ self oopSize! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 15:21'!pop: nItems	"not recommended for use in native code.	use #stackValue: "	self shouldNotImplement  ! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 15:22'!pop: nItems thenPush: anObject	"not recommended for use in native code.	use #stackValue: , and return a result oop from native function instead"	self shouldNotImplement  ! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 16:20'!popRemappableOop	"Pop and return the possibly remapped object from the remap buffer."	^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 16:12'!positive32BitIntegerFor: integerValue	"Convert a (possibly positive) integer value	into corresponding smallint object or positive big int instance	"		^ self gatedCall! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 16:13'!positive32BitValueOf: oop	"Convert the given object into an integer value.	The object may be either a positive ST integer or a four-byte LargePositiveInteger."		^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'IgorStasenko 9/3/2012 00:56'!positive64BitIntegerFor			"Assume integer value is in EAX:EDX register pair.	Make a call as if we push 2 arguments "	| fn |		fn := self functions at: #positive64BitIntegerFor: .		^ self call: fn arguments: { asm EAX. asm EDX }! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'IgorStasenko 9/3/2012 02:31'!positive64BitIntegerFor: op"use positive64BitIntegerFor instead"	self shouldNotImplement.! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'IgorStasenko 9/3/2012 00:23'!positive64BitValueOf: oop 		^ self simpleCall! !!NBInterpreterProxy methodsFor: 'helpers' stamp: 'IgorStasenko 5/28/2012 03:17'!prepareForCallout	"reserve a stack pointer temp above any others		- not used anymore, since Cog supports stackPointerAddress() function	"! !!NBInterpreterProxy methodsFor: 'proxy functions Cog' stamp: 'CamilloBruni 7/19/2012 12:07'!primitiveErrorTable	self shouldBeImplemented ! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 16:32'!primitiveFail	"Fail a primitive."		^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy functions Cog' stamp: 'CamilloBruni 7/19/2012 12:07'!primitiveFailFor: errorCode	^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy functions Cog' stamp: 'CamilloBruni 7/19/2012 12:07'!primitiveFailureCode	self shouldBeImplemented ! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 15:51'!primitiveIndexOf: methodOop	"return a primitive index for given method oop"	^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 16:40'!primitiveMethod	^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 15:22'!push: anObject	"not recommended for use in native code"	self shouldNotImplement  ! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 15:22'!pushBool: trueOrFalse	"not recommended for use in native code"	self shouldNotImplement  ! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 15:22'!pushFloat: f	"not recommended for use in native code"	self shouldNotImplement  ! !!NBInterpreterProxy methodsFor: 'helpers' stamp: 'Igor.Stasenko 9/29/2010 11:03'!pushFloatOopAsFloat32: oop	" input - oop , and operand, pointing to a Oop	output: 32-bit floating-point value pushed on stack	clobbers: EAX, ECX"	Smalltalk compactClassesArray indexOf: Float ifAbsent: [		"if Float is not compact class, do the hard way "		self floatValueOf: oop.		asm sub: (asm ESP) with: 4.		asm fstp: asm ESP ptr32.		^ self.		].	"since Float is a compact, to check that object is instance of float, 	we just need to make sure that its header matching the Float's header format" 	"Floating point value is stored in PowerPC word order"		self verifyCompactClassOf: oop is: Float.		objectFormat floatsMatchingPlatform ifFalse: [		asm 			sub: ESP with: 8;			mov: EAX ptr + self baseHeaderSize to: ECX;			mov: ECX to: ESP ptr+4;			mov: EAX ptr + (4+self baseHeaderSize) to: ECX;			mov: ECX to: ESP ptr;			fld: ESP ptr64;			add: ESP with: 4 ] 		ifTrue: [			asm 				fld: EAX ptr64 + self baseHeaderSize;				sub: ESP with: 4 ].	asm fstp: asm ESP ptr32! !!NBInterpreterProxy methodsFor: 'helpers' stamp: 'Igor.Stasenko 9/29/2010 11:04'!pushFloatOopAsFloat64: oop	" input - oop , and operand, pointing to a Oop	output: 32-bit floating-point value pushed on stack	clobbers: EAX, ECX"	Smalltalk compactClassesArray indexOf: Float ifAbsent: [		"if Float is not compact class, do the hard way "		self floatValueOf: oop.		asm sub: (asm ESP) with: 8.		asm fstp: asm ESP ptr64.		^ self.		].	self verifyCompactClassOf: oop is: Float.	objectFormat floatsMatchingPlatform ifFalse: [		asm 			push: EAX ptr + (self baseHeaderSize);			push: EAX ptr + (self baseHeaderSize+4) ]	ifTrue: [		asm 			push: EAX ptr + (self baseHeaderSize+4);			push: EAX ptr + (self baseHeaderSize) ]! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 15:23'!pushInteger: int	"not recommended for use in native code"	self shouldNotImplement  ! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 16:20'!pushRemappableOop: oop	"Record the given object in a the remap buffer. Objects in this buffer are remapped when a compaction occurs. This facility is used by the interpreter to ensure that objects in temporary variables are properly remapped."	^ self simpleCall! !!NBInterpreterProxy methodsFor: 'helpers' stamp: 'IgorStasenko 5/28/2012 01:31'!receiver	"Input: none.	Output: EAX - a method's receiver"		self canUseStackPointer ifFalse: [ ^self stackValue: self methodArgumentCount ].	"EAX - count "	^self receiverInto: EAX.	"EAX - receiver"	! !!NBInterpreterProxy methodsFor: 'helpers' stamp: 'HenrikSperreJohansen 8/25/2011 13:22'!receiverInto: aReg	"Input: aReg.	Output: aReg - register holding method's receiver"		^self stackValue: self methodArgumentCount storeIn: aReg.	! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/30/2010 20:35'!reestablishContextPriorToCallback: callbackContext	"callbackContext is an activation of invokeCallback:stack:registers:jmpbuf:.  Its sender	 is the interpreter's state prior to the callback.  Reestablish that state."		"WARNING!!!! do not use any proxy functions, which may 	access the ST stack after calling this function, because its changing the active context	and method, stack etc.		Use at your own risk"	^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/30/2010 20:29'!removeGCRoot: addr	^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/30/2010 20:40'!sendInvokeCallback: thunkPtr Stack: stackPtr Registers: regsPtr Jmpbuf: jmpBufPtr	"Send the 4 argument callback message invokeCallback:stack:registers:jmpbuf:	 to Alien class with the supplied args.  The arguments are raw C addresses	 and are converted to integer objects on the way."		"useless without Alien... "	^ self gatedCall	! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 16:36'!setCompilerInitialized: initFlag		^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy functions Cog' stamp: 'CamilloBruni 7/19/2012 12:07'!setInterruptCheckChain: aFunctionAddr	self shouldBeImplemented ! !!NBInterpreterProxy methodsFor: 'helpers' stamp: 'IgorStasenko 8/10/2011 17:52'!shiftForPointer	"answer the shift bits for pointer size"	^ self pointerSize highBit - 1! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 16:34'!showDisplayBits: aForm Left: l Top: t Right: r Bottom: b	"Repaint the portion of the Smalltalk screen bounded by the affected rectangle. Used to synchronize the screen after a Bitblt to the Smalltalk Display object."		"any reason to use it here?"	self shouldBeImplemented! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/30/2010 20:15'!signalSemaphoreWithIndex: index	"Record the given semaphore index in the double buffer semaphores array to be signaled at the next convenient moment. Force a real interrupt check as soon as possible."			^self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 09:38'!signed32BitIntegerFor: value 	^ self gatedCall! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 09:34'!signed32BitValueOf: object	^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'IgorStasenko 9/3/2012 00:54'!signed64BitIntegerFor			"Assume integer value is in EAX:EDX register pair.	Make a call as if we push 2 arguments "	| fn |		fn := self functions at: #signed64BitIntegerFor: .		^ self call: fn arguments: { asm EAX. asm EDX }! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'IgorStasenko 9/3/2012 02:32'!signed64BitIntegerFor: op"use #signed64BitIntegerFor instead"	self shouldNotImplement.! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'IgorStasenko 9/3/2012 00:23'!signed64BitValueOf: oop 		^ self simpleCall! !!NBInterpreterProxy methodsFor: 'call' stamp: 'Igor.Stasenko 9/29/2010 09:27'!simpleCall	| sender fn args |	sender := thisContext sender.	fn := self functions at: (sender method selector).	args := Array new: sender method numArgs.	1 to: args size do: [:i |  args at: i put: (sender tempAt: i ) ].		^ self call: fn arguments: args! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 15:52'!sizeOfSTArrayFromCPrimitive: ptr	"Return the number of indexable fields of the given object. This method is to be called from an automatically generated C primitive. The argument is assumed to be a pointer to the first indexable field of a words or bytes object; the object header starts 4 bytes before that."	^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 15:52'!slotSizeOf: oop	"Returns the number of slots in the receiver.	If the receiver is a byte object, return the number of bytes.	Otherwise return the number of words."	^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy objects' stamp: 'CamilloBruni 7/23/2012 18:03'!specialObjectsArray	" load the special objects array into EAX"		"since we cannot directly access the specialObjectsArray we store it as an extra Root"	NativeBoost extraRootsRegistry		at: #specialObjectsArray ifAbsentPut: [ Smalltalk specialObjectsArray ];		"specialObjectsArray -> EAX"		emitOopAt: #specialObjectsArray generator: gen.! !!NBInterpreterProxy methodsFor: 'proxy objects' stamp: 'CamilloBruni 7/23/2012 17:10'!specialObjectsArrayAt: index	"generate the code to load the value at the given index into EAX"	self specialObjectsArray.	self stObject: asm EAX at: index.! !!NBInterpreterProxy methodsFor: 'proxy objects' stamp: 'CamilloBruni 7/23/2012 18:03'!specialSelectorAt: index	"generate the code to load the symbol at the given index from specialObjectsArray at: 23"	"since we cannot directly access the specialObjectsArray we store it as an extra Root"	NativeBoost extraRootsRegistry		at: #specialSelectorsArray ifAbsentPut: [ Smalltalk specialSelectors ];		"specialSelectorsArray -> EAX"		emitOopAt: #specialSelectorsArray generator: gen.	"EAX at: index"	self stObject: asm EAX at: index.! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 15:53'!stObject: obj at: index	"Return what ST would return for <obj> at: index."	^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 15:53'!stObject: obj at: index put: value	"Do what ST would return for <obj> at: index put: value."	^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 15:54'!stSizeOf: obj	"Return the number of indexable fields in the given object. (i.e., what Smalltalk would return for <obj> size)."	"Note: Assume oop is not a SmallInteger!!"	^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy-stack access' stamp: 'Igor.Stasenko 4/30/2010 20:16'!stackFloatValue: offset	"answer a float value of oop on stack at given offset value.		Note, return value is loaded in FP register, not GP register"		self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy-stack access' stamp: 'Igor.Stasenko 4/30/2010 20:16'!stackIntegerValue: offset	"answer a integer value of oop on stack at given offset value"	^self simpleCall ! !!NBInterpreterProxy methodsFor: 'proxy-stack access' stamp: 'Igor.Stasenko 4/30/2010 20:16'!stackObjectValue: offset	"Ensures that the given object is a real object, not a SmallInteger."	^self simpleCall ! !!NBInterpreterProxy methodsFor: 'helpers' stamp: 'IgorStasenko 5/28/2012 06:32'!stackPointer	(self canUseStackPointer not	or: [stackPtrAddress isNil]) ifTrue: [ 		self error: 'cannot use stack pointer directly' ].	"answer a memory operand "		^ stackPtrAddress asUImm32 ptr32! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'CamilloBruni 7/23/2012 13:29'!stackValue: index			(index isInteger and: [self canUseStackPointer]) ifTrue: [				asm decorateWith: 'InterpreterProxy>>stackValue:' , index asString during:  [ 		asm mov: self stackPointer to: EAX.				objectFormat stackGrowsDown 			ifTrue: [				asm mov: EAX ptr + (self pointerSize*index) to: EAX]			ifFalse: [				asm mov: EAX ptr - (self pointerSize*index) to: EAX].		^ EAX	]].	^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'CamilloBruni 7/23/2012 13:29'!stackValue: index storeIn: aReg			(index isInteger and: [self canUseStackPointer]) ifTrue: [				asm decorateWith: 'InterpreterProxy>>stackValue:' , index asString during:  [ 		asm mov: self stackPointer to: aReg.				objectFormat stackGrowsDown 			ifTrue: [				asm mov: aReg ptr + (self oopSize*index) to: aReg]			ifFalse: [				asm mov: aReg ptr - (self oopSize*index) to: aReg].		^ aReg	]].	self error: 'Not available. (And should not reach here)'! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 15:55'!storeInteger: index ofObject: obj withValue: integerValue	"Note: Integer value must fit in SmallInt , otherwise function will fail primitive"	^ self simpleCall! !!NBInterpreterProxy methodsFor: 'accessing oop fields' stamp: 'Igor.Stasenko 5/19/2010 12:22'!storePointer: op intoVarbytes: destOop at: offset	" input:	  op - register, holding a pointer value	  destOop - register operand with variable bytes oop	  offset - integer value"	^ self 		storeValue: op 		ofSize: self pointerSize 		intoVarbytes: destOop 		at: offset! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 15:56'!storePointer: index ofObject: obj withValue: oop	^ self simpleCall! !!NBInterpreterProxy methodsFor: 'accessing oop fields' stamp: 'Igor.Stasenko 5/19/2010 13:22'!storeValue: op ofSize: numBytes intoVarbytes: destOop at: offset	" input:	  op - a register operand	  numBytes - integer	  destOop - register operand with variable bytes oop	  offset - integer value"	| mem |	mem := destOop ptr + (objectFormat varBytesFirstField + offset).	self assert: (op isGeneralPurpose & destOop isGeneralPurpose).	asm mov: (asm reg: op index size: numBytes) to: (mem size: numBytes).! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 09:39'!success: flag	^ self simpleCall! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 16:36'!superclassOf:  classPointer		^ self simpleCall! !!NBInterpreterProxy methodsFor: 'VM-extras' stamp: 'Igor.Stasenko 5/14/2010 03:48'!swapActiveContext: newContext	"call the 'swapActiveContext' VM function "		| fn |		fn := NativeBoost loadFunction: 'swapActiveContext' from: ''.	self assert: (fn ~= 0).	asm push: newContext.	asm mov: fn asUImm to: EAX.	asm call: EAX;	add: ESP with: 4.	! !!NBInterpreterProxy methodsFor: 'VM-extras' stamp: 'IgorStasenko 5/7/2012 07:30'!swapActiveContext: newContext restoreMethod: aMethodOop	"call the 'swapActiveContextrestoreMethod' VM function "		| fn |		fn := NativeBoost loadFunction: 'swapActiveContextrestoreMethod' from: ''.	self assert: (fn ~= 0).			asm cdeclCall: [ :call |		call push: aMethodOop value.		call push: newContext value.				asm 			mov: fn asUImm to: EAX;			call: EAX	] alignment: gen stackAlignment ! !!NBInterpreterProxy methodsFor: 'proxy functions Cog' stamp: 'CamilloBruni 7/19/2012 12:07'!tenuringIncrementalGC	self shouldBeImplemented ! !!NBInterpreterProxy methodsFor: 'proxy functions Cog' stamp: 'CamilloBruni 7/19/2012 12:07'!topRemappableOop	self shouldBeImplemented ! !!NBInterpreterProxy methodsFor: 'proxy objects' stamp: 'Igor.Stasenko 4/11/2010 16:15'!trueObject		^ self simpleCall! !!NBInterpreterProxy methodsFor: 'testing' stamp: 'IgorStasenko 8/3/2011 05:56'!usedGate 	^ usedGate == true! !!NBInterpreterProxy methodsFor: 'proxy functions Cog' stamp: 'CamilloBruni 7/19/2012 12:07'!utcMicroseconds	self shouldBeImplemented ! !!NBInterpreterProxy methodsFor: 'helpers' stamp: 'IgorStasenko 5/26/2012 15:16'!varBytesFirstFieldOf: oop 	"Answer the address of first byte in oop in EAX.	 oop must be of a variable byte format"		asm 		mov: oop to: asm EAX;		add: asm EAX with: objectFormat varBytesFirstField ! !!NBInterpreterProxy methodsFor: 'helpers' stamp: 'CamilloBruni 7/23/2012 13:29'!verifyClassOf: oop is: aClass	asm decorateWith: 'verifyClassOf:is:', aClass name during: [  	"do a shortcut for compact classes"	Smalltalk compactClassesArray indexOf: aClass ifAbsent: [ | class |		class := gen reserveTemp.		gen proxy fetchClassOf: oop.		asm mov:  asm EAX to: class.		gen emitFetchClass: aClass.		asm cmp: asm EAX with: class;			jne: gen failedLabel.		gen releaseTemps: 1.		^ self	].	^ self verifyCompactClassOf: oop is: aClass	]! !!NBInterpreterProxy methodsFor: 'helpers' stamp: 'IgorStasenko 8/30/2012 18:45'!verifyCompactClassOf: oop is: aClass	" fail prim, if oop class not matching the aClas	output: oop in EAX "	| index cont fail |	index := Smalltalk compactClassesArray indexOf: aClass.	oop = EAX ifFalse: [ asm mov: oop to: EAX ].		cont := asm uniqueLabelName: 'cont'.	fail := asm uniqueLabelName: 'fail'.	asm 	"smallinteger test"			test: EAX with: 1;		jnz: fail;		mov: EAX ptr to: ECX;		and: ECX with: objectFormat compactClassMask;		cmp: ECX with: (index bitShift: objectFormat compactClassIndexShift);		je: cont.		asm label: fail.		gen failWithMessage: 'An instance of ', aClass name , ' expected'.		asm label: cont.		! !!NBInterpreterProxy methodsFor: 'proxy functions' stamp: 'Igor.Stasenko 4/11/2010 16:51'!vmEndianness	^ self simpleCall! !!NBFFICallout class methodsFor: 'generator entry points' stamp: 'IgorStasenko 11/22/2012 13:36'!call: anonFunctionSignature convention: callConvention functionAddress: aFunctionAddressBlock	"Note, this is a special method, which should be sent only from 	methods, which intend to use FFI callout code.	All such methods should use a 'primitiveNativeCall' primitive.	First argument should be an anonymous function signature, describing the return type and arguments. 	Second argument is calling convention for the function, should be either #cdecl or #stdcall (more can be added later)	Third argument is a block, which takes 0 or 1 argument (generator instance) and should return an address of function to call,	either an unsigned integer value, or NBExternalAddress instance.		Example of use: 			myMethod 			<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode >			^ NBFFICallout call: #( int () ) convention: #cdecl functionAddress: [:generator | NativeBoost loadSymbol: 'fork' fromModule: NativeBoost CLibrary]				which is equivalent to: 			myMethod 			<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode >			^ self nbCall: #( int fork() )	This API allows users to define own custom semantics, how/where to obtain a pointer to function which needs to be called.	Please note that function address block is evaluated only once during code generation, and received function address 	will be imprinted into generated code, so this API does not fits for cases, when function address needs to be always	resolved dynamically during each activation of the method.	For that , there is #cdecl:emitCall: / #stdCall:emitCall: API which allow user to provide own assembler code for calling the function. 	" 	| sender |	sender := thisContext sender.	^ self 		handleFailureIn: sender		nativeCode: [ :gen |			gen				sender: sender;				callType: callConvention;				anonSpec: anonFunctionSignature;				generateCallToAddress: aFunctionAddressBlock			]! !!NBFFICallout class methodsFor: 'generator entry points' stamp: 'IgorStasenko 11/22/2012 13:39'!call: anonFunctionSignature convention: callConvention functionAddress: aFunctionAddressBlock options: aCodeGenerationOptions	"	For documentation, please look at #call:convention:functionAddress:	This method differs only by having additional argument - a code generation options	" 	| sender |	sender := thisContext sender.	^ self 		handleFailureIn: sender		nativeCode: [ :gen |			gen				sender: sender;				callType: callConvention;				parseOptions: aCodeGenerationOptions;				anonSpec: anonFunctionSignature;				generateCallToAddress: aFunctionAddressBlock			]! !!NBFFICallout class methodsFor: 'generator entry points' stamp: 'CamilloBruni 7/19/2012 17:28'!cdecl: functionSpec	" A shortcut for writing	    cdecl: AFunctionSpecification module: NativeBoost CLibrary"	| sender |	sender := thisContext sender.	^ self 		handleFailureIn: sender		nativeCode: [ :gen |			gen				sender: sender;				cdecl;				generateCall: functionSpec module: NativeBoost CLibrary ]! !!NBFFICallout class methodsFor: 'generator entry points' stamp: 'CamilloBruni 7/17/2012 13:59'!cdecl: functionSpec emitCall: aCallEmittingBlock	"Note, this is a special method, which should be sent only from 	methods, which intend to use FFI callout code.	All such methods should use a 'primitiveNativeCall' primitive.	First argument is an array of types, where first element denotes a function return type,	and rest denoting argument types.	A CallEmittingBlock serves to emit an actual function call code. 	" 	| sender |	sender := thisContext sender.	^ self 		handleFailureIn: sender		nativeCode: [ :gen |			gen				useEmitCall;				sender: sender;				cdecl;				anonSpec: functionSpec;				generate: aCallEmittingBlock  ]! !!NBFFICallout class methodsFor: 'generator entry points' stamp: 'CamilloBruni 10/4/2012 15:34'!cdecl: functionSpec emitCall: aCallEmittingBlock options: anOptions	"Note, this is a special method, which should be sent only from 	methods, which intend to use FFI callout code.	All such methods should use a 'primitiveNativeCall' primitive.	First argument is an array of types, where first element denotes a function return type,	and rest denoting argument types.	A CallEmittingBlock serves to emit an actual function call code. 	" 	| sender |	sender := thisContext sender.	^ self 		handleFailureIn: sender		nativeCode: [ :gen |			gen				useEmitCall;				sender: sender;				parseOptions: anOptions;				cdecl;				anonSpec: functionSpec;				generate: aCallEmittingBlock  ]! !!NBFFICallout class methodsFor: 'generator entry points' stamp: 'Igor.Stasenko 5/3/2010 21:48'!cdecl: functionSpec module: aModuleName"Note, this is a special method, which should be sent only from methods, which intend to use FFI callout code.All such methods should use a 'primitiveNativeCall' primitive.First argument is an array of types, where first element denotes a function return type,and rest denoting argument types.A CallEmittingBlock serves to emit an actual function call code. " 	| sender |	sender := thisContext sender.	^ self 		handleFailureIn: sender		nativeCode: [ :gen |			gen				sender: sender;				cdecl;				generateCall: functionSpec module: aModuleName ]! !!NBFFICallout class methodsFor: 'generator entry points' stamp: 'Igor.Stasenko 5/3/2010 21:50'!cdecl: functionSpec module: aModuleName options: anOptions"Note, this is a special method, which should be sent only from methods, which intend to use FFI callout code.All such methods should use a 'primitiveNativeCall' primitive.First argument is an array of types, where first element denotes a function return type,and rest denoting argument types.A CallEmittingBlock serves to emit an actual function call code. " 	| sender |	sender := thisContext sender.	^ self 		handleFailureIn: sender		nativeCode: [ :gen |			gen				sender: sender;				parseOptions: anOptions;				cdecl;				generateCall: functionSpec module: aModuleName ]! !!NBFFICallout class methodsFor: 'options' stamp: 'cipt 10/25/2012 19:14'!defaultOptions	"see #allOptions on my instance side"	^ #(		"#optCoerceNilToNull"	"passing nil as a pointer-type argument, converts it to C NULL "			#optAllowExternalAddressPtr	"for a pointer-type argument, accept an instance of NBExternalAddress "		"for a pointer-type argument, allow passing a pointer to byte arrays"	#optAllowByteArraysPtr 		"if function returns a pointer, return nil if pointer is null"	#optReturnNullAsNil  			"If function returns a pointer, fail primitive if pointer is null.	Takes preference over #returnNullAsNil 	Default: disabled. "	"#optFailOnReturnNull"		"if function returns a pointer, convert it to unsigned integer object.	Default: disabled	#optReturnPtrAsInt "		"If function returns a pointer, convert it to an instance of NBExternalAddress.	Takes preference over #returnPtrAsInt.	Default: enabled.  "	#optReturnPtrAsExternalAddress			"directly convert between C integers and Smallintegers instead of using proxy 	functions. perform no range checking"	"#optQuickSmi --  not yet done	" 	"directly convert between C integers and Smallintegers instead of using proxy 	functions. include range checking"	"#optQuickSmiSafe --  not yet done	" 					"string conversion"		"for char* parameter type, when passed an instance of ByteString, 	copy a ByteString's contents on a stack, append null character and pass a pointer to it"	"#optAcceptStringForCharPtr ---  not yet implemented"				"for a function returning char* type, convert it to an instance of ByteString"	"#optReturnCharPtrAsString -- not yet implemented"	"for a function spec taking arguments indirectly from an array using the x@index convention	check that the index is not outside x''s bounds "	#optCheckIndirectArgBounds	)! !!NBFFICallout class methodsFor: 'initialize-release' stamp: 'IgorStasenko 9/3/2012 01:42'!initTypeAliases	"self initTypeAliases"	TypeAliases := Dictionary newFromPairs:	#("not really a type, useful only as return type or with pointers "		void NBVoid		" 0/!!0  <-> false/true "		bool NBBool"fixed size integer types, byte order is platform dependent "		int8 NBInt8		uint8 NBUInt8		int16 NBInt16		uint16 NBUInt16		int32 NBInt32		uint32 NBUInt32		int64 NBInt64		uint64 NBUInt64" aliases to common C compiler types.. some of them are platform dependent, some is not.. to be sorted out later "				signedByte int8		unsignedByte int8		signedShort int16		unsignedShort uint16		signedChar int8  		unsignedChar uint8		schar int8		uchar uint8		signedLong int32		unsignedLong uint32		sbyte int8		byte uint8		short int16		ushort uint16		long int32		ulong uint32		longlong int64		ulonglong uint64		uint uint32		int int32"unsigned for sizes.. usually same size as platform's word size"		size_t NBSizeT		"character type. uint8 <-> accepts Character/Smallint as argument, converts return to Character "		Character NBCharacterType		char NBCharacterType		"Floats fixed-size. platform-dependent byte order"		float16 NBFloat16		float32 NBFloat32		float64 NBFloat64		float128 NBFloat128"Floats, C type name aliases"						float float32		double float64		shortFloat float16		"Special types "				oop NBOop	)	! !!NBFFICallout class methodsFor: 'initialize-release' stamp: 'Igor.Stasenko 4/28/2010 16:46'!initialize	Smalltalk removeFromStartUpList: self .		self initTypeAliases! !!NBFFICallout class methodsFor: 'error messages' stamp: 'IgorStasenko 8/8/2011 17:54'!messageForCode: aCode	CustomErrorCodes ifNil: [ ^ nil ].		^ CustomErrorCodes at: aCode ifAbsent: nil! !!NBFFICallout class methodsFor: 'error messages' stamp: 'IgorStasenko 8/8/2011 17:53'!registerErrorMessage: aString	| newCode |		CustomErrorMessages ifNil: [ 		CustomErrorMessages := Dictionary new.		CustomErrorCodes := Dictionary new.	].	(CustomErrorMessages includesKey: aString) ifTrue: [		^ CustomErrorMessages at: aString	].		"add new message and register code for it "			newCode := 600 + CustomErrorCodes size.	CustomErrorMessages at: aString put: newCode.	CustomErrorCodes at: newCode put: aString.		^ newCode! !!NBFFICallout class methodsFor: 'error messages' stamp: 'IgorStasenko 2/20/2012 13:48'!signalError: errorCode	^ NBFFICalloutError signalError: errorCode! !!NBFFICallout class methodsFor: 'generator entry points' stamp: 'CamilloBruni 7/17/2012 14:01'!stdcall: functionSpec emitCall: aCallEmittingBlock	"Note, this is a special method, which should be sent only from 	methods, which intend to use FFI callout code.	All such methods should use a 'primitiveNativeCall' primitive.	First argument is an array of types, where first element denotes a function return type,	and rest denoting argument types.	A CallEmittingBlock serves to emit an actual function call code. 	" 	| sender |	sender := thisContext sender.	^ self 		handleFailureIn: sender		nativeCode: [ :gen |			gen					useEmitCall;				sender: sender;				stdcall;				anonSpec: functionSpec;				generate: aCallEmittingBlock  ]! !!NBFFICallout class methodsFor: 'generator entry points' stamp: 'CamilloBruni 7/17/2012 14:01'!stdcall: functionSpec emitCall: aCallEmittingBlock options: anOptions	"Note, this is a special method, which should be sent only from 	methods, which intend to use FFI callout code.	All such methods should use a 'primitiveNativeCall' primitive.	First argument is an array of types, where first element denotes a function return type,	and rest denoting argument types.	A CallEmittingBlock serves to emit an actual function call code. 	" 	| sender |	sender := thisContext sender.	^ self 		handleFailureIn: sender		nativeCode: [ :gen |			gen				useEmitCall;				sender: sender;				parseOptions: anOptions;				stdcall;				anonSpec: functionSpec;				generate: aCallEmittingBlock  ]! !!NBFFICallout class methodsFor: 'generator entry points' stamp: 'CamilloBruni 7/17/2012 14:01'!stdcall: functionSpec module: aModuleName	"Note, this is a special method, which should be sent only from 	methods, which intend to use FFI callout code.	All such methods should use a 'primitiveNativeCall' primitive.	First argument is an array of types, where first element denotes a function return type,	and rest denoting argument types.	A CallEmittingBlock serves to emit an actual function call code. 	" 	| sender |	sender := thisContext sender.	^ self 		handleFailureIn: sender		nativeCode: [ :gen |			gen				sender: sender;				stdcall;				generateCall: functionSpec module: aModuleName ]! !!NBFFICallout class methodsFor: 'generator entry points' stamp: 'CamilloBruni 7/17/2012 14:00'!stdcall: functionSpec module: aModuleName options: anOptions	"Note, this is a special method, which should be sent only from 	methods, which intend to use FFI callout code.	All such methods should use a 'primitiveNativeCall' primitive.	First argument is a function specification denoting return value type, name and	arguments.	" 	| sender |	sender := thisContext sender.	^ self 		handleFailureIn: sender		nativeCode: [ :gen |			gen				sender: sender;				parseOptions: anOptions;				stdcall;				generateCall: functionSpec module: aModuleName ]! !!NBFFICallout methodsFor: 'type aliases' stamp: 'Igor.Stasenko 9/28/2010 08:00'!aliasForType: aTypeName	| alias |	alias := aTypeName.	(requestor notNil and: [ requestor respondsTo: #externalTypeAlias: ]) 		ifTrue: [ alias := requestor externalTypeAlias: aTypeName.			alias ifNil: [ alias := aTypeName ] ].		" internal aliases "	TypeAliases ifNil: [ self class initTypeAliases ].	^ TypeAliases at: alias ifAbsent: [ alias ]! !!NBFFICallout methodsFor: 'accessing' stamp: 'IgorStasenko 8/21/2011 11:29'!anonSpec: anonFunctionSpec	fnSpec := self newSpecParser parseAnonFunction: anonFunctionSpec.! !!NBFFICallout methodsFor: 'spec parsing' stamp: 'cipt 10/24/2012 20:25'!argName: argName indirectIndex: anIndex type: typeName ptrArity: ptrArity	| type |	argName		ifNil: [ 			"allow nil,true,false as untyped arguments"			typeName = 'nil'				ifTrue: [ ^ NBFFIConst value: 0 ].			typeName = 'false'				ifTrue: [ ^ NBFFIConst value: 0 ].			typeName = 'true'				ifTrue: [ ^ NBFFIConst value: 1 ].			ptrArity > 0				ifTrue: [ self error: 'missing argument name' ].	"lone self"			typeName = 'self'				ifTrue: [ ^ (requestor asNBExternalType: self) loader: self receiverArgumentLoader ].			^ self resolveType: typeName ].	type := self typeName: typeName ptrArity: ptrArity.	type loader: (self loaderForArgNamed: argName indirectIndex: anIndex).	^ type! !!NBFFICallout methodsFor: 'code generation' stamp: 'Igor.Stasenko 5/1/2010 13:52'!callCleanup 	" for cdecl call type we should pop the function arguments we are pushed on stack..	but since we returning back to interpreter using leave , it will be cleaned anyways"! !!NBFFICallout methodsFor: 'accessing' stamp: 'JavierPimas 11/16/2011 17:08'!callType: aCallType	aCallType == #cdecl ifTrue: [		^ self cdecl.		].		aCallType == #stdcall ifTrue: [		^ self stdcall		].		self error: 'unknown call type'.! !!NBFFICallout methodsFor: 'call conventions' stamp: 'Igor.Stasenko 5/3/2010 22:28'!cdecl	options add: #optCdecl! !!NBFFICallout methodsFor: 'code generation' stamp: 'IgorStasenko 5/11/2011 17:23'!coercionMayFail: aBoolean 	coercionMayFail := coercionMayFail or: aBoolean ! !!NBFFICallout methodsFor: 'failure code' stamp: 'CamilloBruni 7/23/2012 13:29'!emitFailureHandler	"emit failure code only if there was a jump on failed label,	and label are not already defined in code"	| failLbl failWithCodeLabel |	failLbl := self failedLabel.	failWithCodeLabel  := self failedWithCodeLabel.	self assert: failLbl isSet not.	self assert: failWithCodeLabel isSet not.	((asm isLabelUsed: failWithCodeLabel) or: [asm isLabelUsed: failLbl ] ) ifTrue: [		asm decorateWith: 'FFI: handle failure' during: [   		(asm isLabelUsed: failWithCodeLabel) ifTrue: [			"assume that error code is passed in EAX"			asm label: failWithCodeLabel.			proxy primitiveFailFor: asm EAX.			self epilogue ].		(asm isLabelUsed: failLbl) ifTrue: [			asm label: self failedLabel.			proxy primitiveFail.			self epilogue ].	]]	! !!NBFFICallout methodsFor: 'failure code' stamp: 'IgorStasenko 8/3/2011 06:53'!emitFailureTest	"emit call to InterpreterProxy>>failed to check if there's everything ok	(usually done before making a call) "	coercionMayFail ifTrue: [		proxy ifFailedJumpTo: self failedLabel ].! !!NBFFICallout methodsFor: 'failure code' stamp: 'IgorStasenko 8/8/2011 17:50'!errorCodeForMessage: aString		^ self class registerErrorMessage: aString! !!NBFFICallout methodsFor: 'failure code' stamp: 'IgorStasenko 8/6/2011 18:32'!failWithCode: aCode	asm 		mov: aCode to: EAX;		jmp: self failedWithCodeLabel! !!NBFFICallout methodsFor: 'failure code' stamp: 'IgorStasenko 8/8/2011 17:49'!failWithMessage: aString		| errorCode |		errorCode := self errorCodeForMessage: aString.		^ self failWithCode: errorCode! !!NBFFICallout methodsFor: 'failure code' stamp: 'IgorStasenko 8/6/2011 18:25'!failedLabel	^ asm labelNamed: #FFICalloutFailed! !!NBFFICallout methodsFor: 'failure code' stamp: 'IgorStasenko 8/6/2011 18:25'!failedWithCodeLabel	^ asm labelNamed: #FFICalloutFailedWithCode! !!NBFFICallout methodsFor: 'accessing' stamp: 'Igor.Stasenko 4/30/2010 11:48'!fnSpec	^ fnSpec! !!NBFFICallout methodsFor: 'code generation' stamp: 'IgorStasenko 1/18/2012 16:22'!foreignCall: aBlock	callInfo := self newCallInfo.	callInfo alignment: self stackAlignment.	asm performingCall: callInfo in: aBlock.! !!NBFFICallout methodsFor: 'code generation' stamp: 'CamilloBruni 7/25/2012 12:43'!generate: aFunctionBodyBlock	"Answer the byte array, containing the generated machine code"	| generatedCode |		generatedCode := AJGeneratedCode fromInstructions: (self generateInstructions: aFunctionBodyBlock).			^ generatedCode bytes	! !!NBFFICallout methodsFor: 'code generation' stamp: 'IgorStasenko 11/22/2012 18:23'!generateCall: functionSpec module: aModuleNameOrHandle	"Generate a foreign function callout from given function specification and	a module name"		| fnAddress |	self namedFnSpec: functionSpec.	fnAddress := requestor nbGetSymbolAddress: fnSpec functionName module: aModuleNameOrHandle.	fnAddress ifNil: [ self error: 'function unavailable' ].		^ self generateCallToAddress: [ fnAddress ]! !!NBFFICallout methodsFor: 'code generation' stamp: 'IgorStasenko 11/22/2012 18:10'!generateCallToAddress: aFunctionAddressBlock	"Generate a foreign function callout using given function address"	^ self generate: [:gen | | fnAddress |		fnAddress := aFunctionAddressBlock cull: self cull: proxy cull: asm.				fnAddress ifNil: [ self error: 'function unavailable' ].				self optMayGC 			ifTrue: [				"a GC may be triggered during external call. Make sure we making a call via gate "				asm 					push: fnAddress asUImm32;					mov: NativeBoost callgateFunctionAddress asUImm32 to: EAX;					call: EAX ]			ifFalse: [				asm mov: fnAddress asUImm32 to: EAX;				call: EAX.  ] 		]	! !!NBFFICallout methodsFor: 'code generation' stamp: 'IgorStasenko 12/7/2012 01:04'!generateInstructions: aFunctionBodyBlock	| instructions |		proxy prepareForCallout.	"prepare & push arguments"			self foreignCall: [:call |		"do not align, if its not required"		self optNoAlignment ifTrue: [ call alignment: 1].		self pushArguments.			self emitFailureTest.		asm decorateWith: 'FFI: performing a call' during: [			aFunctionBodyBlock valueWithPossibleArgs: { self. proxy. asm}.					"if we're using custom emitcall section, don't bother to cleanup the stack "			(self optEmitCall or: [self optNoCleanup]) ifTrue: [ call disableCleanup ].		].		].		"handle return value"	asm decorateWith: 'FFI: coerce return value' during: [   		fnSpec returnType coerceReturn: self ].		self epilogue.	self emitFailureHandler.	(self optMayGC or: [proxy usedGate ]) ifTrue: [		asm reserveExtraBytesOnStack: asm wordSize*2.	].	instructions := asm prepareInstructions.		self optDebug ifTrue: [ self halt ].		^ instructions! !!NBFFICallout methodsFor: 'argument loaders' stamp: 'cipt 10/24/2012 20:39'!indirectLoader: aLoader byIndex: anIndex	^ NBSTIndirectArgument new		argumentLoader: aLoader;		elementIndex: anIndex! !!NBFFICallout methodsFor: 'initialize-release' stamp: 'IgorStasenko 8/3/2011 06:33'!initialize 	super initialize.	coercionMayFail := false! !!NBFFICallout methodsFor: 'spec parsing' stamp: 'Igor.Stasenko 4/30/2010 11:27'!integerConstantArgument: int	^ NBFFIConst value: int! !!NBFFICallout methodsFor: 'argument loaders' stamp: 'cipt 10/26/2012 19:26'!loaderForArgNamed: argName	| loader |	"try getting the argument from the method arguments"	loader := self loaderFromMethodArgsNamed: argName.	loader		ifNil: [ 			"special case, receiver argument"			argName = 'self'				ifTrue: [ loader := self receiverArgumentLoader ].			loader				ifNil: [ 					"Ask the requestor for the argument"					loader := requestor nbFnArgument: argName generator: self.					loader ifNil: [ Error signal: 'Could not find accessor for variable named "' , argName , '" in ' , method name ] ] ].	"]"	^ loader! !!NBFFICallout methodsFor: 'argument loaders' stamp: 'cipt 10/24/2012 20:30'!loaderForArgNamed: argName indirectIndex: anIndex	| loader |	loader := self loaderForArgNamed: argName.	anIndex isNil		ifFalse: [ loader := self indirectLoader: loader byIndex: anIndex ].	^ loader! !!NBFFICallout methodsFor: 'argument loaders' stamp: 'cipt 10/21/2012 20:25'!loaderFromMethodArgsNamed: argName	methodArgs		ifNotNil: [ 			| index |			index := methodArgs indexOf: argName ifAbsent: [ nil ].			index				ifNotNil: [ 					"ok, this is a method argument"					^ NBSTMethodArgument new stackIndex: methodArgs size - index ] ].	^ nil! !!NBFFICallout methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/3/2010 01:05'!methodArgs	^ methodArgs! !!NBFFICallout methodsFor: 'accessing' stamp: 'Igor.Stasenko 4/30/2010 11:05'!methodArgs: aMethodArgumentNames	"avoid setting them directly,  useful for testing only"	methodArgs := aMethodArgumentNames! !!NBFFICallout methodsFor: 'accessing' stamp: 'IgorStasenko 8/21/2011 11:29'!namedFnSpec: namedFn		fnSpec := self newSpecParser parseNamedFunction: namedFn.	! !!NBFFICallout methodsFor: 'code generation' stamp: 'IgorStasenko 1/18/2012 16:22'!newCallInfo 	self optCdecl ifTrue: [ ^ asm newCdeclCall ].	self optStdcall ifTrue: [ ^ asm newStdCall ].	! !!NBFFICallout methodsFor: 'accessing' stamp: 'Igor.Stasenko 4/30/2010 06:54'!newSpecParser	^ NBFnSpecParser new requestor: self! !!NBFFICallout methodsFor: 'code generation' stamp: 'CamilloBruni 7/23/2012 13:29'!pushArguments	" argument indexes pushed on ST stack are: 	argType   ST stack  C stack 	   index       index        push order	    1              2             2	    2              1             1	    3              0             0	"	asm decorateWith: 'FFI: prepare arguments' during: [   		fnSpec arguments do: [:arg | arg prepareArgumentUsing: self ] ].	"both cdecl/apicall using reverse argument order on stack"	fnSpec arguments notEmpty ifTrue: [		asm decorateWith: 'FFI: pushing arguments' during: [   			fnSpec arguments reverseDo: [:arg | 				asm noticePush: arg stackSize forCall: callInfo.				arg emitPush: self ] ]	].	fnSpec returnType 		prepareReturnValue: self for: callInfo.! !!NBFFICallout methodsFor: 'code generation' stamp: 'IgorStasenko 8/5/2011 18:01'!receiverArgumentLoader	^ NBSTMethodArgument new stackIndex: methodArgs size; isReceiver: true  ! !!NBFFICallout methodsFor: 'accessing' stamp: 'Igor.Stasenko 4/26/2010 02:03'!requestor	^ requestor! !!NBFFICallout methodsFor: 'accessing' stamp: 'Igor.Stasenko 4/26/2010 02:04'!requestor: aRequestor	requestor := aRequestor.		(requestor respondsTo: #ffiCalloutOptions) ifTrue: [		self parseOptions: requestor ffiCalloutOptions	]! !!NBFFICallout methodsFor: 'accessing' stamp: 'IgorStasenko 2/9/2012 12:38'!resolveType: aTypeName	" a type name could be	 - a class variable name	- a class name	- a type name 	- a type name, followed by arbitrary number pointer chars - $*"	| name newName resolver binding ptrArity |		newName := aTypeName.	ptrArity := 0.	"resolve aliases and pointers"		[		name := newName trimRight.  		newName := self aliasForType: name.		newName last = $* ifTrue: [			ptrArity := ptrArity + 1.			newName := newName allButLast ].		name = newName ] whileFalse.		resolver := requestor ifNil: [ self class ].	binding := resolver nbBindingOf: name asSymbol.		binding ifNotNil: [ 		^ (binding value asNBExternalType: self) pointerArity: ptrArity ] .	^ self error: 'Unable to resolve external type: ', aTypeName.! !!NBFFICallout methodsFor: 'spec parsing' stamp: 'IgorStasenko 8/21/2011 11:04'!returnType: aType	^ self  typeName: aType first ptrArity: aType second! !!NBFFICallout methodsFor: 'code generation' stamp: 'Igor.Stasenko 4/28/2010 12:46'!returnValueRegister		"answer a register, which is used by functions to return value"	^ EAX! !!NBFFICallout methodsFor: 'accessing' stamp: 'IgorStasenko 3/27/2012 17:23'!sender: aSenderContext	| nArgs |	self requestor: aSenderContext method methodClass.	nArgs := aSenderContext method numArgs.	methodArgs := aSenderContext method methodNode tempNames first: nArgs.		self assert: (methodArgs size = nArgs).! !!NBFFICallout methodsFor: 'call conventions' stamp: 'Igor.Stasenko 5/3/2010 22:27'!stdcall	options add: #optStdcall! !!NBFFICallout methodsFor: 'spec parsing' stamp: 'Igor.Stasenko 4/30/2010 09:18'!typeName: aName ptrArity: ptrArity	^ (self resolveType: aName) pointerArity: ptrArity! !!NBFFICallout methodsFor: 'accessing' stamp: 'IgorStasenko 8/3/2011 08:42'!useEmitCall	"set the flag that we're generating code which using custom emitCall: section"		options add: #optEmitCall! !!NBFFICallout methodsFor: 'testing' stamp: 'Igor.Stasenko 5/18/2010 02:23'!usesMethodArguments	^ fnSpec arguments anySatisfy: [:type | type loader usesSTStack ]! !!NBNativeFunctionGen class methodsFor: 'generator entry points' stamp: 'IgorStasenko 8/23/2012 18:06'!cdecl: fnSpec emit: aFunctionBodyBlock	^ self new cdecl;		fnSpec: fnSpec;		generate: aFunctionBodyBlock;		yourself! !!NBNativeFunctionGen class methodsFor: 'generator entry points' stamp: 'IgorStasenko 8/23/2012 18:06'!cdecl: fnSpec emit: aFunctionBodyBlock options: anOptions	^ self new cdecl;		parseOptions: anOptions;		fnSpec: fnSpec;		generate: aFunctionBodyBlock;		yourself! !!NBNativeFunctionGen class methodsFor: 'generator entry points' stamp: 'IgorStasenko 8/23/2012 18:06'!stdCall: fnSpec emit: aFunctionBodyBlock	^ self new stdcall;		fnSpec: fnSpec;		generate: aFunctionBodyBlock;		yourself! !!NBNativeFunctionGen class methodsFor: 'generator entry points' stamp: 'IgorStasenko 8/23/2012 18:06'!stdCall: fnSpec emit: aFunctionBodyBlock options: anOptions	^ self new 		parseOptions: anOptions;		stdcall;		fnSpec: fnSpec;		generate: aFunctionBodyBlock;		yourself! !!NBNativeFunctionGen methodsFor: 'accessing' stamp: 'CamilloBruni 8/3/2012 15:36'!address	^ nativeFunction address! !!NBNativeFunctionGen methodsFor: 'convenience' stamp: 'IgorStasenko 5/28/2012 07:23'!arg: aName	| arg |		arg := fnSpec arguments detect: [:argx | argx name = aName ]		ifNone: [ self error: 'invalid argument name' ].		self assert: (arg type typeSize <= 8).		^ (asm EBP ptr + arg offset) size: arg type typeSize! !!NBNativeFunctionGen methodsFor: 'as yet unclassified' stamp: 'cipt 10/26/2012 19:19'!argName: argName indirectIndex: anIndex type: typeName ptrArity: ptrArity	| arg |	arg := NBNativeFunctionArgument new.	arg type: (self typeName: typeName ptrArity: ptrArity).	arg name: argName.		^ arg	! !!NBNativeFunctionGen methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/13/2010 23:34'!code	^ code! !!NBNativeFunctionGen methodsFor: 'code generation' stamp: 'CamilloBruni 7/23/2012 16:40'!epilogue		asm		label: self returnLabel;		emitEpilogue: (self optStdcall ifTrue: [ stackSize] ifFalse: [0]).! !!NBNativeFunctionGen methodsFor: 'accessing' stamp: 'IgorStasenko 8/21/2011 11:01'!fnSpec: anonymousSpec		fnSpec := NBFnSpecParser new requestor: self ; parseAnonFunction: anonymousSpec! !!NBNativeFunctionGen methodsFor: 'code generation' stamp: 'IgorStasenko 8/23/2012 18:14'!generate: aFunctionBodyBlock	code := AJGeneratedCode fromInstructions: (self generateInstructions: aFunctionBodyBlock).	 ! !!NBNativeFunctionGen methodsFor: 'code generation' stamp: 'CamilloBruni 7/23/2012 16:36'!generateInstructions: aFunctionBodyBlock		| instructions |		options add: #optNonMovable.  "native functions are non-movable code"			self prepareArguments.		aFunctionBodyBlock cull: self cull: proxy cull: asm.	self epilogue.		instructions := asm prepareInstructions.		self optDebug ifTrue: [ self halt ].		^ instructions! !!NBNativeFunctionGen methodsFor: 'installing' stamp: 'IgorStasenko 8/23/2012 18:06'!install	"install the code into a memory heap"	self assert: code notNil.	nativeFunction := NBNativeFunction code: code fnSpec: fnSpec.	^ nativeFunction ! !!NBNativeFunctionGen methodsFor: 'accessing' stamp: 'CamilloBruni 8/3/2012 15:36'!nativeFunction	^ nativeFunction! !!NBNativeFunctionGen methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/3/2010 22:12'!nb	^ NativeBoost forCurrentPlatform ! !!NBNativeFunctionGen methodsFor: 'code generation' stamp: 'IgorStasenko 5/28/2012 07:20'!prepareArguments	| args offset |		(self optCdecl or: [ self optStdcall ]) ifTrue: [		args := fnSpec arguments.	].		offset := 8.  "+ return address + EBP"	stackSize := 0.	args withIndexDo: [:arg :i |  | sz |		"arg size is 4 or 8"		sz := arg type stackSize.		stackSize := stackSize + sz.		arg offset: offset.		offset := offset + sz.	].! !!NBNativeFunctionGen methodsFor: 'convenience' stamp: 'CamilloBruni 7/23/2012 16:55'!return	"Generate a jump to the return label.	Use this function instead of directly calling #ret, #leave on the assembler if you want to rely on the default cleanup instructions generated by me"	asm jmp: self returnLabel.! !!NBNativeFunctionGen methodsFor: 'accessing' stamp: 'CamilloBruni 7/23/2012 16:39'!returnLabel	^ returnLabel ifNil: [ 		returnLabel := asm uniqueLabelName: 'Return' ]! !!NBNativeFunctionGen methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/7/2010 22:31'!stackSize	^ stackSize! !!NBNativeFunctionGen methodsFor: 'installing' stamp: 'IgorStasenko 8/23/2012 18:04'!uninstall	"uninstall the code from a memory heap"		nativeFunction ifNotNil: [ nativeFunction uninstall ].! !!NBNativeCodeGen class methodsFor: 'error handling' stamp: 'IgorStasenko 2/13/2012 14:50'!assertIsNBMethod: aMethod	"Check that method having a native-boost primitive"				((aMethod primitive = 117) and: [  | lit |  lit := aMethod literalAt: 1. 			lit first = #NativeBoostPlugin and: [ lit second == #primitiveNativeCall]]) ifFalse: [ ^NBNativeCodeError signalError: ErrNoNBPrimitive ].! !!NBNativeCodeGen class methodsFor: 'debugging' stamp: 'Igor.Stasenko 4/28/2010 18:13'!debugOff	DebugOn := false! !!NBNativeCodeGen class methodsFor: 'debugging' stamp: 'Igor.Stasenko 5/2/2010 18:05'!debugOn	DebugOn := true! !!NBNativeCodeGen class methodsFor: 'options'!defaultOptions	^ #() ! !!NBNativeCodeGen class methodsFor: 'instance creation' stamp: 'IgorStasenko 9/23/2012 04:31'!generateCode: aBlock andRetry: retryCtx	| method bytes newMethod args |	method := retryCtx method.	NBRecursionDetect in: method during: [ 		bytes := aBlock value: (self newForMethod: method).	].	DebugOn == true ifTrue: [ 		(FileStream newFileNamed: 'asm.bin') nextPutAll: bytes; close.		self halt ].		newMethod := self installNativeCode: bytes into: method.		newMethod primitive = self jitPrimitiveNumber ifTrue: [ newMethod forceJIT ].	^ self retrySend: retryCtx! !!NBNativeCodeGen class methodsFor: 'error handling' stamp: 'IgorStasenko 9/20/2012 14:43'!getErrorFrom: aContext lastError: errorCode	| lastError method |	lastError := errorCode.	method := aContext method.	"Check that method has a #primitiveNativeCall, since it required by generator, and sometimes you can forget putting primitive pragma"	(method primitive = 220 or: [	((method primitive = 117) and: [  | lit |  lit := method literalAt: 1. 			lit first = #NativeBoostPlugin and: [ lit second == #primitiveNativeCall]])])		ifFalse: [ ^ ErrNoNBPrimitive ].			"Check if method using an extended primitive pragma (introduced in Cog), 	otherwise we just take an errorCode"	(method pragmas anySatisfy: [:p | p keyword == #primitive:module:error: ])	ifTrue: [		"A primitive error is always the last temp (ensured by compiler) "		lastError := aContext  tempAt: method numTemps. 	].		lastError = ErrNotEnabled ifTrue: [		"If we cannot enable it, report an error..."		NativeBoost enableNativeCode ifFalse: [ ^ NBNativeCodeError signal: 'Cannot enable native code execution' ].			" Fake absence of native code, so then code generator will generate code and retry the call.		Note that if you want to keep native code forever (generated once and kept forever as long as method exists), you might want to override this"				lastError := ErrNoNativeCodeInMethod ].	^ lastError ! !!NBNativeCodeGen class methodsFor: 'error handling' stamp: 'IgorStasenko 9/21/2012 15:48'!getErrorFromJit: aContext	| lastError method |	method := aContext method.	"Check that method has a primitive 220"	(method primitive = self jitPrimitiveNumber)		ifFalse: [ ^ ErrNoNBPrimitive ].	(method pragmas anySatisfy: [:p | p keyword == #primitive:error: ])	ifTrue: [		"A primitive error is always the last temp (ensured by compiler) "		lastError := aContext  tempAt: method numTemps. 	] ifFalse: [ lastError := ErrInvalidPrimitiveVoltageUse ].	^ lastError ! !!NBNativeCodeGen class methodsFor: 'error handling' stamp: 'IgorStasenko 2/20/2012 13:48'!handleFailureIn: aContext nativeCode: aBlock	| method lastError |	"Note: make sure that #lastError are sent first, no guarantee that we won't be preempted before	but this is best we can do if method is not using extended primitive pragma with error code"		lastError := self getErrorFrom: aContext lastError: NativeBoost lastError.	method := aContext method.	"install native code and retry the send"	lastError = ErrNoNativeCodeInMethod		ifTrue: [ ^ self generateCode: aBlock andRetry: aContext ].	"ok, we're out of options, signal an error here"	^ self signalError: lastError! !!NBNativeCodeGen class methodsFor: 'error handling' stamp: 'IgorStasenko 11/9/2012 04:12'!handleFailureInJit: aContext nativeCode: aBlock	| method lastError |	"Note: make sure that #lastError are sent first, no guarantee that we won't be preempted before	but this is best we can do if method is not using extended primitive pragma with error code"		lastError := self getErrorFromJit: aContext.	method := aContext method.	lastError = ErrRunningViaInterpreter ifTrue: [		"a method contains native code, but executed by interpreter "		method forceJIT ifFalse: [ self error: 'Failed to JIT the compiled method. Try reducing it''s size ' ].		^ self retrySend: aContext		].	"install native code and retry the send"	(lastError = ErrNoNativeCodeInMethod or: [ lastError isNil ] )		ifTrue: [ ^ self generateCode: aBlock andRetry: aContext ].	"ok, we're out of options, signal an error here"	^ self signalError: lastError! !!NBNativeCodeGen class methodsFor: 'managing methods' stamp: 'IgorStasenko 2/13/2012 14:21'!installNativeCode: bytes into: method 	"install a native code into a compiled method"	"Installing/removing native code directly:		In some cases user(s) may need it, like in case if  you want to update/flush/recompile generated code 		for a number of methods due to some change in environment.			For example, my class(es) might have a 'DeveloperMode' flag, which depending on its value may affect a generated code		in order to do some additional checks at runtime (when turned on), and suppress them (when turned off). 		And so, in order to switch between those modes, we need a way to flush native code in affected methods.		Also, since a plugin having no way to determine who provided a native code, users may implement own code generators		(or just load code from file/cache) instead of using facilities provided by NativeBoost. "			| trailer newMethod |	trailer := CompiledMethodTrailer new.	trailer 		nativeCode: bytes		platformId: NativeBoost platformId 		sourcePointer: method trailer sourcePointer.	newMethod :=  method copyWithTrailerBytes: trailer.	method methodClass methodDict at: method selector put: newMethod.	^ newMethod! !!NBNativeCodeGen class methodsFor: 'public API' stamp: 'CamilloBruni 10/4/2012 10:37'!jitMethodAssembly: aBlock	"This method will directly inline the nativecode in the jited	method thus eliminating the overhead of running through the 	whole primitive activation each time the method is invoked.	Unlike in the cdecl style NativeBoost code generation the return	value is passed in EDX and not in EAX."	^ self handleFailureInJit: thisContext sender nativeCode:		[:gen | aBlock cull: gen cull: gen proxy cull: gen asm. gen bytes ]! !!NBNativeCodeGen class methodsFor: 'error handling' stamp: 'IgorStasenko 9/20/2012 14:48'!jitPrimitiveNumber	^ 220! !!NBNativeCodeGen class methodsFor: 'public API' stamp: 'HenrikSperreJohansen 8/23/2011 02:34'!methodAssembly: aBlock	"We're get here from a method, which contains  a native code.	There are following error cases:	  - method does not contains a NativeBoost primitive	  - method's native code platform id doesn't match the current platform id	  - method having no native code generated yet	  - a native code runs but caused primitive failure	"		^ self handleFailureIn: thisContext sender nativeCode:		[:gen | aBlock cull: gen cull: gen proxy cull: gen asm. gen bytes ]! !!NBNativeCodeGen class methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/2/2010 13:34'!nativeMethods	" self nativeMethods "	^ CompiledMethod allInstances select: [:m |		m trailer kind = #NativeCodeTrailer 		and: [ m isInstalled ] ]! !!NBNativeCodeGen class methodsFor: 'instance creation' stamp: 'HenrikSperreJohansen 8/23/2011 22:10'!newForMethod: aMethod	^self new setMethod: aMethod! !!NBNativeCodeGen class methodsFor: 'managing methods' stamp: 'IgorStasenko 2/13/2012 14:21'!removeNativeCodeFrom: method	"Installing/removing native code directly:		In some cases user(s) may need it, like in case if  you want to update/flush/recompile generated code 		for a number of methods due to some change in environment.			For example, my class(es) might have a 'DeveloperMode' flag, which depending on its value may affect a generated code		in order to do some additional checks at runtime (when turned on), and suppress them (when turned off). 		And so, in order to switch between those modes, we need a way to flush native code in affected methods.		Also, since a plugin having no way to determine who provided a native code, users may implement own code generators		(or just load code from file/cache) instead of using facilities provided by NativeBoost. "	|trailer|	trailer := method trailer.	trailer kind == #NativeCodeTrailer ifTrue: [  "it _should_ be true.. but lets check to be sure"		| newTrailer |		newTrailer := CompiledMethodTrailer new sourcePointer: trailer sourcePointer.					method isInstalled ifTrue: [			method methodClass methodDict 				at: method selector 				put:  ( method copyWithTrailerBytes: newTrailer)			]	]! !!NBNativeCodeGen class methodsFor: 'error handling' stamp: 'IgorStasenko 9/23/2012 03:38'!retrySend: retryCtx	| method args |	method := retryCtx method.	"just resending the same message"	args := Array new: method numArgs.	1 to: args size do: [ :i |  args at: i put: (retryCtx tempAt: i) ].	thisContext terminateTo: retryCtx sender. 	^ retryCtx receiver perform: method selector withArguments: args.! !!NBNativeCodeGen class methodsFor: 'error handling' stamp: 'IgorStasenko 2/20/2012 13:48'!signalError: errorCode	^ NBNativeCodeError signalError: errorCode! !!NBNativeCodeGen methodsFor: 'accessing' stamp: 'Igor.Stasenko 4/11/2010 09:04'!asm	^ asm! !!NBNativeCodeGen methodsFor: 'retrieving the code' stamp: 'IgorStasenko 8/3/2011 20:08'!bytes	^ self generatedCode bytes! !!NBNativeCodeGen methodsFor: 'options' stamp: 'Igor.Stasenko 5/1/2010 10:18'!defaultOptions	^ self class defaultOptions! !!NBNativeCodeGen methodsFor: 'options' stamp: 'Igor.Stasenko 5/1/2010 13:45'!doesNotUnderstand: message	(message selector isUnary and: [ message selector beginsWith: 'opt'] )		ifTrue: [ ^ options includes: message selector ].			^ super doesNotUnderstand: message! !!NBNativeCodeGen methodsFor: 'retrieving the code' stamp: 'Igor.Stasenko 4/25/2010 01:05'!dumpBytes	^ String streamContents: [:str |		self bytes do: [:b | str nextPutAll: (b printStringBase: 16); space ]		]! !!NBNativeCodeGen methodsFor: 'code generation' stamp: 'Igor.Stasenko 5/2/2010 13:03'!emitFetchClass: aClass	"emit code, which fetching the class oop into EAX"	^  NativeBoost extraRootsRegistry emitFetchClass: aClass generator: self ! !!NBNativeCodeGen methodsFor: 'code generation' stamp: 'CamilloBruni 7/23/2012 16:40'!epilogue	asm emitEpilogue: 0. ! !!NBNativeCodeGen methodsFor: 'retrieving the code' stamp: 'IgorStasenko 8/3/2011 20:15'!generatedCode	proxy usedGate ifTrue: [		asm reserveExtraBytesOnStack: asm wordSize*2.		].		self optDebug ifTrue: [ self halt. ].	^ asm generatedCode.! !!NBNativeCodeGen methodsFor: 'initialize-release' stamp: 'IgorStasenko 5/9/2011 13:12'!initialize	asm := self newAssembler.	options := Set new.	proxy := NBInterpreterProxy forGenerator: self. 	self parseOptions: self defaultOptions.! !!NBNativeCodeGen methodsFor: 'accessing' stamp: 'HenrikSperreJohansen 8/23/2011 22:08'!method	^method! !!NBNativeCodeGen methodsFor: 'accessing' stamp: 'IgorStasenko 5/7/2011 21:27'!newAssembler	^ NativeBoost newAssembler ! !!NBNativeCodeGen methodsFor: 'options' stamp: 'Igor.Stasenko 5/1/2010 10:56'!optionAt: optionName	^ options includes: optionName! !!NBNativeCodeGen methodsFor: 'options' stamp: 'Igor.Stasenko 5/1/2010 10:55'!parseOptions: optionsArray	"parse an array, which is a sequence of options in a form of: 		#( + option1 option2 - option3 ... )		each time the #+ is seen, the options which follow it will be subject for inclusion	and, correspondingly, if #- seen, then they will be excluded	.	By default, (if none of #+ or #- specified initially), all options are subject for inclusion.	"	| include |		include := true.		optionsArray do: [:option |		option == #+ 			ifTrue: [ include := true ]			ifFalse: [				option == #- 					ifTrue: [ include := false ]					ifFalse: [ 						include ifTrue: [ options add: option ] 						ifFalse: [ options remove: option ifAbsent:[] ]]]		].! !!NBNativeCodeGen methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/1/2010 10:27'!proxy	^ proxy! !!NBNativeCodeGen methodsFor: 'temporaries' stamp: 'IgorStasenko 5/9/2011 12:55'!releaseTemps: count	asm releaseTemps: count! !!NBNativeCodeGen methodsFor: 'code generation' stamp: 'IgorStasenko 8/5/2011 07:38'!reserveStackBytes: numBytesOrBlock	"emit code to reserve a given number of bytes, answer the temp,	which will hold an allocated block address "		| address |	address := self reserveTemp.	^ self reserveStackBytes: numBytesOrBlock andStoreAddrTo: address! !!NBNativeCodeGen methodsFor: 'code generation' stamp: 'Igor.Stasenko 4/28/2010 13:48'!reserveStackBytes: numBytesOrBlock andStoreAddrTo: aTemp	"emit code to reserve a given number of bytes, answer the temp,	which will hold an allocated block address "		| numBytes |	numBytes := numBytesOrBlock. 	numBytesOrBlock isBlock ifTrue: [ numBytes := numBytesOrBlock value: self ].		numBytes = EAX ifFalse: [		asm mov: numBytes to: EAX ].		"align stack to 4-bytes (will waste 4 bytes if its already aligned)"	asm		or: EAX with: 3;		inc: EAX	;		sub: ESP with: EAX;		mov: ESP to: aTemp.  "store the allocated space start into a temp"	^ aTemp! !!NBNativeCodeGen methodsFor: 'temporaries' stamp: 'IgorStasenko 5/9/2011 12:55'!reserveTemp	^ asm reserveTemp! !!NBNativeCodeGen methodsFor: 'initialize-release' stamp: 'HenrikSperreJohansen 8/23/2011 22:09'!setMethod: aMethod	method := aMethod! !!NBNativeCodeGen methodsFor: 'accessing' stamp: 'IgorStasenko 8/10/2011 15:08'!stackAlignment	^ self utils stackAlignment ! !!NBNativeCodeGen methodsFor: 'accessing' stamp: 'IgorStasenko 8/10/2011 15:08'!utils	^ NativeBoost forCurrentPlatform! !!NBObjectFormat32 class methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 11/24/2012 17:22'!headerOf: anObject	<primitive: #primitiveNativeCall module: #NativeBoostPlugin >		^ self nbCallout function: #( ulong (oop anObject) ) emit: [:gen |		gen asm pop: gen asm EAX.		gen asm mov: gen asm EAX ptr to: gen asm EAX		]! !!NBObjectFormat32 methodsFor: 'header shifts' stamp: 'Igor.Stasenko 5/20/2010 03:35'!compactClassIndexShift	"answer a compact class index shift"	^ 12! !!NBObjectFormat32 methodsFor: 'header fields' stamp: 'HenrikSperreJohansen 8/22/2011 23:19'!compactClassMask	"answer a bit mask for a compact class index in base header "	" ggghhhhhhhhhhhhcccccffffsssssstt "	^ 2r00000000000000011111000000000000! !!NBObjectFormat32 methodsFor: 'object formats' stamp: 'HenrikSperreJohansen 8/22/2011 22:11'!fixedFieldsFormat 	" fixed fields only (all containing pointers) " 	^ 2r0001! !!NBObjectFormat32 methodsFor: 'testing' stamp: 'Igor.Stasenko 9/29/2010 10:58'!floatsMatchingPlatform	"Answer true if floats are store in platform native endianesness.		This is false for Squeak on x86 , since they are always stored in bigendian format.	Cog promising to always use native format for floats.	"		^ self isCogVM! !!NBObjectFormat32 methodsFor: 'header fields' stamp: 'HenrikSperreJohansen 8/22/2011 23:16'!headerTypeMask	"answer a bit mask for a compact class index in base header "	" ggghhhhhhhhhhhhcccccffffsssssstt "	^ 2r00000000000000000000000000000011! !!NBObjectFormat32 methodsFor: 'header fields' stamp: 'HenrikSperreJohansen 8/22/2011 23:16'!identityHashMask	"answer a bit mask for a compact class index in base header "	" ggghhhhhhhhhhhhcccccffffsssssstt "	^ 2r00011111111111100000000000000000! !!NBObjectFormat32 methodsFor: 'emitting tests' stamp: 'CamilloBruni 7/23/2012 13:29'!ifImmediate: aLocation jumpTo: aLabel	"Jump to aLabel, if the OOP in aLocation is that of an immediate smallinteger"	asm decorateWith: '#jumpTo:ifImmediate::' 	during: [ asm 				test: aLocation with: 1;				jnz: aLabel ]! !!NBObjectFormat32 methodsFor: 'emitting tests' stamp: 'CamilloBruni 7/23/2012 13:29'!ifWordsOOP: aLocation storeHeaderIn: destinationLocation ifNotJumpTo: aLabel	asm decorateWith: '#jumpTo:ifNotWordsOOP:' during: [ 	asm 			mov: aLocation ptr to: destinationLocation;		test: destinationLocation with: (self indexableWordsFormat bitShift: self objectFormatShift);		jz: aLabel	]! !!NBObjectFormat32 methodsFor: 'header shifts' stamp: 'HenrikSperreJohansen 8/22/2011 23:01'!immediateShift	^ 24! !!NBObjectFormat32 methodsFor: 'object formats' stamp: 'HenrikSperreJohansen 8/22/2011 22:11'!indexableBytesFormat	" 8-11      indexable byte fields only (no pointers) (low 2 bits are low 2 bits of size) "	^ 2r1000! !!NBObjectFormat32 methodsFor: 'object formats' stamp: 'HenrikSperreJohansen 8/22/2011 22:11'!indexableWordsFormat	" indexable word fields only (no pointers) "	^ 2r0110! !!NBObjectFormat32 methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 5/19/2010 11:53'!instVarOffsetAt: index	"answer an offset of instance variable with given 1-based index,	relative to some oop"	^ self baseHeaderSize + (self oopSize*(index-1)).! !!NBObjectFormat32 methodsFor: 'emitting tests' stamp: 'HenrikSperreJohansen 8/22/2011 22:26'!isBytes2: oop ifNotJumpTo: label	asm 		mov: oop to: EAX;		test: AL with: 1;		jne: label;		"mov: EAX ptr to: ECX;"		"and: ECX with: self objectFormatMask;"		test: EAX with: (self indexableBytesFormat bitShift: self objectFormatShift);		jz: label! !!NBObjectFormat32 methodsFor: 'emitting tests' stamp: 'Igor.Stasenko 5/20/2010 07:25'!isBytes: oop ifNotJumpTo: label	asm 		mov: oop to: EAX;		test: AL with: 1;		jne: label;		mov: EAX ptr to: ECX;		and: ECX with: self objectFormatMask;		cmp: ECX with: (self indexableBytesFormat bitShift: self objectFormatShift);		jl: label! !!NBObjectFormat32 methodsFor: 'emitting tests' stamp: 'CamilloBruni 7/23/2012 13:29'!isBytesOrWords: oop ifNotJumpTo: label	| gotIt |	gotIt := asm uniqueLabelName: 'gotit'.	asm decorateWith: '#isBytesOrWords:ifNotJumpTo:' during: [ 	asm 		mov: oop to: EAX;		test: AL with: 1;		jne: label;		mov: EAX ptr to: ECX;		and: ECX with: self objectFormatMask;		cmp: ECX with: (self indexableWordsFormat bitShift: self objectFormatShift);		je: gotIt;		cmp: ECX with: (self indexableBytesFormat bitShift: self objectFormatShift);		jl: label;		label: gotIt	]! !!NBObjectFormat32 methodsFor: 'emitting tests' stamp: 'CamilloBruni 7/23/2012 13:29'!jumpTo: aLabel ifImmediate: aLocation	asm decorateWith: '#jumpTo:ifImmediate::' 	during: [ asm 				test: aLocation with: 1;				jnz: aLabel ]! !!NBObjectFormat32 methodsFor: 'emitting tests' stamp: 'CamilloBruni 7/23/2012 13:29'!jumpTo: aLabel ifNotWordsOOP: aLocation	asm decorateWith: '#jumpTo:ifNotWordsOOP:' during: [ 	self ifImmediate: aLocation jumpTo: aLabel .	asm 			push: asm EAX;		mov: aLocation ptr to: asm EAX;		test: asm EAX with: (self indexableWordsFormat bitShift: self objectFormatShift);		pop: asm EAX;		jz: aLabel	]! !!NBObjectFormat32 methodsFor: 'object formats' stamp: 'Igor.Stasenko 5/20/2010 06:06'!noFieldsFormat	^ 0! !!NBObjectFormat32 methodsFor: 'header fields' stamp: 'HenrikSperreJohansen 8/23/2011 21:41'!objectFormatMask	"answer a bit mask for a compact class index in base header "	" ggghhhhhhhhhhhhcccccffffsssssstt "	^ 2r00000000000000000000111100000000! !!NBObjectFormat32 methodsFor: 'header shifts' stamp: 'HenrikSperreJohansen 8/23/2011 00:05'!objectFormatShift	^ 8! !!NBObjectFormat32 methodsFor: 'header fields' stamp: 'HenrikSperreJohansen 8/23/2011 21:41'!objectSizeMask	"answer a bit mask for a compact class index in base header "	" ggghhhhhhhhhhhhcccccffffsssssstt "	^ 2r00000000000000000000000011111100! !!NBObjectFormat32 methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 5/19/2010 11:29'!oopSize	^ 4! !!NBObjectFormat32 methodsFor: 'emitting tests' stamp: 'HenrikSperreJohansen 8/23/2011 01:51'!sizeOf: headerRegister is: anImmediate ifNotJumpTo: aLabel	asm 	and: headerRegister with: self objectSizeMask;		xor: headerRegister with: (anImmediate bitShift: self sizeShift);		jnz: aLabel! !!NBObjectFormat32 methodsFor: 'header shifts' stamp: 'HenrikSperreJohansen 8/23/2011 00:55'!sizeShift	^ 2! !!NBObjectFormat32 methodsFor: 'sizes' stamp: 'HenrikSperreJohansen 8/23/2011 21:50'!stackArgumentSize	"a default number of bytes on stack used by a single argument,	for calling proxy functions"		^self oopSize! !!NBObjectFormat32 methodsFor: 'testing' stamp: 'IgorStasenko 8/5/2011 18:14'!stackGrowsDown	"Squeak interpreter stack grows up, while StackInterpreter down"	^ self isCogVM! !!NativeBoost class methodsFor: 'retrieving symbols' stamp: 'Igor.Stasenko 9/26/2010 04:58'!CLibrary	"answer a C library path, or module handle,	use in FFI callouts as module: argument to call C run-time library function(s)"		^ self forCurrentPlatform CLibrary! !!NativeBoost class methodsFor: 'retrieving symbols' stamp: 'JavierPimas 9/27/2011 14:48'!VMModule	"answer a C library path, or module handle,	use in FFI callouts as module: argument to call C run-time library function(s)"		^ self forCurrentPlatform VMModule! !!NativeBoost class methodsFor: 'memory access' stamp: 'Igor.Stasenko 5/5/2010 14:55'!allocate: size	^ self forCurrentPlatform allocate: size! !!NativeBoost class methodsFor: 'accessing' stamp: 'IgorStasenko 3/28/2012 17:44'!announcer	^ NBAnnouncer ifNil: [ NBAnnouncer := Announcer new ].! !!NativeBoost class methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/2/2010 19:10'!callgateFunctionAddress	^ self forCurrentPlatform callgateFunctionAddress! !!NativeBoost class methodsFor: 'accessing' stamp: 'IgorStasenko 5/10/2011 15:27'!clearNativeCode	"Unconditionally clear all method's native code trailers using a single bulk-become"	| old new |	self isEnabled ifFalse: [ Current := nil ].		Current ifNotNil: [		Current insideCallback ifTrue: [			self error: 'Clearing a native code while inside a callback' ]].		old := OrderedCollection new.	new := OrderedCollection new.		CompiledMethod allInstancesDo: [:method | | trailer |		trailer := method trailer.		trailer kind == #NativeCodeTrailer ifTrue: [			old add: method.			new add: (method copyWithTrailerBytes: 				(CompiledMethodTrailer new sourcePointer: trailer sourcePointer))			]	]. 		old asArray elementsForwardIdentityTo: new asArray! !!NativeBoost class methodsFor: 'system startup' stamp: 'IgorStasenko 5/11/2011 00:55'!discoverPlatformId		| platId |		"should not use it, if Current already set"	self assert: (Current isNil). 	platId := self platformId. 	self allSubclassesDo: [:class |		class targetPlatformId = platId ifTrue: [ 			class new  " should set Current during initialization"	]].	Current isNil ifTrue: [ self unsupportedPlatform ].		^ Current ! !!NativeBoost class methodsFor: 'system startup' stamp: 'IgorStasenko 5/11/2011 00:50'!enableNativeCode	"Enable the native code,	answer true if operation was successfull or false if not"		self isEnabled ifFalse: [		"If native code is disable in plugin, this means 		that a system is just started.		Create a fresh instance of receiver "		Current := nil. 	].	self forCurrentPlatform. 	^ Current notNil! !!NativeBoost class methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/2/2010 13:04'!extraRootsRegistry	^ self forCurrentPlatform extraRootsRegistry! !!NativeBoost class methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/18/2010 23:14'!forCurrentPlatform	"answer my subclass instance, suitable for use on current platform"	self isEnabled ifFalse: [ Current := nil ].		^ Current ifNil: [ self discoverPlatformId ]! !!NativeBoost class methodsFor: 'memory access' stamp: 'Igor.Stasenko 5/5/2010 14:55'!free: address	^ self forCurrentPlatform free: address! !!NativeBoost class methodsFor: 'class initialization' stamp: 'IgorStasenko 3/19/2012 12:43'!initialize "self initialize"	self registerPrimitiveSimulators! !!NativeBoost class methodsFor: 'testing' stamp: 'Igor.Stasenko 9/26/2010 06:28'!insideCallback	^ self forCurrentPlatform insideCallback! !!NativeBoost class methodsFor: 'testing' stamp: 'Igor.Stasenko 5/2/2010 11:00'!isEnabled	"Answer flag indicating whether running a native code enabled by plugin"		<primitive: #primitiveIsEnabled module: #NativeBoostPlugin>		^ self primitiveFailed! !!NativeBoost class methodsFor: 'testing' stamp: 'IgorStasenko 5/28/2012 03:49'!isEnabledOrNil	"Answer flag indicating whether running a native code enabled by plugin"		<primitive: #primitiveIsEnabled module: #NativeBoostPlugin>		^ nil! !!NativeBoost class methodsFor: 'debugger support' stamp: 'Igor.Stasenko 5/17/2010 22:01'!isNativeMethod: aCompiledMethod	| lit |		lit := aCompiledMethod literalAt: 1.	^ aCompiledMethod trailer kind == #NativeCodeTrailer 		and: [ lit first == #NativeBoostPlugin and: [ lit second == #primitiveNativeCall]]! !!NativeBoost class methodsFor: 'errors' stamp: 'IgorStasenko 8/6/2011 17:42'!lastError	<primitive: #primitiveLastNativeCodeError module: #NativeBoostPlugin>	^ self error: 'NativeBoost plugin is not installed?'! !!NativeBoost class methodsFor: 'retrieving symbols' stamp: 'CamilloBruni 7/19/2012 11:50'!loadFunction: fnName	^ self loadFunction: fnName from: ''! !!NativeBoost class methodsFor: 'retrieving symbols' stamp: 'CamilloBruni 7/19/2012 11:50'!loadFunction: fnName from: aModuleName	^ self forCurrentPlatform 		loadFunction: fnName from: aModuleName! !!NativeBoost class methodsFor: 'retrieving symbols' stamp: 'CamilloBruni 7/19/2012 11:51'!loadSymbol: aSymbolName	^ self loadSymbol: aSymbolName fromModule: ''! !!NativeBoost class methodsFor: 'retrieving symbols' stamp: 'CamilloBruni 7/19/2012 11:50'!loadSymbol: aSymbolName fromModule: moduleName	^ self forCurrentPlatform 		loadSymbol: aSymbolName fromModule: moduleName! !!NativeBoost class methodsFor: 'memory access' stamp: 'Igor.Stasenko 5/13/2010 23:06'!memCopy: src to: dst size: numBytes	^ self forCurrentPlatform memCopy: src to: dst size: numBytes! !!NativeBoost class methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/5/2010 16:46'!newAssembler	^ self forCurrentPlatform  newAssembler! !!NativeBoost class methodsFor: 'subscribing for session change' stamp: 'IgorStasenko 3/28/2012 17:48'!notifyAboutSessionChange: anObject	"register an object to be notified about session change"	self announcer weak on: NBSessionChangeAnnouncement send: #nbSessionChanged  to: anObject! !!NativeBoost class methodsFor: 'platform id' stamp: 'Igor.Stasenko 5/2/2010 11:07'!platformId	<primitive: 'primitivePlatformId' module: 'NativeBoostPlugin'>		" do not fail, answer nil instead"	^ nil! !!NativeBoost class methodsFor: 'testing' stamp: 'Igor.Stasenko 9/25/2010 05:16'!primitiveLoadMainModule	"Answer flag indicating whether running a native code enabled by plugin"		<primitive: #primitiveLoadMainModule module: #NativeBoostPlugin>		^ self primitiveFailed! !!NativeBoost class methodsFor: 'debugger support' stamp: 'IgorStasenko 3/19/2012 12:42'!registerPrimitiveSimulators	ContextPart simulatePrimitive: #primitiveNativeCall module: #NativeBoostPlugin with: self! !!NativeBoost class methodsFor: 'private' stamp: 'IgorStasenko 5/11/2011 00:48'!resetInstance	"!!!!!!!! Never use it !!!!!!!!	It is here only for development purposes"	Current := nil.! !!NativeBoost class methodsFor: 'testing' stamp: 'IgorStasenko 5/28/2012 03:58'!sessionChanged: anOldSession	"Answer true if session has changed.	Do a quick test if NB plugin is not enabled yet to prevent fails in	resource finalization during image startup.		anOldSession is object which retrieved before, using #uniqueSessionObject message.	"	self isEnabledOrNil == true ifTrue: [		Current ifNil: [ ^ true ].		^ (Current callgateFunctionAddress  == anOldSession) not	].	"plugin is not enabled, or prim failed, assume session changed"	^ true	! !!NativeBoost class methodsFor: 'debugger support' stamp: 'IgorStasenko 3/19/2012 13:17'!simulatePrimitiveFor: aMethod receiver: recvr arguments: args context: ctx	^ self tryRunNativeCode: aMethod for: recvr withArgs: args! !!NativeBoost class methodsFor: 'platform id' stamp: 'Igor.Stasenko 4/29/2010 04:27'!targetPlatformId	"Should be implemented by subclasses to indicate a target platform.		Answer zero - a non-existing platform id	"		^ 0! !!NativeBoost class methodsFor: 'debugger support' stamp: 'IgorStasenko 3/19/2012 13:38'!tryRunNativeCode: aCompiledMethod for: aReceiver withArgs: arguments	"run only a native code of given method,	and if it fails evaluate aFailBlock instead"	| src node m |	"self assert: (self isNativeMethod: aCompiledMethod)."		src := String streamContents: [:str |		str nextPutAll: 'NBDebug_stub'.		1 to: aCompiledMethod numArgs do: [:i  |			i = 1 				ifTrue: [ str nextPutAll: ': ' ]				ifFalse: [ str nextPutAll: ' with: ' ].			str nextPutAll: 'arg'.			i printOn: str.		].		str cr;		nextPutAll: ' <primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode >'; cr;		nextPutAll: ' ^ ContextPart primitiveFailTokenFor: errorCode'.	].	node := Compiler new 		compile: src 		in: aCompiledMethod methodClass		classified: nil 		notifying: nil 		ifFail: [ ^ ContextPart primitiveFailTokenFor: nil ].	m := node generate: aCompiledMethod trailer.	m flushCache.	m selector flushCache.		^ m valueWithReceiver: aReceiver arguments: arguments.	! !!NativeBoost class methodsFor: 'memory access' stamp: 'Igor.Stasenko 5/3/2010 10:27'!ulongAt: ulongAddr	^ self forCurrentPlatform ulongAt: ulongAddr! !!NativeBoost class methodsFor: 'accessing' stamp: 'IgorStasenko 5/28/2012 08:13'!uniqueSessionObject	"Answer an unique session object, which changes between	image restarts.	A call gate function is a good candidate for this, since its generated each time	when image first boots. "	^ self forCurrentPlatform callgateFunctionAddress ! !!NativeBoost class methodsFor: 'errors' stamp: 'IgorStasenko 5/11/2011 00:55'!unsupportedPlatform 	self error: 'You running on platform which not supported by NativeBoost'! !!NativeBoost methodsFor: 'retrieving symbols' stamp: 'Igor.Stasenko 9/26/2010 04:59'!CLibrary	"answer a C library path, or module handle,	use in FFI callouts as module: argument to call C run-time library function(s)"		self subclassResponsibility ! !!NativeBoost methodsFor: 'retrieving symbols' stamp: 'JavierPimas 9/27/2011 14:47'!VMModule	"answer a C library path, or module handle,	use in FFI callouts as module: argument to call C run-time library function(s)"		self subclassResponsibility ! !!NativeBoost methodsFor: 'memory operations' stamp: 'Igor.Stasenko 9/25/2010 10:03'!allocate: aSize	"Allocate a memory block with given size in bytes,	answer an NBExternalAddress instance - address to the beginning of memory block"		" DO NOT OVERRIDE. Override #basicAllocate: instead"	| addr |	addr := self basicAllocate: aSize.	addr ifNil: [ self allocationFailed ].	^ addr! !!NativeBoost methodsFor: 'memory operations' stamp: 'Igor.Stasenko 5/3/2010 11:03'!allocationFailed	self error: 'Memory allocation failed'! !!NativeBoost methodsFor: 'memory operations' stamp: 'Igor.Stasenko 5/3/2010 10:58'!basicAllocate: aSize	"Allocate a memory block with given size in bytes,	answer an NBExternalAddress instance - address to the beginning of memory block,	or nil if allocation fails."	self subclassResponsibility ! !!NativeBoost methodsFor: 'bootstrapping' stamp: 'IgorStasenko 11/24/2012 15:52'!bootstrapLoadFunction: fnName from: aModuleName into: returnValueBuffer	<primitive: 'primitiveNativeCall' module: 'NativeBoostPlugin'>	" call an interpreter proxy function 		void* ioLoadFunctionFrom(char*, char*)	to retrieve a function pointer of a registered module	"	^ self nbCallout 		function: #( NBBootstrapUlong (String fnName,  String aModuleName) )		emit: [:gen |	gen proxy callFn: #ioLoadFunction:From: ].	! !!NativeBoost methodsFor: 'bootstrapping' stamp: 'IgorStasenko 11/24/2012 15:55'!bootstrapLoadModule: aModuleName ofLength: len into: returnValueBuffer	" call an interpreter proxy function 		void* ioLoadModuleOfLength(char*, int)	to retrieve an external module handle		Returning a long 32 bit value may trigger GC. So, we need a gate function for it,	which we can't have without loading external stuff, so we store result into a byte array	"	<primitive: 'primitiveNativeCall' module: 'NativeBoostPlugin'>	^ self nbCallout 		options: #( - optDirectProxyFnAddress optAllowExternalAddressPtr);		function: #( NBBootstrapUlong (byte * aModuleName , long len) )		emit:  [:gen | 	gen proxy callFn: #ioLoadModule:OfLength: .  ] ! !!NativeBoost methodsFor: 'bootstrapping' stamp: 'IgorStasenko 11/24/2012 15:56'!bootstrapLoadSymbol: symbolName ofLength: symbolLen fromModule: moduleHandleinto: returnValueBuffer	" call an interpreter proxy function void *ioLoadSymbolOfLengthFromModule(sqInt functionNameIndex, sqInt functionNameLength, void *moduleHandle)			to retrieve an external module handle		Returning a long 32 bit value may trigger GC which can move native code.	In order to avoid that, we don't use any proxy function, which may lead to memory allocation.	Thus, we store result into a byte array.	"	<primitive: 'primitiveNativeCall' module: 'NativeBoostPlugin'>	^ self nbCallout 		options: #( - optDirectProxyFnAddress optAllowExternalAddressPtr);		function: #( NBBootstrapUlong (byte * symbolName , long symbolLen, ulong moduleHandle) )		emit:  [:gen |			gen proxy callFn: #ioLoadSymbol:OfLength:FromModule: 		] ! !!NativeBoost methodsFor: 'callback support' stamp: 'Igor.Stasenko 9/26/2010 04:37'!callbackCounterAddress	^ callbackCounterAddr! !!NativeBoost methodsFor: 'accessing' stamp: 'IgorStasenko 5/28/2012 07:00'!callgateFunctionAddress		^ gateFunction ifNil: [		| bytes addr |		NBRecursionDetect 			in: #callgateFunctionAddress during: [					bytes := self generateCallgateCode.			self assert: (bytes class isBytes).					addr := self allocate: bytes size.			"copy generated bytes to external memory"			self memCopy: bytes to: addr size: bytes size.		].	  		"finally set the function address"		gateFunction := addr. 		bootstrapping := false.		gateFunction 	]! !!NativeBoost methodsFor: 'accessing' stamp: 'Igor.Stasenko 9/25/2010 10:12'!extraRootsRegistry	^ extraRootsRegistry ifNil: [			rootsCell := self allocate: (self pointerSize).		extraRootsRegistry := NBExtraRootsRegistry newWithCell: rootsCell	]! !!NativeBoost methodsFor: 'memory operations' stamp: 'Igor.Stasenko 9/26/2010 04:12'!free: address	"Free the external memory, allocated using #allocate: message.	Note: never pass pointers, which you allocated by other means"		self subclassResponsibility ! !!NativeBoost methodsFor: 'bootstrapping' stamp: 'IgorStasenko 8/3/2011 09:22'!generateCallgateCode			"Answer a byte array of generated native code for gate function.	We assume that caller reserves two temporaries on his stack frame	[EBP-4], [EBP-8] for saving return address and pritimiveMethod oop"	| asm primitiveMethod savedMethodOop returnAddr |	asm :=  self newAssembler noStackFrame.	savedMethodOop := EBP ptr - 4. 	returnAddr := EBP ptr - 8.		primitiveMethod := NBInterpreterProxy fnAddressAt: #primitiveMethod.		asm		mov: primitiveMethod to: EAX;		call: EAX;  " retrieve a primitive method oop "		mov: EAX to: savedMethodOop;		pop: returnAddr; "store return address"		pop: EAX; "function to call"		call: EAX;  " call the function "		push: returnAddr; "push return addr back on stack"		push: EAX; " save return value "		push: EDX;		mov: primitiveMethod to: EAX;		call: EAX;  " retrieve a primitive method oop "		sub: EAX with: savedMethodOop;		add: ESP ptr+8 with: EAX;  " current - old + returnAddress "		pop: EDX;		pop: EAX;		ret.			^ asm bytes! !!NativeBoost methodsFor: 'initialize-release' stamp: 'cipt 11/3/2012 18:28'!initialize	"once we have call gate function, we can turn bootstrapping mode off"	bootstrapping := true.		"first, wipe out all native code from image"	self class clearNativeCode.		"now, we can enable the native code"	self primEnableNativeCode.		Current := self.   "set the class var"	"Init basic stuff"	self initializeExternalHeap.			"callback counter"	callbackCounterAddr := self allocate: 4.	callbackCounterAddr nbInt32AtOffset: 0 put:  0.	" finally, generate callgate function to finish bootstrap procedure"	self callgateFunctionAddress.	"notify any observers about session change"	self class announcer announce: NBSessionChangeAnnouncement ! !!NativeBoost methodsFor: 'bootstrapping' stamp: 'Igor.Stasenko 5/2/2010 14:01'!initializeExternalHeap		"create and initialize a new instance of external memory heap"	self subclassResponsibility! !!NativeBoost methodsFor: 'callback support' stamp: 'cipt 11/3/2012 18:28'!insideCallback	bootstrapping ifTrue: [ ^ false ].	^ (callbackCounterAddr nbInt32AtOffset:  0) ~= 0! !!NativeBoost methodsFor: 'retrieving symbols' stamp: 'IgorStasenko 11/24/2012 15:56'!ioLoadFunction: fnName from: aModuleName	<primitive: 'primitiveNativeCall' module: 'NativeBoostPlugin'>	" call an interpreter proxy function 		void* ioLoadFunctionFrom(char*, char*)	to retrieve a function pointer of a registered module	"	^ self nbCallout		function: #( ulong (String fnName,  String aModuleName) )		emit: [:gen |	gen proxy callFn: #ioLoadFunction:From: ].	! !!NativeBoost methodsFor: 'retrieving symbols' stamp: 'Igor.Stasenko 5/2/2010 16:35'!ioLoadModule: aModuleName	" call an interpreter proxy function 		void* ioLoadModuleOfLength(char*, int)	to retrieve an external module handle		if module can't be loaded, or not found , answer nil	"	<primitive: 'primitiveNativeCall' module: 'NativeBoostPlugin'>	^ NBNativeCodeGen methodAssembly: [:gen |		| fail retHandle proxy asm moduleNameOop end |		moduleNameOop := gen reserveTemp.		asm := gen asm.		proxy := gen proxy.		fail := asm uniqueLabelName: 'failed'.		retHandle := asm uniqueLabelName: 'retHandle'.		end := asm uniqueLabelName: 'end'.				proxy stackValue: 0.		asm mov: EAX to: moduleNameOop.		proxy isBytes: EAX.		asm or: EAX with: EAX.		asm jz: fail.		proxy byteSizeOf: moduleNameOop.		asm push: EAX.   " push length "			proxy firstIndexableField: moduleNameOop.		asm push: EAX. "push first indexable field address"				proxy callFn: #ioLoadModule:OfLength: .		asm 			or: EAX with: EAX;			jnz: retHandle.					proxy nilObject.		asm jmp: end.			asm label: retHandle.		proxy signed32BitIntegerFor: EAX.		asm jmp: end.			asm label: fail.		proxy primitiveFail.	asm label: end.		gen epilogue	]! !!NativeBoost methodsFor: 'testing' stamp: 'Igor.Stasenko 9/25/2010 07:32'!isBootstrapping	^ bootstrapping! !!NativeBoost methodsFor: 'retrieving symbols' stamp: 'IgorStasenko 11/24/2012 15:57'!loadFunction: fnName from: aModuleName	<primitive: 'primitiveNativeCall' module: 'NativeBoostPlugin'>	" call an interpreter proxy function 		void* ioLoadFunctionFrom(char*, char*)	to retrieve a function pointer of a registered module	"	^ self nbCallout 		function: #( void* (String fnName,  String aModuleName) )		emit: [:gen |	gen proxy callFn: #ioLoadFunction:From: ].	! !!NativeBoost methodsFor: 'retrieving symbols' stamp: 'IgorStasenko 11/24/2012 15:58'!loadModule: aModuleName	" call an interpreter proxy function 		void* ioLoadModuleOfLength(char*, int)	to retrieve an external module handle		if module can't be loaded, or not found , answer 0	"	<primitive: 'primitiveNativeCall' module: 'NativeBoostPlugin'>	^ self nbCallout			options: #(- optAllowExternalAddressPtr);			function: #( ulong (char* aModuleName, NBByteArraySize aModuleName ))			emit: [:gen |				gen proxy callFn: #ioLoadModule:OfLength: .			] ! !!NativeBoost methodsFor: 'retrieving symbols' stamp: 'IgorStasenko 11/18/2012 17:05'!loadSymbol: aSymbolName fromModule: moduleName	"module could be a string (name) or handle "	| bytes module handle |		bytes := ByteArray new: 8.	moduleName isString ifTrue: [				self 			bootstrapLoadModule: moduleName 			ofLength: moduleName size 			into: bytes.			module := bytes unsignedLongAt: 1 bigEndian: false.		module = 0 ifTrue: [ ^ nil ].	] ifFalse: [		"if value is negative, use 32-bit complement"		module := moduleName bitAnd: 16rFFFFFFFF.	].	self bootstrapLoadSymbol: aSymbolName 		ofLength: aSymbolName size fromModule: module into: bytes.	handle := bytes unsignedLongAt: 1 bigEndian: false.	handle = 0 ifTrue: [ ^ nil ].	^ NBExternalAddress value: handle! !!NativeBoost methodsFor: 'memory operations' stamp: 'IgorStasenko 12/6/2012 14:43'!memCopy: src to: dst size: numBytes	"Copy the numBytes from src to dst memory buffer.	src & dst can be either a variable-byte oop or NBExternalAddress instance.		Warning!!!! Warning!!!! Warning!!!! 	This is a direct memory accees!!!!!! No range checking!!!!!!	"		<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout		options: #( + optAllowByteArraysPtr optAllowExternalAddressPtr);	 	function: #( void (byte * src, byte * dst, ulong numBytes))		emit: [:gen |			| asm temp1 temp2 |			asm := gen asm.			temp1 := gen reserveTemp.			temp2 := gen reserveTemp.			asm				cld;				mov: ESI to: temp1;				mov: EDI to: temp2;							pop: ESI; " src"				pop: EDI; "dst"				pop: ECX; "numBytes"				rep; movsb;				mov: temp1 to: ESI;				mov: temp2 to: EDI		]! !!NativeBoost methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/5/2010 16:47'!newAssembler	self subclassResponsibility ! !!NativeBoost methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 5/2/2010 13:52'!pointerSize	self subclassResponsibility ! !!NativeBoost methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 5/2/2010 13:36'!primEnableNativeCode	"Primitive.	Enables the execution of native code, which initially disabled during fresh image boot "	<primitive: #primitiveEnable module: #NativeBoostPlugin> ! !!NativeBoost methodsFor: 'memory access' stamp: 'Igor.Stasenko 5/3/2010 10:31'!ulongAt: ulongAddr	| buf |		buf := ByteArray new: 8.		self ulongAt: ulongAddr into: buf.		^ buf unsignedLongAt: 1 bigEndian: false! !!NativeBoost methodsFor: 'memory access' stamp: 'IgorStasenko 11/24/2012 16:01'!ulongAt: addr into: returnValueBuffer	"read uint from given address"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>	^ self nbCallout		" do not use optimizations, since it may lead to infinite resursion"		options: #( - optDirectProxyFnAddress optUseStackPointer + optNoAlignment);		function: #( NBBootstrapUlong (ulong addr))		emit: [:gen | |asm|			asm := gen asm.			asm pop: asm EAX.			asm mov: asm EAX ptr to: asm EAX			]! !!Behavior methodsFor: '*NativeBoost-Core' stamp: 'Igor.Stasenko 9/28/2010 08:03'!externalTypeAlias: aTypeName	"override, if you want to introduce type aliases.	Answering nil means no type alias for given type name exists"	^ nil! !!Behavior methodsFor: '*NativeBoost-Core' stamp: 'Igor.Stasenko 5/18/2010 13:02'!nbBindingOf: aName	"answer a binding for a type name,	by default use smalltalk name bindings"	^ self bindingOf: aName! !!Behavior methodsFor: '*NativeBoost-Core' stamp: 'Igor.Stasenko 4/30/2010 12:34'!nbFnArgument: argName generator: gen	"Load the instance variable with given name" 	(self allInstVarNames includes: argName) ifFalse: [ ^ nil ].	^ NBSTIvarArgument new receiverClass: self; ivarName: argName! !!AJImmediate methodsFor: '*NativeBoost-core' stamp: 'IgorStasenko 11/18/2012 16:49'!asNBExternalType: gen	 	^ NBFFIConst value: self! !!Trait method!nbFloat32AtOffset: zeroBasedOffset	"Read 32-bit float at ZERO-based index.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(float32 (self, ulong zeroBasedOffset)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			add: asm EAX with: asm ECX;			fld: asm EAX ptr32. "load a floating point value from memory, at base address, held in EAX register into fp(0) register,				we are using #ptr32, to indicate that memory operand size is 32bits long"	] ! !!Trait method!nbFloat32AtOffset: zeroBasedOffset put: value	"Store 32-bit float at ZERO-based index.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(void (self, ulong zeroBasedOffset, float32 value)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			pop: asm EDX;			mov: asm EDX to: asm EAX ptr + asm ECX	] ! !!Trait method!nbFloat64AtOffset: zeroBasedOffset	"Read 64-bit float at ZERO-based index.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(float64 (self, ulong zeroBasedOffset)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "index"			add: asm EAX with: asm ECX;			fld: asm EAX ptr64. "load a floating point value from memory, at base address, held in EAX register into fp(0) register,				we are using #ptr64, to indicate that memory operand size is 64bits long"	] ! !!Trait method!nbFloat64AtOffset: zeroBasedOffset put: value	"Store 64-bit float at ZERO-based index.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(void (self, ulong zeroBasedOffset, float64 value)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			add: asm EAX with: asm ECX;						mov: asm ESP ptr to: asm ECX;			mov: asm ECX to: asm EAX ptr;			mov: asm ESP ptr +4 to: asm ECX;			mov: asm ECX to: asm EAX ptr +4 	] ! !!Trait method!nbInt16AtOffset: zeroBasedOffset		"Reads signed 16-bit integer from memory at (receiver's address + ZERO-based offset) using native byte order.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(int16 (self, ulong zeroBasedOffset)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			mov: asm EAX ptr16 + asm ECX to: asm AX	]! !!Trait method!nbInt16AtOffset: zeroBasedOffset  put: value		"Store signed 16-bit integer into memory at (receiver's address + ZERO-based offset) using native byte order.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(void (self, ulong zeroBasedOffset, int16 value)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			pop: asm EDX; "value"			mov: asm DX to: asm EAX ptr16 + asm ECX	]! !!Trait method!longAt: zeroBasedOffset		"Reads signed 32-bit integer from memory at (receiver's address + ZERO-based offset) using native byte order.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(int32 (self, ulong zeroBasedOffset)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			mov: asm EAX ptr32 + asm ECX to: asm EAX	]! !!Trait method!nbInt32AtOffset: zeroBasedOffset		"Reads signed 32-bit integer from memory at (receiver's address + ZERO-based offset) using native byte order.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(int32 (self, ulong zeroBasedOffset)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			mov: asm EAX ptr32 + asm ECX to: asm EAX	]! !!Trait method!longAt: zeroBasedOffset  put: value		"Store signed 32-bit integer into memory at (receiver's address + ZERO-based offset) using native byte order.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(void (self, ulong zeroBasedOffset, int32 value)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			pop: asm EDX; "value"			mov: asm EDX to: asm EAX ptr32 + asm ECX	]! !!Trait method!nbInt32AtOffset: zeroBasedOffset  put: value		"Store signed 32-bit integer into memory at (receiver's address + ZERO-based offset) using native byte order.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(void (self, ulong zeroBasedOffset, int32 value)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			pop: asm EDX; "value"			mov: asm EDX to: asm EAX ptr32 + asm ECX	]! !!Trait method!nbInt64AtOffset: zeroBasedOffset		"Reads signed 64-bit integer from memory at (receiver's address + ZERO-based offset) using native byte order.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(int64 (self, ulong zeroBasedOffset)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			mov: asm EAX ptr + asm ECX + 4 to: asm EDX;			mov: asm EAX ptr + asm ECX to: asm EAX	]! !!Trait method!nbInt64AtOffset: zeroBasedOffset  put: value		"Store signed 64-bit integer into memory at (receiver's address + ZERO-based offset) using native byte order.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(void (self, ulong zeroBasedOffset, int64 value)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			pop: asm EDX; "value low word"			mov: asm EDX to: asm EAX ptr32 + asm ECX;			pop: asm EDX; "value high word"			mov: asm EDX to: asm EAX ptr32 + asm ECX + 4	]! !!Trait method!nbInt8AtOffset: zeroBasedOffset		"Reads signed 8-bit integer from memory at (receiver's address + ZERO-based offset) using native byte order.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(int8 (self, ulong zeroBasedOffset)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			mov: asm EAX ptr8 + asm ECX to: asm AL	]! !!Trait method!byteAt: zeroBasedOffset		"Reads signed 8-bit integer from memory at (receiver's address + ZERO-based offset) using native byte order.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(int8 (self, ulong zeroBasedOffset)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			mov: asm EAX ptr8 + asm ECX to: asm AL	]! !!Trait method!nbInt8AtOffset: zeroBasedOffset  put: value		"Store signed 8-bit integer into memory at (receiver's address + ZERO-based offset) using native byte order.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(void (self, ulong zeroBasedOffset, int8 value)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			pop: asm EDX; "value"			mov: asm DL to: asm EAX ptr8 + asm ECX	]! !!Trait method!byteAt: zeroBasedOffset  put: value		"Store signed 8-bit integer into memory at (receiver's address + ZERO-based offset) using native byte order.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(void (self, ulong zeroBasedOffset, int8 value)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			pop: asm EDX; "value"			mov: asm DL to: asm EAX ptr8 + asm ECX	]! !!Trait method!nbUInt16AtOffset: zeroBasedOffset		"Reads unsigned 16-bit integer from memory at (receiver's address + ZERO-based offset) using native byte order.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(uint16 (self, ulong zeroBasedOffset)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			mov: asm EAX ptr16 + asm ECX to: asm AX	]! !!Trait method!nbUInt16AtOffset: zeroBasedOffset  put: value		"Store unsigned 16-bit integer into memory at (receiver's address + ZERO-based offset) using native byte order.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(void (self, ulong zeroBasedOffset, uint16 value)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			pop: asm EDX; "value"			mov: asm DX to: asm EAX ptr16 + asm ECX	] ! !!Trait method!nbUInt32AtOffset: zeroBasedOffset		"Reads unsigned 32-bit integer from memory at (receiver's address + ZERO-based offset) using native byte order.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(uint32 (self, ulong zeroBasedOffset)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			mov: asm EAX ptr32 + asm ECX to: asm EAX	]! !!Trait method!ulongAt: zeroBasedOffset		"Reads unsigned 32-bit integer from memory at (receiver's address + ZERO-based offset) using native byte order.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(uint32 (self, ulong zeroBasedOffset)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			mov: asm EAX ptr32 + asm ECX to: asm EAX	]! !!Trait method!ulongAt: zeroBasedOffset  put: value		"Store unsigned 32-bit integer into memory at (receiver's address + ZERO-based offset) using native byte order.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(void (self, ulong zeroBasedOffset, uint32 value)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			pop: asm EDX; "value"			mov: asm EDX to: asm EAX ptr32 + asm ECX	]! !!Trait method!nbUInt32AtOffset: zeroBasedOffset  put: value		"Store unsigned 32-bit integer into memory at (receiver's address + ZERO-based offset) using native byte order.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(void (self, ulong zeroBasedOffset, uint32 value)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			pop: asm EDX; "value"			mov: asm EDX to: asm EAX ptr32 + asm ECX	]! !!Trait method!nbUInt64AtOffset: zeroBasedOffset		"Reads unsigned 64-bit integer from memory at (receiver's address + ZERO-based offset) using native byte order.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(uint64 (self, ulong zeroBasedOffset)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			mov: asm EAX ptr + asm ECX + 4 to: asm EDX;			mov: asm EAX ptr + asm ECX to: asm EAX	]! !!Trait method!nbUInt64AtOffset: zeroBasedOffset  put: value		"Store unsigned 64-bit integer into memory at (receiver's address + ZERO-based offset) using native byte order.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function:  #(void (self, ulong zeroBasedOffset, uint64 value)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			pop: asm EDX; "value low word"			mov: asm EDX to: asm EAX ptr32 + asm ECX;			pop: asm EDX; "value high word"			mov: asm EDX to: asm EAX ptr32 + asm ECX + 4	]! !!Trait method!nbUInt8AtOffset: zeroBasedOffset		"Reads unsigned 8-bit integer from memory at (receiver's address + ZERO-based offset) using native byte order.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(uint8 (self, ulong zeroBasedOffset)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			mov: asm EAX ptr8 + asm ECX to: asm AL	]! !!Trait method!nbUInt8AtOffset: zeroBasedOffset  put: value		"Store unsigned 8-bit integer into memory at (receiver's address + ZERO-based offset) using native byte order.	Note, there is no range checking "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(void (self, ulong zeroBasedOffset, uint8 value)) emit: [:gen |		| asm |				asm := gen asm.		asm 			pop: asm EAX;  "pointer to receiver's first byte"			pop: asm ECX; "offset"			pop: asm EDX; "value"			mov: asm DL to: asm EAX ptr8 + asm ECX	] ! !"NativeBoost-Core"!!NBUnixExternalHeapManager commentStamp: 'Igor.Stasenko 9/26/2010 04:05' prior: 0!Unix heap implementation, based on mmap()/munmap()functions to manage external heap.!!NBUnixConstants class methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 9/25/2010 08:37'!initDlopenFlags"From <bits/dlfcn.h>"" The MODE argument to `dlopen' contains one of the following: "	RTLD_LAZY	 := 16r00001. "Lazy function call binding."	RTLD_NOW := 16r00002. " Immediate function call binding. "	RTLD_BINDING_MASK := 16r3. " Mask of binding time value. "	RTLD_NOLOAD	:= 16r00004. " Do not load the object."	RTLD_DEEPBIND := 16r00008. " Use deep binding. "" If the following bit is set in the MODE argument to `dlopen',   the symbols of the loaded object and its dependencies are made   visible as if the object were linked directly into the program.  "	RTLD_GLOBAL := 16r00100." Unix98 demands the following flag which is the inverse to RTLD_GLOBAL.   The implementation does this by default and so we can define the   value to zero.  "	RTLD_LOCAL := 0." Do not delete object when closed.  "	RTLD_NODELETE := 16r01000.	" From <dlfcn.h> "" If the first argument of `dlsym' or `dlvsym' is set to RTLD_NEXT   the run-time address of the symbol called NAME in the next shared   object is returned.  The 'next' relation is defined by the order   the shared objects were loaded.  "	RTLD_NEXT := 16rFFFFFFFF.  "  ((void *) -1l) "   " If the first argument to `dlsym' or `dlvsym' is set to RTLD_DEFAULT   the run-time address of the symbol called NAME in the global scope   is returned.  " 	RTLD_DEFAULT := 0.    ! !!NBUnixConstants class methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 9/25/2010 09:12'!initMmapFlags	"From <bits/mman.h>"	" Memory protection flags, can be bitored "				PROT_READ := 16r1.	" Page can be read.  "	PROT_WRITE := 16r2.	" Page can be written. "	PROT_EXEC := 16r4.	" Page can be executed. "	PROT_NONE := 16r0. 	" Page can not be accessed. "	PROT_GROWSDOWN  := 16r01000000. " Extend change to start of growsdown vma (mprotect only). "	PROT_GROWSUP := 16r02000000. "Extend change to start of growsup vma (mprotect only). "		" Sharing types (must choose one and only one of these). "	MAP_SHARED := 16r01.		"Share changes."	MAP_PRIVATE := 16r02.		"Changes are private."		MAP_TYPE := 16r0f. 	"Mask for type of mapping. "	" Other flags. "	MAP_FIXED := 16r10.	"Interpret addr exactly. "	MAP_FILE := 0.	MAP_ANONYMOUS := 16r20. "Don't use a file."	MAP_ANON := MAP_ANONYMOUS.	MAP_32BIT := 16r40.	"Only give out 32-bit addresses."	"These are Linux-specific."	MAP_GROWSDOWN := 16r00100.	"Stack-like segment."	MAP_DENYWRITE := 16r00800.		" ETXTBSY "	MAP_EXECUTABLE := 16r01000.	" Mark it as an executable."	MAP_LOCKED := 16r02000. 		" Lock the mapping. "	MAP_NORESERVE := 16r04000.		" Don't check for reservations. "	MAP_POPULATE := 16r08000.		" Populate (prefault) pagetables. "	MAP_NONBLOCK := 16r10000.		" Do not block on IO."	MAP_STACK := 16r20000.			" Allocation is for a stack. "	MAP_FAILED := 16rFFFFFFFF.  "-1"! !!NBUnixConstants class methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 9/25/2010 06:57'!initialize	" self initialize "	"from <bits/mman.h>"	self		initDlopenFlags;		initMmapFlags! !!NBUnixExternalHeapManager methodsFor: 'flags' stamp: 'Igor.Stasenko 9/25/2010 08:49'!mapFlags	^ MAP_ANON bitOr: MAP_PRIVATE! !!NBUnixExternalHeapManager methodsFor: 'private' stamp: 'IgorStasenko 11/24/2012 17:24'!mmapLength: bytesToAllocate prot: protFlags flags: mapFlags into: returnValueBuffer			<primitive: #primitiveNativeCall module: #NativeBoostPlugin>	"Note:  mmap using 32-bit offset, while mmap64 - 64bit one"	^ self nbCallout 		options: #( - optDirectProxyFnAddress );		function: #(			NBBootstrapUlong ( 0, uint bytesToAllocate, int protFlags, int mapFlags,				-1,  0 "offset" )				) emit:  [:gen | | mmap |			mmap := NativeBoost forCurrentPlatform getGlobalSymbolPointer: 'mmap'.			gen asm mov: mmap asUImm32 to: gen asm EAX.			gen asm call: gen asm EAX			] ! !!NBUnixExternalHeapManager methodsFor: 'memory pages' stamp: 'Igor.Stasenko 9/26/2010 03:37'!primAllocatePage: bytesToAllocate	| ptr buf |	buf := ByteArray new: 4.	self 		mmapLength: bytesToAllocate 		prot: self protFlags 		flags: self mapFlags 		into: buf.	ptr := buf unsignedLongAt: 1 bigEndian: false.	ptr = MAP_FAILED ifTrue: [ self error: 'Unable to map virtual memory' ].		^ ptr ! !!NBUnixExternalHeapManager methodsFor: 'memory pages' stamp: 'Igor.Stasenko 9/26/2010 03:45'!primFreePage: aMemoryPage	"call munmap()"	| res |	res := self unmap: aMemoryPage address length: aMemoryPage length.	res = 0 ifFalse: [ self error: 'error during unmapping virtual memory page' ]! !!NBUnixExternalHeapManager methodsFor: 'flags' stamp: 'Igor.Stasenko 9/26/2010 03:51'!protFlags	"since NativeBoost using heap for placing executable code there,	it is important that all allocated memory should be executable"	^  (PROT_READ bitOr: PROT_WRITE) bitOr: PROT_EXEC! !!NBUnixExternalHeapManager methodsFor: 'private' stamp: 'IgorStasenko 11/24/2012 17:25'!unmap: addr  length: len 			<primitive: #primitiveNativeCall module: #NativeBoostPlugin>	"unmap memory page"	^ self nbCallout 		function: #( int munmap (uint addr, ulong  len)  ) 		module: RTLD_DEFAULT ! !!NativeBoostLinux32 class methodsFor: 'platform id' stamp: 'Igor.Stasenko 9/22/2010 03:12'!targetPlatformId		^ Linux32PlatformId ! !!NativeBoostLinux32 methodsFor: 'retrieving symbols' stamp: 'Igor.Stasenko 9/26/2010 05:00'!CLibrary	"answer a C library path, or module handle,	use in FFI callouts as module: argument to call C run-time library function(s)"		"use global symbol space"	^ RTLD_DEFAULT! !!NativeBoostLinux32 methodsFor: 'retrieving symbols' stamp: 'JavierPimas 9/27/2011 14:46'!VMModule	"taken from CLibrary. Should work for fetching VM functions too.	use in FFI callouts as module: argument to call C run-time library function(s)"		"use global symbol space"	^ RTLD_DEFAULT! !!NativeBoostLinux32 methodsFor: 'memory operations' stamp: 'Igor.Stasenko 9/25/2010 09:37'!basicAllocate: numBytes	"Allocate a memory block with given size in bytes,	answer an NBExternalAddress instance - address to the beginning of memory block"	| addr |	addr := heap allocate: numBytes.	addr = 0 ifTrue: [ ^ nil ].		^ NBExternalAddress value: addr! !!NativeBoostLinux32 methodsFor: 'bootstrapping' stamp: 'IgorStasenko 11/24/2012 16:02'!bootstrapGetGlobalSymbolPointer: symbolName into: returnValueBuffer	" call  dlsym(RTLD_DEFAULT, symbolName) "	<primitive: 'primitiveNativeCall' module: 'NativeBoostPlugin' error: errorCode>	^ self nbCallout		options: #( - optUseStackPointer );		function: #( NBBootstrapUlong (RTLD_DEFAULT , String symbolName) )		emit: [:gen |	 | asm |				self assert: (self primitiveDlsym ~= 0).								asm := gen asm.				asm mov: (self primitiveDlsym asUImm) to: asm EAX.				asm call: asm EAX.		] 	! !!NativeBoostLinux32 methodsFor: 'memory operations' stamp: 'Igor.Stasenko 9/26/2010 04:13'!free: address	"Free the external memory, allocated using #allocate: message.	Note: never pass pointers, which you allocated by other means"		heap free: address value! !!NativeBoostLinux32 methodsFor: 'retrieving symbols' stamp: 'IgorStasenko 1/24/2012 12:38'!getGlobalSymbolPointer: symbolName 	| bytes addr |	bytes := ByteArray new: 8.	self bootstrapGetGlobalSymbolPointer: symbolName into: bytes.	addr := bytes unsignedLongAt: 1 bigEndian: false.		addr = 0 ifTrue: [ self error: 'failed to get a symbol address: ', symbolName ].	^ NBExternalAddress value: addr	! !!NativeBoostLinux32 methodsFor: 'bootstrapping' stamp: 'Igor.Stasenko 9/26/2010 03:50'!initializeExternalHeap	"initialize external memory heap"			heap := NBUnixExternalHeapManager new.	! !!NativeBoostLinux32 methodsFor: 'retrieving symbols' stamp: 'IgorStasenko 1/18/2012 13:45'!loadSymbol: aSymbolName fromModule: moduleName	(moduleName = '' or: [moduleName = 0 ]) ifTrue: [		"if module name is empty, try to retrieve symbol from globals "		^ self getGlobalSymbolPointer: aSymbolName 		].	^ super loadSymbol: aSymbolName fromModule: moduleName! !!NativeBoostLinux32 methodsFor: 'accessing' stamp: 'IgorStasenko 8/5/2011 08:48'!newAssembler	^ AJx86Assembler new.! !!NativeBoostLinux32 methodsFor: 'accessing' stamp: 'Igor.Stasenko 9/22/2010 03:25'!pointerSize	^ 4! !!NativeBoostLinux32 methodsFor: 'primitives' stamp: 'Igor.Stasenko 9/25/2010 06:31'!primitiveDlopen	"retrieve a pointer to dlopen(...) function"	<primitive: 'primitiveDlopenFn' module: #NativeBoostPlugin>			^ self primitiveFailed! !!NativeBoostLinux32 methodsFor: 'primitives' stamp: 'Igor.Stasenko 9/25/2010 06:30'!primitiveDlsym	"retrieve a pointer to dlsym(...) function"	<primitive: 'primitiveDlsymFn' module: #NativeBoostPlugin>			^ self primitiveFailed! !!NativeBoostLinux32 methodsFor: 'accessing' stamp: 'IgorStasenko 8/3/2011 08:08'!stackAlignment	^ 1! !"NativeBoost-Unix"!!NBMacConstants class methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 12/5/2010 19:18'!initMmapflags	PROT_READ := 16r1.	" Page can be read.  "	PROT_WRITE := 16r2.	" Page can be written. "	PROT_EXEC := 16r4.	" Page can be executed. "	PROT_NONE := 16r0. 	" Page can not be accessed. "	MAP_FILE := 0. " map from file (default) "	MAP_ANON := 16r1000. " allocated from memory, swap space "		" Flags contain sharing type and options. 	Sharing types; choose one."		MAP_SHARED := 16r0001. " [MF|SHM] share changes"	MAP_PRIVATE := 16r0002. " [MF|SHM] changes are private"	MAP_COPY  := MAP_PRIVATE.	MAP_FIXED := 16r0010. " [MF|SHM] interpret addr exactly "		MAP_RENAME := 16r0020. " Sun: rename private pages to file "	MAP_NORESERVE := 16r0040. " Sun: don't reserve needed swap area "	MAP_RESERVED0080 := 16r0080. " previously unimplemented MAP_INHERIT "	MAP_NOEXTEND := 16r0100. " for MAP_FILE, don't change file size "	MAP_HASSEMAPHORE := 16r0200. " region may contain semaphores "	MAP_NOCACHE := 16r0400. " don't cache pages for this mapping "	MAP_FAILED := -1 asImm asDWord.! !!NBMacConstants class methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 11/18/2012 17:08'!initialize	RTLD_LAZY := 16r1.	RTLD_NOW := 16r2.	RTLD_LOCAL := 16r4.	RTLD_GLOBAL := 16r8.		RTLD_NOLOAD := 16r10.	RTLD_NODELETE := 16r80.	RTLD_FIRST := 16r100.  " Mac OS X 10.5 and later "		RTLD_NEXT := -1 . " ((void *) -1) Search subsequent objects. "	RTLD_DEFAULT := -2. " ((void *) -2) Use default search algorithm. "	RTLD_SELF := -3. " ((void *) -3)  Search this and subsequent objects (Mac OS X 10.5 and later) "	RTLD_MAIN_ONLY := -5. " ((void *) -5)  Search main executable only (Mac OS X 10.5 and later)"	self initMmapflags.	! !!NBMacExternalHeapManager methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 12/5/2010 19:13'!mapFlags	^ MAP_ANON bitOr: MAP_PRIVATE! !!NBMacExternalHeapManager methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 11/24/2012 17:22'!mmapLength: bytesToAllocate prot: protFlags flags: mapFlags into: returnValueBuffer			<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	"Note:  mmap using 32-bit offset, while mmap64 - 64bit one"	^ self nbCallout 		options: #( - optDirectProxyFnAddress );		function: #(			NBBootstrapUlong ( 0, uint bytesToAllocate, int protFlags, int mapFlags,				-1,  0 "offset" )) 		emit:  [:gen | | mmap |			mmap := NativeBoost forCurrentPlatform getGlobalSymbolPointer: 'mmap'.			gen asm mov: mmap asUImm32 to: gen asm EAX.			gen asm call: gen asm EAX ] ! !!NBMacExternalHeapManager methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 12/5/2010 19:19'!primAllocatePage: bytesToAllocate	| ptr buf |	buf := ByteArray new: 4.	self 		mmapLength: bytesToAllocate 		prot: self protFlags 		flags: self mapFlags 		into: buf.	ptr := buf unsignedLongAt: 1 bigEndian: false.	ptr = MAP_FAILED ifTrue: [ self error: 'Unable to map virtual memory' ].		^ ptr ! !!NBMacExternalHeapManager methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 12/5/2010 19:19'!primFreePage: aMemoryPage	"call munmap()"	| res |	res := self unmap: aMemoryPage address length: aMemoryPage length.	res = 0 ifFalse: [ self error: 'error during unmapping virtual memory page' ]! !!NBMacExternalHeapManager methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 12/5/2010 18:36'!protFlags	"since NativeBoost using heap for placing executable code there,	it is important that all allocated memory should be executable"	^  (PROT_READ bitOr: PROT_WRITE) bitOr: PROT_EXEC! !!NBMacExternalHeapManager methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 11/24/2012 17:22'!unmap: addr  length: len 			<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	"unmap memory page"	^ self nbCallout		function: #( int munmap (uint addr, ulong  len)  ) 		module: RTLD_DEFAULT ! !!NativeBoostMac32 class methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 12/4/2010 22:21'!targetPlatformId		^ Mac32PlatformId ! !!NativeBoostMac32 methodsFor: 'platform-specific' stamp: 'IgorStasenko 2/2/2012 16:00'!VMModule	"answer a C library path, or module handle,	use in FFI callouts as module: argument to call C run-time library function(s)"		^ self CLibrary! !!NativeBoostMac32 methodsFor: 'bootstrapping' stamp: 'IgorStasenko 11/24/2012 16:03'!bootstrapGetGlobalSymbolPointer: symbolName into: returnValueBuffer	" call  dlsym(RTLD_DEFAULT, symbolName) "	" override, since mac using different RTLD_DEFAULT constant value "		<primitive: 'primitiveNativeCall' module: 'NativeBoostPlugin' error: errorCode>	^ self nbCallout		options: #( - optUseStackPointer);		function: #( NBBootstrapUlong (RTLD_DEFAULT , String symbolName) )		emit: [:gen |	 | asm |				asm := gen asm.				asm mov: (self primitiveDlsym asUImm) to: asm EAX.				asm call: asm EAX.		]! !!NativeBoostMac32 methodsFor: 'bootstrapping' stamp: 'IgorStasenko 11/24/2012 16:03'!getEntryPointStackOffset	" call  dlsym(RTLD_DEFAULT, symbolName) "	" override, since mac using different RTLD_DEFAULT constant value "		<primitive: 'primitiveNativeCall' module: 'NativeBoostPlugin' error: errorCode>	^ self nbCallout		function: #( ulong () )		emit: [:gen |	 | asm |				asm := gen asm.				asm mov: asm ESP to: asm EAX;					and: asm EAX with: 16r0F.		].	! !!NativeBoostMac32 methodsFor: 'bootstrapping' stamp: 'Igor.Stasenko 12/5/2010 18:32'!initializeExternalHeap	"initialize external memory heap"			heap := NBMacExternalHeapManager new.	! !!NativeBoostMac32 methodsFor: 'assembler' stamp: 'IgorStasenko 8/5/2011 08:48'!newAssembler	^ AJx86Assembler new! !!NativeBoostMac32 methodsFor: 'platform-specific' stamp: 'IgorStasenko 8/2/2011 06:33'!stackAlignment	^ 16! !"NativeBoost-Mac"!!NBTCHAR commentStamp: 'Igor.Stasenko 4/29/2010 13:44' prior: 0!- depending on context, acts either as char or wchar!!NBTString commentStamp: 'Igor.Stasenko 4/29/2010 14:26' prior: 0!- depending on context, acts either as char* or wchar* string!!NBWin32Handle commentStamp: '<historical>' prior: 0!Instances of this class represent a reference value to a Win32 resource (file, window, ...)!!NBWin32Window commentStamp: 'Igor.Stasenko 4/29/2010 10:54' prior: 0!Through WinTypes pool,  i seen as HWND type ,so whenever you type HWND, you are working with instances of me!!NBTCHAR class methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 5/1/2010 10:56'!asNBExternalType: gen	^ (gen optionAt: #WinUnicode) 		ifTrue: [ 'wchar_t' asNBExternalType: gen ]		ifFalse: [ #uchar asNBExternalType: gen ]! !!NBTString class methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 5/1/2010 10:56'!asNBExternalType: gen	^ (gen optionAt: #WinUnicode) 		ifTrue: [ NBWideString asNBExternalType: gen ]		ifFalse: [ NBExternalString asNBExternalType: gen ]! !!NBWinConstants class methodsFor: 'constants' stamp: 'Igor.Stasenko 5/18/2010 04:16'!classStyles	" Window class styles "	CS_VREDRAW := 16r0001.	CS_HREDRAW := 16r0002.	CS_DBLCLKS := 16r0008.	CS_OWNDC := 16r0020.	CS_CLASSDC := 16r0040.	CS_PARENTDC := 16r0080.	CS_NOCLOSE := 16r0200.	CS_SAVEBITS := 16r0800.	CS_BYTEALIGNCLIENT := 16r1000.	CS_BYTEALIGNWINDOW := 16r2000.	CS_GLOBALCLASS := 16r4000.		CS_IME := 16r00010000.	CS_DROPSHADOW := 16r00020000.! !!NBWinConstants class methodsFor: 'constants' stamp: 'tbn 11/12/2012 09:52'!driveTypes	DRIVE_UNKNOWN := 0.	DRIVE_NO_ROOT_DIR := 1.	DRIVE_REMOVABLE := 2.	DRIVE_FIXED := 3.	DRIVE_REMOTE := 4.	DRIVE_CDROM := 5.	DRIVE_RAMDISK := 6! !!NBWinConstants class methodsFor: 'constants' stamp: 'Igor.Stasenko 5/18/2010 04:07'!gdiConstants" pixel types "PFD_TYPE_RGBA  := 0.PFD_TYPE_COLORINDEX  := 1." layer types "PFD_MAIN_PLANE := 0.PFD_OVERLAY_PLANE := 1.PFD_UNDERLAY_PLANE := -1." PIXELFORMATDESCRIPTOR flags "PFD_DOUBLEBUFFER := 16r00000001.PFD_STEREO := 16r00000002.PFD_DRAW_TO_WINDOW := 16r00000004.PFD_DRAW_TO_BITMAP := 16r00000008.PFD_SUPPORT_GDI := 16r00000010.PFD_SUPPORT_OPENGL := 16r00000020.PFD_GENERIC_FORMAT := 16r00000040.PFD_NEED_PALETTE := 16r00000080.PFD_NEED_SYSTEM_PALETTE := 16r00000100.PFD_SWAP_EXCHANGE := 16r00000200.PFD_SWAP_COPY := 16r00000400.PFD_SWAP_LAYER_BUFFERS := 16r00000800.PFD_GENERIC_ACCELERATED := 16r00001000.PFD_SUPPORT_DIRECTDRAW := 16r00002000." PIXELFORMATDESCRIPTOR flags for use in ChoosePixelFormat only "PFD_DEPTH_DONTCARE := 16r20000000.PFD_DOUBLEBUFFER_DONTCARE := 16r40000000.PFD_STEREO_DONTCARE := 16r80000000.! !!NBWinConstants class methodsFor: 'constants' stamp: 'tbn 11/12/2012 07:07'!getWindowLongConstants	GWL_EXSTYLE := -20.	GWL_HINSTANCE := -6.	GWL_HWNDPARENT := -8.	GWL_ID := -12.	GWL_STYLE := -16.	GWL_USERDATA := -21.	GWL_WNDPROC := -4! !!NBWinConstants class methodsFor: 'constants' stamp: 'Igor.Stasenko 5/2/2010 16:26'!heapConstants	HEAP_CREATE_ENABLE_EXECUTE := 16r00040000.	HEAP_GENERATE_EXCEPTIONS := 16r00000004.	HEAP_NO_SERIALIZE := 16r00000001.		HEAP_REALLOC_IN_PLACE_ONLY := 16r00000010.	HEAP_ZERO_MEMORY := 16r00000008.! !!NBWinConstants class methodsFor: 'class initialization' stamp: 'tbn 11/12/2012 09:52'!initialize	" self initialize"		self classStyles;		heapConstants;		windowStyles;		windowExStyles;		windowCreationConstants;		gdiConstants;		showWindowConstants;		messageBoxConstants;		getWindowLongConstants;		windowMessages;		driveTypes! !!NBWinConstants class methodsFor: 'constants' stamp: 'tbn 11/11/2012 20:14'!messageBoxConstants	MB_ABORTRETRYIGNORE := 16r00000002.	MB_CANCELTRYCONTINUE := 16r00000006.	MB_HELP := 16r00004000.	MB_OK := 16r00000000.	MB_OKCANCEL := 16r00000001.	MB_RETRYCANCEL := 16r00000005.	MB_YESNO := 16r00000004.	MB_YESNOCANCEL := 16r00000003.		"To display an icon in the message box, specify one of the following values."	MB_ICONEXCLAMATION := 16r00000030. 	MB_ICONWARNING := 16r00000030.	MB_ICONINFORMATION := 16r00000040.	MB_ICONASTERISK := 16r00000040.	MB_ICONQUESTION := 16r00000020.	MB_ICONSTOP := 16r00000010.	MB_ICONERROR := 16r00000010.	MB_ICONHAND := 16r00000010.		"To indicate the default button, specify one of the following values."	MB_DEFBUTTON1 := 16r00000000.	MB_DEFBUTTON2 := 16r00000100.	MB_DEFBUTTON3 := 16r00000200.	MB_DEFBUTTON4 := 16r00000300.		"To indicate the modality of the dialog box, specify one of the following values."	MB_APPLMODAL := 16r00000000.	MB_SYSTEMMODAL := 16r00001000.	MB_TASKMODAL := 16r00002000.		"To specify other options, use one or more of the following values."	MB_DEFAULT_DESKTOP_ONLY := 16r00020000.	MB_RIGHT := 16r00080000. "text is right justified"	MB_RTLREADING := 16r00100000.	MB_SETFOREGROUND := 16r00010000.	MB_TOPMOST := 16r00040000.	MB_SERVICE_NOTIFICATION := 16r00200000.		IDABORT := 3.	IDCANCEL := 2.	IDCONTINUE := 11.	IDIGNORE := 5.	IDNO := 7.	IDOK := 1.	IDRETRY := 4.	IDTRYAGAIN := 10.	IDYES := 6.	! !!NBWinConstants class methodsFor: 'constants' stamp: 'Igor.Stasenko 5/20/2010 07:57'!showWindowConstantsSW_HIDE := 0.SW_SHOWNORMAL := 1.SW_NORMAL := 1.SW_SHOWMINIMIZED := 2.SW_SHOWMAXIMIZED := 3.SW_MAXIMIZE := 3.SW_SHOWNOACTIVATE := 4.SW_SHOW := 5.SW_MINIMIZE := 6.SW_SHOWMINNOACTIVE := 7.SW_SHOWNA :=  8.SW_RESTORE :=  9.SW_SHOWDEFAULT := 10.SW_FORCEMINIMIZE := 11.SW_MAX := 11.! !!NBWinConstants class methodsFor: 'constants' stamp: 'Igor.Stasenko 5/17/2010 14:27'!windowCreationConstants	CW_USEDEFAULT  := 16r80000000.! !!NBWinConstants class methodsFor: 'constants' stamp: 'Igor.Stasenko 5/2/2010 15:10'!windowExStyles" Extended Window Styles " WS_EX_DLGMODALFRAME := 16r00000001. WS_EX_NOPARENTNOTIFY := 16r00000004. WS_EX_TOPMOST := 16r00000008. WS_EX_ACCEPTFILES := 16r00000010. WS_EX_TRANSPARENT := 16r00000020. WS_EX_MDICHILD := 16r00000040. WS_EX_TOOLWINDOW := 16r00000080. WS_EX_WINDOWEDGE := 16r00000100. WS_EX_CLIENTEDGE := 16r00000200. WS_EX_CONTEXTHELP := 16r00000400. WS_EX_RIGHT := 16r00001000. WS_EX_LEFT := 16r00000000. WS_EX_RTLREADING := 16r00002000. WS_EX_LTRREADING := 16r00000000. WS_EX_LEFTSCROLLBAR := 16r00004000. WS_EX_RIGHTSCROLLBAR := 16r00000000. WS_EX_CONTROLPARENT := 16r00010000. WS_EX_STATICEDGE := 16r00020000. WS_EX_APPWINDOW := 16r00040000. WS_EX_OVERLAPPEDWINDOW  := (WS_EX_WINDOWEDGE bitOr: WS_EX_CLIENTEDGE). WS_EX_PALETTEWINDOW :=  (WS_EX_WINDOWEDGE bitOr: WS_EX_TOOLWINDOW) bitOr: WS_EX_TOPMOST. WS_EX_LAYERED := 16r00080000. WS_EX_NOINHERITLAYOUT := 16r00100000. " Disable inheritence of mirroring by children " WS_EX_LAYOUTRTL := 16r00400000. " Right to left mirroring " WS_EX_COMPOSITED := 16r02000000. WS_EX_NOACTIVATE := 16r08000000.! !!NBWinConstants class methodsFor: 'constants' stamp: 'tbn 11/12/2012 10:09'!windowMessages	WM_ACTIVATEAPP :=  16r001C.	WM_CANCELMODE :=  16r001F.	WM_CHILDACTIVATE := 16r0022.	WM_CLOSE := 16r0010.	WM_COMPACTING := 16r0041.	WM_CREATE :=  16r0001.	WM_DESTROY := 16r0002.     "http://msdn.microsoft.com/en-us/library/windows/desktop/ms632620(v=vs.85).aspx"   	WM_ENABLE := 16r000A.	WM_ENTERSIZEMOVE := 16r0231.	WM_EXITSIZEMOVE := 16r0232.	WM_GETMINMAXINFO := 16r0024.	WM_GETICON := 16r007F.	WM_INPUTLANGCHANGE := 16r0051.	WM_INPUTLANGCHANGEREQUEST := 16r0050.	WM_MOVE := 16r0003.	WM_MOVING := 16r0216.	WM_NCACTIVATE := 16r0086.	WM_NCCALCSIZE := 16r0083.	WM_NCCREATE := 16r0081.	WM_NCDESTROY := 16r0082.	WM_NULL := 16r0000.                                                                                             	WM_QUERYDRAGICON := 16r0037.	WM_QUERYOPEN := 16r0013.	WM_QUIT := 16r0012.	WM_SHOWWINDOW := 16r0018.	WM_SIZE := 16r0005.	WM_SIZING := 16r0214.	WM_STYLECHANGED := 16r007D.	WM_STYLECHANGING := 16r007C.	WM_THEMECHANGED := 16r031A.	WM_USERCHANGED := 16r0054.	WM_WINDOWPOSCHANGED  := 16r0047.	WM_WINDOWPOSCHANGING  := 16r0046		! !!NBWinConstants class methodsFor: 'constants' stamp: 'Igor.Stasenko 5/2/2010 15:10'!windowStyles"  Window Styles" WS_OVERLAPPED := 16r00000000. WS_POPUP := 16r80000000. WS_CHILD := 16r40000000. WS_MINIMIZE := 16r20000000. WS_VISIBLE := 16r10000000. WS_DISABLED := 16r08000000. WS_CLIPSIBLINGS := 16r04000000. WS_CLIPCHILDREN := 16r02000000. WS_MAXIMIZE := 16r01000000. WS_CAPTION := 16r00C00000. " WS_BORDER | WS_DLGFRAME " WS_BORDER := 16r00800000. WS_DLGFRAME := 16r00400000. WS_VSCROLL := 16r00200000. WS_HSCROLL := 16r00100000. WS_SYSMENU := 16r00080000. WS_THICKFRAME := 16r00040000. WS_GROUP := 16r00020000. WS_TABSTOP := 16r00010000. WS_MINIMIZEBOX := 16r00020000. WS_MAXIMIZEBOX := 16r00010000."  Common Window Styles" WS_OVERLAPPEDWINDOW := ((((WS_OVERLAPPED bitOr: WS_CAPTION ) bitOr: WS_SYSMENU ) bitOr: WS_THICKFRAME ) bitOr: WS_MINIMIZEBOX ) bitOr: WS_MAXIMIZEBOX. WS_POPUPWINDOW := (WS_POPUP bitOr: WS_BORDER) bitOr: WS_SYSMENU. WS_CHILDWINDOW := WS_CHILD. WS_TILED := WS_OVERLAPPED. WS_ICONIC := WS_MINIMIZE. WS_SIZEBOX := WS_THICKFRAME. WS_TILEDWINDOW := WS_OVERLAPPEDWINDOW.! !!NBWin32Handle methodsFor: 'conversion' stamp: 'Igor.Stasenko 5/18/2010 22:56'!asUnsignedLong	^ handle asUnsignedLong! !!NBWin32Handle methodsFor: 'call convention' stamp: 'IgorStasenko 11/25/2012 14:16'!nbCallingConvention	^ #stdcall! !!NBWin32Handle methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/17/2010 05:02'!value: uint	handle value: uint! !!NBWin32Hdc methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 11/25/2012 14:17'!lineToX:  nXEnd y: nYEnd		<primitive: #primitiveNativeCall module: #NativeBoostPlugin>			^self nbCall: #(BOOL LineTo(HDC self, int nXEnd, int nYEnd)) 			module: #gdi32! !!NBWin32Hdc methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 11/25/2012 14:17'!moveToX:  x y: y		<primitive: #primitiveNativeCall module: #NativeBoostPlugin>			^self nbCall: #(BOOL MoveToEx(HDC self, int x, int y, 0)) 			module: #gdi32! !!NBWin32Hdc methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 11/25/2012 14:17'!rectangleLeft: nLeftRect top: nTopRect right: nRightRect bottom: nBottomRect		<primitive: #primitiveNativeCall module: #NativeBoostPlugin>			^self nbCall: #(BOOL Rectangle(			HDC self ,	    			int nLeftRect,	 	     		int nTopRect,	             	int nRightRect,	             	int nBottomRect)) 		module: #gdi32! !!NBWin32Heap class methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 11/24/2012 17:35'!create: options initialiSize: dwInitialSize maximumSize: dwMaximumSize	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>	^ self nbCallout stdcall function: 		#( NBWin32Heap HeapCreate (			DWORD options, 			SIZE_T dwInitialSize,			SIZE_T dwMaximumSize) ) 		module: #Kernel32! !!NBWin32Heap methodsFor: 'win heap api' stamp: 'IgorStasenko 11/24/2012 17:30'!alloc: numberOfBytes	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^ self nbCall: #( LPVOID HeapAlloc (self , 0 , SIZE_T numberOfBytes) )! !!NBWin32Heap methodsFor: 'win heap api' stamp: 'IgorStasenko 11/24/2012 17:31'!compact"The HeapCompact function attempts to compact a specified heap. It compacts the heap by coalescing adjacent free blocks of memory and decommitting large free blocks of memory."	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^ self nbCall: #( SIZE_T HeapCompact (self , 0) )! !!NBWin32Heap methodsFor: 'win heap api' stamp: 'IgorStasenko 11/24/2012 17:31'!destroy	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^ self nbCall: #( BOOL HeapDestroy (self) )! !!NBWin32Heap methodsFor: 'win heap api' stamp: 'IgorStasenko 11/24/2012 17:31'!free: lpMem"The HeapFree function frees a memory block allocated from a heap by the HeapAlloc or HeapReAlloc function. "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^ self nbCall: #( BOOL HeapFree (self, 0, LPVOID lpMem) )! !!NBWin32Heap methodsFor: 'win heap api' stamp: 'IgorStasenko 11/24/2012 17:32'!lock	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^ self nbCall: #( BOOL HeapLock (self) )! !!NBWin32Heap methodsFor: 'call convention' stamp: 'IgorStasenko 11/24/2012 17:29'!nbCallingConvention	^ #stdcall! !!NBWin32Heap methodsFor: 'call convention' stamp: 'IgorStasenko 11/24/2012 17:30'!nbLibraryNameOrHandle	^ #Kernel32! !!NBWin32Heap methodsFor: 'win heap api' stamp: 'Igor.Stasenko 5/3/2010 02:05'!privSetHandle: aHandle	"do not use, if you not sure what you doing"	handle := aHandle! !!NBWin32Heap methodsFor: 'win heap api' stamp: 'IgorStasenko 11/24/2012 17:32'!realloc: flags mem: lpMem size: dwBytes	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^ self nbCall: 			#( LPVOID HeapReAlloc (self, DWORD flags, LPVOID lpMem, SIZE_T dwBytes) )! !!NBWin32Heap methodsFor: 'win heap api' stamp: 'IgorStasenko 11/24/2012 17:32'!sizeOf: lpMem	"The HeapSize function retrieves the size of a memory block allocated from a heap by the HeapAlloc or HeapReAlloc function."	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^ self nbCall: 		#( SIZE_T HeapSize (self, 0 , LPCVOID lpMem) ) ! !!NBWin32Heap methodsFor: 'win heap api' stamp: 'IgorStasenko 11/24/2012 17:32'!unlock	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^ self nbCall: #( BOOL HeapUnlock (self) )! !!NBWin32Heap methodsFor: 'win heap api' stamp: 'IgorStasenko 11/24/2012 17:32'!validate	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^ self nbCall: #( BOOL HeapValidate (self) )! !!NBWin32Heap methodsFor: 'win heap api' stamp: 'IgorStasenko 11/24/2012 17:33'!zalloc: numberOfBytes	"same as #alloc: but additionally zero-fill the allocated memory"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^ self nbCall:		#( LPVOID HeapAlloc (self , HEAP_ZERO_MEMORY , SIZE_T numberOfBytes) ) ! !!NBWin32Window class methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/6/2012 13:58'!DefWindowProcA	^ NativeBoost loadSymbol: #DefWindowProcA fromModule: #user32! !!NBWin32Window class methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 5/17/2010 19:20'!DefWindowProcW	^ NBExternalAddress value: (NativeBoost loadSymbol: #DefWindowProcW fromModule: #user32)! !!NBWin32Window class methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 11/24/2012 17:39'!createWindowExA: dwExStyle lpClassName: lpClassName lpWindowName: lpWindowName dwStyle: dwStylex: x y: y width: nWidth height: nHeight hWndParent: hWndParent hMenu: hMenuhInstance: hInstance lParam: lpParam	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>	^ self nbCallout 		stdcall;		options: #( - WinUnicode );			function: #( HWND 'CreateWindowExA' 			( DWORD dwExStyle,			LPCTSTR lpClassName,			LPCTSTR lpWindowName,			DWORD dwStyle,			ulong x,			ulong y,			ulong nWidth,			ulong nHeight,			HWND hWndParent,			HMENU hMenu,			HINSTANCE hInstance,			LPVOID lpParam) ) 		module: #user32	! !!NBWin32Window class methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 11/24/2012 17:40'!createWindowExW: dwExStyle lpClassName: lpClassName lpWindowName: lpWindowName dwStyle: dwStylex: x y: y width: nWidth height: nHeight hWndParent: hWndParent hMenu: hMenuhInstance: hInstance lParam: lpParam	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>	^ self nbCallout		stdcall;		options: #( + WinUnicode );		function: #( HWND 'CreateWindowExW' 			( DWORD dwExStyle,			LPCTSTR lpClassName,			LPCTSTR lpWindowName,			DWORD dwStyle,			ulong x,			ulong y,			ulong nWidth,			ulong nHeight,			HWND hWndParent,			HMENU hMenu,			HINSTANCE hInstance,			LPVOID lpParam) ) 		module: #user32	! !!NBWin32Window class methodsFor: 'callout options' stamp: 'IgorStasenko 9/16/2012 18:10'!ffiCalloutOptions 	^ #( + optMayGC )! !!NBWin32Window class methodsFor: 'accessing' stamp: 'tbn 11/19/2012 06:51'!getDesktopWindow	"Return the handle of the windows desktop window"		<primitive: 'primitiveNativeCall' module: 'NativeBoostPlugin'>	^ NBFFICallout stdcall: #( HWND GetDesktopWindow()) module: #user32! !!NBWin32Window class methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 11/24/2012 17:40'!getFocus 	"Return the HWND currently having the input focus"	<primitive: 'primitiveNativeCall' module: 'NativeBoostPlugin'>	^ self nbCallout stdcall function: #( HWND GetFocus ()) module: #user32! !!NBWin32Window class methodsFor: 'accessing' stamp: 'tbn 11/19/2012 06:57'!getForegroundWindow 	"Returns the handle of the foreground window (the window with which the user is currently working)."		<primitive: 'primitiveNativeCall' module: 'NativeBoostPlugin'>	^ NBFFICallout stdcall: #( HWND GetForegroundWindow()) module: #user32! !!NBWin32Window methodsFor: 'operations' stamp: 'Igor.Stasenko 5/17/2010 15:11'!destroy	^ self destroyWindow! !!NBWin32Window methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 11/24/2012 17:35'!destroyWindow	"destroy the window"	<primitive: 'primitiveNativeCall' module: 'NativeBoostPlugin'>	^ self nbCallout 		stdcall; 		options: #( + optMayGC );  " calls windowproc"  		function: #( BOOL DestroyWindow ( HWND self ))		module: #user32! !!NBWin32Window methodsFor: 'accessing' stamp: 'IgorStasenko 11/25/2012 14:18'!getDC	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCall: #( HDC GetDC ( HWND self ) )		module: #user32! !!NBWin32Window methodsFor: 'accessing' stamp: 'tbn 11/12/2012 07:11'!getWindowExStyle	"Retrieves the extended window styles"		^self getWindowLongAtIndex: GWL_EXSTYLE! !!NBWin32Window methodsFor: 'api' stamp: 'IgorStasenko 11/25/2012 14:18'!getWindowLong: hWnd index: nIndex 		<primitive: #primitiveNativeCall module: #NativeBoostPlugin>			^self nbCall: #(LONG GetWindowLongA(HWND hWnd, int nIndex)) 			module: #user32! !!NBWin32Window methodsFor: 'api' stamp: 'IgorStasenko 11/25/2012 14:18'!getWindowLongAtIndex: nIndex 		<primitive: #primitiveNativeCall module: #NativeBoostPlugin>			^self nbCall: #(LONG GetWindowLongA(HWND self, int nIndex)) 			module: #user32! !!NBWin32Window methodsFor: 'accessing' stamp: 'tbn 11/12/2012 07:11'!getWindowStyle	"Retrieves the window styles"		^self getWindowLongAtIndex: GWL_STYLE! !!NBWin32Window methodsFor: 'api' stamp: 'tbn 11/11/2012 01:03'!getWindowText	"	self getFocus getWindowText	"	| len str |		str := ByteString new: 1000.	len := self getWindowText: self buffer: str bufferSize: 1000.	^ str first: len.	 ! !!NBWin32Window methodsFor: 'api' stamp: 'IgorStasenko 11/25/2012 14:18'!getWindowText: hWnd buffer: lpString bufferSize: nMaxCount		<primitive: #primitiveNativeCall module: #NativeBoostPlugin>			^self nbCall: #(int GetWindowTextA(HWND hWnd, char* lpString, int nMaxCount)) 			module: #user32! !!NBWin32Window methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 11/24/2012 17:36'!hide	"destroy the window"	<primitive: 'primitiveNativeCall' module: 'NativeBoostPlugin'>	^ self nbCallout 		stdcall;		options: #( + optMayGC );  " calls windowproc"		function: #( BOOL ShowWindow ( HWND self, SW_HIDE ))		module: #user32! !!NBWin32Window methodsFor: 'testing' stamp: 'IgorStasenko 11/25/2012 14:18'!isIconic	"Determines whether the specified window is minimized (iconic). "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^self nbCall: #(BOOL IsIconic(HWND self)) module: #user32! !!NBWin32Window methodsFor: 'testing' stamp: 'IgorStasenko 11/25/2012 14:18'!isVisible	"Retrieves the visibility state of the specified window. . "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^self nbCall: #(BOOL IsWindowVisible(HWND self)) module: #user32! !!NBWin32Window methodsFor: 'testing' stamp: 'IgorStasenko 11/25/2012 14:19'!isZoomed	"Determines whether a window is maximized. "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^self nbCall: #(BOOL IsZoomed(HWND self)) module: #user32! !!NBWin32Window methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 11/24/2012 17:37'!moveWindowX: x y: y width: nWidth height: nHeight	"move window example"	<primitive: 'primitiveNativeCall' module: 'NativeBoostPlugin'>	^ self nbCallout		stdcall;  		options: #( + optMayGC );  " calls windowproc"		function: #( 			BOOL MoveWindow ( HWND self,				int x,				int y,				int nWidth,   				int nHeight, 				false				))		module: #user32! !!NBWin32Window methodsFor: 'accessing' stamp: 'IgorStasenko 11/25/2012 14:19'!releaseDC: hdc	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCall: #( 			int ReleaseDC (		  HWND self ,  " handle to window"		  HDC hdc     " handle to DC "		))		module: #user32! !!NBWin32Window methodsFor: 'operations' stamp: 'tbn 11/12/2012 09:20'!setNonResizable	| newStyle |	newStyle := self getWindowStyle bitClear: (WS_SIZEBOX|WS_MINIMIZE|WS_MAXIMIZE). 	self setWindowLong: self index: GWL_STYLE newVale: newStyle. 	 		! !!NBWin32Window methodsFor: 'accessing' stamp: 'IgorStasenko 11/25/2012 14:19'!setWindowLong: hWnd index: nIndex newVale: dwNewLong		<primitive: #primitiveNativeCall module: #NativeBoostPlugin>			^self nbCall: #(LONG SetWindowLongA(HWND hWnd, int nIndex, LONG dwNewLong)) 			module: #user32! !!NBWin32Window methodsFor: 'accessing' stamp: 'IgorStasenko 11/25/2012 14:19'!setWindowText: lpString		<primitive: #primitiveNativeCall module: #NativeBoostPlugin>			^self nbCall: #(BOOL SetWindowTextA(HWND self, LPCTSTR lpString)) 			module: #user32! !!NBWin32Window methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 11/24/2012 17:38'!show	"destroy the window"	<primitive: 'primitiveNativeCall' module: 'NativeBoostPlugin'>	^ self nbCallout stdcall 		options: #( + optMayGC );  " calls windowproc"		function: #( BOOL ShowWindow ( HWND self, SW_SHOW ))		module: #user32! !!NBWin32MessageBox class methodsFor: 'instance creation' stamp: 'IgorStasenko 11/25/2012 14:49'!messageBox: hWnd text: lpText title: lpCaption flags: uType	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>	^ self nbCallout stdcall function: #(int MessageBoxA(  			HWND hWnd,    			LPCTSTR  lpText,    			LPCTSTR  lpCaption,      		UINT uType		)) module: #user32! !!NBWin32MessageBox class methodsFor: 'instance creation' stamp: 'tbn 11/11/2012 20:00'!test	self messageBox: NBWin32Window getFocus text: 'Hello from Pharo' title: 'Pharo' flags: MB_YESNO! !!NBWin32Shell class methodsFor: 'accessing' stamp: 'tbn 11/9/2012 22:28'!getAllUsersProfileFolder	"Return the profile path for all users.  	 typically this is C:\Documents and Settings\All Users			self getAllUsersProfileFolder	"		^self getEnvironmentVariable: 'ALLUSERSPROFILE'! !!NBWin32Shell class methodsFor: 'accessing' stamp: 'tbn 11/9/2012 22:28'!getApplicationDataFolder	"Return the folder for application data			self getApplicationDataFolder	"		^self getEnvironmentVariable: 'APPDATA'! !!NBWin32Shell class methodsFor: 'accessing' stamp: 'tbn 11/9/2012 22:28'!getCommandLineProcessor	"Return command line processor executable			self getCommandLineProcessor	"		^self getEnvironmentVariable: 'ComSpec'! !!NBWin32Shell class methodsFor: 'accessing' stamp: 'tbn 11/9/2012 22:28'!getCommonProgramFiles 	"Return the common program files   	 typically this is C:\Program Files\Common Files			self getCommonProgramFiles 	"		^self getEnvironmentVariable: 'COMMONPROGRAMFILES'! !!NBWin32Shell class methodsFor: 'accessing-64bit' stamp: 'tbn 11/9/2012 22:31'!getCommonProgramFilesX86	"Return the common program files x86.  	 typically this is C:\Program Files (x86)\Common Files			self getCommonProgramFilesX86	"		^self getEnvironmentVariable: 'COMMONPROGRAMFILES(x86)'! !!NBWin32Shell class methodsFor: 'accessing' stamp: 'tbn 11/9/2012 22:29'!getComputerName	"Return the name of the computer.			self getComputerName	"		^self getEnvironmentVariable: 'COMPUTERNAME'! !!NBWin32Shell class methodsFor: 'api calls' stamp: 'tbn 11/12/2012 10:04'!getDriveType: lpRootPathName	"		self getDriveType:  'D:\' 	"		| types |	types := #(DRIVE_UNKNOWN DRIVE_NO_ROOT_DIR DRIVE_REMOVABLE DRIVE_FIXED DRIVE_REMOTE DRIVE_CDROM DRIVE_RAMDISK).	^types at: (self primGetDriveType: lpRootPathName) +  1! !!NBWin32Shell class methodsFor: 'accessing' stamp: 'TorstenBergmann 12/20/2012 10:14'!getEnvironmentVariable: variableName	"Return the value of the given environment variable"		<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode >	 ^ self nbCall: #( String getenv (String variableName) ) module: NativeBoost CLibrary! !!NBWin32Shell class methodsFor: 'accessing' stamp: 'tbn 11/9/2012 22:29'!getHomeDrive	"Return the drive letter of the home drive.			self getHomeDrive	"		^self getEnvironmentVariable: 'HOMEDRIVE'! !!NBWin32Shell class methodsFor: 'accessing' stamp: 'tbn 11/9/2012 22:29'!getHomePath	"Return the home path. Typically this is \Documents and Settings\{username}			self getHomePath	"		^self getEnvironmentVariable: 'HOMEPATH'! !!NBWin32Shell class methodsFor: 'accessing' stamp: 'tbn 11/9/2012 22:29'!getNumberOfProcessors	"Return the number of processors/cores.			self getNumberOfProcessors	"		^self getEnvironmentVariable: 'NUMBER_OF_PROCESSORS'! !!NBWin32Shell class methodsFor: 'accessing' stamp: 'tbn 11/9/2012 22:29'!getOS	"Return the name of the OS"		^self getEnvironmentVariable: 'OS'! !!NBWin32Shell class methodsFor: 'accessing' stamp: 'tbn 11/9/2012 22:29'!getPathEntries	"Return the PATH entries"		^(self getEnvironmentVariable: 'PATH') findTokens: $;! !!NBWin32Shell class methodsFor: 'accessing' stamp: 'tbn 11/9/2012 22:29'!getPathExtensions	"Returns a list of the file extensions that the OS considers to be executable.			self getPathExtensions	"		^self getEnvironmentVariable: 'PATHEXT'! !!NBWin32Shell class methodsFor: 'accessing' stamp: 'tbn 11/9/2012 22:29'!getProcessorArchitecture	"Return processor chip architecture. Values: x86, IA64.			self getProcessorArchitecture	"		^self getEnvironmentVariable: 'PROCESSOR_ARCHITECTURE'! !!NBWin32Shell class methodsFor: 'accessing' stamp: 'tbn 11/9/2012 22:29'!getProcessorIdentifier	"Return a description of the processor.			self getProcessorIdentifier	"		^self getEnvironmentVariable: 'PROCESSOR_IDENTIFIER'! !!NBWin32Shell class methodsFor: 'accessing' stamp: 'tbn 11/9/2012 22:29'!getProcessorLevel	"Return the model number of the computer's processor.			self getProcessorLevel	"		^self getEnvironmentVariable: 'PROCESSOR_LEVEL'! !!NBWin32Shell class methodsFor: 'accessing' stamp: 'tbn 11/9/2012 22:29'!getProcessorRevision	"Return the revision number of the processor.			self getProcessorRevision	"		^self getEnvironmentVariable: 'PROCESSOR_REVISION'! !!NBWin32Shell class methodsFor: 'accessing' stamp: 'tbn 11/9/2012 22:30'!getProgramFilesDirectory	"Return the program files directory			self getProgramFilesDirectory	"		^self getEnvironmentVariable: 'PROGRAMFILES'! !!NBWin32Shell class methodsFor: 'accessing' stamp: 'tbn 11/9/2012 22:30'!getSystemDrive	"Return the drive containing the Windows root directory, usually C:			self getSystemDrive	"		^self getEnvironmentVariable: 'SYSTEMDRIVE'! !!NBWin32Shell class methodsFor: 'accessing' stamp: 'tbn 11/9/2012 22:30'!getSystemRootDirectory	"Return the systems root directory. Typically this is	  'C:\WINDOWS'			self getSystemRootDirectory	"		^self getEnvironmentVariable: 'SystemRoot'! !!NBWin32Shell class methodsFor: 'accessing' stamp: 'tbn 11/9/2012 22:30'!getTempDirectory	"Return the name of the temp directory.			self getTempDirectory	"		^self getEnvironmentVariable: 'TEMP'! !!NBWin32Shell class methodsFor: 'accessing' stamp: 'tbn 11/9/2012 22:30'!getTmpDirectory	"Return the name of the temp directory.			self getTmpDirectory	"		^self getEnvironmentVariable: 'TMP'! !!NBWin32Shell class methodsFor: 'accessing' stamp: 'tbn 11/9/2012 22:30'!getUserDomain	"Return the name of the domain that contains the users account.			self getUserDomain	"		^self getEnvironmentVariable: 'USERDOMAIN'! !!NBWin32Shell class methodsFor: 'accessing' stamp: 'tbn 11/9/2012 22:30'!getUserName	"Return the name of the logged in user			self getUserName	"		^self getEnvironmentVariable: 'USERNAME'! !!NBWin32Shell class methodsFor: 'accessing' stamp: 'tbn 11/9/2012 22:30'!getUserProfile	"Return the users profile location. Typically this is C:\Documents and Settings\{username}			self getUserProfile	"		^self getEnvironmentVariable: 'USERPROFILE'! !!NBWin32Shell class methodsFor: 'accessing' stamp: 'tbn 11/9/2012 22:30'!getWindowsDirectory	"Return the path to the windows directory"		^self getEnvironmentVariable: 'windir'! !!NBWin32Shell class methodsFor: 'debugging' stamp: 'tbn 11/19/2012 07:05'!isDebuggerPresent	"Indicates whether the calling process is running under the context of a debugger.."		<primitive: 'primitiveNativeCall' module: 'NativeBoostPlugin'>	^ NBFFICallout stdcall: #( BOOL IsDebuggerPresent()) module: #kernel32! !!NBWin32Shell class methodsFor: 'special' stamp: 'tbn 11/9/2012 22:22'!lockWorkstation	"Locks the workstation."	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCall: #(BOOL LockWorkStation(void)) module: #user32! !!NBWin32Shell class methodsFor: 'debugging' stamp: 'tbn 11/9/2012 22:07'!outputDebugString: lpOutputString	"Sends a string to the debugger for display.  Use tools like DebugView to display"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^self nbCall: #(void OutputDebugStringA(LPCTSTR lpOutputString)) module: #Kernel32	! !!NBWin32Shell class methodsFor: 'api calls' stamp: 'tbn 11/12/2012 09:50'!primGetDriveType: lpRootPathName	"		self getDriveType: 'c:\' 	"		<primitive: #primitiveNativeCall module: #NativeBoostPlugin>			^ self nbCall: #(UINT GetDriveTypeA(LPCTSTR lpRootPathName)) module: #kernel32! !!NBWin32Shell class methodsFor: 'api calls' stamp: 'tbn 11/9/2012 22:09'!shellAbout: hWnd application: szApp other: szOtherStuff icon: hIcon	"		self shellAbout: NBWin32Window getFocus application: 'Pharo' other: 'More' icon: (NBWin32Handle new value: 0)	"		<primitive: #primitiveNativeCall module: #NativeBoostPlugin>			^ self nbCall: #(int ShellAboutA(     			HWND hWnd,         		LPCTSTR szApp,     			LPCTSTR szOtherStuff,     			HICON hIcon		)) module: #shell32! !!NBWin32Shell class methodsFor: 'operations' stamp: 'tbn 11/9/2012 22:11'!shellBrowse: url	"	self shellBrowse: 'http://www.pharo-project.org'	"	^self shellExecute: 'open' file: url parameters: '' directory: '' show: SW_SHOW! !!NBWin32Shell class methodsFor: 'api calls' stamp: 'tbn 11/9/2012 22:10'!shellExecute: lpOperation file: lpFile parameters: lpParameters directory: lpDirectory show: nShowCmd		<primitive: #primitiveNativeCall module: #NativeBoostPlugin>			^ self nbCall: #( 			HINSTANCE ShellExecuteA(     				0,     				LPCTSTR lpOperation,         			LPCTSTR lpFile,     				LPCTSTR lpParameters,     				LPCTSTR lpDirectory,        			INT nShowCmd)) module: 'Shell32.dll'	! !!NBWin32Shell class methodsFor: 'api calls' stamp: 'tbn 11/9/2012 22:09'!shellExecute: hwnd operation: lpOperation file: lpFile parameters: lpParameters directory: lpDirectory show: nShowCmd		<primitive: #primitiveNativeCall module: #NativeBoostPlugin>			^ self nbCall: #( 			HINSTANCE ShellExecuteA(     				HWND hwnd,     				LPCTSTR lpOperation,         			LPCTSTR lpFile,     				LPCTSTR lpParameters,     				LPCTSTR lpDirectory,        			INT nShowCmd)) module: 'Shell32.dll'	! !!NBWin32Shell class methodsFor: 'operations' stamp: 'tbn 11/9/2012 22:11'!shellExplore: folder	"	self shellExplore: 'c:\'	"	^self shellExecute: 'explore' file: folder parameters: '' directory: '' show: SW_SHOW! !!NBWin32Shell class methodsFor: 'operations' stamp: 'tbn 11/9/2012 22:12'!shellOpen: file	"	self shellOpen: 'c:\pharo.pdf'	"	^self shellExecute: 'open' file: file parameters: '' directory: '' show: SW_SHOW! !!NBWin32Shell class methodsFor: 'operations' stamp: 'tbn 11/9/2012 22:13'!shellPrint: file	"	self shellPrint: 'c:\index.html'	"	^self shellExecute: 'print' file: file parameters: '' directory: '' show: SW_SHOW! !!NBWin32Shell class methodsFor: 'operations' stamp: 'tbn 11/9/2012 22:25'!shellRunDLL: cmd	"	self shellRunDLL: 'shell32.dll,Control_RunDLL odbccp32.cpl'	"		^self shellExecute: 'open' file: 'rundll32.exe' parameters: cmd directory: '' show: SW_SHOW! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:32'!showAccessibilityCommonSettings	"Show the common settings for accessibility			self showAccessibilityCommonSettings	"	^self shellRunDLL: 'shell32.dll,Control_RunDLL access.cpl,,5'! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:32'!showAccessibilityDisplaySettings	"Show the keyboard settings 			self showAccessibilityDisplaySettings	"	^self shellRunDLL: 'shell32.dll,Control_RunDLL access.cpl,,3'! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:32'!showAccessibilityKeyboardSettings	"Show the keyboard settings for Windows accessibility			self showAccessibilityKeyboardSettings	"	^self shellRunDLL: 'shell32.dll,Control_RunDLL access.cpl,,1'! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:32'!showAccessibilityMouseSettings	"Show the mouse settings for accessibility 			self showAccessibilityMouseSettings	"	^self shellRunDLL: 'shell32.dll,Control_RunDLL access.cpl,,4'! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:32'!showAccessibilitySoundSettings	"Show the sound settings for accessibility 			self showAccessibilitySoundSettings	"	^self shellRunDLL: 'shell32.dll,Control_RunDLL access.cpl,,2'! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:32'!showAddPrinterWizard	"	self showAddPrinterWizard	"	^self shellRunDLL: 'shell32.dll,SHHelpShortcuts_RunDLL AddPrinter' ! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:32'!showBluetoothSettings	"			self showBluetoothSettings	"	^self shellRunDLL: 'irprops.cpl,,BluetoothAuthenticationAgent'! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:32'!showCOMPortsSettings	"	self showCOMPortsSettings	"	^self shellRunDLL: 'shell32.dll,Control_RunDLL ports.cpl' ! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:32'!showControlPanel	"	self showControlPanel	"	^self shellRunDLL: 'Shell32.dll,Control_RunDLL'! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:32'!showDateTimeProperties	"	self showDateTimeProperties	"	^self shellRunDLL: 'Shell32.dll,Control_RunDLL Timedate.cpl'! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:32'!showDateTimePropertiesTimezone	"	self showDateTimePropertiesTimezone	"	^self shellRunDLL: 'shell32.dll,Control_RunDLL timedate.cpl,,/f'! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:32'!showDisplaySettingsAppearance	"  			self showDisplaySettingsAppearance	"	^self shellRunDLL: 'shell32.dll,Control_RunDLL desk.cpl,,2'! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:33'!showDisplaySettingsBackground	"  			self showDisplaySettingsBackground	"	^self shellRunDLL: 'shell32.dll,Control_RunDLL desk.cpl,,0'! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:33'!showDisplaySettingsCommon	"  			self showDisplaySettingsCommon	"	^self shellRunDLL: 'shell32.dll,Control_RunDLL desk.cpl,,3'! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:33'!showDisplaySettingsScreenSaver	"  			self showDisplaySettingsScreenSaver	"	^self shellRunDLL: 'shell32.dll,Control_RunDLL desk.cpl,,1'! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:33'!showFindFastSetting	"		self showFindFastSetting	"	^self shellRunDLL: 'shell32.dll,Control_RunDLL findfast.cpl'! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:33'!showFontsInstallationFolder	"	self showFontsInstallationFolder	"	^self shellRunDLL: 'Shell32.dll,SHHelpShortcuts_RunDLL FontsFolder'! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:33'!showFontsProperties	"	self showFontsProperties	"	^self shellRunDLL: 'shell32.dll,Control_RunDLL main.cpl @3'! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:33'!showFormatDrive	"	self showFormatDrive	"	^self shellRunDLL: 'shell32.dll,SHFormatDrive'! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:33'!showHotPlugRemoveDialog	"	self showHotPlugRemoveDialog	"	^self shellRunDLL: 'Shell32.dll,Control_RunDLL HotPlug.dll'! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:33'!showInternationalSettingsCurrency	"			self showInternationalSettingsCurrency	"	^self shellRunDLL: 'Shell32.dll,Control_RunDLL Intl.cpl,,2'! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:33'!showInternationalSettingsDate	"Show the internation settings for input locales.			self showInternationalSettingsDate	"	^self shellRunDLL: 'Shell32.dll,Control_RunDLL Intl.cpl,,4'! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:33'!showInternationalSettingsInputLocales	"Show the internation settings for input locales.			self showInternationalSettingsInputLocales	"	^self shellRunDLL: 'Shell32.dll,Control_RunDLL Intl.cpl,,5'! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:34'!showInternationalSettingsNumber	"Show the internation settings dialog for number.			self showInternationalSettingsNumber	"	^self shellRunDLL: 'Shell32.dll,Control_RunDLL Intl.cpl,,1'! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:34'!showInternationalSettingsRegionalSettings	"Show the regional and language settings. 			self showInternationalSettingsRegionalSettings	"	^self shellRunDLL: 'Shell32.dll,Control_RunDLL Intl.cpl,,0'! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:34'!showInternationalSettingsTime	"Show the internation settings for input locales.			self showInternationalSettingsTime	"	^self shellRunDLL: 'Shell32.dll,Control_RunDLL Intl.cpl,,3'! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:34'!showInternetExplorerFavoriteManager	"	self showInternetExplorerFavoriteManager	"	^self shellRunDLL: 'shdocvw.dll,DoOrganizeFavDlg'! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:34'!showInternetExplorerSettings	"Show the internet explorer settings 			self showInternetExplorerSettings	"	^self shellRunDLL: 'Shell32.dll,Control_RunDLL Inetcpl.cpl,,6'! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:34'!showInternetSettingsAdvanced	"  			self showInternetSettingsAdvanced	"	^self shellRunDLL: 'Shell32.dll,Control_RunDLL Inetcpl.cpl,,6'! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:34'!showInternetSettingsConnections	"  			self showInternetSettingsConnections	"	^self shellRunDLL: 'Shell32.dll,Control_RunDLL Inetcpl.cpl,,4'! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:34'!showInternetSettingsContent	"  			self showInternetSettingsContent	"	^self shellRunDLL: 'Shell32.dll,Control_RunDLL Inetcpl.cpl,,3'! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:34'!showInternetSettingsGeneral	"  			self showInternetSettingsGeneral	"	^self shellRunDLL: 'Shell32.dll,Control_RunDLL Inetcpl.cpl,,0'! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:34'!showInternetSettingsPrograms	"  			self showInternetSettingsPrograms	"	^self shellRunDLL: 'Shell32.dll,Control_RunDLL Inetcpl.cpl,,5'! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:35'!showInternetSettingsSecurity	"  			self showInternetSettingsSecurity	"	^self shellRunDLL: 'Shell32.dll,Control_RunDLL Inetcpl.cpl,,1'! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:35'!showJoystickSettings	"			self showJoystickSettings	"	^self shellRunDLL: 'shell32.dll,Control_RunDLL joy.cpl'! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:35'!showKeyboardProperties	"	self showKeyboardProperties	"	^self shellRunDLL: 'shell32.dll,Control_RunDLL main.cpl @1'! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:35'!showMailAndFaxSettings	"	self showMailAndFaxSettings	"	^self shellRunDLL: 'shell32.dll,Control_RunDLL mlcfg32.cpl'! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:35'!showMapNetworkDriveWizard	"	self showMapNetworkDriveWizard	"	^self shellRunDLL: 'Shell32.dll,SHHelpShortcuts_RunDLL Connect'! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:35'!showMicrosoftWorkgroupPostofficeSettings	"	self showMicrosoftWorkgroupPostofficeSettings	"	^self shellRunDLL: 'shell32.dll,Control_RunDLL wgpocpl.cpl'! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:35'!showModemSettings	"	self showModemSettings	"	^self shellRunDLL: 'shell32.dll,Control_RunDLL modem.cpl' ! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:35'!showMouseProperties	"	self showMouseProperties	"	^self shellRunDLL: 'Shell32.dll,Control_RunDLL main.cpl @0,0'! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:35'!showMultimediaSettingsAudio	"	self showMultimediaSettingsAudio	"	^self shellRunDLL: 'shell32.dll,Control_RunDLL mmsys.cpl,,0'! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:35'!showMultimediaSettingsCDMusic	"	self showMultimediaSettingsCDMusic	"	^self shellRunDLL: 'shell32.dll,Control_RunDLL mmsys.cpl,,3'! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:35'!showMultimediaSettingsDevices	"	self showMultimediaSettingsDevices	"	^self shellRunDLL: 'shell32.dll,Control_RunDLL mmsys.cpl,,4'! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:36'!showMultimediaSettingsMIDI	"	self showMultimediaSettingsMIDI	"	^self shellRunDLL: 'shell32.dll,Control_RunDLL mmsys.cpl,,2'! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:36'!showMultimediaSettingsVideo	"	self showMultimediaSettingsVideo	"	^self shellRunDLL: 'shell32.dll,Control_RunDLL mmsys.cpl,,1'! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:36'!showODBCSettings	"	self showODBCSettings	"	^self shellRunDLL: 'shell32.dll,Control_RunDLL odbccp32.cpl' ! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:36'!showPowerOptions	"	self showPowerOptions	"	^self shellRunDLL: 'Shell32.dll,Control_RunDLL Ups.cpl'! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:36'!showPrinterManagementFolder	"	self showPrinterManagementFolder	"	^self shellRunDLL: 'Shell32.dll,SHHelpShortcuts_RunDLL PrintersFolder'! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:36'!showPrinterProperties	"	self showPrinterProperties	"	^self shellRunDLL: 'shell32.dll,Control_RunDLL main.cpl @2'! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:36'!showProgramPropertiesInstallUninstall	"  			self showProgramPropertiesInstallUninstall	"	^self shellRunDLL: 'shell32.dll,Control_RunDLL appwiz.cpl,,1'! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:36'!showProgramPropertiesStartupDisk	"  			self showProgramPropertiesStartupDisk	"	^self shellRunDLL: 'shell32.dll,Control_RunDLL appwiz.cpl,,3'! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:36'!showProgramPropertiesWindowsSetup	"  			self showProgramPropertiesWindowsSetup	"	^self shellRunDLL: 'shell32.dll,Control_RunDLL appwiz.cpl,,2'! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:36'!showServerProperties	"	self showServerProperties	"	^self shellRunDLL: 'shell32.dll,Control_RunDLL srvmgr.cpl' ! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:36'!showSoundSettings	"Show the sound properties dialog box. 			self showSoundSettings	"	^self shellRunDLL: 'Shell32.dll,Control_RunDLL Mmsys.cpl,,0'! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:37'!showSystemSettings	"Show the system settings. Note that the argument zero opens the first tab. 			self showSystemSettings	"	^self shellRunDLL: 'Shell32.dll,Control_RunDLL Sysdm.cpl,,0'! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:37'!showTelephonySettings	"	self showTelephonySettings	"	^self shellRunDLL: 'shell32.dll,Control_RunDLL telephon.cpl' ! !!NBWin32Shell class methodsFor: 'control panel applets' stamp: 'tbn 11/9/2012 22:37'!showThemesSettings	"	self showThemesSettings	"	^self shellRunDLL: 'shell32.dll,Control_RunDLL themes.cpl' ! !!NBWinTest class methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 4/29/2010 15:35'!createWindow"	NBWin32Window		createWindowExA: 		lpClassName:  lpWindowName:  dwStyle:  x:  y:  width:  height:  hWndParent:  hMenu:  hInstance:  lParam: 			"! !!NBWinTypes class methodsFor: 'initialization' stamp: 'Igor.Stasenko 5/19/2010 07:14'!initialize	" self initialize "	BOOL := #bool.	DWORD := #ulong.	HWND := #NBWin32Window.	HDC := #NBWin32Hdc.	HMENU := #HANDLE.	UINT := #ulong.		ATOM := #WORD.	BOOLEAN := #BYTE.	BYTE := #unsignedByte.	CALLBACK := #'void*'.	CHAR := #char.	COLORREF := #DWORD.	DWORDLONG := #ULONGLONG.	DWORD32 := #ulong.	DWORD64 := #ulonglong.	FLOAT := #float.	HRESULT := #LONG.	INT := #long.	INT32 := #long.	INT64 := #longlong.	LANGID := #WORD.	LCID := #DWORD.	LCTYPE := #DWORD.	LGRPID := #DWORD.	LONG := #long.	LONGLONG := #longlong.	LONG32 := #long.	LONG64 := #longlong.	LPARAM := #'LONG_PTR'.	LPBOOL := #'BOOL*'.	LPBYTE := #'BYTE*'.	LPCOLORREF := #'DWORD*'.	LPCVOID := #'void*'.	LPDWORD := #'DWORD*'.		WNDPROC := #'void*'.	HANDLE := #NBWin32Handle.	HINSTANCE :=  HMODULE := HCURSOR := HBRUSH := 	HACCEL :=  HCOLORSPACE :=  HCONV := HICON := HCONVLIST := HDDEDATA := 	HDESK := HDROP := HDWP := HENHMETAFILE := HFILE := HFONT := HGDIOBJ  := 	HGLOBAL  := HHOOK  := HKEY  := HKL  := HLOCAL  := HMETAFILE  := HMODULE :=	HMONITOR  := HPALETTE  := HPEN  := HRGN  := HRSRC  := HSZ  := HWINSTA := #HANDLE.	self initialize2.	self initialize3.	self stringTypes.	self objTypes.	! !!NBWinTypes class methodsFor: 'initialization' stamp: 'Igor.Stasenko 4/29/2010 13:37'!initialize2	" self initialize "		DWORD_PTR :=	#ULONG_PTR.	HALF_PTR := #short. "Half the size of a pointer"	INT_PTR := #long.	LONG_PTR := #long.	PDWORD_PTR := 'DWORD_PTR*'.	PHALF_PTR := 'HALF_PTR*'.	PINT_PTR := 'INT_PTR*'.	PLONG_PTR := 'LONG_PTR*'.		POINTER_32 := '__ptr32'.	POINTER_64 := '__ptr64'.	PSIZE_T := 'SIZE_T*'.	PSSIZE_T := 'SSIZE_T*'.	PUHALF_PTR := 'UHALF_PTR*'.	PUINT_PTR := 'UINT_PTR*'.	PULONG_PTR := 'ULONG_PTR*'.	SC_HANDLE := #HANDLE.	SC_LOCK := #LPVOID.	SERVICE_STATUS_HANDLE := #HANDLE.	SIZE_T := 'ULONG_PTR'.	SSIZE_T := 'LONG_PTR'.	UHALF_PTR := #ushort.  "different in 32/64"	UINT_PTR := #uint.	ULONG_PTR := #ulong. "different in 32/64"					! !!NBWinTypes class methodsFor: 'initialization' stamp: 'Igor.Stasenko 4/29/2010 14:23'!initialize3	" self initialize "		LPHANDLE := 'HANDLE*'.	LPINT := 'INT*'.	LPLONG := 'LONG*'.		LPVOID := 'void*'.	LPWORD := 'WORD*'.	LRESULT := 'LONG_PTR'.	PBOOL := 'BOOL*'.	PBOOLEAN := 'BOOLEAN*'.	PBYTE := 'BYTE*'.	PCHAR := 'CHAR*'.	PDWORD := 'DWORD*'.	PDWORDLONG := 'DWORDLONG*'.	PDWORD32 := 'DWORD32*'.	PDWORD64 := 'PDWORD64*'.	PFLOAT := 'FLOAT*'.	PHANDLE :='HANDLE*'.	PHKEY := 'HKEY*'.	PINT := 'INT*'.	PINT32 := 'INT32*'.	PINT64 := 'INT64*'.	PLCID := 'PDWORD'.	PLONG := 'LONG*'.	PLONGLONG := 'LONGLONG*'.	PLONG32 := 'LONG32*'.	PLONG64 := 'LONG64*'.	PSHORT := 'SHORT*'.	PTBYTE := 'TBYTE*'.	PTCHAR := 'TCHAR*'.	PUCHAR := 'UCHAR*'.	PUINT := 'UINT*'.	PUINT32 := 'UINT32*'.	PUINT64 := 'UINT64*'.	PULONG := 'ULONG*'.	PULONGLONG := 'ULONGLONG*'.	PULONG32 := 'ULONG32*'.	PULONG64 := 'ULONG64*'.	PUSHORT := 'USHORT*'.	PVOID := 'void*'.	PWCHAR := 'WCHAR*'.	PWORD := 'WORD*'.	SHORT := 'short'.	TBYTE := 'TCHAR'.	UCHAR := #uchar.	UINT := #uint.	UINT32 := #uint.	UINT64 := #uint64.	ULONG := #ulong.	ULONGLONG := #ulonglong.	ULONG32 := #uint.	ULONG64 := #uint64.	USHORT := #ushort.	USN := #LONGLONG.	VOID := #void.	WCHAR := #ushort.	WORD := #ushort.	WPARAM := #'UINT_PTR'.					! !!NBWinTypes class methodsFor: 'object types' stamp: 'Igor.Stasenko 5/17/2010 15:19'!objTypes	WNDCLASSEX := #NBWndClassEx! !!NBWinTypes class methodsFor: 'initialization' stamp: 'Igor.Stasenko 5/17/2010 05:24'!stringTypes	TCHAR := #NBTCHAR.	LPTCH := 'TCHAR*'.	WCHAR := 'wchar_t'.	LPWCH := 'WCHAR*'.	LPTSTR := #NBTString.	LPWSTR := #NBWideString.	LPSTR := #NBExternalString.		LPCSTR := #LPSTR.	LPCTSTR := #LPTSTR.	LPCWSTR := #LPWSTR.		PCSTR := #LPCSTR.	PCTSTR := #LPCTSTR.	PCWSTR := #LPCWSTR.	PSTR := #LPSTR.	PTSTR := #LPTSTR.	PWSTR := #LPWSTR.! !!NBWndClassEx class methodsFor: 'fields description' stamp: 'Igor.Stasenko 5/19/2010 09:24'!fieldsDesc^ #(	UINT cbSize;	UINT style;	WNDPROC lpfnWndProc;	int cbClsExtra;	int cbWndExtra;	HINSTANCE hInstance;	HICON hIcon;	HCURSOR hCursor;	HBRUSH hbrBackground;	NBExternalAddress lpszMenuName;	NBExternalAddress lpszClassName;	HICON hIconSm;)! !!NBWndClassEx class methodsFor: 'unregistering' stamp: 'Igor.Stasenko 5/17/2010 18:54'!unregister: aWndClassName 	^ self unregister: aWndClassName instance: NativeBoostWin32 getVMModuleHandle.! !!NBWndClassEx class methodsFor: 'unregistering' stamp: 'IgorStasenko 11/24/2012 17:40'!unregister: aWndClassName instance: hInstance	<primitive: #primitiveNativeCall module: #NativeBoostPlugin >	^ self nbCallout stdcall  		function: #( BOOL UnregisterClassA ( LPCTSTR aWndClassName, HINSTANCE hInstance ))		module: #user32	! !!NBWndClassEx methodsFor: 'initialize-release' stamp: 'Igor.Stasenko 4/29/2010 14:05'!initialize	self cbSize: (self basicSize).! !!NBWndClassEx methodsFor: 'registering' stamp: 'IgorStasenko 11/24/2012 16:24'!register	<primitive: #primitiveNativeCall module: #NativeBoostPlugin >	^ self nbCallout stdcall 		function: #( ATOM RegisterClassExA (WNDCLASSEX * self) ) 		module: #user32! !!NativeBoostWin32 class methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 11/24/2012 16:09'!getModuleHandle: lpModuleName"The GetModuleHandle function retrieves a module handle for the specified module if the file has been mapped into the address space of the calling process."	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>	^ self nbCallout 		options: #( - WinUnicode );		stdcall;		function: #( HMODULE GetModuleHandleA (LPCTSTR lpModuleName ) ) 		module: #Kernel32! !!NativeBoostWin32 class methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 11/24/2012 16:17'!getProcAddress: hModule procName: lpProcName 	<primitive: 'primitiveNativeCall' module: 'NativeBoostPlugin'>	^ self nbCallout		stdcall;		function: #( 		FARPROC GetProcAddress (			HMODULE hModule,			LPCSTR lpProcName ) ) 		module: #Kernel32! !!NativeBoostWin32 class methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 11/24/2012 16:17'!getVMModuleHandle"The GetModuleHandle function retrieves a module handle for the specified module if the file has been mapped into the address space of the calling process."	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>	^ self nbCallout		stdcall;		function: #( HMODULE GetModuleHandleA (0) ) 		module: #Kernel32! !!NativeBoostWin32 class methodsFor: 'accessing' stamp: 'tbn 11/11/2012 01:01'!getVMModuleName	| len str |		str := ByteString new: 1000.	len := self primGetModuleFileName: str with: 1000.		^ str first: len.! !!NativeBoostWin32 class methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 11/24/2012 16:18'!loadLibrary: libName	<primitive: 'primitiveNativeCall' module: 'NativeBoostPlugin'>	^ self nbCallout		stdcall function: #( long LoadLibraryA ( String libName )) module: #Kernel32! !!NativeBoostWin32 class methodsFor: 'C heap access' stamp: 'IgorStasenko 11/24/2012 16:18'!malloc: aSize	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #( void* malloc (ulong aSize) ) module: 'crtdll.dll'! !!NativeBoostWin32 class methodsFor: 'as yet unclassified' stamp: 'tbn 11/10/2012 23:48'!primGetModuleFileName: lpFileName with: nSize"The GetModuleFileName function retrieves the fully-qualified path for the file that contains the specified module that the current process owns."	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>	^ NBFFICallout 		stdcall: #(			DWORD GetModuleFileNameA (				0,				char * lpFileName,				DWORD nSize)) 		module: #Kernel32		options: #( - optCoerceNilToNull WinUnicode )! !!NativeBoostWin32 class methodsFor: 'C heap access' stamp: 'IgorStasenko 11/24/2012 16:19'!realloc: address newSize: aSize	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(ulong realloc (ulong address, ulong aSize)) module: 'crtdll.dll'! !!NativeBoostWin32 class methodsFor: 'as yet unclassified' stamp: 'tbn 11/11/2012 00:47'!squeakWindowHandle	"This is slow, but efficient"		^(self loadFunction: 'stWindow' from: '') nbUInt32AtOffset: 0		! !!NativeBoostWin32 class methodsFor: 'platform id' stamp: 'Igor.Stasenko 4/29/2010 04:31'!targetPlatformId		^ Win32PlatformId! !!NativeBoostWin32 methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 9/26/2010 05:00'!CLibrary	"answer a C library path, or module handle,	use in FFI callouts as module: argument to call C run-time library function(s)"		"GNU/mingw compiler"	^ 'crtdll.dll'! !!NativeBoostWin32 methodsFor: 'retrieving symbols' stamp: 'IgorStasenko 2/8/2013 12:56'!VMModule	^ self class getVMModuleHandle handle! !!NativeBoostWin32 methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 5/3/2010 10:59'!basicAllocate: numBytes	"answer an instance of NBExternalAddress, or nil if failed"	| address |	address := NBExternalAddress new.	self bootstrapAllocate: numBytes into: address.	(address asUnsignedLong) = 0 ifTrue: [ ^ nil ].	^ address! !!NativeBoostWin32 methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 11/24/2012 16:08'!bootstrapAllocate: size into: returnValueBuffer	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>	^ self nbCallout 		stdcall;		options: #( - optDirectProxyFnAddress optAllowExternalAddressPtr);		function: #( NBBootstrapUlong HeapAlloc (ulong heapHandle , 0 , SIZE_T size) ) module: #Kernel32! !!NativeBoostWin32 methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 11/24/2012 16:08'!free: lpMem"The HeapFree function frees a memory block allocated from a heap by the HeapAlloc or HeapReAlloc function. "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>	^ self nbCallout		stdcall;		"allow only external address"		options: #( - optAllowByteArraysPtr + optAllowExternalAddressPtr );		function: #( BOOL HeapFree (ulong heapHandle, 0, LPVOID lpMem) ) module: #Kernel32! !!NativeBoostWin32 methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 5/3/2010 10:50'!initializeExternalHeap	"initialize external memory heap"	| bytes |	bytes := ByteArray new: 4.	self privCreateHeap: bytes.	heapHandle := bytes unsignedLongAt: 1 bigEndian: false.	heapHandle = 0 ifTrue: [ self error: 'Unable to create external heap' ].	! !!NativeBoostWin32 methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 8/5/2011 08:48'!newAssembler	^ AJx86Assembler new.! !!NativeBoostWin32 methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 5/3/2010 10:44'!pointerSize	^ 4! !!NativeBoostWin32 methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 11/24/2012 16:09'!privCreateHeap: returnValueBuffer	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>	^ self nbCallout			options: #( - optDirectProxyFnAddress );			stdcall;			function: #( NBBootstrapUlong HeapCreate ( HEAP_CREATE_ENABLE_EXECUTE , 0 , 0 ) ) module: #Kernel32! !!NativeBoostWin32 methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 8/3/2011 08:08'!stackAlignment	^ 1! !"NativeBoost-Win32"!!NBMockExternalObject class methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 8/24/2012 17:18'!finalizeResourceData: object	object value! !!NBMockExternalObject methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 8/24/2012 17:05'!data: anObject	data := anObject! !!NBMockExternalObject methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 8/24/2012 17:05'!resourceData	^ data! !!NBTestUnion1Byte class methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 1/19/2013 17:28'!fieldsDesc	"		self rebuildFieldAccessors		 "	^#(		byte field1		byte field2		)! !!NBTestUnion2Pointers class methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 1/19/2013 17:31'!fieldsDesc	"			self rebuildFieldAccessors 			"	^ #(		NBExternalAddress addr1		NBExternalAddress addr2		)! !!NBTestUnionIntSize class methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 1/19/2013 17:33'!fieldsDesc	" 		self rebuildFieldAccessors 			"	^ #(		int x;		int y;		char field		)! !!NBTestUnionWithCallback class methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 1/19/2013 17:36'!fieldsDesc	" 		self rebuildFieldAccessors 			"	^ #(		char x;		NBQSortCallback callback;		)! !!NBTestUnionWithStructure class methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 1/19/2013 17:38'!fieldsDesc	"		self rebuildFieldAccessors		 "	^ #(		char x;		NBTestStructure9bytes struct;		int z;	)! !!NBTestUnionWithUnion class methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 1/19/2013 17:43'!fieldsDesc	"		self rebuildFieldAccessors		 "	^ #(		char x;		NBTestUnionIntSize union;		double z;	)! !!NBTestNestedStructure class methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 5/26/2012 19:45'!fieldsDesc" self createAccessors "	^ #(			NBTestStructure1byte oneByte;		int otherField		)! !!NBTestStructure class methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 9/3/2012 01:44'!fieldsDesc" self rebuildFieldAccessors "	^ #(		byte byte;		short short;		long long;		float float;		double double;		int64 int64;		)! !!NBTestStructure1byte class methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 9/3/2012 02:36'!fieldsDesc" self rebuildFieldAccessors "	^ #(		byte field		)! !!NBTestStructure2 class methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 9/3/2012 02:36'!fieldsDesc" self rebuildFieldAccessors "	^ #(		NBExternalAddress addr		)! !!NBTestStructure9bytes class methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 9/3/2012 02:36'!fieldsDesc" self rebuildFieldAccessors"	^ #(		int x;		int y;		char field		)! !!NBTestStructureWithCallback class methodsFor: 'as yet unclassified' stamp: 'cipt 11/28/2012 19:10'!fieldsDesc" self rebuildFieldAccessors "	^ #(		int x;		NBQSortCallback callback;		int y;		)! !!NBTestEnumeration class methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 12/11/2012 19:10'!enumDecl	^ {(#AAA -> 1).	(#BBB -> 2).	(#CCC -> 3).	(#DDD -> 2400)} asDictionary ! !!NBTestEnumerationFromPairs class methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 12/13/2012 08:22'!enumDecl	^ #(AAA 1	BBB  2	CCC 3	DDD 2400) ! !!NBExternalAddressTests methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 8/4/2011 08:25'!testAddressAndStruct	| struct addr string |		struct := NBTestStructure2 new.		self assert: struct addr class == NBExternalAddress .  		addr := NativeBoost allocate: 10.	[		addr writeString: 'abcde'.		struct addr: addr.				self assert: addr = struct addr.		string := struct addr readString .			] ensure: [ NativeBoost free: addr ].	self assert: string = 'abcde'! !!NBExternalAddressTests methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 5/13/2010 22:51'!testMemoryAccess	| addr |		addr := NativeBoost allocate: 10.	[		1 to: 10 do: [:i |			addr byteAt: i-1 put: i ].			1 to: 10 do: [:i |			self assert: (addr byteAt: i-1) = i ].	] ensure: [ NativeBoost free: addr ]! !!NBExternalAddressTests methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 8/4/2011 07:29'!testStringAccess	| addr string |		addr := NativeBoost allocate: 10.	[		addr writeString: 'abcde'.		string := addr readString. 	] ensure: [ NativeBoost free: addr ].	self assert: string = 'abcde'! !!NBExternalAddressTests methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 8/4/2011 08:50'!testStructCopy	| struct addr string struct2 |		struct := NBTestStructure new.		struct byte: 5;		long: 10;		short: 20.			addr := NativeBoost allocate: NBTestStructure instanceSize.		NativeBoost memCopy: struct to: addr size:  NBTestStructure instanceSize.	struct2 := NBTestStructure fromPointer: addr.	NativeBoost free: addr.		  	self assert: struct2 byte = 5.	self assert: struct2 long = 10.	self assert: struct2 short = 20.! !!NBExternalEnumFromPairsTest methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 12/13/2012 20:14'!cbClass	^NBTestCallbackReturnEnum1  ! !!NBExternalEnumFromPairsTest methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 12/13/2012 20:01'!enumClass	^NBTestEnumerationFromPairs ! !!NBExternalEnumFromPairsTest methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 12/13/2012 20:27'!enumToInt: anEnum 	^self primEnumToInt1: anEnum ! !!NBExternalEnumFromPairsTest methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 12/13/2012 20:25'!executeCb: anEnumCb	^self primExecuteCallbackEnumReturn1: anEnumCb	! !!NBExternalEnumFromPairsTest methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 12/13/2012 20:26'!primEnumToInt1: aMyEnumInst	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>	^ NBFFICallout 		cdecl: {NBInt32. {self enumClass. #aMyEnumInst}}		emitCall: [ :gen :proxy :asm | 			asm pop: asm EAX 		]! !!NBExternalEnumFromPairsTest methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 12/13/2012 20:25'!primExecuteCallbackEnumReturn1: anEnumCb	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>	^ NBFFICallout		cdecl: {self enumClass. {self cbClass. #anEnumCb}}		emitCall: [ :gen :proxy :asm | 			asm pop: asm EAX.			asm push: 2400 asImm.			asm call: asm EAX ]		options: #(#optMayGC)! !!NBExternalEnumTests methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 12/13/2012 20:06'!callback	^ self cbClass on: [ :anInt | self enumClass at: (self enumClass itemAt: anInt) ]! !!NBExternalEnumTests methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 12/13/2012 20:06'!callbackAAA	^ self cbClass on: [ :anInt | self enumClass AAA ]! !!NBExternalEnumTests methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 12/13/2012 20:06'!callbackWrongReturn	^ self cbClass		on: [ :anInt | 			"this callback will return a plain integer"			self enumClass itemAt: anInt ]! !!NBExternalEnumTests methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 12/13/2012 20:06'!cbClass	 ^NBTestCallbackReturnEnum! !!NBExternalEnumTests methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 12/11/2012 19:53'!enumClass	^NBTestEnumeration ! !!NBExternalEnumTests methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 12/13/2012 20:27'!enumToInt: anEnum	^self primEnumToInt: anEnum ! !!NBExternalEnumTests methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 12/13/2012 20:24'!executeCb: anEnumCb	^self primExecuteCallbackEnumReturn: anEnumCb	! !!NBExternalEnumTests methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 12/13/2012 20:02'!initialize	super initialize.	self enumClass initialize! !!NBExternalEnumTests methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 12/13/2012 20:04'!primEnumToInt: aMyEnumInst	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>	^ NBFFICallout 		cdecl: {NBInt32. {self enumClass. #aMyEnumInst}}		emitCall: [ :gen :proxy :asm | 			asm pop: asm EAX 		]! !!NBExternalEnumTests methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 12/13/2012 20:05'!primExecuteCallbackEnumReturn: anEnumCb	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>	^ NBFFICallout		cdecl: {self enumClass. {self cbClass. #anEnumCb}}		emitCall: [ :gen :proxy :asm | 			asm pop: asm EAX.			asm push: 2400 asImm.			asm call: asm EAX ]		options: #(#optMayGC)! !!NBExternalEnumTests methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 12/13/2012 20:05'!primIntToEnum: anInteger	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>	^ NBFFICallout 		cdecl: {self enumClass. {#NBInt32. #anInteger}}		emitCall: [ :gen :proxy :asm | 			asm pop: asm EAX. 		]! !!NBExternalEnumTests methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 12/13/2012 20:25'!testCallbackAAA	|result|	result := (self executeCb:  self callbackAAA ).	self assert: (result isKindOf: self enumClass ).	self assert: result value = 1.	self assert: result item = #AAA.! !!NBExternalEnumTests methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 12/13/2012 20:25'!testCallbackEnumFromInt	|result|	result := (self executeCb:  self callback ).	self assert: (result isKindOf: self enumClass ).	self assert: result value = 2400.	self assert: result item = #DDD. ! !!NBExternalEnumTests methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 12/13/2012 08:25'!testCallbackWrongReturn	"there is an issue with callback return. If it fails I cannot see how we can catch the exception and continue"	"so this test is supposed to fail for now."	"In the future we might accept enumeration representation values (int/uint) and fix this"	<expectedFailure>	self should: [Error signal. self primExecuteCallbackEnumReturn: self callbackWrongReturn ] raise: NBNativeCodeError! !!NBExternalEnumTests methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 12/10/2012 20:11'!testEnumIdents	self assert: self enumClass AAA value = 1.	self assert: self enumClass DDD value = 2400! !!NBExternalEnumTests methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 12/10/2012 19:58'!testEnumIncludes	self assert: (self enumClass includes: #DDD).	self deny: (self enumClass includes: #EEE)! !!NBExternalEnumTests methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 12/13/2012 20:27'!testEnumToInt	self assert: (self enumToInt:  self enumClass AAA) = 1.	self assert: (self enumToInt: self enumClass BBB) = 2.	self assert: (self enumToInt: self enumClass CCC) = 3.	self assert: (self enumToInt: self enumClass DDD) = 2400.! !!NBExternalEnumTests methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 12/13/2012 19:59'!testFromIntegerFailure	self should: [ self enumClass fromInteger: 234 ] raise: Error! !!NBExternalEnumTests methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 12/13/2012 19:59'!testFromIntegerOk	self assert: (self enumClass fromInteger:  1) value = 1 .	self assert: (self enumClass fromInteger: 2) value = 2.	self assert: (self enumClass fromInteger: 3) value = 3.	self assert: (self enumClass fromInteger: 2400) value = 2400.! !!NBExternalEnumTests methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 12/10/2012 19:57'!testIntToEnum	self assert: (self primIntToEnum: 1) value = 1 .	self assert: (self primIntToEnum: 2) value = 2.	self assert: (self primIntToEnum: 3) value = 3.	self assert: (self primIntToEnum: 2400) value = 2400.! !!NBExternalEnumTests methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 12/10/2012 19:57'!testIntToEnumNotIncluded	self assert: (self primIntToEnum: 7) value = 7.	self assert: (self primIntToEnum: 3) value = 3.		self assert: (self primIntToEnum: 7) item isNil.	self assert: (self primIntToEnum: 256) item isNil.! !!NBExternalEnumTests methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 12/10/2012 21:04'!testNewError	self should: [ self enumClass new ] raise: ShouldNotImplement! !!NBExternalEnumTests methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 12/13/2012 20:07'!testNotEnumMember	self should: [ self enumClass TTT ] raise: MessageNotUnderstood ! !!NBExternalHeapManagerTests methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 8/5/2011 07:20'!newHeap	^  NBMockExternalHeapManager new! !!NBExternalHeapManagerTests methodsFor: 'as yet unclassified' stamp: 'FernandoOlivero 10/5/2010 20:47'!testAllocate	" 		self new testAllocate 		"	| heap address size |		size := 100.	heap := self newHeap.		address := heap allocate: size.		self assert:  ( heap isValidAddress: address size: size ) .	self assert:   heap totalAllocatedMemory = size.	self assert:   heap numPages = 1 .	self assert:  heap numAllocatedBlocks = 1.	heap free: address.	self assert: heap numAllocatedBlocks = 0.	self assert: heap numPages = 0 .	self assert: heap numBlocks = 0 .	self assert:  (heap isValidAddress: address size: size) not .		self assert: heap totalAllocatedMemory = 0.			! !!NBExternalHeapManagerTests methodsFor: 'as yet unclassified' stamp: 'FernandoOlivero 10/5/2010 20:45'!testAllocate2	" 		self new testAllocate2 		"	| heap addr1 addr2 |		heap := self newHeap.	addr1 := heap allocate: 1.	addr2 := heap allocate: 2.		self assert:  heap totalAllocatedMemory = 3 .	self assert:  heap numAllocatedBlocks = 2 .	heap free: addr1.	self assert:  heap numAllocatedBlocks = 1.	self assert:  heap totalAllocatedMemory = 2 .	heap free: addr2.		self assert:  heap numPages = 0 .	self assert: heap numBlocks = 0 .	self assert:  heap totalAllocatedMemory = 0 .			! !!NBFFICalloutIndirectArgumentTests methodsFor: 'error messages' stamp: 'cipt 10/26/2012 21:05'!boundsError	^'Bound checking failed on indirect argument loading'! !!NBFFICalloutIndirectArgumentTests methodsFor: 'nativeboost-primitives' stamp: 'IgorStasenko 11/24/2012 17:11'!primIsPointers: anObject	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>	^ self nbCallout function: #(NBBool (oop anObject)) 		emit: [ :gen :proxy :asm | 			asm pop: asm EAX. 			proxy isPointers:  asm EAX 		]! !!NBFFICalloutIndirectArgumentTests methodsFor: 'nativeboost-primitives' stamp: 'IgorStasenko 11/24/2012 17:12'!returnOop1Of: anArg 	<primitive: #primitiveNativeCall module: #NativeBoostPlugin >		^ self nbCallout 		options: #( + optUseStackPointer optNoAlignment +optCheckIndirectArgBounds - optDirectProxyFnAddress );				function: #( oop (oop anArg@1) ) emit: [:gen |		gen asm mov: gen asm ESP ptr to: gen asm EAX ]	! !!NBFFICalloutIndirectArgumentTests methodsFor: 'nativeboost-primitives' stamp: 'IgorStasenko 11/24/2012 17:13'!returnOop2Of: anArg 	<primitive: #primitiveNativeCall module: #NativeBoostPlugin >		^ self nbCallout		options: #( + optUseStackPointer optNoAlignment +optCheckIndirectArgBounds - optDirectProxyFnAddress );		 function: #( oop (oop anArg@2) ) emit: [:gen |			gen asm mov: gen asm ESP ptr to: gen asm EAX ]	! !!NBFFICalloutIndirectArgumentTests methodsFor: 'nativeboost-primitives' stamp: 'IgorStasenko 11/24/2012 17:13'!returnOop5Of: anArg 	<primitive: #primitiveNativeCall module: #NativeBoostPlugin >		^ self nbCallout 		options: #( + optUseStackPointer optNoAlignment +optCheckIndirectArgBounds - optDirectProxyFnAddress );			function: #( oop (oop anArg@5) ) emit: [:gen |			gen asm mov: gen asm ESP ptr to: gen asm EAX ]	! !!NBFFICalloutIndirectArgumentTests methodsFor: 'nativeboost-primitives' stamp: 'IgorStasenko 11/24/2012 17:14'!returnOopMinus1Of: anArg 	<primitive: #primitiveNativeCall module: #NativeBoostPlugin >		^ self nbCallout		options: #( + optUseStackPointer optNoAlignment +optCheckIndirectArgBounds - optDirectProxyFnAddress );		function: #( oop (oop anArg@ -1) ) emit: [:gen |			gen asm mov: gen asm ESP ptr to: gen asm EAX ]	! !!NBFFICalloutIndirectArgumentTests methodsFor: 'nativeboost-primitives' stamp: 'IgorStasenko 11/24/2012 17:15'!returnOopMinus3Of: anArg 	<primitive: #primitiveNativeCall module: #NativeBoostPlugin >		^ self nbCallout 		options: #( + optUseStackPointer optNoAlignment +optCheckIndirectArgBounds - optDirectProxyFnAddress );		function: #( oop (oop anArg@ -3) ) emit: [:gen |			gen asm mov: gen asm ESP ptr to: gen asm EAX ]	! !!NBFFICalloutIndirectArgumentTests methodsFor: 'tests' stamp: 'cipt 10/27/2012 12:23'!testIndirectArgumentArrayNegativeIndirect	| array |	array := {1.	2.	3.	4.	5}.	self should: [(self returnOopMinus1Of: array)] raise: NBFFICalloutError  withExceptionDo: [:anEx | self assert: anEx messageText = self boundsError ].	self should: [(self returnOopMinus3Of: array)] raise: NBFFICalloutError  withExceptionDo: [:anEx | self assert: anEx messageText = self boundsError ].! !!NBFFICalloutIndirectArgumentTests methodsFor: 'tests' stamp: 'cipt 10/26/2012 20:43'!testIndirectArgumentArrayOk	| array |	array := {1.	2.	3.	4.	5}.	self assert: (self returnOop1Of: array) == 1.	self assert: (self returnOop2Of: array) == 2.	self assert: (self returnOop5Of: array) == 5! !!NBFFICalloutIndirectArgumentTests methodsFor: 'tests' stamp: 'cipt 10/27/2012 12:21'!testIndirectArgumentDictionayFailure	| array |	array := {(1 -> 2).	(3 -> 3)} asDictionary.	self assert: (self returnOop1Of: array) =  2. "tally"	self assert: (self returnOop2Of: array) = {nil. 1->2. nil. 3->3. nil}. "array"	self		should: [ self returnOop5Of: array ]		raise: NBFFICalloutError		withExceptionDo: [ :anEx | self assert: anEx messageText = self boundsError ]! !!NBFFICalloutIndirectArgumentTests methodsFor: 'tests' stamp: 'cipt 10/26/2012 21:08'!testIndirectArgumentFloatFailure	| array |	array := 2.0.	self		should: [ self returnOop1Of: array ]		raise: NBFFICalloutError		withExceptionDo: [ :anEx | self assert: anEx messageText = self typeError ].	self		should: [ self returnOop2Of: array ]		raise: NBFFICalloutError		withExceptionDo: [ :anEx | self assert: anEx messageText = self typeError ].	self		should: [ self returnOop5Of: array ]		raise: NBFFICalloutError		withExceptionDo: [ :anEx | self assert: anEx messageText = self typeError ]! !!NBFFICalloutIndirectArgumentTests methodsFor: 'tests' stamp: 'cipt 10/27/2012 12:16'!testIndirectArgumentLargePositiveIntegerFailure	| array |	array := 100 factorial.	self		should: [ self returnOop1Of: array ]		raise: NBFFICalloutError		withExceptionDo: [ :anEx | self assert: anEx messageText = self typeError ].	self		should: [ self returnOop2Of: array ]		raise: NBFFICalloutError		withExceptionDo: [ :anEx | self assert: anEx messageText = self typeError ].	self		should: [ self returnOop5Of: array ]		raise: NBFFICalloutError		withExceptionDo: [ :anEx | self assert: anEx messageText = self typeError ]! !!NBFFICalloutIndirectArgumentTests methodsFor: 'tests' stamp: 'cipt 10/26/2012 21:08'!testIndirectArgumentObjectBoundsFailure	| array |	array := Object new.	self		should: [ self returnOop2Of: array ]		raise: NBFFICalloutError		withExceptionDo: [ :anEx | self assert: anEx messageText = self boundsError ].	self		should: [ self returnOop5Of: array ]		raise: NBFFICalloutError		withExceptionDo: [ :anEx | self assert: anEx messageText = self boundsError ]! !!NBFFICalloutIndirectArgumentTests methodsFor: 'tests' stamp: 'cipt 10/26/2012 20:53'!testIndirectArgumentObjectFirstBoundsFailure	| array |	array := Object new.	self should: [ self returnOop1Of: array ] raise: NBFFICalloutError.! !!NBFFICalloutIndirectArgumentTests methodsFor: 'tests' stamp: 'cipt 10/26/2012 21:08'!testIndirectArgumentPointFailure	| array |	array := 2 @ 5.	self assert: (self returnOop1Of: array) == 2.	self assert: (self returnOop2Of: array) == 5.	self		should: [ self returnOop5Of: array ]		raise: NBFFICalloutError		withExceptionDo: [ :anEx | self assert: anEx messageText = self boundsError ]! !!NBFFICalloutIndirectArgumentTests methodsFor: 'tests' stamp: 'cipt 10/26/2012 21:08'!testIndirectArgumentSmallIntegerFailure	| array |	array := 2.	self		should: [ self returnOop1Of: array ]		raise: NBFFICalloutError		withExceptionDo: [ :anEx | self assert: anEx messageText = self typeError ].	self		should: [ self returnOop2Of: array ]		raise: NBFFICalloutError		withExceptionDo: [ :anEx | self assert: anEx messageText = self typeError ].	self		should: [ self returnOop5Of: array ]		raise: NBFFICalloutError		withExceptionDo: [ :anEx | self assert: anEx messageText = self typeError  ]! !!NBFFICalloutIndirectArgumentTests methodsFor: 'tests' stamp: 'cipt 10/27/2012 12:41'!testIndirectableObjects	|ok |	ok := {	Object new.	{1. 2}.	{1->2. 2->3} asDictionary.	2@3.	}.	ok do:[:each | self assert: (self primIsPointers: each)].! !!NBFFICalloutIndirectArgumentTests methodsFor: 'tests' stamp: 'cipt 10/27/2012 12:43'!testNotIndirectableObjects	|ok |	ok := {	2. "small integer"	100 factorial. "large positive integer"	3.4. "float"	'abcd'. "bytestring"	'abcd' asByteArray. "bytearray"	}.	ok do:[:each | self deny: (self primIsPointers: each)].! !!NBFFICalloutIndirectArgumentTests methodsFor: 'error messages' stamp: 'cipt 10/26/2012 21:04'!typeError	^'Type checking failed on indirect argument loading'! !!NBFFICalloutTests methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 11/24/2012 17:15'!arraySize2: array with: param2		<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout		function: #(ulong (NBByteArraySize array, long param2))		emit: [:gen |			"pop the array size"			gen asm pop: gen asm EAX		]! !!NBFFICalloutTests methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 11/24/2012 17:15'!arraySize: array		<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout 		function: #(ulong (NBByteArraySize array))		emit: [:gen |			"pop the array size"			gen asm pop: gen asm EAX		]! !!NBFFICalloutTests methodsFor: 'generator callbacks' stamp: 'IgorStasenko 9/3/2012 00:12'!asNBExternalType: gen	self assert: (gen respondsTo: #asm).	self assert: (gen respondsTo: #proxy).		self assert: (gen requestor == self).		^ NBUInt32 new! !!NBFFICalloutTests methodsFor: 'tests' stamp: 'Igor.Stasenko 4/30/2010 12:02'!checkType: type class: typeClass arity: ptrArity stackIndex: stackIndex	self assert: type class == typeClass.	self assert: type pointerArity = ptrArity.	self assert: type loader class == NBSTMethodArgument.	self assert: type loader stackIndex = stackIndex ! !!NBFFICalloutTests methodsFor: 'tests' stamp: 'cipt 10/26/2012 19:32'!checkType: type class: typeClass arity: ptrArity stackIndex: stackIndex elementIndex: anIndex	self assert: type class == typeClass.	self assert: type pointerArity = ptrArity.	self assert: type loader class == NBSTIndirectArgument.	self assert: type loader argumentLoader stackIndex = stackIndex. 	self assert: type loader elementIndex = anIndex  	! !!NBFFICalloutTests methodsFor: 'tests' stamp: 'Igor.Stasenko 4/30/2010 12:03'!checkType: type class: typeClass value: const	self assert: type class == typeClass.	self assert: type value = const! !!NBFFICalloutTests methodsFor: 'tests' stamp: 'IgorStasenko 11/24/2012 17:15'!nativeFailWithCode: aCode	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout 		function: #(void (uint aCode) ) emit: [:gen :proxy :asm |			asm pop: asm EAX.			gen failWithCode: asm EAX.		]! !!NBFFICalloutTests methodsFor: 'generator callbacks' stamp: 'IgorStasenko 3/27/2012 18:19'!nbBindingOf: aName	^ self class bindingOf: aName! !!NBFFICalloutTests methodsFor: 'generator callbacks' stamp: 'IgorStasenko 2/24/2012 17:53'!nbFnArgument: argName generator: gen	self assert: argName = 'testIvar'.	^ 'testIvar loader'! !!NBFFICalloutTests methodsFor: 'tests' stamp: 'IgorStasenko 11/24/2012 17:16'!returnParamUsingStackPtr: aParam	<primitive: #primitiveNativeCall module: #NativeBoostPlugin >		^ self nbCallout 		options: #( + optUseStackPointer optNoAlignment - optDirectProxyFnAddress );		function: #( oop (oop aParam) ) emit: [:gen |			gen asm mov: gen asm ESP ptr to: gen asm EAX ]	! !!NBFFICalloutTests methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 11/24/2012 17:16'!returnReceiver: x arg2: y	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout		function: #( oop (oop self , oop x, oop y)) emit: [		:gen :proxy :asm |			proxy receiver		] ! !!NBFFICalloutTests methodsFor: 'tests' stamp: 'Igor.Stasenko 5/3/2010 23:31'!testArraySize	| arr |		arr := ByteArray new: 100.	self assert: (self arraySize: arr) = 100.	self assert: (self arraySize2: arr with: 20) = 100.! !!NBFFICalloutTests methodsFor: 'tests' stamp: 'IgorStasenko 9/3/2012 00:03'!testBuildingFnSpec	| generator type s |	generator := NBFFICallout new.		CLASSVAR := 100.	TYPEVAR := 'long'.		generator		requestor: self;		methodArgs: #( 'arg1' 'arg2' 'arg3' );		cdecl;		anonSpec: #( long* (int self ,  String arg1, void**arg2, TYPEVAR arg1, char arg3, 0, nil, true, false , CLASSVAR ) ).	type := generator fnSpec returnType.	self assert: (type class == NBInt32).		self assert: (type pointerArity = 1).		self assert: (generator fnSpec arguments size = 10).	s := generator fnSpec arguments readStream."int self"		self checkType: s next class:  NBInt32 arity: 0 stackIndex: 3 ."String arg1"	self checkType: s next class: NBExternalString arity: 0 stackIndex: 2 ."void**arg2"	self checkType: s next class: NBVoid arity: 2 stackIndex: 1."TYPEVAR arg1"	self checkType: s next class:  NBInt32 arity: 0 stackIndex: 2."char arg3"		self checkType: s next class: NBCharacterType arity: 0 stackIndex: 0."0"				self checkType: s next class: NBFFIConst value: 0."nil"				self checkType: s next class: NBFFIConst value: 0."true"			self checkType: s next class: NBFFIConst value: 1."false"			self checkType: s next class: NBFFIConst value: 0."CLASSVAR"	self checkType: s next class: NBFFIConst value: 100.! !!NBFFICalloutTests methodsFor: 'tests' stamp: 'cipt 10/24/2012 19:32'!testBuildingFnSpecWithQueries	| generator type s |	generator := NBFFICallout new.		CLASSVAR := 100.	TYPEVAR := 'long'.		generator		requestor: self;		methodArgs: #( 'arg1' 'arg2' 'arg3' );		cdecl;		anonSpec: #( long* (int self , int arg3@2,  String arg1, void**arg2, TYPEVAR arg1, long **arg1@1, char arg3, 0, nil, true, false , CLASSVAR ) ).	type := generator fnSpec returnType.	self assert: (type class == NBInt32).		self assert: (type pointerArity = 1).		self assert: (generator fnSpec arguments size = 12).	s := generator fnSpec arguments readStream."int self"		self checkType: s next class:  NBInt32 arity: 0 stackIndex: 3 ."int arg3@2"    self checkType: s next class: NBInt32 arity: 0 stackIndex: 0 elementIndex: 2."String arg1"	self checkType: s next class: NBExternalString arity: 0 stackIndex: 2 ."void**arg2"	self checkType: s next class: NBVoid arity: 2 stackIndex: 1."TYPEVAR arg1"	self checkType: s next class:  NBInt32 arity: 0 stackIndex: 2."long ** arg1@1"    self checkType: s next class: NBInt32 arity: 2 stackIndex: 2 elementIndex: 1."char arg3"		self checkType: s next class: NBCharacterType arity: 0 stackIndex: 0."0"				self checkType: s next class: NBFFIConst value: 0."nil"				self checkType: s next class: NBFFIConst value: 0."true"			self checkType: s next class: NBFFIConst value: 1."false"			self checkType: s next class: NBFFIConst value: 0."CLASSVAR"	self checkType: s next class: NBFFIConst value: 100.! !!NBFFICalloutTests methodsFor: 'tests' stamp: 'IgorStasenko 8/6/2011 18:36'!testFailCode	self assert: 	(			[ self nativeFailWithCode: 1234. false ] on: NBNativeCodeError do: [:ex |			ex return: ex errorCode = 1234 ]	)	! !!NBFFICalloutTests methodsFor: 'tests' stamp: 'IgorStasenko 8/10/2011 18:27'!testProxyReceiver		self assert: 		(self returnReceiver: 10 arg2: 20) == self! !!NBFFICalloutTests methodsFor: 'tests' stamp: 'IgorStasenko 9/3/2012 00:12'!testSupportedProtocols	| gen spec arg | 	gen := NBFFICallout new requestor: self.	CLASSVAR := self. "so we will receive #asNBExternalType: "	gen anonSpec: #(CLASSVAR (CLASSVAR testIvar)).		spec := gen fnSpec.		self assert: spec returnType class == NBUInt32.		arg := spec arguments first.	self assert: arg class == NBUInt32.	self assert: arg loader ='testIvar loader'.		! !!NBFFICalloutTests methodsFor: 'tests' stamp: 'Igor.Stasenko 5/1/2010 12:02'!testUseStackPointer	self assert: (self returnParamUsingStackPtr: 100) = 100.! !!NBFFIExternalStructTests methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 1/29/2013 19:21'!returnStruct1Byte	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout		function: #(NBTestStructure1byte () ) 		emit: [:gen :proxy :asm |			NativeBoost platformId ~= NativeBoostConstants linux32PlatformId ifTrue:[			asm mov: 42 to: asm EAX]			ifFalse:[				asm mov: asm ESP ptr to: asm EAX;				mov: 42 to: asm EAX ptr]		]	! !!NBFFIExternalStructTests methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 11/24/2012 17:18'!returnStruct9Bytes	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout 		function: #(NBTestStructure9bytes () ) 		emit: [:gen :proxy :asm |					asm 				mov: asm ESP ptr to: asm EAX;		"fill struct with 1, 2, 3 values"				mov: 1 to: asm EAX ptr;				mov: 2 to: asm EAX ptr+4;				mov: 3 to: asm EAX ptr+8		]	! !!NBFFIExternalStructTests methodsFor: 'as yet unclassified' stamp: 'cipt 11/28/2012 19:29'!returnStructWithCallback: aCallback	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout 		function: #(NBTestStructureWithCallback (NBQSortCallback aCallback) ) 		emit: [:gen :proxy :asm |					asm				"mov: asm ESP ptr to: asm EAX;"				pop: asm EAX;				pop: asm EDX;		"fill struct with 1, 2, 3 values"				mov: 1 to: asm EAX ptr;				mov: asm EDX to: asm EAX ptr+4;				mov: 3 to: asm EAX ptr+8;				push: asm EAX		 ]	! !!NBFFIExternalStructTests methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 9/3/2012 02:33'!testNestedStructure	| s1 s2 |		NBTestStructure1byte rebuildFieldAccessors.	NBTestNestedStructure rebuildFieldAccessors.	s1 := NBTestNestedStructure new.	s2 := NBTestStructure1byte new.	s2 field: 42.		self assert: s1 oneByte field = 0.		s1 oneByte: s2.		self assert: s1 oneByte field = 42.	! !!NBFFIExternalStructTests methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 9/3/2012 02:33'!testReturnStruct1Byte	| s |	NBTestStructure1byte rebuildFieldAccessors.	NBTestNestedStructure rebuildFieldAccessors.		NBNativeCodeGen removeNativeCodeFrom: self class >> #returnStruct1Byte.		s := self returnStruct1Byte.		self assert: s field = 42.! !!NBFFIExternalStructTests methodsFor: 'as yet unclassified' stamp: 'cipt 11/28/2012 19:03'!testReturnStruct9Bytes	| s |		NBTestStructure1byte rebuildFieldAccessors.	NBTestNestedStructure rebuildFieldAccessors.	NBTestStructure9bytes  rebuildFieldAccessors.		NBNativeCodeGen removeNativeCodeFrom: self class >> #returnStruct9Bytes.	s := self returnStruct9Bytes.		self assert: s x = 1.	self assert: s y = 2.	self assert: s field asciiValue = 3.! !!NBFFIExternalStructTests methodsFor: 'as yet unclassified' stamp: 'cipt 11/28/2012 19:40'!testReturnStructWithCallback	| s callback|	NBTestStructureWithCallback rebuildFieldAccessors.		NBNativeCodeGen removeNativeCodeFrom: self class >> #returnStructWithCallback:.	callback := NBQSortCallback on: [:a :b | a < b].	s := self returnStructWithCallback: callback.		self assert: s x = 1.	self assert: s callback trunk  = callback trunk.	self assert: s y = 3.! !!NBFFIExternalUnionTests methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 1/29/2013 19:39'!return4Bytes: asm	NativeBoost platformId ~= NativeBoostConstants linux32PlatformId 		ifTrue:[			asm pop: asm EAX]		ifFalse:[			asm 				pop: asm EAX;				pop: asm EDX;				mov: asm EDX to: asm EAX ptr; 				push: asm EAX]! !!NBFFIExternalUnionTests methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 1/29/2013 19:22'!returnUnion1Byte	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout		function: #(NBTestUnion1Byte  () ) 		emit: [:gen :proxy :asm |			NativeBoost platformId ~= NativeBoostConstants linux32PlatformId ifTrue:[			asm mov: 42 to: asm EAX]			ifFalse:[				asm mov: asm ESP ptr to: asm EAX;				mov: 42 to: asm EAX ptr]		]	! !!NBFFIExternalUnionTests methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 1/29/2013 19:39'!returnUnionPointer: aPointer	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout 		function: #(NBTestUnion2Pointers (void * aPointer) ) 		emit: [:gen :proxy :asm |			self return4Bytes: asm.		]	! !!NBFFIExternalUnionTests methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 1/29/2013 19:39'!returnUnionUnionChar: aChar	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout 		function: #(NBTestUnionWithUnion (char  aChar) ) 		emit: [:gen :proxy :asm |			self return4Bytes: asm.		]	! !!NBFFIExternalUnionTests methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 1/29/2013 19:34'!returnUnionUnionDouble: aN	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout 		function: #(NBTestUnionWithUnion (double aN) ) 		emit: [:gen :proxy :asm |			NativeBoost platformId ~= NativeBoostConstants linux32PlatformId 				ifTrue:[					asm 						pop: asm EAX;						pop: asm EDX.]				ifFalse:[					asm						pop: asm EAX;						pop: asm ECX;						pop: asm EDX;						mov: asm ECX to: asm EAX ptr;						mov: asm EDX to: asm EAX ptr + 4;						push: asm EAX.										]		]	! !!NBFFIExternalUnionTests methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 1/29/2013 19:39'!returnUnionUnionInt: aN	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout 		function: #(NBTestUnionWithUnion (int  aN) ) 		emit: [:gen :proxy :asm |			self return4Bytes: asm.		]	! !!NBFFIExternalUnionTests methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 1/29/2013 19:39'!returnUnionWithCallback: aCallback	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout 		function: #(NBTestUnionWithCallback (NBQSortCallback aCallback) ) 		emit: [:gen :proxy :asm |			self return4Bytes: asm.		 ]	! !!NBFFIExternalUnionTests methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 1/19/2013 18:20'!returnUnionWithStructChar: aChar	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout 		function: #(NBTestUnionWithStructure (char  aChar) ) 		emit: [:gen :proxy :asm |					asm				pop: asm EAX;				pop: asm EDX;		"fill union with int"				mov: asm DL to: asm EAX ptr8;				push: asm EAX		 ]	! !!NBFFIExternalUnionTests methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 1/19/2013 18:15'!returnUnionWithStructInt: anInt	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout 		function: #(NBTestUnionWithStructure (int  anInt) ) 		emit: [:gen :proxy :asm |					asm				pop: asm EAX;				pop: asm EDX;		"fill union with int"				mov: asm EDX to: asm EAX ptr;				push: asm EAX		 ]	! !!NBFFIExternalUnionTests methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 1/19/2013 18:51'!returnUnionWithStructStruct: aStructure	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout 		function: #(NBTestUnionWithStructure (NBTestStructure9bytes  aStructure) ) 		emit: [:gen :proxy :asm |					asm				pop: asm EAX;				pop: asm EDX;		"fill union with structure"				mov: asm EDX to: asm EAX ptr;				pop: asm EDX;				mov: asm EDX to: asm EAX ptr + 4;				pop: asm EDX;				mov: asm EDX to: asm EAX ptr + 8;				push: asm EAX.		 ]	! !!NBFFIExternalUnionTests methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 1/19/2013 18:30'!testReturnUnion1Byte	| s |	NBTestUnion1Byte rebuildFieldAccessors.	NBNativeCodeGen removeNativeCodeFrom: self class >> #returnUnion1Byte.	s := self returnUnion1Byte.	self assert: s field1 = 42.	self assert: s field2 = 42! !!NBFFIExternalUnionTests methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 1/19/2013 22:05'!testReturnUnion2Pointers	| s ptr|	NBTestUnion2Pointers rebuildFieldAccessors.		NBNativeCodeGen removeNativeCodeFrom: self class >> #returnUnionPointer:.	ptr := NBExternalAddress fromString: 'abcd'.	s := self returnUnionPointer: ptr.		self assert: s addr1  =  ptr .	self assert: s addr2    =  ptr .	self assert: s addr1 readString = 'abcd'.! !!NBFFIExternalUnionTests methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 1/19/2013 22:16'!testReturnUnionUnionChar	| s |	NBTestUnionWithUnion rebuildFieldAccessors.	NBTestUnionIntSize rebuildFieldAccessors.	NBNativeCodeGen removeNativeCodeFrom: self class >> #returnUnionUnionChar:.	s := self returnUnionUnionChar: $,.	self assert: s x = $,! !!NBFFIExternalUnionTests methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 1/20/2013 00:11'!testReturnUnionUnionDouble	| s dp |	NBTestUnionWithUnion rebuildFieldAccessors.	NBTestUnionIntSize rebuildFieldAccessors.	NBNativeCodeGen removeNativeCodeFrom: self class >> #returnUnionUnionDouble:.	s := self returnUnionUnionDouble: 2.3.	self assert: (s z closeTo: 2.3)! !!NBFFIExternalUnionTests methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 1/19/2013 22:46'!testReturnUnionUnionInt	| s |	NBTestUnionWithUnion rebuildFieldAccessors.	NBTestUnionIntSize rebuildFieldAccessors.	NBNativeCodeGen removeNativeCodeFrom: self class >> #returnUnionUnionInt:.	s := self returnUnionUnionInt: 2344.	self assert: s union x = 2344! !!NBFFIExternalUnionTests methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 1/19/2013 18:40'!testReturnUnionWithCallback	| s callback|	NBTestUnionWithCallback rebuildFieldAccessors.	NBNativeCodeGen removeNativeCodeFrom: self class >> #returnUnionWithCallback:.	callback := NBQSortCallback on: [:a :b | a < b].	s := self returnUnionWithCallback: callback.		self assert: s callback trunk  = callback trunk.! !!NBFFIExternalUnionTests methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 1/19/2013 18:39'!testReturnUnionWithStructChar	| s |	NBTestUnionWithStructure rebuildFieldAccessors.	NBTestStructure9bytes rebuildFieldAccessors.	NBNativeCodeGen removeNativeCodeFrom: self class >> #returnUnionWithStructChar:.	s := self returnUnionWithStructChar: $,.	self assert: s x = $,! !!NBFFIExternalUnionTests methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 1/19/2013 18:39'!testReturnUnionWithStructInt	| s |	NBTestUnionWithStructure rebuildFieldAccessors.	NBTestStructure9bytes rebuildFieldAccessors.	NBNativeCodeGen removeNativeCodeFrom: self class >> #returnUnionWithStructInt:.	s := self returnUnionWithStructInt: 300.	self assert: s z = 300! !!NBFFIExternalUnionTests methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 1/19/2013 18:39'!testReturnUnionWithStructStruct	| s struct|	NBTestUnionWithStructure rebuildFieldAccessors.	NBTestStructure9bytes rebuildFieldAccessors.		NBNativeCodeGen removeNativeCodeFrom: self class >> #returnUnionWithStructStruct:.	struct := NBTestStructure9bytes new.	struct x: 2345.	struct y: 6789.	struct field: $+.	s := self returnUnionWithStructStruct: struct.		self assert: s struct x   =  struct x.	self assert: s struct y   =  struct y.	self assert: s struct field   =  struct field.! !!NBFFIExternalUnionTests methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 1/19/2013 17:57'!testUnionWithUnion	|u1 u2|	NBTestUnionIntSize rebuildFieldAccessors.	NBTestUnionWithUnion rebuildFieldAccessors.	u1 := NBTestUnionWithUnion new.	u2 := NBTestUnionIntSize new.		u2 y: 300.		self assert: u1 union x = 0.	self assert: u1 union y = 0.	self assert: u1 union field = Character null.		u1 union: u2.	self assert: u1 union x = 300.	self assert: u1 union y = 300.		self assert: u1 union field = $,.! !!NBFnSpecParserTest methodsFor: 'as yet unclassified' stamp: 'cipt 10/26/2012 19:19'!argName: argName indirectIndex: anIndex type: typeName ptrArity: ptrArity	^ #argument! !!NBFnSpecParserTest methodsFor: 'callbacks' stamp: 'IgorStasenko 2/13/2012 13:03'!integerConstantArgument: int	^ #integerConstant! !!NBFnSpecParserTest methodsFor: 'parser' stamp: 'IgorStasenko 2/13/2012 13:01'!newParser	^ NBFnSpecParser new! !!NBFnSpecParserTest methodsFor: 'callbacks' stamp: 'IgorStasenko 2/13/2012 13:04'!returnType: aType	^ #returnType! !!NBFnSpecParserTest methodsFor: 'tests' stamp: 'cipt 10/26/2012 19:30'!testParseAnonFn	 | parser args |		#(		#(int * * ( 0, nil, -10, FOO_BAR , int a, int* _b, char** c, void* * * d_))		'int * * ( 0, nil, -10, FOO_BAR , int a, int* _b, char** c, void* * * d_)'  ) do: [:spec |				parser := self newParser parseAnonFunction: spec.				self assert: parser returnType = #('int' 2).			args := parser arguments.		self assert: args size = 8.		self assert: (args at: 1) = 0. 		self assert: (args at: 2) = #(nil nil 'nil' 0). 		self assert: (args at: 3) = -10. 		self assert: (args at: 4) = #(nil nil 'FOO_BAR' 0). 		self assert: (args at: 5) = #('a' nil 'int' 0). 		self assert: (args at: 6) = #('_b' nil 'int' 1). 		self assert: (args at: 7) = #('c' nil 'char' 2). 		self assert: (args at: 8) = #('d_' nil 'void' 3 ). 	]! !!NBFnSpecParserTest methodsFor: 'tests' stamp: 'cipt 10/26/2012 19:30'!testParseNamedFn	 | parser args |		#(	(int * * #'function_n$a$m$e' ( 0, nil, -10, FOO_BAR , int a, int* _b, char** c, void* * * d_))	' int * * function_n$a$m$e (0, nil, -10, FOO_BAR , int a, int* _b, char** c, void* * * d_    ' ) do: [:spec |		parser := self newParser parseNamedFunction: spec.				self assert: parser functionName = 'function_n$a$m$e'.		self assert: parser returnType = #('int' 2).				args := parser arguments.		self assert: args size = 8.		self assert: (args at: 1) = 0. 		self assert: (args at: 2) = #(nil nil 'nil' 0). 		self assert: (args at: 3) = -10. 		self assert: (args at: 4) = #(nil nil 'FOO_BAR' 0). 		self assert: (args at: 5) = #('a' nil 'int' 0). 		self assert: (args at: 6) = #('_b' nil 'int' 1). 		self assert: (args at: 7) = #('c' nil 'char' 2). 		self assert: (args at: 8) = #('d_' nil 'void' 3 ). 	].! !!NBFnSpecParserTest methodsFor: 'tests' stamp: 'IgorStasenko 2/9/2012 12:44'!testParseNoArgsFn	 | parser args |	#( 	 #(int * * function_name ( void ) )	' int * * function_name  ( void ) '	) do: [:spec |		parser := self newParser parseNamedFunction: spec.				self assert: parser functionName = 'function_name'.		self assert: parser returnType = #('int' 2).			args := parser arguments.		self assert: args size = 0.	]! !!NBFnSpecParserTest methodsFor: 'tests' stamp: 'IgorStasenko 2/13/2012 13:16'!testParserCallbacks	| parser  spec parsedSpec args | 	parser := self newParser requestor: self.		spec := #(int * * function_name ( 0, nil, -10, FOO_BAR , int a, int* _b, char** c, void* * * d_)).	parsedSpec := parser parseNamedFunction: spec.		self assert: parsedSpec returnType equals: #returnType.		args := parsedSpec arguments.		self assert: args first = #integerConstant.	self assert: args third = #integerConstant.	args := args reject: [:each | each = #integerConstant ].	self assert: args size = 6.	self assert: args asSet size = 1.	self assert: args first = #argument! !!NBInterpreterProxyTest methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 11/24/2012 17:20'!primCheckStackPointer	"should answer 0"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>		^ self nbCallout function: #(uint () ) emit: [:gen :proxy :asm | 		| get |		proxy getStackPointer.		asm 			mov: NBInterpreterProxy stackPointerAddress asUImm32 to: asm ECX;		 	mov: asm ECX ptr to: asm ECX;			sub: asm EAX with: asm ECX	] ! !!NBInterpreterProxyTest methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 11/24/2012 17:21'!primCheckStackPointer2	"should answer 0"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>		^ self nbCallout		function: #(uint () ) 		emit: [:gen :proxy :asm | 			| get |			proxy getStackPointer.			asm 				mov: NBInterpreterProxy stackPointerAddress asUImm32 ptr32 to: asm ECX;				sub: asm EAX with: asm ECX		] ! !!NBInterpreterProxyTest methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 5/28/2012 04:42'!testStackPointer	self assert: self primCheckStackPointer=0	! !!NBInterpreterProxyTest methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 5/28/2012 05:22'!testStackPointer2	self assert: self primCheckStackPointer2=0	! !!NBTestCallbackReturnEnum class methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 12/11/2012 19:53'!fnSpec 	^#(#NBTestEnumeration (NBInt32))! !!NBTestCallbackReturnEnum1 class methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 12/13/2012 20:14'!fnSpec 	^#(#NBTestEnumerationFromPairs (NBInt32))! !!NBMockExternalHeapManager methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 9/25/2010 00:20'!primAllocatePage: numBytes	^ 0! !!NBMockExternalHeapManager methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 9/25/2010 00:21'!primFreePage: aMemoryPage	^ 0! !!NBCoreTests methodsFor: 'misc' stamp: 'IgorStasenko 2/8/2013 16:11'!anotherMethodWithPrimitive220	<primitive:220 error:errorCode>		^ errorCode asString! !!NBCoreTests methodsFor: 'misc' stamp: 'IgorStasenko 2/8/2013 15:48'!methodWithPrimitive220	<primitive:220 error:errorCode>		^errorCode ! !!NBCoreTests methodsFor: 'misc' stamp: 'IgorStasenko 2/20/2012 12:01'!nonExistedPrim: aBlock	| a b c|	<primitive: #abra module: #kadabra error: errorCode >		^ aBlock value: thisContext	! !!NBCoreTests methodsFor: 'misc' stamp: 'IgorStasenko 2/20/2012 14:08'!return0Code	" a simple routine, just return 1 (smallinteger = 0)"	| asm |		^ (asm :=  NativeBoost newAssembler )		noStackFrame;		mov: 1 to: asm EAX;		ret;		bytes! !!NBCoreTests methodsFor: 'misc' stamp: 'IgorStasenko 2/13/2012 13:25'!stub	<primitive: #primitiveNativeCall module: #NativeBoostPlugin >		^ 100! !!NBCoreTests methodsFor: 'misc' stamp: 'IgorStasenko 2/13/2012 13:42'!stub2	<primitive: #primitiveNativeCall module: #NativeBoostPlugin >		^ NBNativeCodeGen generateCode: [:gen | 						self return0Code				] andRetry: thisContext! !!NBCoreTests methodsFor: 'tests' stamp: 'IgorStasenko 8/24/2012 17:19'!testExternalResourceManagerFinalization		| obj count |			count := 0. 	obj := NBMockExternalObject new.	obj data: [ count := count + 1 ].			obj registerAsExternalResource.	obj := nil.	Smalltalk garbageCollect; garbageCollect.		self assert: (count = 1)! !!NBCoreTests methodsFor: 'tests' stamp: 'IgorStasenko 5/31/2012 14:53'!testFinalization	| reg objs count |		reg := NBFinalizationRegistry new.	count := 0.	reg freeItemsDo: [:item | count := count + 1].		self assert: count = reg initialSize.		objs := OrderedCollection new.	133 timesRepeat: [ reg add: (objs add: Object new) ].		count := 0.	reg freeItemsDo: [:item | count := count + 1].	self assert: reg items size - count = 133.		objs := nil.	Smalltalk garbageCollect.		count := 0.	reg freeItemsDo: [:item | count := count + 1].		self assert: count = reg items size.		reg reset.	count := 0.	reg freeItemsDo: [:item | count := count + 1].		self assert: count = reg initialSize.! !!NBCoreTests methodsFor: 'tests' stamp: 'IgorStasenko 2/20/2012 14:26'!testGenerateAndRetry	NBNativeCodeGen removeNativeCodeFrom: (self class>>#stub2). 	[		self assert: self stub2 = 0.	] ensure: [		NBNativeCodeGen removeNativeCodeFrom: (self class>>#stub2).	].	 ! !!NBCoreTests methodsFor: 'tests' stamp: 'IgorStasenko 2/20/2012 12:13'!testGettingError	self nonExistedPrim: [:context |	"This error produced by Cog VM, when primitive not found"		self assert: 		(context tempAt: 	context method numTemps ) == #'not found'		]! !!NBCoreTests methodsFor: 'tests' stamp: 'IgorStasenko 3/20/2011 04:12'!testHasTrailerInstalled		"Make sure compiled methods trailer installed"		self assert: (CompiledMethodTrailer trailerKinds includes: #NativeCodeTrailer )! !!NBCoreTests methodsFor: 'tests' stamp: 'IgorStasenko 2/13/2012 14:04'!testInstallingNativeCode	"	Test a protocol for installing/removing native code directly.	"	NBNativeCodeGen removeNativeCodeFrom: (self class>>#stub).	self assert: (self class>>#stub) hasNativeCode not.		self assert: self stub = 100.		 [		NBNativeCodeGen installNativeCode: self return0Code into: (self class>>#stub).		self assert: (self class>>#stub) hasNativeCode.		self assert: (self stub = 0).	] ensure: [		NBNativeCodeGen removeNativeCodeFrom: (self class>>#stub).	].	 	self assert: (self class>>#stub) hasNativeCode not.! !!NBCoreTests methodsFor: 'tests' stamp: 'IgorStasenko 3/20/2011 04:05'!testPlatformId	"sometimes i forget to set platform ID, when building plugin"		self assert: NativeBoost platformId ~= 0! !!NBCoreTests methodsFor: 'tests' stamp: 'IgorStasenko 2/8/2013 17:10'!testPrimitive220	"	Test a protocol for installing/removing native code directly.	"	| asm label method gen |	[ ^ self ] value.  " this code will crash your VM " 	method := self class>>#anotherMethodWithPrimitive220.	NBNativeCodeGen removeNativeCodeFrom: method.		method := self class>>#anotherMethodWithPrimitive220.	self assert: method hasNativeCode not.			asm := NativeBoost forCurrentPlatform newAssembler noStackFrame.		label := asm uniqueLabelName: 'done'.	gen := NBNativeCodeGen newForMethod: method.		asm := gen asm. 	asm noStackFrame.		asm push: 999.	gen proxy callFn: (gen proxy functions at:#primitiveFailFor: ). 	asm 		int3;		jmp: label;		mov: 1 to: asm EDX;	label: label.	NBNativeCodeGen installNativeCode: asm bytes into: method.	( self class>>#anotherMethodWithPrimitive220 ) forceJIT.		^ self anotherMethodWithPrimitive220 ! !!NBCoreTests methodsFor: 'tests' stamp: 'IgorStasenko 2/8/2013 15:51'!testPrimitive220ErrorCode	"	Test a protocol for installing/removing native code directly.	"	NBNativeCodeGen removeNativeCodeFrom: (self class>>#methodWithPrimitive220).	self assert: (self class>>#methodWithPrimitive220) hasNativeCode not.		"502 is error code = ErrNoNativeCodeInMethod "	self methodWithPrimitive220 = 502.! !!NBCoreTests methodsFor: 'tests' stamp: 'IgorStasenko 5/28/2012 07:00'!testRecursionDetection	| result |	result := false.		NBRecursionDetect in: #abc during: [		result := (NBRecursionDetect signalForMethod: #abc ) 			].	self assert: result == true.		result := (NBRecursionDetect signalForMethod: #abc ).	self assert: result == false.! !!NBExternalArrayTest methodsFor: 'misc' stamp: 'IgorStasenko 12/7/2012 16:06'!apiClass	^ NBExternalArray ! !!NBExternalArrayTest methodsFor: 'testing - class protocols' stamp: 'IgorStasenko 12/7/2012 01:22'!testAccessors	"make sure a generated class has accessors installed "	| cls m_at m_atput |		cls := self apiClass ofType: 'int32' .		self assert: (cls methodDict includesKey: #at: ).	self assert: (cls methodDict includesKey: #at:put: ).		m_at := cls compiledMethodAt: #at: .	m_atput  := cls compiledMethodAt: #at:put: .	"make sure they are properly installed"		self assert: m_at methodClass == cls.	self assert: m_atput methodClass == cls.	"make sure they are not same as in superclass "		self assert: m_at ~~ (self apiClass compiledMethodAt: #at: ).	self assert: m_atput ~~ (self apiClass compiledMethodAt: #at:put: ).! !!NBExternalArrayTest methodsFor: 'testing - class protocols' stamp: 'IgorStasenko 12/7/2012 02:22'!testAnonymousClassCreation	| cls |		cls := self apiClass ofType: 'int32' .		"should get an anonymous subclass" 	self assert: (cls inheritsFrom: self apiClass).		".. with properly initialized values" 	self assert: cls elementType equals: 'int32'.	self assert: cls elementSize = 4 .		" and, of course, they should not be the same object" 	self assert: cls ~~ self apiClass.	! !!NBExternalArrayTest methodsFor: 'testing - instances' stamp: 'IgorStasenko 12/7/2012 02:22'!testBasicProtocol	| cls array |		cls := self apiClass ofType: 'int32' .			array := cls new: 10.		self assert: array size equals: 10.		"instantiating with #new: should create an array in object memory "	self assert: array isExternal equals: false.		self assert: (array at: 1 put: 42) equals: 42.	self assert: (array at: 1) equals: 42.		self assert: (array at: 10 put: 420) equals: 420.	self assert: (array at: 10) = 420.		! !!NBExternalArrayTest methodsFor: 'testing - instances' stamp: 'IgorStasenko 12/7/2012 02:45'!testExternalArray	| cls array |		cls := self apiClass ofType: 'int32' .			[ array := cls externalNew: 10.		self assert: array size equals: 10.		"instantiating with #externalNew: should create an array in external memory "	self assert: array isExternal equals: true.		self assert: (array at: 1 put: 42) equals: 42.	self assert: (array at: 1) equals: 42.		self assert: (array at: 10 put: 420) equals: 420.	self assert: (array at: 10) = 420.	] ensure: [ array free ] 	! !!NBExternalArrayTest methodsFor: 'testing - instances' stamp: 'IgorStasenko 12/7/2012 02:44'!testExternalCopy	| cls array copy |		cls := self apiClass ofType: 'int32' .			[		array := cls externalNew: 10.		array at: 1 put: 2.		array at: 2 put: 3.		copy := array copy.			"#copy of external array should create a copy in object memory heap " 		self assert: copy isExternal equals: false.				"and , of course, copies should be equal "		self assert: array = copy.		] ensure: [ array free ] 	! !!NBFFICallbackTests methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 9/26/2010 05:38'!benchQSort	| bytes memBytes callback callback2 times |		bytes := #[ 2 5 3 10 39 4 80 203 94 215 30 60 80 20 1 4 0 ].	memBytes := NativeBoost allocate: bytes size.		callback := self createNativeCallback.	callback2 := NBQSortCallback on: [:a :b | (a byteAt: 0) - (b byteAt: 0) ].	[ 		callback install.				times := { 			[ bytes copy sort ].	  		[ self primNativeQSort: bytes copy compare: callback address ].			[ NativeBoost memCopy: bytes to:  memBytes size: bytes size. 			  self primStQSort: memBytes len: bytes size compare: callback2 ].		}		collect: [:block |			[ 100000 timesRepeat: block ] timeToRun ].	] ensure:  [ callback uninstall. NativeBoost free: memBytes ].	^ times! !!NBFFICallbackTests methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 11/24/2012 16:26'!checkCallback: arr1 with: arr2 compare: nativeCallback	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(long  (NBExternalAddress nativeCallback, byte* arr1, byte* arr2 ))		emit: [:gen |			gen asm pop: EAX;				call: EAX			] ! !!NBFFICallbackTests methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 11/24/2012 16:26'!checkCallbackAddress:  nativeCallbackAddr	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #(ulong  (NBExternalAddress nativeCallbackAddr))		emit: [:gen | 	gen asm pop: EAX ] "			options: #( - optAllowByteArraysPtr +optAllowExternalAddressPtr  ) "! !!NBFFICallbackTests methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 11/24/2012 16:26'!checkEmitFetchClass"	checker for fetching the class code emitting"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout		function: #(oop  ())		emit: [:gen |			gen emitFetchClass: NBExternalAddress			]! !!NBFFICallbackTests methodsFor: 'language-side callback' stamp: 'IgorStasenko 11/24/2012 16:26'!checkSTCallbackAddress:  callback	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout 		function: #(void *  (NBQSortCallback  callback))		emit: [:gen | 	gen asm pop: EAX ] ! !!NBFFICallbackTests methodsFor: 'native callbacks' stamp: 'Igor.Stasenko 9/26/2010 05:36'!createNativeCallback	"	The routine must compare the elements, then return one of the following values:	< 0 elem1 less than elem2 	0 elem1 equivalent to elem2 	> 0 elem1 greater than elem2 	"	^ NBNativeFunctionGen 		cdecl: #( int (byte* a, byte * b) )		emit: [:gen | | asm |			asm := gen asm.			asm 				mov: (gen arg: #b) to: EAX;				mov: EAX ptr8 to: CL;				mov: (gen arg: #a) to: EAX;				mov: EAX ptr8 to: AL;				sub: AL with: CL;				movsx: EAX with: AL  "sign-extend the result"		]! !!NBFFICallbackTests methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 5/5/2010 16:55'!dummyMethod: aParam	^ aParam! !!NBFFICallbackTests methodsFor: 'qsort callouts' stamp: 'IgorStasenko 11/24/2012 16:27'!primNativeQSort: base compare: nativeCallback"Here, the base must be a ByteArray instance 	num, the number of elements in it	width = 4Call qsort function:		void qsort(	   void *base, - array ptr	   size_t num,  - number of elements	   size_t width,  - size of element	   int (__cdecl *compare )(const void *, const void *) 	);	"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout 		function: #(void qsort (byte* base, NBByteArraySize base, 1, NBExternalAddress nativeCallback))		module: NativeBoost CLibrary! !!NBFFICallbackTests methodsFor: 'qsort callouts' stamp: 'IgorStasenko 11/24/2012 16:27'!primStQSort: base len: size compare: qsortCallback	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout		options: #( optMayGC );		function: #(void qsort (NBExternalAddress base, ulong size, 1, NBQSortCallback qsortCallback))		module: NativeBoost CLibrary! !!NBFFICallbackTests methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 11/24/2012 16:28'!readByte: array	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout		function: #(byte (byte * array))		emit: [:gen |			gen asm pop: EAX;				mov: EAX ptr8 to: AL			] ! !!NBFFICallbackTests methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 11/24/2012 16:28'!readByte: array at: index	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout		function: #(byte (byte * array, ulong index))		emit: [:gen |			gen asm pop: EAX;				pop: ECX;				add: EAX with: ECX;				mov: EAX ptr8 to: AL			] ! !!NBFFICallbackTests methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 9/16/2012 19:35'!testCBGeneratedCode		| addr trunk |		addr := NBQSortCallback callbackEnterAddress asUnsignedLong.	trunk := NBQSortCallback trunkCode.		self assert: (trunk bytes unsignedLongAt: 1+ (trunk offsetAt: #cbEnterAddress) bigEndian: false) = addr.			! !!NBFFICallbackTests methodsFor: 'language-side callback' stamp: 'IgorStasenko 11/24/2012 15:42'!testCallbackCounter	| callback orig bytes result ctr |		"There was a bug in callback code, which crashed VM	due to override of callgate saved method oop and return address,	and GC, happened during callback"	 	orig := #[ 2 5 55 23 67 23 ] copy.	bytes := NativeBoost allocate: orig size.		NativeBoost memCopy: orig to: bytes  size: orig size.	ctr := 0.	callback := NBQSortCallback on: [:a :b |		NativeBoost insideCallback ifTrue: [ ctr := ctr+ 1].  "this involves using callgate" 		Smalltalk garbageCollect. "this involves GC"		 (a byteAt: 0) - (b byteAt: 0) ].		self primStQSort: bytes len: orig size compare: callback.	result := ByteArray new: orig size.	NativeBoost memCopy: bytes to: result size: orig size.	NativeBoost free: bytes.	self assert: (ctr > 0).			self assert: (orig sort = result)! !!NBFFICallbackTests methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 5/5/2010 17:00'!testCreateContext	| context |		context := 		MethodContext 			sender: nil			receiver: 1			method: (self class compiledMethodAt: #dummyMethod: )			arguments: #( 55 ).						^ context! !!NBFFICallbackTests methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 5/4/2010 00:14'!testEmitFetchClass   self assert: (self checkEmitFetchClass ==  NBExternalAddress)! !!NBFFICallbackTests methodsFor: 'native callbacks' stamp: 'Igor.Stasenko 9/26/2010 05:38'!testInstallCallback	| callback |		callback := self createNativeCallback.	callback install.	self assert:(callback address notNil).	callback uninstall.! !!NBFFICallbackTests methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 5/14/2010 01:03'!testMemCopy	| mem bytes |	bytes := #[ 1 2 3 4 5 6 7 8 9 10 ].		mem := NativeBoost allocate: bytes size.		[	NativeBoost memCopy: bytes to: mem size: bytes size.		1 to: bytes size do: [:i |		self assert: (bytes at:i) = (mem byteAt: i-1)		].	] ensure: [ NativeBoost free: mem ]! !!NBFFICallbackTests methodsFor: 'native callbacks' stamp: 'sig 3/30/2012 14:55'!testNativeCallback	| orig bytes callback |		orig := #[ 2 5 3 10 39 4 80 ] copy.	bytes := orig copy.		callback := self createNativeCallback.		[ 		callback install.		self primNativeQSort: bytes compare: callback address.	] ensure:  [ callback uninstall ].	self assert: (orig sort = bytes)! !!NBFFICallbackTests methodsFor: 'language-side callback' stamp: 'IgorStasenko 9/16/2012 19:33'!testQSortCallbackST		| callback orig bytes result |		orig := #[ 2 5 3 10 39 4 80 ] copy.	bytes := NativeBoost allocate: orig size.		NativeBoost memCopy: orig to: bytes  size: orig size.	callback := NBQSortCallback on: [:a :b | (a byteAt: 0) - (b byteAt: 0) ].		self primStQSort: bytes len: orig size compare: callback.	result := ByteArray new: orig size.	NativeBoost memCopy: bytes to: result size: orig size.	NativeBoost free: bytes.			self assert: (orig sort = result)! !!NBFFICallbackTests methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 5/4/2010 00:33'!testReadByte	| arr |		arr := #(240 2 3 4 ) asByteArray.		self assert: (self readByte: arr) == 240! !!NBFFICallbackTests methodsFor: 'language-side callback' stamp: 'IgorStasenko 11/24/2012 15:29'!testSTCallbackInstalled	| callback trunk index |	callback := NBQSortCallback on: [:x :y | ]. 	trunk := callback trunk.	index := callback index.		self assert: ((NativeBoost extraRootsRegistry at: #callbacks) at: index +1) == callback.		self assert: (self checkSTCallbackAddress:  callback) = trunk	! !!NBFFICallbackTests methodsFor: 'native callbacks' stamp: 'Igor.Stasenko 9/26/2010 05:38'!testcallbackAddress	| callback addr1 addr2 |	callback := self createNativeCallback.		[ 		callback install.		addr1 := callback address value.		addr2 := self checkCallbackAddress: callback address.	] ensure:  [ callback uninstall ].	self assert: (addr1 = addr2)! !!NBObjectFormat32Tests methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 11/24/2012 17:23'!getFloatPtrOffset: aFloat	"return the difference between float oop and pointer to its stored floating-point value ,	must be base header size"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout 		function: #( ulong (oop aFloat, NBFloatPtr aFloat))		emit: [:gen | | asm |			asm := gen asm.			asm pop: asm ECX. "oop"			asm pop: asm EAX. "float ptr"			asm sub: asm EAX with: asm ECX		]! !!NBObjectFormat32Tests methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 11/24/2012 17:23'!pushDouble: aFloat	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout 		function: #( double (double aFloat))		emit: [:gen |			| asm |			asm := gen asm.			asm fld: asm ESP ptr64				]! !!NBObjectFormat32Tests methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 11/24/2012 17:24'!pushFloat: aFloat	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout 		function: #( double (float aFloat))		emit: [:gen |			| asm |			asm := gen asm.			asm fld: asm ESP ptr32				]! !!NBObjectFormat32Tests methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 11/23/2011 10:46'!testCompactFloats	| idx format |	format := NBObjectFormat32 new.	idx := Smalltalk compactClassesArray indexOf: Float ifAbsent: [ ^ nil ].	idx := idx bitShift: format compactClassIndexShift.	NativeBoost enableNativeCode.	Float allInstances do: [:each |		| oopIdx |		oopIdx := (NBObjectFormat32 headerOf: each) bitAnd: format compactClassMask.		self assert: (oopIdx = idx) ]! !!NBObjectFormat32Tests methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 12/21/2011 14:21'!testPushingFloatPointers	self assert: (self getFloatPtrOffset: 10.0) =  NBObjectFormat current baseHeaderSize.! !!NBObjectFormat32Tests methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 5/20/2010 09:19'!testPushingFloats	self assert: (self pushFloat: 100.0) = 100.0.	self assert: (self pushDouble: 100.0) = 100.0.! !!NativeCodeTests methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 8/5/2011 08:22'!createMoveTestCode	^ NBFFICallout new		anonSpec: #( int ());		cdecl;		generate: [:gen :proxy :asm |			| methodOop |						methodOop := gen reserveTemp.						proxy primitiveMethod.			asm mov: asm EAX to: methodOop.						"call fullGC to trigger memory compaction"			proxy fullGC.						"return the difference between old primitiveMethod oop value and new one"			proxy primitiveMethod.			asm sub: asm EAX with: methodOop.	].! !!NativeCodeTests methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 5/2/2010 10:56'!install: nativeCode into: method	| trailer  newMethod |	trailer := CompiledMethodTrailer new.	trailer nativeCode: nativeCode platformId: NativeBoost platformId sourcePointer: method trailer sourcePointer.	newMethod := method copyWithTrailerBytes: trailer.		method methodClass methodDict at: method selector put: newMethod.	! !!NativeCodeTests methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 4/11/2010 18:21'!movableStub	<primitive: 'primitiveNativeCall' module: 'NativeBoostPlugin'>	^ 999! !!NativeCodeTests methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 3/27/2012 18:20'!testArgumentOffsets	"cdecl arguments placed in reverse order,		push c;	push b;	push a..		so, c is most closer to stack frame and having smallest offset.	"	NBNativeFunctionGen 		cdecl: #( int (byte a, void * b, double c) )		emit: [:gen |			| arg |			arg := gen arg: #a.			self assert: (arg isMem).			self assert: (arg displacement value = 8).			arg := gen arg: #b.			self assert: (arg isMem).			self assert: (arg displacement value = 12).			arg := gen arg: #c.			self assert: (arg isMem).			self assert: (arg displacement value = 16).					]! !!NativeCodeTests methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 8/5/2011 08:24'!testMovableStuff	"test that if native code calls a VM function which triggers	a full gc and relocates a native code, it will survive the move,		a native code should return a difference between old and new primitive method,	in case if its moved, the difference will be nonzero"		| code |	code := self createMoveTestCode.	" we should not crash here ;) "	^ (1 to: 10) collect: 		[:each| 			Array new: (Random new nextInt: 100). 			self install: code into: (self class methodDict at: #movableStub).		  			self movableStub  		]		! !!NativeCodeTests methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 4/30/2010 20:03'!testProxyFunctions	| functions |		functions := NBInterpreterProxy functions.	functions valuesDo: [:fn |		self assert: (NBInterpreterProxy canUnderstand: fn selector ).	]! !!NativeCodeTests methodsFor: 'as yet unclassified' stamp: 'GuyHylton 9/12/2012 13:53'!testStructAccess	| struct |		NBTestStructure rebuildFieldAccessors.		struct := NBTestStructure new.		struct byte: 10.	struct short: -20.	struct long: 100.	struct float: 1.0.	struct double: 2.0.	struct int64: 123456789101112.		self assert: (struct byte = 10).	self assert: (struct short = -20).		self assert: (struct long = 100).		self assert: (struct float = 1.0).		self assert: (struct double = 2.0).		self assert: (struct int64 = 123456789101112).		! !"NativeBoost-Tests"!!NBBasicExamples commentStamp: '<historical>' prior: 0!I am a collection on examples on how to use the NativeBoost infrastructure. Check my class-side methods for more details.!!NBUTF8StringExample commentStamp: 'IgorStasenko 8/8/2011 17:29' prior: 0!This is an example of defining custom type.This type accepts a string(s) and converts them into utf-8 representation on stack on the fly and then pushes the pointer to converted string to callee.UTF8TextConverter new convertFromSystemString: (NBBasicExamples new encodeToUTF8: 'owehjfopeh fr' asWideString)!!NBCPrinter class methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 9/27/2010 01:46'!initialize	" self initialize "	printFormat := '%s'.! !!NBCPrinter class methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 11/24/2012 16:20'!printf: aString	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout function: #( void printf (String printFormat, String aString) )		module: NativeBoost CLibrary! !!Object methodsFor: '*NativeBoost-Examples' stamp: 'IgorStasenko 11/23/2012 14:02'!nbOopHeader" This method provided only for educational purposes.  Do not rely on it, if you wanna keep your code portable among various object memory formats "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin >		" simply return an object header word in a form which it is "		^ self nbCallout   		function:  #( uint (oop self) )		emit: [:gen :proxy :asm |  			asm 				pop: asm EAX;				push: asm EAX.							proxy isIntegerObject: asm EAX.			asm or: asm EAX with: asm EAX;				jne: #notOop;				pop: asm EAX;				mov: asm EAX ptr to: asm EAX; "load the header"				jmp: #exitt;				label: #notOop;				mov: 0 to: asm EAX;			label: #exitt		].! !!ByteString methodsFor: '*NativeBoost-Examples' stamp: 'IgorStasenko 11/24/2012 15:52'!nbBeginsWithByteString: prefix"an assembler implementation of #beginsWith: ,note, works only for byte strings "	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>		^ self nbCallout function: #( oop (oop self, oop prefix) ) emit: [:gen :proxy :asm |		| string sz1 prefixStr sz2 returnFalse done |				string := gen reserveTemp.		sz1 := gen reserveTemp.		prefixStr := gen reserveTemp.		sz2 := gen reserveTemp.		returnFalse := asm uniqueLabelName: 'returnFalse'.		done := asm uniqueLabelName: 'done'.				asm mov: asm ESP ptr to: asm EAX  "self ".		proxy varBytesFirstFieldOf:  asm EAX.		asm mov: asm EAX to: string.		asm pop: asm EAX  "self ".		proxy byteSizeOf: asm EAX. 		asm mov: asm EAX to: sz1.		asm mov: asm ESP ptr to: asm EAX  "self ".		proxy varBytesFirstFieldOf: asm EAX.		asm mov: asm EAX to: prefixStr.		asm pop: asm EAX  "self ".		proxy byteSizeOf: asm EAX. 		asm mov: asm EAX to: sz2.				asm 			mov: sz1 to: asm EAX;			cmp: asm EAX with: sz2;			jl: returnFalse.		asm 			mov: string to: asm ESI;			mov: prefixStr to: asm EDI;			mov: sz2 to: asm ECX;			cld;			repe; cmpsb;						cmp: asm ECX with: 0;			jnz: returnFalse.		proxy trueObject.		asm jmp: done.		asm label: returnFalse.		proxy falseObject.		asm label: done	] ! !!NBBasicExamples class methodsFor: 'basic-interpreter-proxy-interaction' stamp: 'IgorStasenko 11/23/2012 14:04'!failIfNegative: anInteger		<primitive: 'primitiveNativeCall' module: 'NativeBoostPlugin'>	^ self nbCallout 		function: #( void ( int anInteger ) )  		emit: [:gen :proxy :asm |			"aNumber -> EAX"			asm pop: asm EAX.			"check if the index in EAX is negative"			asm test: asm EAX with: asm EAX.			"if not signed (AKA positive jump to success)"			asm jns: 'success'.			gen failWithMessage: 'A negative number is forbidden!!'.			asm label: 'success'.		]! !!NBBasicExamples class methodsFor: 'basic-external-function' stamp: 'IgorStasenko 8/24/2012 15:13'!nbGetEnv: str"	This is a basic example for making an external call. 	This method calls a Standard C library getenv() function"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode >	 ^ self nbCall: #( String getenv (String str) ) module: NativeBoost CLibrary! !!NBBasicExamples class methodsFor: 'basic-interpreter-proxy-interaction' stamp: 'IgorStasenko 11/23/2012 14:05'!primitiveFail		<primitive: 'primitiveNativeCall' module: 'NativeBoostPlugin'>	^ self nbCallout 		function: #( oop ( void) )  		emit: [:gen :proxy :asm |			"Fail the native code"			proxy primitiveFail.		].! !!NBBasicExamples class methodsFor: 'basic-interpreter-proxy-interaction' stamp: 'IgorStasenko 11/23/2012 14:06'!primitiveFailWithMessage		<primitive: 'primitiveNativeCall' module: 'NativeBoostPlugin'>	^ self nbCallout 		function: #( oop ( void) )  		emit: [:gen :proxy :asm |			"Fail the native code"			gen failWithMessage: 'here is a message you wanna show to users when you fail a primitive'		].! !!NBBasicExamples class methodsFor: 'basc-types' stamp: 'IgorStasenko 11/23/2012 14:06'!returnAddressOf: anObject	"Yes, here we demonstrating that we can obtain a pointer (address) of object in memory.	But in fact it has no any practical use, because at any moment once you return from the method,	a GC may be triggered and given object can be relocated into different memory region,	rendering an obtained address invalid"	<primitive: 'primitiveNativeCall' module: 'NativeBoostPlugin'>	^ self nbCallout 		function: #( int ( oop anObject ) )  		emit: [:gen :proxy :asm |			asm pop: asm EAX.		]! !!NBBasicExamples class methodsFor: 'basic-interpreter-proxy-interaction' stamp: 'IgorStasenko 11/23/2012 14:07'!returnArrayClass		<primitive: 'primitiveNativeCall' module: 'NativeBoostPlugin'>	^ self nbCallout 		function: #( oop ( void) )  		emit: [:gen :proxy :asm |			"Access an internal data structure via the interpreter proxy"			proxy classArray.		]! !!NBBasicExamples class methodsFor: 'basic-interpreter-proxy-interaction' stamp: 'IgorStasenko 11/23/2012 14:07'!returnAsBit: aBoolean		<primitive: 'primitiveNativeCall' module: 'NativeBoostPlugin'>	^ self nbCallout 		function: #( int ( oop aBoolean ) )  		emit: [:gen :proxy :asm |			" aBoolean -> EAX "			asm pop: asm EAX.			"^ EAX = true ifTrue: [ 1 ] ifFalse: [ 0 ] "			proxy booleanValueOf: asm EAX.		]! !!NBBasicExamples class methodsFor: 'basic-interpreter-proxy-interaction' stamp: 'IgorStasenko 11/23/2012 14:08'!returnClassOf: anObject		<primitive: 'primitiveNativeCall' module: 'NativeBoostPlugin'>	^ self nbCallout 		function: #( oop ( oop anObject ) )  		emit: [:gen :proxy :asm |			" anObject -> EAX "			asm pop: asm EAX.			"^ anObject class "			proxy fetchClassOf: asm EAX.		]! !!NBBasicExamples class methodsFor: 'basc-types' stamp: 'CamilloBruni 7/16/2012 10:33'!returnFloat! !!NBBasicExamples class methodsFor: 'basic-interpreter-proxy-interaction' stamp: 'IgorStasenko 11/23/2012 14:11'!returnInstVar: aNumber from: anObject	<primitive: 'primitiveNativeCall' module: 'NativeBoostPlugin'>	^ self nbCallout 		function: #( oop ( int aNumber, oop anObject ) )  		emit: [:gen :proxy :asm |			"aNumber -> EAX"			asm pop: asm EAX.			"EAX = aNumebr-1"			asm sub: asm EAX with: 1.			"if signed (AKA negative jump to failure)"			asm js: 'failure'.					"anObject -> EDX"			asm pop: asm EDX.			"EAX = anObject instVarAt: aNumber"			proxy fetchPointer: asm EAX ofObject: asm EDX.			asm leave; ret.							asm label: 'failure'.			proxy primitiveFail.		]! !!NBBasicExamples class methodsFor: 'basc-types' stamp: 'IgorStasenko 11/23/2012 14:11'!returnInteger		<primitive: 'primitiveNativeCall' module: 'NativeBoostPlugin'>	^ self nbCallout 		function: #( int ( void) )  		emit: [:gen :proxy :asm |			asm mov: 123456789 to: asm EAX		]! !!NBBasicExamples class methodsFor: 'basc-types' stamp: 'IgorStasenko 11/23/2012 14:11'!returnInteger: a minus: b		<primitive: 'primitiveNativeCall' module: 'NativeBoostPlugin'>	^ self nbCallout 		function: #( int ( int a,  int b) )  		emit: [:gen :proxy :asm |			" a "			asm pop: asm EAX.			" b "			asm pop: asm EDX.			"result := a - b"			asm sub: asm EAX with: asm EDX		]! !!NBBasicExamples class methodsFor: 'basc-types' stamp: 'IgorStasenko 11/23/2012 14:12'!returnIntegerDirectOOP		<primitive: 'primitiveNativeCall' module: 'NativeBoostPlugin'>"here, since we put a return type 'oop', this means that NB FFI won't perform any conversionof returned value, therefore a native code must take care by itself for returning a valid oop"	^ self nbCallout 		function: #( oop ( void) )  		emit: [:gen :proxy :asm |			asm mov: (123456789 << 1) + 1 to: asm EAX		]! !!NBBasicExamples class methodsFor: 'basic-interpreter-proxy-interaction' stamp: 'IgorStasenko 11/23/2012 14:12'!returnMethodLiteral		<primitive: 'primitiveNativeCall' module: 'NativeBoostPlugin'>	^ self nbCallout 		function: #( oop ( void) )  		emit: [:gen :proxy :asm |			"store this method in EAX"			proxy primitiveMethod.			"the current method is in EAX				EAX literalAt: 0 "			proxy literal: 0 ofMethod: asm EAX.		]! !!NBBasicExamples class methodsFor: 'basic-interpreter-proxy-interaction' stamp: 'IgorStasenko 11/23/2012 14:12'!returnNewArraySize3		<primitive: 'primitiveNativeCall' module: 'NativeBoostPlugin'>	^ self nbCallout 		function: #( oop ( void ))  		emit: [:gen :proxy :asm |			"Array -> EAX"			proxy classArray.			"Array new: 3 (Array oop is stored in EAX)"			proxy instantiateClass: asm EAX indexableSize: 3		]! !!NBBasicExamples class methodsFor: 'basic-interpreter-proxy-interaction' stamp: 'IgorStasenko 11/23/2012 14:13'!returnNil		<primitive: 'primitiveNativeCall' module: 'NativeBoostPlugin'>	^ self nbCallout 		function: #( oop ( void ) )  		emit: [:gen :proxy :asm |			"nilObject -> EAX"			proxy nilObject.		]! !!NBBasicExamples class methodsFor: 'basic-interpreter-proxy-interaction' stamp: 'IgorStasenko 11/23/2012 14:13'!returnSelf		<primitive: 'primitiveNativeCall' module: 'NativeBoostPlugin'>	^ self nbCallout 		function: #( oop ( void) )  		emit: [:gen :proxy :asm |			"this is equivalent to: 				proxy receiverInto: asm EAX."			proxy receiver.		]! !!NBBasicExamples class methodsFor: 'basic-interpreter-proxy-interaction' stamp: 'IgorStasenko 11/23/2012 14:13'!returnSpecialObjectsArray		<primitive: 'primitiveNativeCall' module: 'NativeBoostPlugin'>	^ self nbCallout 		function: #( oop ( void) )  		emit: [:gen :proxy :asm |			"store the special objects array into EAX"			proxy specialObjectsArray.		]! !!NBBasicExamples class methodsFor: 'basic-float-operations' stamp: 'IgorStasenko 11/23/2012 14:13'!swapDoubFirst: r1 withSecond: r2     <primitive: #primitiveNativeCall module: #NativeBoostPlugin>    ^ self nbCallout		function: #( double ( double r1, double r2 ))	    emit: [:gen :proxy :asm |			"store r1 and r2 into the FPU stack"	       asm fld: asm ESP ptr64.	       asm fld: asm ESP ptr64 + 8.			"swap the two topmost FPU stack elements"			asm fxch: asm ST1. 	   ]! !!NBBasicExamples methodsFor: 'custom type' stamp: 'IgorStasenko 11/23/2012 14:15'!encodeToUTF8: aWideString	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^		self nbCallout 			function: #(String (NBUTF8StringExample aWideString)) 			emit: [:gen :proxy :asm |				asm pop: asm EAX			] ! !!NBBasicExamples methodsFor: 'double type' stamp: 'IgorStasenko 11/23/2012 14:16'!externalAddressValue: externalAddress	"	NBBasicExamples new externalAddressValue: (NBExternalAddress value: 10)	Error message is in: 	#verifyClassOf:is:generator:	"	<primitive: 'primitiveNativeCall' module: 'NativeBoostPlugin'>	^ self nbCallout  		 		function: #( ulong ( NBExternalAddress  externalAddress) )  		emit: [:gen :proxy :asm |			asm pop: asm EAX		]! !!NBBasicExamples methodsFor: 'object format' stamp: 'Igor.Stasenko 12/9/2010 14:29'!getObjectHeader: anObject	"Answer the word, representing an object header. See Object>>nbOopHeader for implementation.	This method provided only for educational purposes"		^ anObject nbOopHeader! !!NBBasicExamples methodsFor: 'double type' stamp: 'IgorStasenko 11/23/2012 14:23'!readDoubleFrom: address	" This method loads the double from given external address.	an address can be an instance of NBExternalAddress, or	simple ByteArray with at least 8 bytes long, which holds a double floating value"		<primitive: 'primitiveNativeCall' module: 'NativeBoostPlugin' error: errorCode>	"We are using a pseudo-function prototype and supplying own assembler code,	instead of making a call to external function.	In given example, an address argument , after coercion is pushed on stack. "		^ self nbCallout		"An additional options may affect the code generation. If options are omitted, then code generator will use defaults			(see NBFFICallout class>>defaultOptions)"		options: #( 			"do not accept nil as a pointer argument. 			This means that passing nil as address will cause a primitive failure."		- optCoerceNilToNull  					" accept a byte array as pointer. In our case, address to a first byte in byte array will be pushed on stack"		+ optAllowByteArraysPtr					" accept an instance of NBExternalAddress when coercing pointer arguments.			In our case, this method can accept NBExternalAddres in its address argument"		+ optAllowExternalAddressPtr				);		cdecl;  "Use cdecl C calling convention. This can be actually omitted, because it is default convention used by code generator. "								function: #( double ( void * address) )  		" A pseudo-function takes 1 argument, and returns double value.		  Under cdecl call convention, all floating point return types is returned in fp(0) CPU register"				emit: [:gen |  | asm |			asm := gen asm.			"Here , we expecting that an address value is already pushed on stack"						asm 				pop: asm EAX;  "load an address value into EAX register by popping a stack"				fld: (asm EAX ptr64). "load a floating point value from memory, at base address, held in EAX register into fp(0) register,				we are using #ptr64, to indicate that memory operand size is 64bits long"						" return value set, we are done. A code generator will take care for emitting code, which converts			a double floating point value into smalltalk object. "		]! !!NBBasicExamples methodsFor: 'double type' stamp: 'IgorStasenko 11/23/2012 14:23'!storeDouble: aDouble at: address	" This method stores a double floating point value at given memory address.	an address can be an instance of NBExternalAddress, or	simple ByteArray with at least 8 bytes long, which will hold a 64bit floating-point value"		<primitive: 'primitiveNativeCall' module: 'NativeBoostPlugin' error: errorCode>	"We are using a pseudo-function prototype and supplying own assembler code,	instead of making a call to external function.	An address and aDouble arguments are pushed on stack after coercion. "		^ self nbCallout 		"An additional options may affect the code generation. If options are omitted, then code generator will use defaults		(see NBFFICallout class>>defaultOptions)"		 options: #( 			"do not accept nil as a pointer arument. 			This means that passing nil as address will cause a primitive failure."		- optCoerceNilToNull  					" accept a byte array as pointer. In our case, address to a first byte in byte array will be pushed on stack"		+ optAllowByteArraysPtr					" accept an instance of NBExternalAddress when coercing pointer arguments.			In our case, this method can accept NBExternalAddres in its address argument"		+ optAllowExternalAddressPtr				);		function: #( void (void * address, double aDouble) )  		" A pseudo-function takes 2 arguments, and having no return value. In this case, method will always answer nil object.		  Under cdecl calling convention, arguments are pushed on stack in reverse order,		  so, first pushed aDouble , then address"				emit: [:gen |  | asm |			asm := gen asm.			"Here , we expecting that an address value is on top of the stack"			asm 				pop: EDX;  "load an address value into EDX register by popping it from a stack"							"now copy the floating point value (which is 8-bytes long) to the given address"				mov: ESP ptr to: EAX;				mov: EAX to: EDX ptr;  " store first 32bit part of 64bit double value"							mov: ESP ptr + 4 to: EAX;				mov: EAX to: EDX ptr + 4.  " store second 32bit part of 64bit double value"					]		! !!NBBasicExamples methodsFor: 'double type' stamp: 'Igor.Stasenko 9/23/2010 04:53'!writeAndReadDoubles	| d bytes result |		d := 1.5 .		bytes := ByteArray new: 8.		self storeDouble: d at: bytes.		result := self readDoubleFrom: bytes.		self assert: (result = d ).! !!NBUTF8StringExample methodsFor: 'as yet unclassified' stamp: 'CamilloBruni 7/23/2012 13:29'!prepareArgumentUsing: gen	"prepare the ByteString argument.	Allocate a space for string on stack, then copy string contents there	and add terminating null character "		| asm stringOop len loop done donePreparing notNil 	 moreThanOne moreThanTwo moreThanThree typeCheck |		asm := gen asm.		typeCheck := asm uniqueLabelName: 'ok'.	loop := asm uniqueLabelName: 'loop'.	done := asm uniqueLabelName: 'done'.	notNil  := asm uniqueLabelName: 'notNil'.	donePreparing := asm uniqueLabelName: 'donePreparing'.	moreThanOne := asm uniqueLabelName: 'moreThanOne'.  	moreThanTwo := asm uniqueLabelName: 'moreThanTwo'.  	moreThanThree := asm uniqueLabelName: 'moreThanThree'.  	    	loader emitLoad: gen.	"reserve after emitting load, otherwise, if proxy using stackpointer temp, it will be clobbered"	address := gen reserveTemp.  	stringOop := gen reserveTemp.	len := gen reserveTemp.	asm mov: EAX to: stringOop.		gen optStringOrNull ifTrue: [		"allow passing nil as string, effectively will push null pointer as argument"		gen proxy nilObject.		asm 			cmp: EAX with: stringOop;			jne: notNil;			mov: 0 to: address;  "null pointer"			jmp: donePreparing.	].	asm label: notNil.	gen proxy isWords: stringOop.	asm or: EAX with: EAX.	asm jne: typeCheck.	gen failWithMessage: 'WideString instance expected'.	asm label: typeCheck.		gen proxy slotSizeOf: stringOop.	asm mov: EAX to: len.	"len*4 +1 - the total number of bytes to reserve on stack"	asm 		shl: EAX with: 2;		inc: EAX.	gen reserveStackBytes: EAX andStoreAddrTo: address.	gen proxy firstIndexableField: stringOop.	asm decorateWith: ' copy string contents to the stack ' during: [	asm 		push: ESI;		push: EDI;		mov: EAX to: ESI;		mov: address to: EDI;		mov: len to: ECX;	label: loop;		dec: ECX;		jl: done;				"load the unicode value"		mov: ESI ptr to: EAX;				cmp: EAX with: 16r7F;		jg: moreThanOne;	"one byte"		mov: AL to: EDI ptr;		inc: EDI;		add: ESI with: 4;		jmp: loop;	label: moreThanOne;		cmp: EAX with: 16r7FF;	 	jg: moreThanTwo;	"two bytes"		mov: EAX to: EDX;		shr: EDX with: 6;		or: DL with: 16rC0 asUImm;		mov: DL to: EDI ptr;		inc: EDI;		and: AL with: 2r111111;		or: AL with: 16r80 asUImm;		mov: AL to: EDI ptr;		inc: EDI;		add: ESI with: 4;		jmp: loop;	label: moreThanTwo;		cmp: EAX with: 16rFFFF;	 	jg: moreThanThree;	"three bytes"			mov: EAX to: EDX;		shr: EDX with: 12;		or: DL with: 2r11100000 asUImm;		mov: DL to: EDI ptr;		inc: EDI;		mov: EAX to: EDX;		shr: EDX with: 6;		and: DL with: 2r111111;		or: DL with: 16r80 asUImm;		mov: DL to: EDI ptr;		inc: EDI;		and: AL with: 2r111111;		or: AL with: 16r80 asUImm;		mov: AL to: EDI ptr;		inc: EDI;		add: ESI with: 4;		jmp: loop;			label: moreThanThree;		cmp: EAX with: 16r1FFFFF;		jg: gen failedLabel; "no more than 4 bytes!!"	"4 bytes"		mov: EAX to: EDX;		shr: EDX with: 18;		or: DL with: 2r11110000 asUImm;		mov: DL to: EDI ptr;		inc: EDI;		mov: EAX to: EDX;		shr: EDX with: 12;		and: DL with: 2r111111;		or: DL with: 16r80 asUImm;		mov: DL to: EDI ptr;		inc: EDI;		mov: EAX to: EDX;		shr: EDX with: 6;		and: DL with: 2r111111;		or: DL with: 16r80 asUImm;		mov: DL to: EDI ptr;		inc: EDI;		and: AL with: 2r111111;		or: AL with: 16r80 asUImm;		mov: AL to: EDI ptr;		inc: EDI;		add: ESI with: 4;		jmp: loop;			label: done;		mov: 0 to: EDI ptr8;  "store null-terminating character"		pop: EDI;		pop: ESI.	].	gen releaseTemps: 2.  "keep the address reserved, otherwise it will be clobbered"	asm label: donePreparing! !!NBUTF8StringExample methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 8/6/2011 16:04'!pushAsValue: gen	gen asm push: address.! !!WideString methodsFor: '*NativeBoost-Examples' stamp: 'Igor.Stasenko 5/15/2010 00:31'!nbHash	^ self nbStringHash: ByteString identityHash! !!WideString methodsFor: '*NativeBoost-Examples' stamp: 'IgorStasenko 11/23/2012 18:02'!nbStringHash: speciesHash	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>		^ self nbCallout		function: #(ulong (oop self , ulong speciesHash)) emit: [:gen |		| asm proxy rcvr cnt EAX EDX ECX ESI EBX |		asm := gen asm.		EAX := asm EAX. EDX := asm EDX. ECX := asm ECX. 		ESI := asm ESI. EBX := asm EBX.				proxy := gen proxy.		rcvr := gen reserveTemp.		cnt := gen reserveTemp.				asm pop: rcvr.		proxy stSizeOf: rcvr.		asm mov: EAX to: cnt.  "size"		proxy firstIndexableField: rcvr.		asm 			pop: EDX; "speciesHash"			push: EBX;			push: ESI;			mov: cnt to: ECX;		label: #loop;			and: EDX with: 16rFFFFFFF;			dec: ECX;			jl: #wedone;			add: EDX with: EAX ptr; "hash := hash + (aString at: pos) asInteger."			mov: EDX to: EBX;			and: EBX with: 16r3FFF;  "low := hash bitAnd: 16383."			mov: EBX to: ESI;			imul: ESI with: 16r260D;  " 16r260D * low "			shr: EDX with: 14; 			imul: EDX with: 16r260D; "16r260D * (hash bitShift: -14)"			imul: EBX with: 16r0065; " (16r0065 * low) "			add: EDX with: EBX;			and: EDX with: 16383;			shl: EDX with: 14;   " (16r260D * (hash bitShift: -14) + (16r0065 * low) bitAnd: 16383) * 16384 "			add: EDX with: ESI;			add: EAX with: 4;			jmp: #loop;		label: #wedone;			pop: ESI;			pop: EBX;			mov: asm EDX to: asm EAX.				].	! !"NativeBoost-Examples"!!CLLibraryMap class methodsFor: 'accessing' stamp: 'CiprianTeodorov 12/24/2012 22:01'!at: aSymbol	^ self at: aSymbol ifAbsent: [ super nbBindingOf: aSymbol ]! !!CLLibraryMap class methodsFor: 'accessing' stamp: 'CiprianTeodorov 12/24/2012 22:01'!at: aSymbol ifAbsent: aBlock	^ typeMap at: aSymbol ifAbsent: aBlock! !!CLLibraryMap class methodsFor: 'class initialization' stamp: 'CiprianTeodorov 12/24/2012 22:03'!initialize	super initialize.	self initializeTypeMap! !!CLLibraryMap class methodsFor: 'class initialization' stamp: 'CiprianTeodorov 12/24/2012 22:02'!initializeTypeMap	typeMap := Dictionary newFromPairs: self typeMap.! !!CLLibraryMap class methodsFor: 'accessing' stamp: 'CiprianTeodorov 12/25/2012 17:23'!libraryNameOrHandle	^self subclassResponsibility ! !!CLLibraryMap class methodsFor: 'accessing' stamp: 'CiprianTeodorov 12/24/2012 22:02'!typeMap	^#()! !!ManifestTalkFFIRuntime class methodsFor: 'meta data' stamp: 'CiprianTeodorov 2/2/2013 20:07'!rejectClasses^ #()! !!ManifestTalkFFIRuntime class methodsFor: 'meta data' stamp: 'CiprianTeodorov 2/2/2013 20:07'!rejectRules^ #()! !!ManifestTalkFFIRuntime class methodsFor: 'meta data' stamp: 'CiprianTeodorov 2/2/2013 20:20'!ruleClassInstVarNotInitializedRuleV1TruePositive^ #(#(#(#RGClassDefinition #(#CLExternalLibraryWrapper)) #'2013-02-02T20:20:52.855+01:00') )! !!ManifestTalkFFIRuntime class methodsFor: 'meta data' stamp: 'CiprianTeodorov 2/2/2013 20:52'!ruleInconsistentMethodClassificationRuleV1TruePositive^ #(#(#(#RGMethodDefinition #(#'CLLibraryMap class' #at: #true)) #'2013-02-02T20:50:25.692000001+01:00') #(#(#RGMethodDefinition #(#'CLLibraryMap class' #initialize #true)) #'2013-02-02T20:50:25.731+01:00') #(#(#RGMethodDefinition #(#'CLExternalLibraryWrapper class' #initialize #true)) #'2013-02-02T20:52:11.08+01:00') #(#(#RGMethodDefinition #(#CLExternalLibraryWrapper #libraryNameOrHandle #false)) #'2013-02-02T20:52:11.117000001+01:00') #(#(#RGMethodDefinition #(#'CLExternalLibraryWrapper class' #new #true)) #'2013-02-02T20:52:11.157+01:00') )! !!ManifestTalkFFIRuntime class methodsFor: 'meta data' stamp: 'CiprianTeodorov 2/2/2013 20:27'!ruleSendsDifferentSuperRuleV1TruePositive^ #(#(#(#RGMethodDefinition #(#'CLExternalLibraryWrapper class' #uniqueInstance #true)) #'2013-02-02T20:27:31.016+01:00') )! !!ManifestTalkFFIRuntime class methodsFor: 'meta data' stamp: 'CiprianTeodorov 2/2/2013 21:02'!ruleUnclassifiedMethodsRuleV1TruePositive^ #(#(#(#RGMethodDefinition #(#'CLExternalLibraryWrapper class' #initialize #true)) #'2013-02-02T21:02:19.246+01:00') #(#(#RGMethodDefinition #(#'CLExternalLibraryWrapper class' #new #true)) #'2013-02-02T21:02:19.281000001+01:00') #(#(#RGMethodDefinition #(#'CLLibraryMap class' #at:ifAbsent: #true)) #'2013-02-02T21:02:19.318+01:00') #(#(#RGMethodDefinition #(#'CLLibraryMap class' #libraryNameOrHandle #true)) #'2013-02-02T21:02:19.583+01:00') #(#(#RGMethodDefinition #(#'CLLibraryMap class' #at: #true)) #'2013-02-02T21:02:19.618000001+01:00') #(#(#RGMethodDefinition #(#'CLExternalLibraryWrapper class' #uniqueInstance #true)) #'2013-02-02T21:02:19.797000001+01:00') #(#(#RGMethodDefinition #(#'CLLibraryMap class' #initialize #true)) #'2013-02-02T21:02:19.832000001+01:00') #(#(#RGMethodDefinition #(#'CLLibraryMap class' #typeMap #true)) #'2013-02-02T21:02:19.976000001+01:00') #(#(#RGMethodDefinition #(#'CLExternalLibraryWrapper class' #reset #true)) #'2013-02-02T21:02:20.194+01:00') #(#(#RGMethodDefinition #(#CLExternalLibraryWrapper #libraryNameOrHandle #false)) #'2013-02-02T21:02:20.338+01:00') #(#(#RGMethodDefinition #(#'CLLibraryMap class' #initializeTypeMap #true)) #'2013-02-02T21:02:20.373000001+01:00') )! !!CLExternalLibraryWrapper class methodsFor: 'class initialization' stamp: 'CiprianTeodorov 2/2/2013 20:20'!initialize	uniqueInstance := super new! !!CLExternalLibraryWrapper class methodsFor: 'instance creation' stamp: 'CiprianTeodorov 12/26/2012 22:16'!new	self error: 'External library wrappers are singleton -- send uniqueInstance instead'! !!CLExternalLibraryWrapper class methodsFor: 'class initialization' stamp: 'CiprianTeodorov 12/25/2012 18:47'!reset	^ uniqueInstance := nil! !!CLExternalLibraryWrapper class methodsFor: 'instance creation' stamp: 'CiprianTeodorov 3/9/2013 20:25'!uniqueInstance	^ uniqueInstance		ifNil: [ 			self initialize.			uniqueInstance ]		ifNotNil: [ uniqueInstance ]! !!CLExternalLibraryWrapper methodsFor: 'as yet unclassified' stamp: 'CiprianTeodorov 12/26/2012 20:06'!call: fnSpec options: callOptions	" you can override this method if you need to"	^ (self nbCalloutIn: thisContext sender)		cdecl;		options: callOptions;		function: fnSpec module: self libraryNameOrHandle! !!CLExternalLibraryWrapper methodsFor: 'utils' stamp: 'CiprianTeodorov 12/24/2012 22:16'!libraryNameOrHandle	^ self class nbLibraryNameOrHandle! !!CLExternalLibraryWrapper methodsFor: 'utils' stamp: 'CiprianTeodorov 12/24/2012 22:16'!nbLibraryNameOrHandle	^ self class nbLibraryNameOrHandle! !"TalkFFI-Runtime"!!Json commentStamp: '<historical>' prior: 0!This class reads and writes JSON format data - strings, numbers, boolean, nil, arrays and dictionaries. See http://www.crockford.com/JSON/index.html. It has been extended with syntax for invoking a prearranged list of constructors on read objects.!!JsonSyntaxError commentStamp: '<historical>' prior: 0!Class Json signals instances of me when an input stream contains invalid JSON input.!!JsonTests commentStamp: '<historical>' prior: 0!I provide a number of test cases for class Json.!!Json class methodsFor: 'as yet unclassified' stamp: 'ul 11/9/2010 04:07'!escapeForCharacter: c		| asciiValue |	(asciiValue := c asciiValue) < 128		ifTrue: [ ^escapeArray at: asciiValue + 1 ].	^nil! !!Json class methodsFor: 'as yet unclassified' stamp: 'TommasoDalSasso 3/17/2015 09:31'!initialize	"Json initialize."		escapeArray := Array new: 128.	(0 to: 31), #(127) do: [ :each |		escapeArray at: each + 1 put: '\u', (each printStringHex padLeftTo: 4 with: $0) ].	{		$" -> '\"'.		$\ -> '\\'.		Character backspace -> '\b'.		Character lf -> '\n'.		Character newPage -> '\f'.		Character cr -> '\r'.		Character tab -> '\t'.	} do: [ :each |		escapeArray at: each key asciiValue + 1 put: each value ].! !!Json class methodsFor: 'as yet unclassified' stamp: 'tonyg 8/24/2005 14:48'!mimeType	^ 'application/x-json'! !!Json class methodsFor: 'as yet unclassified' stamp: 'dkb 12/25/2009 02:51'!newWithConstructors: aCollection	| m |	m := Dictionary new.	aCollection do: [:each |		(each isKindOf: Association)			ifTrue: [m add: each]			ifFalse: [m at: each name asString put: each]].	^ self new ctorMap: m; yourself.! !!Json class methodsFor: 'as yet unclassified' stamp: 'tonyg 8/17/2005 09:09'!numbersMayContain: aChar	^ aChar isDigit or: [#($- $+ $. $e $E) includes: aChar]! !!Json class methodsFor: 'as yet unclassified' stamp: 'tonyg 11/29/2005 17:45'!readFrom: aStream	^ self new readFrom: aStream.! !!Json class methodsFor: 'as yet unclassified' stamp: 'tonyg 8/17/2005 07:45'!render: anObject	| s |	s := WriteStream on: String new.	anObject jsonWriteOn: s.	^ s contents.! !!Json class methodsFor: 'as yet unclassified' stamp: 'tonyg 11/30/2005 16:32'!render: anObject withConstructor: aConstructorName on: aStream	aStream nextPutAll: '@', aConstructorName.	anObject jsonWriteOn: aStream.! !!Json class methodsFor: 'as yet unclassified' stamp: 'dkb 12/25/2009 02:52'!renderInstanceVariables: aCollection of: anObject on: aStream	| map |	map := Dictionary new.	aCollection do: [:ivarName | map at: ivarName put: (anObject instVarNamed: ivarName)].	self render: map withConstructor: anObject class name asString on: aStream! !!Json methodsFor: 'private' stamp: 'Igor.Stasenko 4/7/2010 01:19'!consume: aString returning: anObject	aString do: [:c | stream next == c ifFalse: [JsonSyntaxError signal: 'Expected ''', aString, ''''] ].	^ anObject! !!Json methodsFor: 'accessing' stamp: 'tonyg 11/29/2005 11:40'!ctorMap	^ ctorMap! !!Json methodsFor: 'accessing' stamp: 'dkb 12/25/2009 02:52'!ctorMap: m	ctorMap := m! !!Json methodsFor: 'private' stamp: 'Igor.Stasenko 4/7/2010 01:19'!interpretStringEscape	| c |	c := stream next.	c == $b ifTrue: [^ Character backspace].	c == $n ifTrue: [^ Character lf].	c == $f ifTrue: [^ Character newPage].	c == $r ifTrue: [^ Character cr].	c == $t ifTrue: [^ Character tab].	c == $u ifTrue: [^ self unescapeUnicode].	^ c.! !!Json methodsFor: 'parsing' stamp: 'Igor.Stasenko 4/7/2010 01:45'!readAny	"This is the main entry point for the JSON parser. See also readFrom: on the class side."	| c |	self skipWhitespace.	c := stream peek asLowercase.	c == ${ ifTrue: [stream next. ^ self readDictionary].	c == $[ ifTrue: [stream next. ^ self readArray].	c == $" ifTrue: [stream next. ^ self readString].	c == $t ifTrue: [^ self consume: 'true' returning: true].	c == $f ifTrue: [^ self consume: 'false' returning: false].	c == $n ifTrue: [^ self consume: 'null' returning: nil].	c == $@ ifTrue: [stream next. ^ self readConstructor].	(Json numbersMayContain: c) ifTrue: [^ self readNumber].	JsonSyntaxError signal: 'Unknown Json input'! !!Json methodsFor: 'private' stamp: 'Igor.Stasenko 4/7/2010 01:39'!readArray	| a |	a := OrderedCollection new.	self skipWhitespace.	(stream peekFor: $]) ifTrue: [ ^ #() ].		[		a add: self readAny.		self skipWhitespace.		(stream peekFor: $]) ifTrue: [ ^ a asArray].		(stream peekFor: $, ) ifFalse: [JsonSyntaxError signal: 'Missing comma'].	] repeat.! !!Json methodsFor: 'private' stamp: 'Igor.Stasenko 4/7/2010 01:20'!readConstructor	| s c v ctor |	s := WriteStream on: ''.	[		c := stream peek.		c ifNil: [JsonSyntaxError signal: 'Premature EOF reading constructor name'].		((c == $.) or: [c isLetter])			ifTrue: [s nextPut: c. stream next]			ifFalse: [				v := self readAny.				s := s contents.				ctor := ctorMap ifNotNil: [ctor := ctorMap at: s ifAbsent: [nil]].				ctor ifNil: [JsonSyntaxError signal: 'Unknown ctor ', s].				^ ctor constructFromJson: v]	] repeat.! !!Json methodsFor: 'private' stamp: 'Igor.Stasenko 4/7/2010 01:43'!readDictionary	| m k v needComma |	m := JsonObject new.	needComma := false.	[		self skipWhitespace.		(stream peekFor: $}) ifTrue: [ ^ m].		needComma			ifTrue: [ (stream peekFor: $,) ifFalse: [JsonSyntaxError signal: 'Missing comma'].					self skipWhitespace]			ifFalse: [needComma := true]."		k := self readAny. "		(stream peekFor: $") ifFalse: [JsonSyntaxError signal: 'Key in dictionary must be string'].		k := self readString.		self skipWhitespace.		(stream peekFor: $:) ifFalse: [JsonSyntaxError signal: 'Missing colon'].		v := self readAny.		m at: k put: v.	] repeat.! !!Json methodsFor: 'parsing' stamp: 'tonyg 11/29/2005 17:44'!readFrom: aStream	self stream: aStream.	^ self readAny! !!Json methodsFor: 'private' stamp: 'Igor.Stasenko 4/7/2010 01:21'!readNumber	| acc c |	acc := WriteStream on: ''.	[		c := stream peek.		(c isNil not and: [Json numbersMayContain: c]) ifFalse: [			[^ acc contents asNumber] on: Error do: [JsonSyntaxError signal: 'Invalid number']].		acc nextPut: c.		stream next.	] repeat.! !!Json methodsFor: 'private' stamp: 'Igor.Stasenko 4/7/2010 01:22'!readString	| s c |	s := WriteStream on: ''.	[		c := stream next.		c == $\			ifTrue: [s nextPut: self interpretStringEscape.]			ifFalse: [c == $" ifTrue: [^ s contents.].					s nextPut: c]	] repeat.! !!Json methodsFor: 'private' stamp: 'Igor.Stasenko 4/7/2010 01:22'!skipComment	stream peek == $/ ifTrue: [		stream next.		stream peek == $/			ifTrue: [self skipToEndOfLine]			ifFalse: [stream peek == $*						ifTrue: [stream next. self skipCommentBody]						ifFalse: [JsonSyntaxError signal: 'Invalid comment syntax']]]! !!Json methodsFor: 'private' stamp: 'Igor.Stasenko 4/7/2010 01:22'!skipCommentBody	[		[stream next == $*] whileFalse.		stream peek == $/	] whileFalse.	stream next. "skip that last slash"	self skipWhitespace.! !!Json methodsFor: 'private' stamp: 'Igor.Stasenko 4/7/2010 01:24'!skipToEndOfLine	| cr lf |	cr := Character cr. lf := Character lf.	[ | c | (c := stream peek) == cr or: [ c == lf]] whileFalse: [stream next].	self skipWhitespace! !!Json methodsFor: 'private' stamp: 'Igor.Stasenko 4/7/2010 01:24'!skipWhitespace	[stream peek isSeparator] whileTrue: [stream next].	self skipComment.! !!Json methodsFor: 'accessing' stamp: 'tonyg 8/16/2005 20:20'!stream	"Answer the value of stream"	^ stream! !!Json methodsFor: 'accessing' stamp: 'djr 10/2/2007 22:44'!stream: anObject	"Set the value of stream"	stream := anObject.	(stream respondsTo: #reset) ifTrue: [		stream reset.	].! !!Json methodsFor: 'private' stamp: 'Igor.Stasenko 4/7/2010 01:28'!unescapeUnicode	|string|	string := (String with: stream next with: stream next with: stream next with: stream next) asUppercase.	^ Unicode value: (Integer readFrom: string readStream base: 16)! !!JsonDummyTestObject class methodsFor: 'as yet unclassified' stamp: 'tonyg 11/29/2005 17:49'!constructFromJson: j	^ self new a: (j at: 'a'); b: (j at: 'b'); c: (j at: 'c'); yourself! !!JsonDummyTestObject methodsFor: 'as yet unclassified' stamp: 'tonyg 11/29/2005 17:56'!= other	^ other class == self class and: [		a = other a and: [		b = other b and: [		c = other c]]]! !!JsonDummyTestObject methodsFor: 'accessing' stamp: 'tonyg 11/29/2005 17:48'!a	"Answer the value of a"	^ a! !!JsonDummyTestObject methodsFor: 'accessing' stamp: 'dkb 12/25/2009 02:56'!a: anObject	"Set the value of a"	a := anObject! !!JsonDummyTestObject methodsFor: 'accessing' stamp: 'tonyg 11/29/2005 17:48'!b	"Answer the value of b"	^ b! !!JsonDummyTestObject methodsFor: 'accessing' stamp: 'dkb 12/25/2009 02:56'!b: anObject	"Set the value of b"	b := anObject! !!JsonDummyTestObject methodsFor: 'accessing' stamp: 'tonyg 11/29/2005 17:48'!c	"Answer the value of c"	^ c! !!JsonDummyTestObject methodsFor: 'accessing' stamp: 'dkb 12/25/2009 02:56'!c: anObject	"Set the value of c"	c := anObject! !!JsonDummyTestObject methodsFor: 'as yet unclassified' stamp: 'tonyg 11/30/2005 16:42'!jsonWriteOn: s	Json renderInstanceVariables: {#a. #b. #c} of: self on: s! !!Object methodsFor: '*JSON' stamp: 'Igor.Stasenko 1/9/2010 16:18'!asJsonString	^ String streamContents: [:str |		self jsonWriteOn: str ]! !!Number methodsFor: '*JSON-writing' stamp: 'ul 11/4/2008 04:46'!jsonWriteOn: aWriteStream 	self printOn: aWriteStream base: 10! !!Dictionary methodsFor: '*JSON-writing' stamp: 'Igor.Stasenko 12/27/2009 08:10'!jsonWriteOn: aStream	| needComma |	needComma := false.	aStream nextPut: ${.	self associationsDo: [ :assoc |		needComma			ifTrue: [ aStream nextPut: $, ]			ifFalse: [ needComma := true ].		assoc key jsonWriteOn: aStream.		aStream nextPut: $:.		assoc value jsonWriteOn: aStream ].	aStream nextPut: $}.! !!JsonObject class methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 1/9/2010 16:51'!fromAssociations: collectionOfAssociations	| result |	result := self new.		collectionOfAssociations do: [:each |		result at: each key put: each value ].	^ result! !!JsonObject methodsFor: 'accessing' stamp: 'rh 2/19/2010 21:34'!at: aKey	"make it work more like javascript objects"	^ self at: aKey ifAbsent: [nil]! !!JsonObject methodsFor: 'as yet unclassified' stamp: 'rh 2/19/2010 21:33'!doesNotUnderstand: aMessage	| key |	key := aMessage selector.	key isUnary ifTrue: [^ self at: key ifAbsent: [nil]].	^ (key isKeyword and: [(key occurrencesOf: $:) = 1])		ifTrue: [key := key allButLast asSymbol.				self at: key put: aMessage arguments first]		ifFalse: [super doesNotUnderstand: aMessage]					! !!JsonObject methodsFor: 'accessing' stamp: 'rh 2/27/2010 00:03'!name"override 'cause Object defines this"	^self at: 'name'! !!JsonObject methodsFor: 'accessing' stamp: 'rh 2/27/2010 00:04'!value"override 'cause Object defines this"	^self at: 'value'! !!UndefinedObject methodsFor: '*JSON-writing' stamp: 'tonyg 8/17/2005 00:45'!jsonWriteOn: aWriteStream 	aWriteStream nextPutAll: 'null'! !!String methodsFor: '*JSON-writing' stamp: 'ul 11/9/2010 04:07'!jsonWriteOn: aStream	aStream nextPut: $".	self do: [ :ch |		(Json escapeForCharacter: ch)			ifNil: [ aStream nextPut: ch ]			ifNotNil: [ :replacement |				aStream nextPutAll: replacement ] ].	aStream nextPut: $".! !!True methodsFor: '*JSON-writing' stamp: 'tonyg 8/17/2005 00:44'!jsonWriteOn: aStream	aStream nextPutAll: 'true'! !!False methodsFor: '*JSON-writing' stamp: 'tonyg 8/17/2005 00:43'!jsonWriteOn: aStream	aStream nextPutAll: 'false'! !!Association methodsFor: '*JSON-writing' stamp: 'matthias.berth 11/19/2009 10:21'!jsonWriteOn: aStream	self key asString jsonWriteOn: aStream.	aStream nextPut: $:; space.	self value jsonWriteOn: aStream.! !!Integer methodsFor: '*JSON-writing' stamp: 'Igor.Stasenko 12/27/2009 08:05'!jsonWriteOn: aWriteStream	^ self printOn: aWriteStream base: 10! !!Text methodsFor: '*json-printing' stamp: 'cwp 10/26/2006 22:25'!jsonWriteOn: aStream	self string jsonWriteOn: aStream! !!Collection methodsFor: '*json' stamp: 'Igor.Stasenko 12/27/2009 08:03'!jsonWriteOn: aStream	"By default, use array braces "	aStream nextPut: $[.		self do: [:each |		each jsonWriteOn: aStream		  ] separatedBy: [ aStream nextPut: $, ].	aStream nextPut: $]! !!JsonTests methodsFor: 'as yet unclassified' stamp: 'tonyg 11/29/2005 18:03'!json: aString equals: aValue	| readValue |	readValue := self readFrom: aString.	self assert: readValue = aValue.! !!JsonTests methodsFor: 'as yet unclassified' stamp: 'tonyg 11/29/2005 18:03'!readFrom: aString	^ (Json newWithConstructors: {JsonDummyTestObject.}) readFrom: aString readStream! !!JsonTests methodsFor: 'as yet unclassified' stamp: 'tonyg 8/17/2005 16:24'!render: anObject equals: aString	self assert: (Json render: anObject) = aString! !!JsonTests methodsFor: 'as yet unclassified' stamp: 'tonyg 11/29/2005 17:51'!simpleDummyObject	^ JsonDummyTestObject new a: 1; b: 2; c: 3; yourself! !!JsonTests methodsFor: 'as yet unclassified' stamp: 'tonyg 8/16/2005 23:51'!testArray	self json: '[]' equals: #().	self json: '[[]]' equals: #(#()).	self json: '[[], []]' equals: #(#() #()).	self json: '["hi", "there"]' equals: #('hi' 'there').	self json: '[["a", "b", null]]' equals: #(('a' 'b' nil)).! !!JsonTests methodsFor: 'as yet unclassified' stamp: 'tonyg 8/16/2005 23:42'!testAtomFalse	self json: 'false' equals: false.	self json: '  false' equals: false.	self json: 'false  ' equals: false.	self json: '  false  ' equals: false.! !!JsonTests methodsFor: 'as yet unclassified' stamp: 'tonyg 8/16/2005 23:43'!testAtomNull	self json: 'null' equals: nil.	self json: '  null' equals: nil.	self json: 'null  ' equals: nil.	self json: '  null  ' equals: nil.! !!JsonTests methodsFor: 'as yet unclassified' stamp: 'tonyg 8/17/2005 09:10'!testAtomNumber	self json: '1' equals: 1.	self json: '0123' equals: 123.	self json: '1.23e2' equals: 123.	self json: '-1' equals: -1.	self json: '-0' equals: 0.	self json: '[-1.2]' equals: #(-1.2).! !!JsonTests methodsFor: 'as yet unclassified' stamp: 'tonyg 8/21/2009 22:57'!testAtomString	self json: '"hi"' equals: 'hi'.	self json: '"\""' equals: '"'.	self json: '"\\"' equals: '\'.	self json: '""' equals: ''.	self json: '"a\u0004b"' equals: ({$a. Character value: 4. $b} as: String).	self json: '"a\nb"' equals: ({$a. Character lf. $b} as: String).! !!JsonTests methodsFor: 'as yet unclassified' stamp: 'tonyg 8/16/2005 23:36'!testAtomTrue	self json: 'true' equals: true.	self json: '  true' equals: true.	self json: 'true  ' equals: true.	self json: '  true  ' equals: true.! !!JsonTests methodsFor: 'as yet unclassified' stamp: 'tonyg 11/29/2005 17:58'!testCtor	self json: '@JsonDummyTestObject {"a": 1, "b": 2, "c": 3}' equals: self simpleDummyObject.	self json: (Json render: self simpleDummyObject) equals: self simpleDummyObject.! !!JsonTests methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 12/27/2009 08:19'!testDictionary	self json: '{}' equals: (JsonObject new).	self json: '{"a": "a"}' equals: (JsonObject new at: 'a' put: 'a'; yourself).	self json: '{"a": [[]]}' equals: (JsonObject new at: 'a' put: #(#()); yourself).	self json: '{"a":"b", "b":"a"}' equals: (JsonObject new add: 'a'->'b'; add: 'b'->'a';yourself).! !!JsonTests methodsFor: 'as yet unclassified' stamp: 'cwp 10/19/2006 19:06'!testMissingCtor	self 		should: [self readFrom: '@Missing[]']		raise: JsonSyntaxError! !!JsonTests methodsFor: 'as yet unclassified' stamp: 'cwp 10/19/2006 19:06'!testMissingCtorNoMap	self 		should: [Json new readFrom: '@Missing[]' readStream]		raise: JsonSyntaxError! !!JsonTests methodsFor: 'as yet unclassified' stamp: 'ul 11/9/2010 04:16'!testStringWithUnicode	| unicodeString |	unicodeString := (Unicode value: 16r263A) asString.	self json: '"\u263A"' equals:unicodeString.	self json: '"', unicodeString, '"' equals: unicodeString.	self render: unicodeString equals: '"', unicodeString, '"'.! !!JsonTests methodsFor: 'as yet unclassified' stamp: 'matthias.berth 11/19/2009 10:21'!testWriteAssociation	self render: 'key' -> 'value' equals: '"key": "value"'.	self render: 'key' -> 2 equals: '"key": 2'.	"keys should be strings"	self render: 42 -> 2 equals: '"42": 2'.	"try to do _something_ for more complex keys"	self render: #(42 43 44) -> 2 equals:  '"#(42 43 44)": 2'.			! !!JsonTests methodsFor: 'as yet unclassified' stamp: 'tonyg 8/21/2009 22:55'!testWriteString	self render: '"' equals: '"\""'.	self render: '\' equals: '"\\"'.	self render: 'hi' equals: '"hi"'.	self render: ({$a. Character lf. $b} as: String) equals: '"a\nb"'.	self render: ({$a. Character value: 4. $b} as: String) equals: '"a\u0004b"'.! !!WriteStream methodsFor: '*json-printing' stamp: 'cwp 10/25/2006 12:27'!jsonPrint: anObject	anObject jsonWriteOn: self! !"JSON"!!PGConnection commentStamp: 'TudorGirba 3/3/2014 07:29' prior: 0!Instances of PGConnection implement a client interface to a PostgreSQL backend.See the "Frontend/Backend Protocol" chapter in the "PostgreSQL Programmer's Guide" for more information.!!LicenseOringinally created by  in 2001-2003. Released under MIT.Copyright (c) 2001-2003 Yanni ChiuPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.!!TestPGConnection methodsFor: 'private' stamp: 'yj 11/10/2004 23:32'!asFloat8Arg: aFloat	"Convert aFloat to a ByteArray for use as a function call argument."	| word1 word2 bigEndian arg tmp |	word1 := aFloat basicAt: 1.	word2 := aFloat basicAt: 2.	bigEndian := false.	bigEndian ifTrue: [			tmp := word1.			word1 := word2.			word2 := tmp.		].	arg := ByteArray new: 8.	arg at: 1 put: ((word1 bitShift: -24) bitAnd: 16rFF).	arg at: 2 put: ((word1 bitShift: -16) bitAnd: 16rFF).	arg at: 3 put: ((word1 bitShift: -8) bitAnd: 16rFF).	arg at: 4 put: ((word1 bitShift: 0) bitAnd: 16rFF).	arg at: 5 put: ((word2 bitShift: -24) bitAnd: 16rFF).	arg at: 6 put: ((word2 bitShift: -16) bitAnd: 16rFF).	arg at: 7 put: ((word2 bitShift: -8) bitAnd: 16rFF).	arg at: 8 put: ((word2 bitShift: 0) bitAnd: 16rFF).	^ arg! !!TestPGConnection methodsFor: 'private' stamp: 'yj 2/9/2005 21:51'!asFloat8ArgVW: aFloat	"Convert aFloat to a ByteArray for use as a function call argument."	| arg |	arg := ByteArray new: 8.	1 to: 8 do: [:i | arg at: i put: (aFloat basicAt: 8 - i + 1)].	^arg! !!TestPGConnection methodsFor: 'private' stamp: 'yj 4/24/2003 23:01'!copy: sql withStream: aStream	| conn |	conn := self newConnection.	conn startup.	conn copy: sql withStream: aStream.	conn terminate.! !!TestPGConnection methodsFor: 'tests' stamp: 'EstebanMaringolo 9/4/2014 15:55'!createJsonFieldConverterTable	self executeAll: #('CREATE TABLE jsonfieldconvertertable (jsonField json)').! !!TestPGConnection methodsFor: 'tests' stamp: 'yj 4/24/2003 23:01'!createTestCopyInOutTable	self executeAll: #(			'CREATE TABLE TestCopyInOutTable (				id integer,				name text			)'		).! !!TestPGConnection methodsFor: 'tests' stamp: 'yj 4/24/2003 23:01'!createTestFieldConverterTable	self executeAll: #('CREATE TABLE TestFieldConverterTable (aBool1 boolean,aBool2 boolean,aChar char,aChar1 char(1),aChar2 char(2),anInt2 int2,anInt4 int4,anInt8 int8,aFloat4 float4,aFloat8 float8,aNumeric numeric,aDate date,aTime time,aText text)'		).! !!TestPGConnection methodsFor: 'tests' stamp: 'yj 4/24/2003 23:01'!createTestTable	self executeAll: #(			'CREATE TABLE products (				product_no integer,				name text,				price numeric			)'		).! !!TestPGConnection methodsFor: 'tests' stamp: 'EstebanMaringolo 9/4/2014 15:55'!dropJsonFieldConverterTable	self executeAll: #(			'DROP TABLE jsonfieldconvertertable'		).! !!TestPGConnection methodsFor: 'tests' stamp: 'yj 4/24/2003 23:01'!dropTestCopyInOutTable	self executeAll: #(			'DROP TABLE TestCopyInOutTable'		).! !!TestPGConnection methodsFor: 'tests' stamp: 'yj 4/24/2003 23:01'!dropTestFieldConverterTable	self executeAll: #(			'DROP TABLE TestFieldConverterTable'		).! !!TestPGConnection methodsFor: 'tests' stamp: 'yj 4/24/2003 23:01'!dropTestTable	self executeAll: #(			'DROP TABLE products'		).! !!TestPGConnection methodsFor: 'private' stamp: 'yj 4/24/2003 23:01'!execute: sql on: conn	| result resultStream |	resultStream := ReadWriteStream on: String new.	result := conn execute: sql.	result displayResultOn: resultStream.	^ resultStream contents.! !!TestPGConnection methodsFor: 'private' stamp: 'yj 4/24/2003 23:01'!executeAll: queries	self executeAll: queries withDelayForMilliseconds: nil! !!TestPGConnection methodsFor: 'private' stamp: 'yj 4/24/2003 23:01'!executeAll: queries withDelayForMilliseconds: millisecondDelay	| conn result |	conn := self newConnection.	conn startup.	queries do: [:each |		Transcript nextPutAll: 'QUERY: '; nextPutAll: each; cr; flush.		result := conn execute: each.		result displayResultOn: Transcript.		Transcript flush.		millisecondDelay isNil ifFalse: [			Transcript nextPutAll: 'Delaying for ', millisecondDelay printString, ' ms...'; cr.			(Delay forMilliseconds: millisecondDelay) wait.			Transcript flush.		].	].	conn terminate.! !!TestPGConnection methodsFor: 'private' stamp: 'yj 11/10/2004 23:52'!floatFromByteArray: aByteArray	"Convert aByteArray to a Float."	| word1 word2 aFloat |	word1 := (aByteArray at: 1) bitShift: 24.	word1 := word1 bitOr: ((aByteArray at: 2) bitShift: 16).	word1 := word1 bitOr: ((aByteArray at: 3) bitShift: 8).	word1 := word1 bitOr: ((aByteArray at: 4) bitShift: 0).	word2 := (aByteArray at: 5) bitShift: 24.	word2 := word2 bitOr: ((aByteArray at: 6) bitShift: 16).	word2 := word2 bitOr: ((aByteArray at: 7) bitShift: 8).	word2 := word2 bitOr: ((aByteArray at: 8) bitShift: 0).	aFloat := 0.0.	aFloat basicAt: 1 put: word1.	aFloat basicAt: 2 put: word2.	^aFloat! !!TestPGConnection methodsFor: 'private' stamp: 'yj 2/9/2005 21:59'!floatFromByteArrayVW: aByteArray	"Convert aByteArray to a Float."	| aFloat |	aFloat := ByteArray new: 8.	1 to: 8 do: [:i | aFloat at: 8 - i + 1 put: (aByteArray at: i)].	aFloat changeClassTo: Double.	^aFloat! !!TestPGConnection methodsFor: 'private' stamp: 'yj 4/24/2003 23:01'!functionCall: oid arguments: arguments	| conn result |	conn := self newConnection.	conn startup.	result := conn functionCall: oid arguments: arguments.	conn terminate.	^ result! !!TestPGConnection methodsFor: 'tests' stamp: 'yj 4/24/2003 23:01'!makeCopyInOutEos	"Answer the COPY IN/OUT end of stream code."	^ String with: $\ with: $.with: Character lf! !!TestPGConnection methodsFor: 'tests' stamp: 'yj 4/24/2003 23:01'!makeCopyInOutLine: aCollection	| ws |	ws := WriteStream on: (String new: 512).	aCollection withIndexDo: [:each :i |		ws nextPutAll: each.		i < aCollection size ifTrue: [ws tab]	].	ws nextPut: Character lf.	^ ws contents.! !!TestPGConnection methodsFor: 'private' stamp: 'yj 4/24/2003 23:01'!newConnection	| conn |	conn := PGConnection new.	(useConnectionDefaults isNil or: [useConnectionDefaults not])		ifTrue: [ conn connectionArgs: PGConnection buildDefaultConnectionArgs ]		ifFalse: [ PGConnection defaultConnectionArgs: nil. conn connectionArgs: nil ].	(notificationSubscriberCount notNil and: [notificationSubscriberCount > 0 ])		ifTrue: [			1 to: notificationSubscriberCount do: [:i |				conn addNotificationSubscriber: PGNotificationSubscriber new]		].	^ conn! !!TestPGConnection methodsFor: 'tests' stamp: 'yj 4/24/2003 23:01'!oidAbs	"oid 1395 is abs(float8)"	^ 1395! !!TestPGConnection methodsFor: 'tests' stamp: 'yj 4/24/2003 23:01'!oidSqrt	"oid 1344 is sqrt(float8)"	^ 1344! !!TestPGConnection methodsFor: 'tests' stamp: 'yj 4/24/2003 23:01'!oidTimenow	^ 250! !!TestPGConnection methodsFor: 'postgres test suite' stamp: 'yj 4/24/2003 23:01'!regress: testName	| inStream conn outStream line pos result sql |	Transcript show: testName, '--starting test'; cr.	conn := self newConnection.	conn startup.	inStream := FileStream readOnlyFileNamed: 'u:\lib\pgsql\test\regress\sql\', testName, '.sql'.	outStream := FileStream newFileNamed: testName, '.out'.	sql := ''.	[inStream atEnd] whileFalse: [		line := inStream upTo: Character lf.		(line beginsWith: '--')			ifTrue: [outStream nextPutAll: line; cr].		(line size > 0 and: [(line beginsWith: '--') not]) ifTrue: [			pos := line findString: '\g'. "\g is psql execute command"			pos > 0 ifTrue: [line := line copyFrom: 1 to: pos - 1].			sql := sql, line, String cr.			(line endsWith: ';') ifTrue: [				result := conn execute: sql.				Transcript show: sql; flush.				outStream nextPutAll: sql.				result displayResultOn: outStream.				sql := ''.			].		].	].	inStream close.	outStream close.	conn terminate.	Transcript show: testName, '--test completed'; cr.! !!TestPGConnection methodsFor: 'postgres test suite' stamp: 'yj 4/24/2003 23:01'!regressionTestNames	^#(		#('boolean' 'char' 'name' 'varchar' 'text' 'int2' 'int4' 'int8' 'oid' 'float4' 'float8' 'numeric')		'strings'		'numerology'		#('point' 'lseg' 'box' 'path' 'polygon' 'circle' 'interval' 'timestamp' 'reltime' 'tinterval' 'inet' 'comments' 'oidjoins' 'type_sanity' 'opr_sanity')		'abstime'		'geometry'		'horology'		'create_function_1'		'create_type'		'create_table'		'create_function_2'		'copy'		#('constraints' 'triggers' 'create_misc' 'create_aggregate' 'create_operator' 'create_index')		'create_view'		'sanity_check'		'errors'		'select'		#('select_info' 'select_distinct' 'select_distinct_on' 'select_implicit' 'select_having' 'subselect' 'union' 'case' 'join' 'aggregates' 'transactions' 'random' 'portals' 'arrays' 'btree_index' 'hash_index')		'misc'		#('select_views' 'alter_table' 'portals_p2' 'rules' 'foreign_key')		#('limit' 'plpgsql' 'temp')	)! !!TestPGConnection methodsFor: 'postgres test suite' stamp: 'yj 4/24/2003 23:01'!runRegressionTests	"TestPGConnection new runRegressionTests"	self regress: 'drop'.	(self regressionTestNames at: 1) do: [:each | self regress: each].	"self regressionTestNames do: [:test |		test isString			ifTrue: [self regress: test]			ifFalse: [test do: [:each | self regress: each]]	]."! !!TestPGConnection methodsFor: 'tests' stamp: 'EstebanMaringolo 9/4/2014 15:33'!sampleJsonObject	| jsonObject |	jsonObject := JsonObject new		at: 'string' put: 'Hello world';		at: 'number' put: 10;		at: 'float' put: 10.2;		at: 'boolean' put: true;		at: 'collection' put: #(1 2 3 5 8 11 19);		at: 'mixedCollection' put: #(1 'Hello' false);		yourself.	^ jsonObject! !!TestPGConnection methodsFor: 'tests' stamp: 'EstebanMaringolo 9/4/2014 16:01'!supportsJsonType: conn		^(conn execute: 'SELECT oid,typname from pg_type  WHERE oid = 114') rows size > 0		! !!TestPGConnection methodsFor: 'private' stamp: 'yj 4/24/2003 23:01'!tearDown	PGConnection defaultConnectionArgs: nil.! !!TestPGConnection methodsFor: 'tests' stamp: 'yj 4/24/2003 23:01'!testCancelRequest	"Test: CancelRequest.	Set the debug level of the postmaster daemon to 1 or greater.	Capture the postmaster output in a log file.	Examine the log file for a cancel request with a matching process id.	Example, an init.d script containing:		su -l postgres -s /bin/sh -c ""/usr/bin/pg_ctl  -D $PGDATA -p /usr/bin/postmaster -o '-i -d 1' start  > /var/log/postgresql/log 2>&1"" < /dev/null	yields a line in the log:		/usr/bin/postmaster: processCancelRequest: sending SIGINT to process 13142	"	| conn |	conn := self newConnection.	conn startup.	conn cancelRequest.	conn terminate.! !!TestPGConnection methodsFor: 'tests' stamp: 'yj 4/24/2003 23:01'!testConnection	"Test: connect and disconnect, without any queries."	self executeAll: #().! !!TestPGConnection methodsFor: 'tests' stamp: 'yj 4/24/2003 23:01'!testCopyIn1	| ws conn result |	ws := WriteStream on: String new.	ws nextPutAll: self makeCopyInOutEos.	self dropTestCopyInOutTable.	self createTestCopyInOutTable.	conn := self newConnection.	conn startup.	conn copy: 'copy TestCopyInOutTable from stdin' withStream: ws.	result := conn execute: 'select * from TestCopyInOutTable'.	conn terminate.	self assert: result rows size = 0.! !!TestPGConnection methodsFor: 'tests' stamp: 'yj 4/24/2003 23:01'!testCopyIn2	| ws result conn |	self dropTestCopyInOutTable.	self createTestCopyInOutTable.	ws := WriteStream on: String new.	ws nextPutAll: (self makeCopyInOutLine: (Array with: '77' with: 'abcde')).	ws nextPutAll: self makeCopyInOutEos.	conn := self newConnection.	conn startup.	conn copy: 'copy TestCopyInOutTable from stdin' withStream: ws.	result := conn execute: 'select * from TestCopyInOutTable'.	conn terminate.	self assert: result rows size = 1.! !!TestPGConnection methodsFor: 'tests' stamp: 'yj 4/24/2003 23:01'!testCopyOut1	| ws |	self dropTestCopyInOutTable.	self createTestCopyInOutTable.	ws := WriteStream on: (String new: 512).	self copy: 'copy TestCopyInOutTable to stdout' withStream: ws.	"Transcript show: ws contents printString; cr."	self assert: ws contents = (String with: $\ with: $. with: Character lf).! !!TestPGConnection methodsFor: 'tests' stamp: 'yj 4/24/2003 23:01'!testCopyOut2	| ws rs |	ws := WriteStream on: String new.	ws nextPutAll: (self makeCopyInOutLine: (Array with: '77' with: 'abcde')).	ws nextPutAll: self makeCopyInOutEos.	self dropTestCopyInOutTable.	self createTestCopyInOutTable.	self executeAll: #('insert into TestCopyInOutTable values(77,''abcde'')').	rs := WriteStream on: (String new: 512).	self copy: 'copy TestCopyInOutTable to stdout' withStream: rs.	self assert: rs contents = ws contents.! !!TestPGConnection methodsFor: 'tests' stamp: 'yj 4/24/2003 23:01'!testCopyOut3	| ws rs |	ws := WriteStream on: String new.	ws nextPutAll: (self makeCopyInOutLine: (Array with: '77' with: 'abcde')).	ws nextPutAll: (self makeCopyInOutLine: (Array with: '88' with: 'vwxyz')).	ws nextPutAll: self makeCopyInOutEos.	self dropTestCopyInOutTable.	self createTestCopyInOutTable.	self executeAll: #('insert into TestCopyInOutTable values(77,''abcde'')').	self executeAll: #('insert into TestCopyInOutTable values(88,''vwxyz'')').	rs := WriteStream on: (String new: 512).	self copy: 'copy TestCopyInOutTable to stdout' withStream: rs.	self assert: rs contents = ws contents.! !!TestPGConnection methodsFor: 'tests' stamp: 'yj 4/24/2003 23:01'!testExecute1	self executeAll: #(			'select timenow()'			'select abs(-1)'		).! !!TestPGConnection methodsFor: 'tests' stamp: 'yj 4/24/2003 23:01'!testExecute2	self executeAll: #(			'select timenow(); select abs(-1)'		).! !!TestPGConnection methodsFor: 'tests' stamp: 'yj 4/24/2003 23:01'!testExecuteUsingConnectionDefaults	useConnectionDefaults := true.	self executeAll: #(			'select timenow()'			'select abs(-1)'		).! !!TestPGConnection methodsFor: 'tests' stamp: 'yj 4/24/2003 23:01'!testFieldConverter	"Test: two different connections can have a different field converter for a given typeOid.	This capability would be useful when using one image to connect to two different databases,	where the same (custom) typeOid is defined differently in each database.	"	| conn1 result1 conn2 result2 newConverter |	self dropTestTable.	self createTestTable.	conn1 := self newConnection.	conn2 := self newConnection.	conn1 startup.	conn2 startup.	result1 := conn1 execute: 'INSERT INTO products VALUES (1);'.	result1 := conn1 execute: 'select * from products'.	newConverter := [:value | value].	conn2 fieldConverterAt: 20 put: newConverter.	conn2 fieldConverterAt: 21 put: newConverter.	conn2 fieldConverterAt: 23 put: newConverter.	result2 := conn2 execute: 'select * from products'.	conn1 terminate.	conn2 terminate.	self assert: result1 rows size = 1.	self assert: result1 rows first data first = 1.	self assert: result2 rows size = 1.	self assert: result2 rows first data first = '1'.! !!TestPGConnection methodsFor: 'tests' stamp: 'yj 2/1/2006 11:37'!testFieldConverter2	| conn result data |	self dropTestFieldConverterTable.	self createTestFieldConverterTable.	conn := self newConnection.	conn startup.	result := conn execute:'INSERT INTO TestFieldConverterTable VALUES (TRUE,FALSE,''A'',''B'',''CD'',77,88,99,11.11,22.22,33.33,''2001-01-01'',''04:05:06'',''abcd'');'.	result := conn execute: 'select * from TestFieldConverterTable'.	conn terminate.	self assert: result rows size = 1.	data := result rows first data.	"result rows first inspect."	self assert: (data at: 1).	self assert: (data at: 2) not.	self assert: (data at: 3) = 'A'.	self assert: (data at: 4) = 'B'.	self assert: (data at: 5) = 'CD'.	self assert: (data at: 6) = 77.	self assert: (data at: 7) = 88.	self assert: (data at: 8) = 99.	self assert: ((data at: 9) - 11.11) abs < 0.0001.	self assert: ((data at: 10) - 22.22) abs < 0.0001.	self assert: ((data at: 11) - 33.33) abs < 0.0001.	"self assert: (data at: 12) = (DateAndTime year: 2001 month: 1 day: 1 hour: 0 minute: 0 second: 0)."	self assert: (data at: 12) = (Date newDay: 1 month: 1 year: 2001).	self assert: (data at: 13) = (Time fromSeconds: (4*60*60) + (5*60) + 6).	self assert: (data at: 14) = 'abcd'.! !!TestPGConnection methodsFor: 'tests' stamp: 'yj 2/1/2006 11:37'!testFieldConverter3	| conn result d |	self dropTestFieldConverterTable.	self createTestFieldConverterTable.	conn := self newConnection.	conn startup.	result := conn execute:'INSERT INTO TestFieldConverterTable VALUES (TRUE,FALSE,''A'',''B'',''CD'',77,88,99,11.11,22.22,33.33,''2001-01-01'',''04:05:06'',''abcd'');'.	result := conn execute: 'select * from TestFieldConverterTable'.	conn terminate.	self assert: result rows size = 1.	d := result rows first dataKeyedByFieldName.	"result rows first inspect."	self assert: (d at: 'aBool1' asLowercase).	self assert: (d at: 'aBool2' asLowercase) not.	self assert: (d at: 'aChar' asLowercase) = 'A'.	self assert: (d at: 'aChar1' asLowercase) = 'B'.	self assert: (d at: 'aChar2' asLowercase) = 'CD'.	self assert: (d at: 'anInt2' asLowercase) = 77.	self assert: (d at: 'anInt4' asLowercase) = 88.	self assert: (d at: 'anInt8' asLowercase) = 99.	self assert: ((d at: 'aFloat4' asLowercase) - 11.11) abs < 0.0001.	self assert: ((d at: 'aFloat8' asLowercase) - 22.22) abs < 0.0001.	self assert: ((d at: 'aNumeric' asLowercase) - 33.33) abs < 0.0001.	"self assert: (d at: 'aDate' asLowercase) = (DateAndTime year: 2001 month: 1 day: 1 hour: 0 minute: 0 second: 0)."	self assert: (d at: 'aDate' asLowercase) = (Date newDay: 1 month: 1 year: 2001).	self assert: (d at: 'aTime' asLowercase) = (Time fromSeconds: (4*60*60) + (5*60) + 6).	self assert: (d at: 'aText' asLowercase) = 'abcd'.! !!TestPGConnection methodsFor: 'tests' stamp: 'yj 4/24/2003 23:01'!testFunctionCall	"Test: make several function calls before terminating."	| conn result arg |	arg := self asFloat8Arg: 1.0.	conn := self newConnection.	conn startup.	result := conn functionCall: self oidTimenow arguments: OrderedCollection new.	result := conn functionCall: self oidAbs arguments: (OrderedCollection with: arg).	result := conn functionCall: self oidSqrt arguments: (OrderedCollection with: arg).	conn terminate.	^ result! !!TestPGConnection methodsFor: 'tests' stamp: 'yj 4/24/2003 23:01'!testFunctionCall1	| result |	result := self functionCall: self oidTimenow arguments: OrderedCollection new.	self assert: result functionResult notNil.! !!TestPGConnection methodsFor: 'tests' stamp: 'yj 11/10/2004 23:52'!testFunctionCall2	| arg result |	arg := self asFloat8Arg: -1.0.	result :=  self functionCall: self oidAbs arguments: (OrderedCollection with: arg).	self assert: result functionResult notNil.	self assert: (self floatFromByteArray: result functionResult result) = 1.0.! !!TestPGConnection methodsFor: 'tests' stamp: 'yj 11/10/2004 23:54'!testFunctionCall3	| arg result |	arg := self asFloat8Arg: 1.0.	result := self functionCall: self oidSqrt arguments: (OrderedCollection with: arg).	self assert: result functionResult notNil.	self assert: (self floatFromByteArray: result functionResult result) = 1.0.! !!TestPGConnection methodsFor: 'tests' stamp: 'EstebanMaringolo 9/4/2014 16:06'!testJsonFieldConverter	| conn result data jsonObject |		conn := self newConnection.	conn startup.	(self supportsJsonType: conn) ifFalse: [ 		conn terminate.		self skip].	self dropJsonFieldConverterTable.	self createJsonFieldConverterTable.	jsonObject := self sampleJsonObject.	result := conn execute: 'INSERT INTO jsonfieldconvertertable VALUES (' , (Json render: jsonObject) printString , ')'.	result := conn execute: 'SELECT * from jsonfieldconvertertable'.	conn terminate.	self assert: result rows size = 1.	data := result rows first data.	"result rows first inspect."	self assert: (data at: 1) class = JsonObject.	self assert: (data at: 1) = jsonObject.			! !!TestPGConnection methodsFor: 'tests' stamp: 'yj 4/24/2003 23:01'!testNotify1	notificationSubscriberCount := 1.	[		self executeAll: #(			'notify pgtest' 'notify pgtest' 'notify pgtest' 'notify pgtest' 'notify pgtest'			'notify pgtest' 'notify pgtest' 'notify pgtest' 'notify pgtest' 'notify pgtest'		) withDelayForMilliseconds: 1000	] fork.	self executeAll: #(		'listen pgtest'		'select timenow()'		'select timenow()'	) withDelayForMilliseconds: 5000! !!TestPGConnection methodsFor: 'tests' stamp: 'yj 4/24/2003 23:01'!testNotify2	"Test: a NoticeResponse will be sent because there is an extra field on the input line."	| ws conn |	notificationSubscriberCount := 2.	self dropTestTable.	self createTestTable.	ws := WriteStream on: String new.	ws nextPutAll: (self makeCopyInOutLine: (Array with: '77' with: 'abcde' with: '123.456' with: '999.999')).	ws nextPutAll: self makeCopyInOutEos.	conn := self newConnection.	conn startup.	conn copy: 'copy products from stdin' withStream: ws.	conn terminate.! !!TestPGConnection methodsFor: 'as yet unclassified' stamp: 'noha 11/26/2007 16:58'!testReadWriteWithEncoding	| conn1 result1 |	self dropTestTable.	self createTestTable.	conn1 := self newConnection.	conn1 connectionArgs clientEncoding: #utf8.	conn1 startup.	result1 := conn1 execute: 'INSERT INTO products VALUES (1, '''');'.	result1 := conn1 execute: 'select * from products'.	conn1 terminate.	self assert: result1 rows size = 1.	self assert: result1 rows first data second = ''.! !!TestPGConnection methodsFor: 'tests' stamp: 'yj 4/24/2003 23:01'!testResultSet1	| conn result |	self dropTestTable.	self createTestTable.	conn := self newConnection.	conn startup.	result := conn execute: 'insert into products values(77,''abcde'',123.456)'.	result := conn execute: 'select * from products'.	conn terminate.	self assert: result rows size = 1.! !!TestPGConnection methodsFor: 'tests' stamp: 'yj 4/24/2003 23:01'!testResultSet2	| conn result rs1 rs2 |	self dropTestTable.	self createTestTable.	conn := self newConnection.	conn startup.	result := conn execute: 'insert into products values(49,''abcde'',123.456)'.	result := conn execute: 'insert into products values(50,''abcde'',123.456)'.	result := conn execute: 'insert into products values(51,''abcde'',123.456)'.	result := conn execute: 'insert into products values(52,''abcde'',123.456)'.	result := conn execute: 'select * from products; select * from products where product_no > 50'.	conn terminate.	rs1 := result resultSets at: 1.	self assert: rs1 rows size = 4.	rs2 := result resultSets at: 2.	self assert: rs2 rows size = 2.! !!TestPGDateAndTimeExtension methodsFor: 'tests' stamp: 'YanniChiu 2/4/2011 22:52'!testYearMonthDayInstanceCreation	"#year:month:day: shortcuts #year:month:day:hour:minute:second:,	but it should not forget about the offset.	This test will fail to detect a problem if run where the local timezone offset is 0."	| year month day date1 date2 |	year := 2011.	month := 2.	day := 4.	date1 := DateAndTime year: year month: month day: day hour: 0 minute: 0 second: 0.	date2 := DateAndTime year: year month: month day: day.	self assert: date1 = date2! !!PGActiveObject class methodsFor: 'stt' stamp: 'kb 1/30/2009 20:07'!buildStateTransitionTable	^IdentityDictionary new! !!PGActiveObject class methodsFor: 'stt' stamp: 'yj 4/24/2003 23:01'!resetStateTransitionTable	stateTransitionTable := nil! !!PGActiveObject class methodsFor: 'stt' stamp: 'yj 4/24/2003 23:01'!stateTransitionTable	stateTransitionTable == nil ifTrue: [stateTransitionTable := self buildStateTransitionTable].	^ stateTransitionTable! !!PGActiveObject methodsFor: 'private-sa' stamp: 'yj 4/24/2003 23:01'!generateEvent: event to: receiver	^self == receiver		ifTrue: [self processEvent: event]		ifFalse: [receiver queueEvent: event].! !!PGActiveObject methodsFor: 'initialize/release' stamp: 'yj 4/24/2003 23:01'!initialize	state := #Created.	events := OrderedCollection new.	^self! !!PGActiveObject methodsFor: 'trace' stamp: 'yj 4/24/2003 23:01'!log: where text: text	self logInfo: where, ': ', text.! !!PGActiveObject methodsFor: 'trace' stamp: 'yj 4/24/2003 23:01'!logIdString	^ self class name, '(', self hash printString, ')'.! !!PGActiveObject methodsFor: 'trace' stamp: 'yj 4/24/2003 23:01'!logInfo: text	Transcript		nextPut: $[;		nextPutAll: self logIdString;		nextPut: $];		space;		nextPutAll: text;		cr;		flush.! !!PGActiveObject methodsFor: 'private-sa' stamp: 'yj 4/24/2003 23:01'!nextEvent	^ #CantHappen! !!PGActiveObject methodsFor: 'private-sa' stamp: 'yj 11/12/2004 18:20'!processEvent: event	| nextState eventName eventNameString traceText |	eventName := event isSymbol ifTrue: [event] ifFalse: [event eventName].	nextState := (self stateTransitionTable at: state)		at: eventName		ifAbsent: [ #CantHappen ].	trace >= 8 ifTrue: [		eventNameString := event isSymbol ifTrue: [event asString] ifFalse: [event eventName].		traceText := nextState = #EventIgnored			ifTrue: [ state asString, ' IGNORE ', eventNameString ]			ifFalse: [ state asString, '-->', nextState asString, ' on ', eventNameString ].		self log: 'processEvent' text: traceText.	].	nextState = #EventIgnored		ifFalse: [			state := nextState.			self perform: ('st', state asString, ':') asSymbol with: event.		].! !!PGActiveObject methodsFor: 'private-sa' stamp: 'yj 4/24/2003 23:01'!queueEvent: event	events addLast: event.! !!PGActiveObject methodsFor: 'private-sa' stamp: 'yj 4/24/2003 23:01'!saProcessEventsUntil: newStates	[		[events size > 0] whileTrue: [			self processEvent: events removeFirst.		].		(newStates includes: state) 			ifFalse: [self generateEvent: self nextEvent to: self].		(newStates includes: state) not	] whileTrue.! !!PGActiveObject methodsFor: 'private-sa' stamp: 'yj 4/24/2003 23:01'!stCantHappen: event	"Handle a defective state machine."	self error: self class name, ' has a defective state machine'.! !!PGActiveObject methodsFor: 'private-sa' stamp: 'yj 4/24/2003 23:01'!stateTransitionTable	^ self class stateTransitionTable! !!PGActiveObject methodsFor: 'trace' stamp: 'yj 4/24/2003 23:01'!trace	^trace! !!PGActiveObject methodsFor: 'trace' stamp: 'yj 4/24/2003 23:01'!trace: anInteger	trace := anInteger! !!PGConnection class methodsFor: 'converters' stamp: 'kb 1/31/2009 02:41'!booleanArrayConverter	^[ :s | 		| readStream |		readStream := s readStream.		readStream next.		Array streamContents: [ :stream | 			[ readStream atEnd or: [ readStream peek = $} ] ] whileFalse: [				stream nextPut: (self nextBooleanFrom: readStream) ] ] ].! !!PGConnection class methodsFor: 'converters' stamp: 'kb 1/31/2009 02:41'!booleanConverter	^[ :s | s = 't' or: [ s = 'T' ] ]! !!PGConnection class methodsFor: 'initialization' stamp: 'EstebanMaringolo 9/4/2014 16:04'!buildDefaultConnectionArgs	^ PGConnectionArgs		hostname: 'localhost'		portno: 5432		databaseName: 'sodbxtest'		userName: 'sodbxtest'		password: 'sodbxtest'! !!PGConnection class methodsFor: 'initialization' stamp: 'EstebanMaringolo 9/4/2014 15:09'!buildDefaultFieldConverters	"The type oid's can be found using:		SELECT oid,typname from pg_type	Also, see the source code file:		.../src/include/catalog/pg_type.h	"	| converters |	converters := IdentityDictionary new.	#(		(booleanConverter (16 "boolean"))		(booleanArrayConverter (1000 "boolean[]"))		(characterConverter (18 "char" 1002 "_char" 1042 "bpchar")) "fix the array converter!!"		(integerConveter (20 "int8" 21 "int2" 23 "int4"))		(integerArrayConveter (1005 "_int2[]" 1007 "_int4[]" 1016 "_int8[]"))		(stringArrayConveter (1009)) "doesn't handle nulls"		(floatConverter (700 "float4" 701 "float8" 1021 "_float4" 1022 "_float8")) "fix the array converter"		(numericConverter (1700 "numeric")) "fix it, it returns a float now"		(dateConverter (1082 "date" 1182 "_date")) "fix the array converter"		(timeConverter (1083 "time" 1183 "_time")) "fix the array converter"		(timestampConverter (1114 "timestamp" 1115 "_timestamp")) "fix the array converter"		(timeWithTimezoneConverter (1266 "timetz" 1270 "_timetz")) "probably omits the timezone. fix the array converter"		(timestampWithTimezoneConverter (1184 "timestamptz " 1185 "_timestamptz")) "fix the array converter"		(jsonConverter (114 114))	) do: [ :each |		each second do: [ :typeOid |			converters at: typeOid put: (self perform: each first) ] ].	^ converters! !!PGConnection class methodsFor: 'initialization' stamp: 'kb 1/30/2009 20:08'!buildStateTransitionTable	"self resetStateTransitionTable"	^#(	(Created (		(Startup Startup)))	(Startup (		(AuthenticationKerberosV4 UnsupportedAuthentication)		(AuthenticationKerberosV5 UnsupportedAuthentication)		(AuthenticationCleartextPassword SendingCleartextPassword)		(AuthenticationCryptPassword UnsupportedAuthentication)		(AuthenticationMD5Password	SendingMD5Password)		(AuthenticationSCMCredential UnsupportedAuthentication)		(AuthenticationOk AuthenticationOk)		(ConnectionFailed ConnectionFailed)		(Terminate Terminated)		(ErrorResponse TerminalError)))	(SendingCleartextPassword (		(AuthenticationOk AuthenticationOk)		(Terminate Terminated)		(ErrorResponse TerminalError)))	(SendingMD5Password (		(AuthenticationOk AuthenticationOk)		(Terminate Terminated)		(ErrorResponse TerminalError)))	(UnsupportedAuthentication (		(Terminate Terminated)))	(AuthenticationOk (		(BackendKeyData GotBackendKeyData)		(Terminate Terminated)		(ErrorResponse TerminalError)))	(GotBackendKeyData (		(ReadyForQuery ReadyForQuery)		(Terminate Terminated)		(ErrorResponse ErrorResponse)))	(ReadyForQuery (		(Query Querying)		(FunctionCall FunctionCall)		(Terminate Terminated)		(ErrorResponse ErrorResponse)))	(Querying (		(CursorResponse GotCursor)		(CopyOutResponse GotCopyOut)		(CopyInResponse GotCopyIn)		(CompletedResponse GotCompleted)		(Terminate Terminated)		(ErrorResponse ErrorResponse)))	(FunctionCall (		(FunctionResultResponse GotFunctionResult)		(Terminate Terminated)		(ErrorResponse ErrorResponse)))	(GotCursor (		(RowDescription GotRowDescription)		(CompletedResponse GotCompleted)		(Terminate Terminated)		(ErrorResponse ErrorResponse)))	(GotRowDescription (		(AsciiRow GotRow)		(BinaryRow GotRow)		(CompletedResponse GotCompleted)		(Terminate Terminated)		(ErrorResponse ErrorResponse)))	(GotRow (		(AsciiRow GotRow)		(BinaryRow GotRow)		(CompletedResponse GotCompleted)		(Terminate Terminated)		(ErrorResponse ErrorResponse)))	(GotCopyOut (		(CompletedResponse GotCompleted)		(Terminate Terminated)		(ErrorResponse ErrorResponse)))	(GotCopyIn (		(CompletedResponse GotCompleted)		(Terminate Terminated)		(ErrorResponse ErrorResponse)))	(GotFunctionResult (		(ReadyForQuery ReadyForQuery)		(CompletedResponse GotCompleted)		(Terminate Terminated)		(ErrorResponse ErrorResponse)))	(GotCompleted (		(ReadyForQuery ReadyForQuery)		(CursorResponse GotCursor)		(CompletedResponse GotCompleted)		(Terminate Terminated)		(ErrorResponse ErrorResponse)))	(Terminated (		(Startup Startup)))	(ConnectionFailed (		(Startup Startup)		(Query EventIgnored)		(FunctionCall EventIgnored)		(Terminate EventIgnored)))	(ErrorResponse (		(Terminate Terminated)		(ReadyForQuery ReadyForQuery)		(CompletedResponse GotCompleted)))	(TerminalError (		))	)	inject: IdentityDictionary new	into: [:table :each |		table			at: (each at: 1)			put: ((each at: 2)					inject: IdentityDictionary new					into: [:stateTransitions :transition |						stateTransitions at: (transition at: 1) put: (transition at: 2).						stateTransitions]).		table].! !!PGConnection class methodsFor: 'converters' stamp: 'kb 1/31/2009 02:39'!characterConverter	^[ :s | s ]! !!PGConnection class methodsFor: 'converters' stamp: 'ul 9/13/2009 15:58'!dateConverter 	^[:s |		Date			year: (s copyFrom: 1 to: 4) asInteger			month: (s copyFrom: 6 to: 7) asInteger			day: (s copyFrom: 9 to: 10) asInteger ]! !!PGConnection class methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!defaultConnectionArgs	DefaultConnectionArgs isNil ifTrue: [DefaultConnectionArgs := self buildDefaultConnectionArgs].	^ DefaultConnectionArgs! !!PGConnection class methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!defaultConnectionArgs: aConnectionArgs	"self defaultConnectionArgs: nil"	DefaultConnectionArgs := aConnectionArgs! !!PGConnection class methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!defaultTraceLevel	DefaultTraceLevel isNil ifTrue: [DefaultTraceLevel := 0].	^DefaultTraceLevel! !!PGConnection class methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!defaultTraceLevel: anInteger	"	PGConnection defaultTraceLevel: 0.	PGConnection defaultTraceLevel: 2.	PGConnection defaultTraceLevel: 5.	PGConnection defaultTraceLevel: 8.	PGConnection defaultTraceLevel: 10.	"	DefaultTraceLevel := anInteger! !!PGConnection class methodsFor: 'converters' stamp: 'kb 1/31/2009 04:09'!floatConverter	^[ :s | (Number readFrom: (ReadStream on: s)) asFloat ]! !!PGConnection class methodsFor: 'converters' stamp: 'kb 1/31/2009 02:48'!integerArrayConveter	^[:s | 		| readStream |		readStream := s readStream.		readStream next.		Array streamContents: [ :stream | 			[ readStream atEnd or: [ readStream peek = $} ] ] whileFalse: [ 				stream nextPut: (self readIntegerFrom: readStream).				readStream next ] ] ]! !!PGConnection class methodsFor: 'converters' stamp: 'kb 1/31/2009 02:42'!integerConveter	^[ :s | self readIntegerFrom: (ReadStream on: s) ].! !!PGConnection class methodsFor: 'converters' stamp: 'EstebanMaringolo 9/4/2014 15:14'!jsonConverter 	^[:string | Json readFrom: string readStream ]! !!PGConnection class methodsFor: 'instance creation' stamp: 'yj 4/24/2003 23:01'!new	^self basicNew initialize! !!PGConnection class methodsFor: 'private' stamp: 'kb 1/31/2009 03:06'!nextBooleanFrom: readStream	| firstChar result |	firstChar := readStream next.	result := firstChar caseOf: { 		[ $t ] -> [ true ].		[ $T ] -> [ true ].		[ $f ] -> [ false ].		[ $F ] -> [ false ].		[ $N ] -> [ 			(readStream next: 3) = 'ULL' ifFalse: [				self parseError ].			nil ] }.	readStream skip: 1.	^result! !!PGConnection class methodsFor: 'private' stamp: 'EstebanMaringolo 5/18/2014 22:27'!nextDateAndTimeFrom: string	"Accepted format: 'YYYY-MM-DD HH:MM:SS[.ss...s][(+|-)HH]' fractional seconds and timezone are optional"	"#( '1967-08-07 18:50:12+02' '1967-08-07 18:50:12' '1967-08-07 18:50:12.12+02' 		'1967-08-07 18:50:12.123+02' '1967-08-07 18:50:12.123456' ) 		collect: [ :each | self nextDateAndTimeFrom: each ] "		| stream parser parseInteger direction fractionalSeconds offset |	stream := ReadStream on: string.	parser := NumberParser on: stream.	parseInteger := [ :from :to | 		stream setFrom: from to: to. 		parser nextUnsignedIntegerBase: 10 ].	fractionalSeconds := 0.	offset := DateAndTime localOffset.	string size > 19 		ifTrue: [ | offsetStart |			(string at: 20) = $.				ifTrue: [					offsetStart := 21.					[ offsetStart <= string size and: [ (string at: offsetStart) isDigit ] ]						whileTrue: [ offsetStart := offsetStart + 1 ].					offsetStart > 21 ifTrue: [ fractionalSeconds := parseInteger value: 21 value: offsetStart - 1 ] ]				ifFalse: [ 					offsetStart := 20 ].			offsetStart <= string size				ifTrue: [						direction := (string at: offsetStart) = $- ifTrue: [ -1 ] ifFalse: [ 1 ].					offset := Duration hours: (parseInteger value: offsetStart + 1 value: string size) * direction ] ].	^ DateAndTime		year: (parseInteger value: 1 value: 4)		month: (parseInteger value: 6 value: 7)		day: (parseInteger value: 9 value: 10)		hour: (parseInteger value: 12 value: 13)		minute: (parseInteger value: 15 value: 16)		second: (parseInteger value: 18 value: 19)		nanoSecond: fractionalSeconds * (10 raisedToInteger: (9 - fractionalSeconds numberOfDigits))		offset: offset! !!PGConnection class methodsFor: 'private' stamp: 'kb 10/2/2008 16:37'!nextStringFrom: readStream	| escape |	^String streamContents: [ :stream |		readStream peek = $" 			ifFalse: [ 				[ #($, $}) includes: readStream peek ] whileFalse: [ 					stream nextPut: readStream next ] ]			ifTrue: [				escape := false.				readStream skip: 1.				[ escape not and: [ readStream peek = $" ] ] whileFalse: [ 					| character |					character := readStream next.					escape 						ifTrue: [							stream nextPut: character.							escape := false ]						ifFalse: [							escape := character = $\.							escape ifFalse: [ stream nextPut: character ] ].					].				readStream skip: 1 ].		readStream skip: 1 " drop comma or curlybrace " ]! !!PGConnection class methodsFor: 'converters' stamp: 'kb 1/31/2009 04:13'!numericConverter	"This should convert the value to ScaledDecimal"	^[ :s | (Number readFrom: (ReadStream on: s)) asFloat ]! !!PGConnection class methodsFor: 'private' stamp: 'kb 1/31/2009 03:04'!readIntegerFrom: readStream	| next result sign |	readStream atEnd ifTrue: [ ^self parseError ].	readStream peek caseOf: {		[ $- ] -> [			sign := -1.			readStream skip: 1 ].		[ $N ] -> [			(readStream next: 4) = 'NULL' ifTrue: [ ^nil].			self parseError ]}		otherwise: [ sign := 1 ].	result := 0.	[ (next := readStream next) == nil or: [		(next := next asciiValue - 48) < 0 or: [			next > 9 ] ] ] whileFalse: [		result := result * 10 + next ].	readStream skip: -1.	^result * sign! !!PGConnection class methodsFor: 'converters' stamp: 'kb 1/31/2009 03:21'!stringArrayConveter	^[ :s |		| readStream |		readStream := s readStream.		readStream next.		Array streamContents: [ :stream | 			[ readStream atEnd or: [ readStream peek = $} ] ] whileFalse: [				stream nextPut: (self nextStringFrom: readStream) ] ] ]! !!PGConnection class methodsFor: 'tests' stamp: 'kb 1/31/2009 04:36'!testConvertersWith: aPGConnection	{ 		'select b::boolean from (values (true), (false), (null)) t(b)' -> #(true false nil).		'select array[true, false, null]::boolean[]' -> #((true false nil)).		'select i::integer from (values (-1), (1), (null), (1234567890)) t(i)' -> #(-1 1 nil 1234567890).		'select array[1, 2, null, -1]::integer[]' -> #((1 2 nil -1)).		"'select array[''foo'', ''bar'', null, ''baz'']::text[]' -> #(('foo' 'bar' nil 'baz'))"		'select d::date from (values (''1234-12-30''), (null), (''2009-01-31'')) t(d)' -> { Date year: 1234 month: 12 day: 30. nil. Date year: 2009 month: 1 day: 31 }.			} do: [ :each |		| dataRows |		dataRows := (aPGConnection executeAndCheckResult: each key) dataRows.		self assert: (dataRows collect: [ :row | row at: 1 ]) asArray = each value ]	! !!PGConnection class methodsFor: 'converters' stamp: 'kb 1/31/2009 04:15'!timeConverter 	^[ :s | Time readFrom: (ReadStream on: s) ]! !!PGConnection class methodsFor: 'converters' stamp: 'kb 1/31/2009 04:19'!timeWithTimezoneConverter 	^[:s |		| list |		list := (s subStrings: ':') collect:[:i | i asInteger].		Time fromSeconds: ((list at: 1) * 3600) + ((list at: 2) * 60) + (list at: 3) ]! !!PGConnection class methodsFor: 'converters' stamp: 'SvenVanCaekenberghe 10/31/2011 13:34'!timestampConverter 	^[:s | self nextDateAndTimeFrom: s]! !!PGConnection class methodsFor: 'converters' stamp: 'SvenVanCaekenberghe 10/31/2011 13:33'!timestampWithTimezoneConverter	^[ :s | self nextDateAndTimeFrom: s]! !!PGConnection methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!addNotificationSubscriber: aNotificationSubscriber	^ self notificationSubscribers add: aNotificationSubscriber! !!PGConnection methodsFor: 'api' stamp: 'yj 4/24/2003 23:01'!cancelRequest	"Issue a cancel request. Open a new connection to the server and send a CancelRequest message."	self sendCancel.! !!PGConnection methodsFor: 'as yet unclassified' stamp: 'kb 11/28/2008 11:11'!clientEncoding: aSymbol	sqlStringConverter := [ :sqlString | 		sqlString convertToEncoding: aSymbol ].	receivingTextConverter := TextConverter newForEncoding: aSymbol.	#(25 1043) do: [ 	:each | 		self fieldConverters  at: each put: [ :s | 			s convertFromWithConverter: receivingTextConverter ] ].	! !!PGConnection methodsFor: 'private-actions' stamp: 'yj 4/24/2003 23:01'!closeSocket	self closeSocket: socket! !!PGConnection methodsFor: 'private-actions' stamp: 'yj 4/24/2003 23:01'!closeSocket: aSocket	trace >= 2		ifTrue: [ self log: 'closeSocket' text: 'hostname: ', connectionArgs hostname, ':', connectionArgs portno printString ].	trace >= 2		ifTrue: [ self log: 'closeSocket' text: 'socket: ', aSocket printString ].	aSocket closeAndDestroy.	trace >= 2		ifTrue: [ self log: 'closeSocket' text: 'socket: ', aSocket printString ].! !!PGConnection methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!connectionArgs	^connectionArgs! !!PGConnection methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!connectionArgs: aConnectionArgs	connectionArgs := aConnectionArgs! !!PGConnection methodsFor: 'api' stamp: 'yj 4/24/2003 23:01'!copy: copySql withStream: aStream	"The syntax of a COPY command is:	COPY [ BINARY ] table [ WITH OIDS ]		FROM { 'filename' | stdin }		[ [USING] DELIMITERS 'delimiter' ]		[ WITH NULL AS 'null string' ]	COPY [ BINARY ] table [ WITH OIDS ]		TO { 'filename' | stdout }		[ [USING] DELIMITERS 'delimiter' ]		[ WITH NULL AS 'null string' ]	The 'stdin' or 'stdout' option must be used, not the 'filename' option.	'aStream' will supply the COPY...FROM input.	'aStream' will received the COPY...TO output.	"	sql := copySql.	copyStream := aStream.	self queueEvent: #Query.	self saProcessEventsUntil: #(ReadyForQuery ConnectionFailed).	^ result! !!PGConnection methodsFor: 'private-actions' stamp: 'yj 4/24/2003 23:01'!copyInDataRows	"copyStream is initially positioned at the start of a data rows stream.	The contents are sent down the socket.	In a stream of data rows, each row is terminatated by a Byte1('\n').	A sequence of Byte1('\\'), Byte1('.'), Byte1('\n') is the last line.	"	trace >= 8		ifTrue: [ self log: 'copyInDataRows' text: copyStream contents printString ].	socket sendData: copyStream contents.	"socket sendData: (String with: $\ with: $. with: Character lf)."! !!PGConnection methodsFor: 'private-actions' stamp: 'yj 4/24/2003 23:01'!copyOutDataRows	| ch lf notDone pch ppch |	lf := Character lf.	notDone := true.	pch := $x.	ch := $x.	[notDone] whileTrue: [		ppch := pch.		pch := ch.		ch := self next.		copyStream nextPut: ch.		((ch = lf and: [pch = $.]) and: [ppch = $\])			ifTrue: [notDone := false].	].! !!PGConnection methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!copyStream	^copyStream! !!PGConnection methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!copyStream: aStream	copyStream := aStream! !!PGConnection methodsFor: 'api' stamp: 'kb 2/14/2009 20:32'!execute: sqlString	trace >= 2 ifTrue: [self log: 'execute' text: sqlString].	self isConnected ifFalse: [ self error: 'Connection not valid' ].	sql := sqlString convertToWithConverter: receivingTextConverter. "sqlStringConverter value: sqlString."	self queueEvent: #Query.	self saProcessEventsUntil: #(ReadyForQuery ConnectionFailed).	"There's an extra result set, so nuke it here."	result resultSets size > 0		ifTrue: [ result resultSets removeLast ].	^ result! !!PGConnection methodsFor: 'api' stamp: 'pf 11/28/2007 11:52'!execute: sqlString withRowBlock: aRowBlock	"Iterate thru resultset with block (for each row) without loading all bulk resultset data into memory (internal arrays). Implemented by database CURSORs.	Row block has 2 parameters: 		1) row description (PGRowDescription - column names, data types etc.)		2) row data (OrderedCollection)"	| cursorName rslt rowDesc rows |	cursorName := 'squeakTempCursor', Time now nanoSecond asString.	self executeAndCheckResult: 'BEGIN WORK'.	[ 	self executeAndCheckResult: 'DECLARE ', cursorName, ' CURSOR FOR ', sqlString asString.		[ 			[	rslt := self executeAndCheckResult: 'FETCH FORWARD 5000 FROM ', cursorName.				rowDesc := rslt resultSets first rowDescription.				rows := rslt resultSets first rows.				rows size > 0.			] whileTrue: [				rows do: [ :row | aRowBlock value: rowDesc value: row data ].								].								] ensure: [ self executeAndCheckResult: 'CLOSE ', cursorName ]	] ensure: [ self executeAndCheckResult: 'COMMIT WORK' ].	! !!PGConnection methodsFor: 'api' stamp: 'pf 11/28/2007 11:52'!executeAndCheckResult: sqlString	"Same as execute: but check responce - throw exception if error in responce" 	| res |	res := self execute: sqlString.	(res errorResponse isKindOf: PGErrorResponse) ifTrue: [ Error signal: res errorResponse value ].	^ res.! !!PGConnection methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!fieldConverterAt: typeOid	^ fieldConverters at: typeOid ifAbsent: [nil]! !!PGConnection methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!fieldConverterAt: typeOid put: converter	fieldConverters at: typeOid put: converter! !!PGConnection methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!fieldConverters	^ fieldConverters! !!PGConnection methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!fieldConverters: anObject	fieldConverters := anObject! !!PGConnection methodsFor: 'api' stamp: 'yj 4/24/2003 23:01'!functionCall: oid arguments: arguments	functionCallOid := oid.	functionCallArgs := arguments.	self queueEvent: #FunctionCall.	self saProcessEventsUntil: #(ReadyForQuery ConnectionFailed).	^ result! !!PGConnection methodsFor: 'initialize/release' stamp: 'noha 11/26/2007 16:23'!initialize	| readBufferSize |	super initialize.	trace := self class defaultTraceLevel.	readBufferSize := 8096.	readBuffer := String new: readBufferSize.	readIndex := readBufferSize + 1.	lastReadIndex := readBufferSize.	self fieldConverters: self class buildDefaultFieldConverters.	result := PGResult on: self.	sqlStringConverter := [:sqlString| sqlString].	"^ self"! !!PGConnection methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!isConnected	^ socket notNil and: [ socket isConnected]! !!PGConnection methodsFor: 'private-actions' stamp: 'kb 2/14/2009 20:26'!next	readIndex >= lastReadIndex 		ifTrue: 			[trace >= 10 				ifTrue: [self log: 'next' text: '**** filling read buffer ****'].			"(Delay forMilliseconds: 500) wait."			socket waitForData. "For: Socket standardTimeout."						[(lastReadIndex := socket receiveDataInto: readBuffer) = 0 				ifTrue: 					[trace >= 10 						ifTrue: [self log: 'next' text: '**** zero length received from socket ****'].					(Delay forMilliseconds: 100) wait].			lastReadIndex = 0] 					whileTrue.			readIndex := 0.			trace >= 10 				ifTrue: 					[self log: 'next' text: '**** read ' , lastReadIndex printString , ' ****']].	readIndex := readIndex + 1.	trace >= 10 		ifTrue: 			[self log: 'next'				text: 'readIndex=' , readIndex printString , ',lastReadIndex=' 						, lastReadIndex printString , ',ch=' 						, (readBuffer at: readIndex) printString].	^readBuffer at: readIndex! !!PGConnection methodsFor: 'private-actions' stamp: 'yj 4/24/2003 23:01'!nextEvent	| pkt noticeFlag |	[		pkt := self receivePacket.		(noticeFlag := #(NoticeResponse NotificationResponse) includes: pkt eventName)			ifTrue: [ self notifySubscribers: pkt ].		noticeFlag.	] whileTrue.	^ pkt! !!PGConnection methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!notificationSubscribers	notificationSubscribers isNil ifTrue: [ notificationSubscribers := OrderedCollection new ].	^ notificationSubscribers! !!PGConnection methodsFor: 'private-actions' stamp: 'yj 4/24/2003 23:01'!notifySubscribers: pkt	notificationSubscribers isNil		ifTrue: [ self logInfo: 'NOTIFICATION: ', pkt printString ]		ifFalse: [ notificationSubscribers do: [:each | each receive: pkt from: self ]].! !!PGConnection methodsFor: 'private-actions' stamp: 'yj 10/16/2003 10:58'!openSocket	| newSocket |	trace >= 2 		ifTrue: 			[self log: 'openSocket'				text: 'hostname: ' , connectionArgs hostname , ':' 						, connectionArgs portno printString].	Socket initializeNetwork.	newSocket := Socket newTCP.	newSocket 		connectTo: (NetNameResolver addressForName: connectionArgs hostname				timeout: 15)		port: connectionArgs portno.	newSocket waitForConnectionFor: Socket standardTimeout ifTimedOut: [newSocket := nil].	trace >= 2 		ifTrue: [self log: 'openSocket' text: 'socket: ' , newSocket printString].	^newSocket! !!PGConnection methodsFor: 'private-actions' stamp: 'yj 11/12/2004 18:27'!receivePacket	| typeCode packet |	typeCode := self next.	trace >= 5		ifTrue: [ self log: 'packet typeCode=' text: typeCode printString ].	packet := PGPacket newPacket: typeCode.	packet == nil		ifTrue: [packet := #UnknownPacket]		ifFalse: [packet receiveFrom: self ].	trace >= 5		ifTrue: [ self log: 'receivePacket' text: packet printString ].	^ packet! !!PGConnection methodsFor: 'private-actions' stamp: 'yj 4/24/2003 23:01'!resetResult	"Clear the result, a new query or function call will follow."	result		reset;		addResultSet.! !!PGConnection methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!result	^result! !!PGConnection methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!result: aResult	result := aResult! !!PGConnection methodsFor: 'private-actions' stamp: 'yj 4/24/2003 23:01'!sendCancel	| cancelRequestSocket |	trace >= 2		ifTrue: [ self log: 'sendCancel' text: 'processId=', processId printString ].	cancelRequestSocket := self openSocket.	self sendPacket: (PGCancelRequest processId: processId secretKey: secretKey) on: cancelRequestSocket.	self closeSocket: cancelRequestSocket.! !!PGConnection methodsFor: 'private-actions' stamp: 'yj 4/24/2003 23:01'!sendPacket: aPacket on: aSocket	| s |	s := WriteStream on: String new.	aPacket writeOn: s.	trace >= 5		ifTrue: [			self log: 'sendPacket' text: aPacket printString.			trace >= 10 ifTrue: [self log: 'sendPacket' text: s contents printString].		].	aSocket sendData: s contents.! !!PGConnection methodsFor: 'private-actions' stamp: 'yj 4/24/2003 23:01'!sendStartup	self sendPacket: (PGStartupPacket databaseName: connectionArgs databaseName userName: connectionArgs userName) on: socket.! !!PGConnection methodsFor: 'private-actions' stamp: 'yj 4/24/2003 23:01'!sendTerminate	self sendPacket: PGTerminate new on: socket.! !!PGConnection methodsFor: 'private-states' stamp: 'yj 4/24/2003 23:01'!stAuthenticationOk: event	"Do nothing"! !!PGConnection methodsFor: 'private-states' stamp: 'yj 4/24/2003 23:01'!stCantHappen: event	"Try to send the terminate packet, then close the socket"	self isConnected ifTrue: [ self sendTerminate ].	socket isNil ifFalse: [ self closeSocket ].	super stCantHappen: event.! !!PGConnection methodsFor: 'private-states' stamp: 'yj 4/24/2003 23:01'!stConnectionFailed: event	"Do nothing"! !!PGConnection methodsFor: 'private-states' stamp: 'yj 4/24/2003 23:01'!stErrorResponse: event	result errorResponse: event.! !!PGConnection methodsFor: 'private-states' stamp: 'yj 4/24/2003 23:01'!stFunctionCall: event	self resetResult.	self sendPacket: (PGFunctionCall oid: functionCallOid arguments: functionCallArgs) on: socket.! !!PGConnection methodsFor: 'private-states' stamp: 'yj 4/24/2003 23:01'!stGotBackendKeyData: backendKeyData	"event is a BackendKeyData packet."	processId := backendKeyData processId.	secretKey := backendKeyData secretKey.! !!PGConnection methodsFor: 'private-states' stamp: 'yj 4/24/2003 23:01'!stGotCompleted: event	result completedResponse: event.	"This causes an extra result set to be added.	But a result set has to be available at this point,	given the current state machine.	"	result addResultSet.! !!PGConnection methodsFor: 'private-states' stamp: 'yj 4/24/2003 23:01'!stGotCopyIn: event	self copyInDataRows.! !!PGConnection methodsFor: 'private-states' stamp: 'yj 4/24/2003 23:01'!stGotCopyOut: event	self copyOutDataRows.! !!PGConnection methodsFor: 'private-states' stamp: 'yj 4/24/2003 23:01'!stGotCursor: event	"Do nothing"! !!PGConnection methodsFor: 'private-states' stamp: 'yj 4/24/2003 23:01'!stGotFunctionResult: event	result functionResult: event.! !!PGConnection methodsFor: 'private-states' stamp: 'yj 4/24/2003 23:01'!stGotRow: event	result rows add: event.! !!PGConnection methodsFor: 'private-states' stamp: 'yj 4/24/2003 23:01'!stGotRowDescription: event	result rowDescription: event.! !!PGConnection methodsFor: 'private-states' stamp: 'TudorGirba 3/2/2014 17:42'!stQuerying: event	self resetResult.	self sendPacket: (PGQuery sql: sql) on: socket.! !!PGConnection methodsFor: 'private-states' stamp: 'yj 4/24/2003 23:01'!stReadyForQuery: event	"Do nothing"! !!PGConnection methodsFor: 'private-states' stamp: 'yj 4/24/2003 23:01'!stSendingCleartextPassword: event	self sendPacket: (PGPasswordPacket password: connectionArgs password) on: socket.! !!PGConnection methodsFor: 'private-states' stamp: 'yj 1/31/2006 18:57'!stSendingMD5Password: event 	"MD5 authentication as explain in http://archives.postgresql.org/pgsql-novice/2003-05/msg00305.php"	| hashedCredentials hashedMessage |	hashedCredentials := (MD5 hashMessage: (connectionArgs password, connectionArgs userName)) hex asLowercase.	hashedMessage := 'md5', (MD5 hashMessage: (hashedCredentials, event salt asString)) hex asLowercase.	self	sendPacket: (PGPasswordPacket password: hashedMessage) on: socket.! !!PGConnection methodsFor: 'private-states' stamp: 'yj 4/24/2003 23:01'!stStartup: event	self resetResult.	socket := self openSocket.	socket isNil		ifTrue: [ self generateEvent: #ConnectionFailed to: self ]		ifFalse: [ self sendStartup ].! !!PGConnection methodsFor: 'private-states' stamp: 'yj 4/24/2003 23:01'!stTerminalError: event	result errorResponse: event.	self closeSocket: socket.	socket := nil.! !!PGConnection methodsFor: 'private-states' stamp: 'yj 4/24/2003 23:01'!stTerminated: event	self sendTerminate.	self closeSocket: socket.	socket := nil.! !!PGConnection methodsFor: 'private-states' stamp: 'yj 1/31/2006 22:52'!stUnsupportedAuthentication: event	"result errorResponse: 'Unsupported authentication method: ', event eventName."	PGUnsupportedAuthentication signal: 'Unsupported authentication method: ', event eventName.! !!PGConnection methodsFor: 'api' stamp: 'noha 12/7/2007 15:12'!startup	self connectionArgs isNil ifTrue: [		self connectionArgs: self class defaultConnectionArgs.	].	self connectionArgs clientEncoding ifNotNil: [		self clientEncoding: self connectionArgs clientEncoding.	] ifNil: [		self clientEncoding: #utf8	].	self queueEvent: #Startup.	self saProcessEventsUntil: #(ReadyForQuery ConnectionFailed TerminalError UnsupportedAuthentication).	^ result! !!PGConnection methodsFor: 'api' stamp: 'yj 4/24/2003 23:01'!terminate	self queueEvent: #Terminate.	self saProcessEventsUntil: #(Terminated ConnectionFailed).! !!PGNotificationSubscriber methodsFor: 'api' stamp: 'yj 4/24/2003 23:01'!receive: notice from: aConnection	self logInfo: notice printString, ' received from ', aConnection logIdString.! !!PGConnectionArgs class methodsFor: 'instance creation' stamp: 'yj 11/28/2005 17:30'!hostname: host portno: port databaseName: database userName: user password: pwd	^(self new)		hostname: host;		portno: port;		databaseName: database;		userName: user;		password: pwd;		yourself! !!PGConnectionArgs class methodsFor: 'instance creation' stamp: 'yj 11/28/2005 17:30'!hostname: host portno: port databaseName: database userName: user password: pwd extraArgs: extra debugTty: debug	^(self new)		hostname: host;		portno: port;		databaseName: database;		userName: user;		password: pwd;		extraArgs: extra;		debugTty: debug;		yourself! !!PGConnectionArgs methodsFor: 'as yet unclassified' stamp: 'noha 11/26/2007 16:08'!clientEncoding	^ clientEncoding! !!PGConnectionArgs methodsFor: 'as yet unclassified' stamp: 'noha 11/26/2007 16:08'!clientEncoding: aSymbol	clientEncoding := aSymbol! !!PGConnectionArgs methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!databaseName	^databaseName! !!PGConnectionArgs methodsFor: 'accessing' stamp: 'yj 11/28/2005 17:28'!databaseName: anObject	databaseName := anObject! !!PGConnectionArgs methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!debugTty	^debugTty! !!PGConnectionArgs methodsFor: 'accessing' stamp: 'yj 11/28/2005 17:28'!debugTty: anObject	debugTty := anObject! !!PGConnectionArgs methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!extraArgs	^extraArgs! !!PGConnectionArgs methodsFor: 'accessing' stamp: 'yj 11/28/2005 17:28'!extraArgs: anObject	extraArgs := anObject! !!PGConnectionArgs methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!hostname	^hostname! !!PGConnectionArgs methodsFor: 'accessing' stamp: 'yj 11/28/2005 17:28'!hostname: anObject	hostname := anObject! !!PGConnectionArgs methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!password	^password! !!PGConnectionArgs methodsFor: 'accessing' stamp: 'yj 11/28/2005 17:28'!password: anObject	password := anObject! !!PGConnectionArgs methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!portno	^portno! !!PGConnectionArgs methodsFor: 'accessing' stamp: 'yj 11/28/2005 17:28'!portno: anObject	portno := anObject! !!PGConnectionArgs methodsFor: 'private-initialize' stamp: 'yj 4/24/2003 23:01'!setHostname: host portno: port databaseName: database userName: user password: pwd extraArgs: extra debugTty: debug	hostname := host.	portno := port.	databaseName := database.	userName := user.	password := pwd.	extraArgs := extra.	debugTty := debug.	^self! !!PGConnectionArgs methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!userName	^userName! !!PGConnectionArgs methodsFor: 'accessing' stamp: 'yj 11/28/2005 17:28'!userName: anObject	userName := anObject! !!PGDataRow class methodsFor: 'as yet unclassified' stamp: 'kb 10/30/2008 16:42'!for: aDictionary	^(self new: aDictionary size)		dictionary: aDictionary;		yourself! !!PGDataRow methodsFor: 'as yet unclassified' stamp: 'kb 10/30/2008 17:03'!atName: aSymbol	^self at: (dictionary at: aSymbol)! !!PGDataRow methodsFor: 'as yet unclassified' stamp: 'kb 10/30/2008 17:11'!atName: aSymbol ifAbsent: aBlock	^self at: (dictionary 		at: aSymbol		ifAbsent: [ ^aBlock value ])! !!PGDataRow methodsFor: 'accessing' stamp: 'kb 3/12/2009 17:32'!dictionary		^dictionary! !!PGDataRow methodsFor: 'as yet unclassified' stamp: 'kb 10/30/2008 16:39'!dictionary: anIdentityDictionary	dictionary := anIdentityDictionary ! !!PGDataRow methodsFor: 'as yet unclassified' stamp: 'kb 10/30/2008 16:54'!doesNotUnderstand: aMessage	^self at: (		dictionary 			at: aMessage selector			ifAbsent: [ ^super doesNotUnderstand: aMessage ])! !!PGDataRow methodsFor: 'as yet unclassified' stamp: 'kb 11/28/2008 12:22'!indexOf: aSymbol	^dictionary at: aSymbol ifAbsent: 0! !!PGDataRow methodsFor: 'as yet unclassified' stamp: 'kb 10/30/2008 17:03'!name	^self atName: #name! !!PGDataRow methodsFor: 'as yet unclassified' stamp: 'kb 11/8/2008 12:55'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	(dictionary associations		sort: [ :a :b | a value < b value ])		do: [ :assoc |			aStream 				nextPutAll: assoc key;				nextPutAll: ': ';				print: (self at: assoc value) ]		separatedBy: [ aStream nextPutAll: ', ' ].	aStream nextPut: $)! !!PGAbstractStringResponse methodsFor: 'printing' stamp: 'yj 4/24/2003 23:01'!printOn: aStream	super printOn: aStream.	aStream		nextPutAll: '(';		nextPutAll: 'value='; nextPutAll: value printString;		nextPutAll: ')'! !!PGAbstractStringResponse methodsFor: 'receiving' stamp: 'yj 4/24/2003 23:01'!receiveFrom: aStream	value := self readStringFrom: aStream.! !!PGAbstractStringResponse methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!value	^value! !!PGCompletedResponse methodsFor: 'printing' stamp: 'yj 4/24/2003 23:01'!displayOn: aStream	aStream nextPutAll: value.! !!PGCompletedResponse methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!eventName	^#CompletedResponse! !!PGCursorResponse methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!eventName	^#CursorResponse! !!PGEmptyQueryResponse methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!eventName	^#EmptyQueryResponse! !!PGErrorResponse methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!eventName	^#ErrorResponse! !!PGNoticeResponse methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!eventName	^#NoticeResponse! !!PGAsciiRow class methodsFor: 'instance creation' stamp: 'yj 4/24/2003 23:01'!description: aRowDescription	^self new		description: aRowDescription;		yourself.! !!PGAsciiRow class methodsFor: 'instance creation' stamp: 'yj 4/24/2003 23:01'!new	^self basicNew initialize.! !!PGAsciiRow methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!data	| converters converter data |	converters := description resultSet result connection fieldConverters.	data := OrderedCollection new.	rawData with: description columnDescriptions do: [:each :aColumnDescription |		data addLast: (			each isNil				ifTrue: [nil]				ifFalse: [					converter := converters at: aColumnDescription typeOid ifAbsent: [nil].					converter isNil ifTrue: [ each ] ifFalse: [ converter value: each ].				]).	].	^data! !!PGAsciiRow methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!dataKeyedByFieldName	| d |	d := Dictionary new.	self data with: description columnDescriptions do: [:each :aColumnDescription |		d at: aColumnDescription fieldName put: each.	].	^ d! !!PGAsciiRow methodsFor: 'accessing' stamp: 'kb 10/30/2008 16:46'!dataRow	| converters converter data dictionary index |	converters := description resultSet result connection fieldConverters.	dictionary := description columnDescriptionDictionary.	data := PGDataRow for: dictionary.	index := 0.	rawData with: description columnDescriptions do: [ :each :aColumnDescription |		data			at: (index := index + 1)			put: (				each ifNotNil: [					(converter := converters at: aColumnDescription typeOid ifAbsent: nil)						ifNil: [ each ]						ifNotNil: [ converter reentrant value: each ] ]) ].	^data! !!PGAsciiRow methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!description: aRowDescription	description := aRowDescription.! !!PGAsciiRow methodsFor: 'printing' stamp: 'yj 4/24/2003 23:01'!displayOn: aStream	rawData withIndexDo: [:each :i |		aStream nextPutAll: (each == nil ifTrue: ['0'] ifFalse: [each]).		i < rawData size ifTrue: [aStream space].	].! !!PGAsciiRow methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!eventName	^#AsciiRow! !!PGAsciiRow methodsFor: 'initialize' stamp: 'yj 4/24/2003 23:01'!initialize	rawData := OrderedCollection new.	^self! !!PGAsciiRow methodsFor: 'printing' stamp: 'yj 4/24/2003 23:01'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: '('.	rawData do: [:each | each printOn: aStream. aStream nextPut: $,].	aStream nextPutAll: ')'.! !!PGAsciiRow methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!rawData	^ rawData! !!PGAsciiRow methodsFor: 'receiving' stamp: 'yj 4/24/2003 23:01'!receiveFrom: connection	| ncol |	description := connection result rowDescription.	ncol := description numberOfColumns.	nullFields := self readBitmap: ncol from: connection.	0 to: ncol - 1 do: [:i |		((nullFields at: (i // 8) + 1) bitAnd: (2r10000000 bitShift: (i \\ 8) negated)) > 0			ifTrue: [rawData add: (self readFieldFrom: connection)]			ifFalse: [rawData add: nil].	].! !!PGBinaryRow methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!eventName	^#BinaryRow! !!PGAuthentication methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!eventName	type > 6 ifTrue: [self error: 'Unknown authentication type'].	^#(		AuthenticationOk		AuthenticationKerberosV4		AuthenticationKerberosV5		AuthenticationCleartextPassword		AuthenticationCryptPassword		AuthenticationMD5Password		AuthenticationSCMCredential	) at: (type + 1)! !!PGAuthentication methodsFor: 'printing' stamp: 'yj 4/24/2003 23:01'!printOn: aStream	super printOn: aStream.	aStream		nextPutAll: '(';		nextPutAll: 'type='; nextPutAll: type printString;		nextPutAll: ',salt='; nextPutAll: salt printString;		nextPutAll: ')'! !!PGAuthentication methodsFor: 'receiving' stamp: 'yj 1/31/2006 22:27'!receiveFrom: connection	type := self readInt32From: connection.	"AuthenticationCryptPassword"	type == 4 ifTrue: [ salt := self readByteN: 2 from: connection ].	"AuthenticationMD5Password"	type == 5 ifTrue: [ salt := self readByteN: 4 from: connection ].	"	For documentation purposes here are the other authentication methods.	There is no other packet data to read in these cases.	type == 1 AuthenticationKerberosV4	type == 2 AuthenticationKerberosV5	type == 3 AuthenticationCleartextPassword	type == 6 AuthenticationSCMCredential	"! !!PGAuthentication methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!salt	^salt! !!PGAuthentication methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!salt: anInteger	salt := anInteger! !!PGAuthentication methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!type	^type! !!PGAuthentication methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!type: anInteger	type := anInteger! !!PGBackendKeyData methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!eventName	^#BackendKeyData! !!PGBackendKeyData methodsFor: 'printing' stamp: 'yj 4/24/2003 23:01'!printOn: aStream	super printOn: aStream.	aStream		nextPutAll: '(';		nextPutAll: 'processId='; nextPutAll: processId printString;		nextPutAll: ',secretKey='; nextPutAll: secretKey printString;		nextPutAll: ')'! !!PGBackendKeyData methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!processId	^processId! !!PGBackendKeyData methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!processId: anInteger	processId := anInteger! !!PGBackendKeyData methodsFor: 'receiving' stamp: 'yj 4/24/2003 23:01'!receiveFrom: aStream	processId := self readInt32From: aStream.	secretKey := self readInt32From: aStream.! !!PGBackendKeyData methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!secretKey	^secretKey! !!PGBackendKeyData methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!secretKey: anInteger	secretKey := anInteger! !!PGCancelRequest class methodsFor: 'instance creation' stamp: 'yj 4/24/2003 23:01'!processId: pid secretKey: secretKey	^self new		processId: pid;		secretKey: secretKey;		yourself.! !!PGCancelRequest methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!eventName	^#CancelRequest! !!PGCancelRequest methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!processId	^processId! !!PGCancelRequest methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!processId: anInteger	processId := anInteger! !!PGCancelRequest methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!secretKey	^secretKey! !!PGCancelRequest methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!secretKey: anInteger	secretKey := anInteger! !!PGCancelRequest methodsFor: 'sending' stamp: 'yj 4/24/2003 23:01'!writeOn: aStream	"Write a cancel request on the stream."	"80877102 - The cancel request code.	The value is chosen to contain 1234 in the most significant 16 bits,	and 5678 in the least 16 significant bits. (To avoid confusion,	this code must not be the same as any protocol version number.)	"	self writeInt32: 16 on: aStream.	self writeInt32: 80877102 on: aStream. "major=1234, minor=5678"	self writeInt32: self processId on: aStream.	self writeInt32: self secretKey on: aStream.! !!PGColumnDescription methodsFor: 'printing' stamp: 'yj 4/24/2003 23:01'!displayOn: aStream	aStream nextPutAll: fieldName.! !!PGColumnDescription methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!eventName	^#ColumnDescription! !!PGColumnDescription methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!fieldName	^ fieldName! !!PGColumnDescription methodsFor: 'printing' stamp: 'yj 4/24/2003 23:01'!printOn: aStream	super printOn: aStream.	aStream		nextPutAll: '(';		nextPutAll: 'fieldName='; nextPutAll: fieldName printString;		nextPutAll: ',typeOid='; nextPutAll: typeOid printString;		nextPutAll: ',typeSize='; nextPutAll: typeSize printString;		nextPutAll: ',typeModifier='; nextPutAll: typeModifier printString;		nextPutAll: ')'! !!PGColumnDescription methodsFor: 'receiving' stamp: 'yj 4/24/2003 23:01'!receiveFrom: connection	fieldName := self readStringFrom: connection.	typeOid := self readInt32From: connection.	typeSize := self readInt16From: connection.	typeModifier := self readInt32From: connection.! !!PGColumnDescription methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!typeModifier	^ typeModifier! !!PGColumnDescription methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!typeOid	^ typeOid! !!PGColumnDescription methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!typeSize	^ typeSize! !!PGCopyInResponse methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!eventName	^#CopyInResponse! !!PGCopyOutResponse methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!eventName	^#CopyOutResponse! !!PGFunctionCall class methodsFor: 'instance creation' stamp: 'yj 4/24/2003 23:01'!oid: anInteger arguments: aCollection	"Return a new instance of the receiver.	'anInteger' specifies the object ID of the function to call. The object ID is a site specific PostgreSQL value.	'aCollection' contains the arguments of the function call. It should contain String values, which may have non-printable characters (i.e. values 0..255).	"	^ self new setOid: anInteger arguments: aCollection! !!PGFunctionCall methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!arguments	^arguments! !!PGFunctionCall methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!arguments: value	arguments := value! !!PGFunctionCall methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!oid	^oid! !!PGFunctionCall methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!oid: value	oid := value! !!PGFunctionCall methodsFor: 'printing' stamp: 'yj 4/24/2003 23:01'!printOn: aStream	super printOn: aStream.	aStream		nextPutAll: '(';		nextPutAll: 'oid='; nextPutAll: oid printString;		nextPutAll: ',arguments='; nextPutAll: arguments printString;		nextPutAll: ')'! !!PGFunctionCall methodsFor: 'private-initialize' stamp: 'yj 4/24/2003 23:01'!setOid: anInteger arguments: anArray	oid := anInteger.	arguments := anArray! !!PGFunctionCall methodsFor: 'printing' stamp: 'yj 11/12/2004 18:18'!writeOn: aStream	self writeByte: $F on: aStream.	self writeString: '' on: aStream.	self writeInt32: self oid on: aStream.	self writeInt32: self arguments size on: aStream.	self arguments do: [:arg |		self writeInt32: arg size on: aStream.		arg do: [:b | self writeByte: (Character value: b) on: aStream].	]! !!PGFunctionResultResponse methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!eventName	^#FunctionResultResponse! !!PGFunctionResultResponse methodsFor: 'printing' stamp: 'yj 4/24/2003 23:01'!printOn: aStream	super printOn: aStream.	aStream		nextPutAll: '(';		nextPutAll: 'result='; nextPutAll: result printString;		nextPutAll: ')'! !!PGFunctionResultResponse methodsFor: 'receiving' stamp: 'yj 4/24/2003 23:01'!receiveFrom: connection	| emptyFlag resultSize |	emptyFlag := connection next codePoint.	emptyFlag == 71  "$G codePoint == 71 indicates non-void response"		ifTrue: [			resultSize := self readInt32From: connection.			result := ByteArray new: resultSize.			1 to: resultSize do: [:i | result at: i put: connection next codePoint].			connection next. "toss the extra 0 byte"	].! !!PGFunctionResultResponse methodsFor: 'accessing' stamp: 'yj 11/10/2004 23:07'!result	^result! !!PGNotificationResponse methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!conditionName	"Answer the value of conditionName"	^ conditionName! !!PGNotificationResponse methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!conditionName: anObject	"Set the value of conditionName"	conditionName := anObject! !!PGNotificationResponse methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!eventName	^#NotificationResponse! !!PGNotificationResponse methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!processId	"Answer the value of processId"	^ processId! !!PGNotificationResponse methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!processId: anObject	"Set the value of processId"	processId := anObject! !!PGNotificationResponse methodsFor: 'receiving' stamp: 'yj 4/24/2003 23:01'!receiveFrom: connection	processId := self readInt32From: connection.	conditionName := self readStringFrom: connection.! !!PGPacket class methodsFor: 'initialize-release' stamp: 'yj 11/12/2004 18:04'!initialize	"PGPacket initialize"	PacketClasses := IdentityDictionary new		at: $K put: PGBackendKeyData;		at: $R put: PGAuthentication;		at: $C put: PGCompletedResponse;		at: $G put: PGCopyInResponse;		at: $H put: PGCopyOutResponse;		at: $P put: PGCursorResponse;		at: $I put: PGEmptyQueryResponse;		at: $E put: PGErrorResponse;		at: $V put: PGFunctionResultResponse;		at: $N put: PGNoticeResponse;		at: $A put: PGNotificationResponse;		at: $Z put: PGReadyForQuery;		at: $T put: PGRowDescription;		at: $D put: PGAsciiRow;		at: $B put: PGBinaryRow;		yourself! !!PGPacket class methodsFor: 'factory' stamp: 'yj 11/12/2004 18:12'!newPacket: typeCode	| packetClass |	packetClass := PacketClasses at: typeCode ifAbsent: [nil].	^packetClass isNil		ifTrue: [nil]		ifFalse: [packetClass new]! !!PGPacket methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!eventName	^self subclassResponsibility! !!PGPacket methodsFor: 'printing' stamp: 'yj 4/24/2003 23:01'!printOn: aStream	aStream nextPutAll: self class name.! !!PGPacket methodsFor: 'receiving' stamp: 'yj 4/24/2003 23:01'!readBitmap: nbits from: connection	| nbytes bitmap |	nbytes := (nbits + 7) // 8.	bitmap := ByteArray new: nbytes.	1 to: nbytes do: [:i |		bitmap at: i put: connection next codePoint.	].	^bitmap! !!PGPacket methodsFor: 'receiving' stamp: 'yj 1/31/2006 18:15'!readByteN: n from: connection	| bytes |	bytes := ByteArray new: n.	1 to: n do: [:i | bytes byteAt: i put: connection next codePoint].	^bytes! !!PGPacket methodsFor: 'receiving' stamp: 'yj 4/24/2003 23:01'!readFieldFrom: connection	| n tmp |	n := (self readInt32From: connection) - 4.	tmp := WriteStream on: String new.	1 to: n do: [:i |		tmp nextPut: connection next.	].	^tmp contents! !!PGPacket methodsFor: 'receiving' stamp: 'yj 4/24/2003 23:01'!readInt16From: connection	| value |	value := connection next codePoint.	value := (value bitShift: 8) bitOr: connection next codePoint.	^value! !!PGPacket methodsFor: 'receiving' stamp: 'yj 4/24/2003 23:01'!readInt32From: connection	| value |	value := connection next codePoint.	value := (value bitShift: 8) bitOr: connection next codePoint.	value := (value bitShift: 8) bitOr: connection next codePoint.	value := (value bitShift: 8) bitOr: connection next codePoint.	^value! !!PGPacket methodsFor: 'receiving' stamp: 'yj 4/24/2003 23:01'!readStringFrom: connection	| tmp ch |	tmp := WriteStream on: String new.	[ (ch := connection next) codePoint ~= 0 ] whileTrue: [		tmp nextPut: ch.	].	^tmp contents! !!PGPacket methodsFor: 'receiving' stamp: 'yj 4/24/2003 23:01'!receiveFrom: connection	"Read nothing, by default"! !!PGPacket methodsFor: 'sending' stamp: 'yj 4/24/2003 23:01'!writeByte: aCharacter on: aStream	aStream		nextPut: aCharacter;		yourself.! !!PGPacket methodsFor: 'sending' stamp: 'yj 4/24/2003 23:01'!writeInt16: anInteger on: aStream	aStream		nextPut: (Character value: ((anInteger bitShift: -1*8) bitAnd: 16rFF));		nextPut: (Character value: ((anInteger bitShift: 0*8) bitAnd: 16rFF));		yourself.! !!PGPacket methodsFor: 'sending' stamp: 'yj 4/24/2003 23:01'!writeInt32: anInteger on: aStream	aStream		nextPut: (Character value: ((anInteger bitShift: -3*8) bitAnd: 16rFF));		nextPut: (Character value: ((anInteger bitShift: -2*8) bitAnd: 16rFF));		nextPut: (Character value: ((anInteger bitShift: -1*8) bitAnd: 16rFF));		nextPut: (Character value: ((anInteger bitShift: 0*8) bitAnd: 16rFF));		yourself.! !!PGPacket methodsFor: 'sending' stamp: 'yj 4/24/2003 23:01'!writeLimString: aString size: size on: aStream	aString isNil ifTrue: [		size timesRepeat: [ aStream nextPut: (Character value: 0) ].		^aStream.	].	aString size < size		ifTrue: [			aStream nextPutAll: aString.			(size - aString size max: 0) timesRepeat: [ aStream nextPut: (Character value: 0) ].		]		ifFalse: [			aStream nextPutAll: (aString copyFrom: 1 to: size).		].	^aStream.! !!PGPacket methodsFor: 'sending' stamp: 'yj 4/24/2003 23:01'!writeOn: aStream	self subclassResponsiblity! !!PGPacket methodsFor: 'sending' stamp: 'yj 4/24/2003 23:01'!writeString: aString on: aStream	aStream		nextPutAll: aString;		nextPut: (Character value: 0);		yourself.! !!PGPasswordPacket class methodsFor: 'instance creation' stamp: 'yj 4/24/2003 23:01'!password: aString	^self new		password: aString;		yourself.! !!PGPasswordPacket methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!password	^password! !!PGPasswordPacket methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!password: aString	password := aString! !!PGPasswordPacket methodsFor: 'printing' stamp: 'yj 4/24/2003 23:01'!printOn: aStream	super printOn: aStream.	aStream		nextPutAll: '(';		nextPutAll: 'password='; nextPutAll: password printString;		nextPutAll: ')'! !!PGPasswordPacket methodsFor: 'sending' stamp: 'yj 4/24/2003 23:01'!writeOn: aStream	"Add 5 for the 32bit size header, and add 1 for the '\0' after the string"	self writeInt32: self password size + 5 on: aStream.	self writeString: self password on: aStream.! !!PGQuery class methodsFor: 'instance creation' stamp: 'yj 4/24/2003 23:01'!sql: aString	^self new		queryString: aString;		yourself.! !!PGQuery methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!eventName	^#Query! !!PGQuery methodsFor: 'printing' stamp: 'yj 4/24/2003 23:01'!printOn: aStream	super printOn: aStream.	aStream		nextPutAll: '(';		nextPutAll: 'queryString='; nextPutAll: queryString printString;		nextPutAll: ')'! !!PGQuery methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!queryString	^queryString! !!PGQuery methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!queryString: aString	queryString := aString! !!PGQuery methodsFor: 'sending' stamp: 'yj 4/24/2003 23:01'!writeOn: aStream	self writeByte: $Q on: aStream.	self writeString: self queryString on: aStream.! !!PGReadyForQuery methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!eventName	^#ReadyForQuery! !!PGRowDescription class methodsFor: 'instance creation' stamp: 'yj 4/24/2003 23:01'!new	^self basicNew initialize.! !!PGRowDescription methodsFor: 'as yet unclassified' stamp: 'kb 10/30/2008 16:39'!columnDescriptionDictionary	^columnDescriptionDictionary ifNil: [		columnDescriptionDictionary := IdentityDictionary new.		columnDescriptions doWithIndex: [ :each :i |			columnDescriptionDictionary at: each fieldName asSymbol put: i ].		columnDescriptionDictionary ]! !!PGRowDescription methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!columnDescriptions	^ columnDescriptions! !!PGRowDescription methodsFor: 'printing' stamp: 'yj 4/24/2003 23:01'!displayOn: aStream	columnDescriptions withIndexDo: [:each :i |		each displayOn: aStream.		i < columnDescriptions size ifTrue: [aStream space].	].! !!PGRowDescription methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!eventName	^#RowDescription! !!PGRowDescription methodsFor: 'initialize' stamp: 'yj 4/24/2003 23:01'!initialize	numberOfColumns := 0.	columnDescriptions := OrderedCollection new.! !!PGRowDescription methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!numberOfColumns	^numberOfColumns! !!PGRowDescription methodsFor: 'printing' stamp: 'yj 4/24/2003 23:01'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: '('; cr.	columnDescriptions do: [:each | each printOn: aStream. aStream cr].	aStream nextPutAll: ')'.! !!PGRowDescription methodsFor: 'receiving' stamp: 'EstebanMaringolo 9/4/2014 15:16'!receiveFrom: connection	numberOfColumns := self readInt16From: connection.	1 to: numberOfColumns do: [:i |		columnDescriptions add: (PGColumnDescription new receiveFrom: connection; yourself).	].! !!PGRowDescription methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!resultSet	^ resultSet! !!PGRowDescription methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!resultSet: anObject	resultSet := anObject! !!PGStartupPacket class methodsFor: 'instance creation' stamp: 'yj 4/24/2003 23:01'!databaseName: database userName: user	^self new		setDatabaseName: database userName: user;		yourself! !!PGStartupPacket methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!byteCount	^296! !!PGStartupPacket methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!databaseName	^databaseName! !!PGStartupPacket methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!databaseName: aString	databaseName := aString! !!PGStartupPacket methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!debugTty	^debugTty! !!PGStartupPacket methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!debugTty: aString	debugTty := aString! !!PGStartupPacket methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!extraArgs	^extraArgs! !!PGStartupPacket methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!extraArgs: aString	extraArgs := aString! !!PGStartupPacket methodsFor: 'printing' stamp: 'yj 4/24/2003 23:01'!printOn: aStream	super printOn: aStream.	aStream		nextPutAll: '(';		nextPutAll: 'databaseName='; nextPutAll: databaseName printString;		nextPutAll: ',userName='; nextPutAll: userName printString;		nextPutAll: ',extraArgs='; nextPutAll: extraArgs printString;		nextPutAll: ',debugTty='; nextPutAll: debugTty printString;		nextPutAll: ',version='; nextPutAll: version printString;		nextPutAll: ')'! !!PGStartupPacket methodsFor: 'private-initialize' stamp: 'yj 4/24/2003 23:01'!setDatabaseName: database userName: user	^self		version: (2 bitShift: 16); "major=2 minor=0"		databaseName: database;		userName: user;		yourself! !!PGStartupPacket methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!userName	^userName! !!PGStartupPacket methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!userName: aString	userName := aString! !!PGStartupPacket methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!version	^version! !!PGStartupPacket methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!version: anInteger	version := anInteger! !!PGStartupPacket methodsFor: 'sending' stamp: 'yj 4/24/2003 23:01'!writeOn: aStream	self writeInt32: self byteCount on: aStream.	self writeInt32: self version on: aStream.	self writeLimString: self databaseName size: 64 on: aStream.	self writeLimString: self userName size: 32 on: aStream.	self writeLimString: self extraArgs size: 64 on: aStream.	self writeLimString: nil size: 64 on: aStream. "unused"	self writeLimString: self debugTty size: 64 on: aStream.! !!PGTerminate methodsFor: 'sending' stamp: 'yj 4/24/2003 23:01'!writeOn: aStream	self writeByte: $X on: aStream.! !!PGResult class methodsFor: 'instance creation' stamp: 'yj 4/24/2003 23:01'!new	^ self error: 'should not use'! !!PGResult class methodsFor: 'instance creation' stamp: 'yj 4/24/2003 23:01'!on: aConnection	^ self basicNew initialize		connection: aConnection;		yourself.! !!PGResult methodsFor: 'accessing-convenience' stamp: 'yj 4/24/2003 23:01'!addResultSet	resultSets add: (PGResultSet on: self).! !!PGResult methodsFor: 'accessing-convenience' stamp: 'yj 4/24/2003 23:01'!completedResponse	^ self lastResultSet completedResponse! !!PGResult methodsFor: 'accessing-convenience' stamp: 'yj 4/24/2003 23:01'!completedResponse: value	self lastResultSet completedResponse: value! !!PGResult methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!connection	^ connection! !!PGResult methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!connection: value	connection := value! !!PGResult methodsFor: 'accessing-convenience' stamp: 'kb 2/25/2009 20:05'!dataRows	^ self lastResultSet ifNotNilDo: [ :rs |		rs dataRows ]! !!PGResult methodsFor: 'printing' stamp: 'yj 4/24/2003 23:01'!displayResultOn: aStream	errorResponse isNil ifFalse: [		aStream nextPutAll: errorResponse value.		aStream cr].	resultSets do: [:each | each displayResultSetOn: aStream].! !!PGResult methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!errorResponse	^ errorResponse! !!PGResult methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!errorResponse: value	errorResponse := value! !!PGResult methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!functionResult	^ functionResult! !!PGResult methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!functionResult: value	functionResult := value! !!PGResult methodsFor: 'initialize' stamp: 'yj 4/24/2003 23:01'!initialize	resultSets := OrderedCollection new.! !!PGResult methodsFor: 'accessing-convenience' stamp: 'kb 2/25/2009 20:06'!lastResultSet	^resultSets		ifEmpty: [ nil ]		ifNotEmpty: [ resultSets last ]! !!PGResult methodsFor: 'initialize' stamp: 'yj 4/24/2003 23:01'!reset	"Clear the previous results in preparation to hold new query results."	"There's an opportunity to tweak the code here for performance.	If the result sets are cleared each time, then there's a lot of	re-allocation. But, if the old results are just cleared, an earlier	large result set may cause a large collection to remain in memory.	Maybe it's just better to let GC handle it.	"	self errorResponse: nil.	self functionResult: nil.	resultSets := OrderedCollection new.! !!PGResult methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!resultSets	^ resultSets! !!PGResult methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!resultSets: value	resultSets := value! !!PGResult methodsFor: 'accessing-convenience' stamp: 'yj 4/24/2003 23:01'!rowDescription	^ self lastResultSet rowDescription! !!PGResult methodsFor: 'accessing-convenience' stamp: 'yj 4/24/2003 23:01'!rowDescription: aRowDescription	| rs |	rs := self lastResultSet.	rs rowDescription: aRowDescription.	rs result: self.	aRowDescription resultSet: rs.! !!PGResult methodsFor: 'accessing-convenience' stamp: 'yj 4/24/2003 23:01'!rows	^ self lastResultSet rows! !!PGResult methodsFor: 'accessing-convenience' stamp: 'yj 4/24/2003 23:01'!rows: value	self lastResultSet rows: value! !!PGResultSet class methodsFor: 'instance creation' stamp: 'yj 4/24/2003 23:01'!new	self error: 'should not use'! !!PGResultSet class methodsFor: 'instance creation' stamp: 'yj 4/24/2003 23:01'!on: aResult	^ self basicNew initialize		result: aResult;		yourself.! !!PGResultSet methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!completedResponse	"Answer the value of completedResponse"	^ completedResponse! !!PGResultSet methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!completedResponse: anObject	"Set the value of completedResponse"	completedResponse := anObject! !!PGResultSet methodsFor: 'accessing' stamp: 'kb 12/17/2008 17:53'!dataRows	^rows collect: [ :e | e dataRow ]! !!PGResultSet methodsFor: 'printing' stamp: 'yj 4/24/2003 23:01'!displayResultSetOn: aStream	completedResponse isNil ifFalse: [		completedResponse displayOn: aStream.		aStream cr.	].	rowDescription isNil ifFalse: [		self displayRowDescriptionOn: aStream.		aStream cr; nextPutAll: '----------'; cr.		self displayRowsOn: aStream.		aStream nextPut: $(.		rows size printOn: aStream.		aStream nextPutAll: ' row'.		rows size > 1 ifTrue: [aStream nextPut: $s].		aStream nextPut: $); cr; cr.	].! !!PGResultSet methodsFor: 'printing' stamp: 'yj 4/24/2003 23:01'!displayRowDescriptionOn: aStream	rowDescription displayOn: aStream.! !!PGResultSet methodsFor: 'printing' stamp: 'yj 4/24/2003 23:01'!displayRowsOn: aStream	rows do: [:each | each displayOn: aStream. aStream cr.].! !!PGResultSet methodsFor: 'initialize' stamp: 'yj 4/24/2003 23:01'!initialize	rows := OrderedCollection new.! !!PGResultSet methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!result	"Answer the value of result"	^ result! !!PGResultSet methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!result: anObject	"Set the value of result"	result := anObject! !!PGResultSet methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!rowDescription	"Answer the value of rowDescription"	^ rowDescription! !!PGResultSet methodsFor: 'accessing' stamp: 'EstebanMaringolo 9/4/2014 15:15'!rowDescription: anObject	"Set the value of rowDescription"	rowDescription := anObject! !!PGResultSet methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!rows	"Answer the value of rows"	^ rows! !!PGResultSet methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!rows: anObject	"Set the value of rows"	rows := anObject! !!PGResultSet methodsFor: 'accessing' stamp: 'yj 4/24/2003 23:01'!valueAt: fieldName	| i |	i := rowDescription columnDescriptions findFirst: [:each | each fieldName = fieldName].	i = 0 ifTrue: [^ nil].	rows == nil ifTrue: [^ nil].	^ (rows at: 1) rawData at: i! !"PostgresV2"!!GAConnectionString commentStamp: 'GuillermoPolito 5/5/2015 16:28' prior: 0!I am a database connection string for url-like connections. For example:mysql://localhost:5432/sodbxtest?&user=sodbxtest&password=sodbxtestMore generally, a connection string is written as:driver://host:port/database?key=value&key2=value2Internally, I use ZnUrl to parse and access the data inside a connection string.!!GAContinuousIntegrationConfiguration commentStamp: 'GuillermoPolito 4/17/2015 16:41' prior: 0!This class has methods to configure the connection strings to run the tests from the CI infrastructure!!GADriver commentStamp: 'GuillermoPolito 5/5/2015 15:28' prior: 0!This is the basic interface to instantiate and look for database drivers.Database drivers subscribe themselves to a global driver manager using this class. Then, they are instantiated through it.It also describes the minimal interface of all drivers. Its API contains the main methods to execute database queries, prepare statements and manage transactions. Also, to handle the differences between different drivers, this API provides a bunch of supports* methods to check the provided features.!!GADriverManager commentStamp: 'GuillermoPolito 5/5/2015 16:03' prior: 0!I am a simple driver manager that handle the subscriptions of database drivers. You can also ask a driver manager which are the installed drivers and get a driver by id.Drivers are handled in a weak way: unloading a driver will eventually garbage collect the driver and the manager will be cleaned up.!!GADriverTestFixture commentStamp: '<historical>' prior: 0!I am a fixture setting up and tearing down the database and tables needed for running tests.Each of my concrete subclasses implement the particular details of a database vendor. That is, for each driver flavor, one of me should be available.For insight into my usage, look at the setup and teardown methods in DBXDriverTest!!GAResultSet commentStamp: 'GuillermoPolito 5/5/2015 16:05' prior: 0!I am a garage result set representing a result from a database query. I provide a collection-like interface with methods such as #at:, #collect:, #do:, #select.!!GAResultSetReadStream commentStamp: 'GuillermoPolito 5/5/2015 16:15' prior: 0!I provide a stream-like  API to access a result set. I ask the result set for its rows in a lazy way. If no more rows are available, the #next method will return nil and the #next: method will return just an array with the available rows.!!GAStatement commentStamp: 'GuillermoPolito 5/5/2015 16:21' prior: 0!I am a statement object. I can be prepared or directly executed in the database.If I support being prepared, I also support the configuration of bindings with the #at:bind: method.Finally, I support the configuration of a #fetchSize: to use batch queries.!!GAConnectionStringTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/17/2015 14:26'!testConnectionStringDatabase	| driver |	driver := GAConnectionString fromString: 'someDatabase://Host:1111/adatabase?user=username&password=password'.	self assert: driver database = 'adatabase'.! !!GAConnectionStringTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/17/2015 14:26'!testConnectionStringDefaultDatabase	| driver |	driver := GAConnectionString fromString: 'someDatabase://Host:1111?user=username&password=password'.	self assert: driver database = ''.! !!GAConnectionStringTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/17/2015 14:25'!testConnectionStringDefaultPassword	| driver |	driver := GAConnectionString fromString: 'someDatabase://Host:1111'.	self assert: driver password = ''.! !!GAConnectionStringTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/17/2015 14:25'!testConnectionStringDefaultUser	| driver |	driver := GAConnectionString fromString: 'someDatabase://Host:1111?password=password'.	self assert: driver user = ''.! !!GAConnectionStringTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/17/2015 14:25'!testConnectionStringHost	| driver |	driver := GAConnectionString fromString: 'someDatabase://Host:1111/database?user=username&password=password'.	self assert: driver host = 'Host' asLowercase.! !!GAConnectionStringTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/17/2015 14:25'!testConnectionStringPassword	| driver |	driver := GAConnectionString fromString: 'someDatabase://Host:1111?password=pa55w0rd'.	self assert: driver password = 'pa55w0rd'.! !!GAConnectionStringTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/17/2015 14:24'!testConnectionStringPort	| driver |	driver := GAConnectionString fromString: 'someDatabase://Host:1111/database?user=username&password=password'.	self assert: driver port = 1111.! !!GAConnectionStringTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/17/2015 14:21'!testConnectionStringUser	| driver |	driver := GAConnectionString fromString: 'someDatabase://Host:1111?user=username&password=password'.	self assert: driver user = 'username'.! !!GADriverManagerTest methodsFor: 'tests' stamp: 'GuillermoPolito 5/5/2015 11:46'!testAccessingAvailableDriversYieldsDriver	| manager driver |	manager := GADriverManager new.	driver := GAMockDriver new.	manager subscribeDriver: driver.		self assert: (manager driverAt: driver driverId) equals: driver! !!GADriverManagerTest methodsFor: 'tests' stamp: 'GuillermoPolito 5/5/2015 11:45'!testAccessingUnavailableDriversRaisesError	| manager  |	manager := GADriverManager new.	self should: [manager driverAt: 1 ] raise: Error! !!GADriverManagerTest methodsFor: 'tests' stamp: 'GuillermoPolito 5/5/2015 11:42'!testAvailableDriversDoNotListCollectedDrivers	| manager driver |	manager := GADriverManager new.	manager subscribeDriver: GAMockDriver new.		driver := nil.	Smalltalk garbageCollect.	self assert: manager availableDrivers equals: #()! !!GADriverManagerTest methodsFor: 'tests' stamp: 'GuillermoPolito 5/5/2015 11:41'!testAvailableDriversListsSubscribedDrivers	| manager driver id |	manager := GADriverManager new.	driver := GAMockDriver new.	id := driver driverId.	manager subscribeDriver: driver.		self assert: manager availableDrivers equals: { id }! !!GADriverManagerTest methodsFor: 'tests' stamp: 'GuillermoPolito 5/5/2015 11:45'!testDriverManagerIsInitiallyEmpty	| manager |	manager := GADriverManager new.	self assert: manager availableDrivers equals: #()! !!GADriverManagerTest methodsFor: 'tests' stamp: 'GuillermoPolito 5/5/2015 11:39'!testSubscribe	| manager driver |	manager := GADriverManager new.	driver := GAMockDriver new.	manager subscribeDriver: driver.		self assert: (manager isAvailable: driver driverId)! !!GADriverManagerTest methodsFor: 'tests' stamp: 'GuillermoPolito 5/5/2015 11:40'!testSubscribeIsWeak	| manager driver id |	manager := GADriverManager new.	driver := GAMockDriver new.	id := driver driverId.	manager subscribeDriver: driver.		driver := nil.	Smalltalk garbageCollect.	self assert: (manager isAvailable: id) not! !!GADriverManagerTest methodsFor: 'tests' stamp: 'GuillermoPolito 5/5/2015 11:48'!testSubscribeTwiceReplaces	| manager driver |	manager := GADriverManager new.	driver := GAMockDriver new.	manager subscribeDriver: driver.	manager subscribeDriver: driver.		self assert: manager availableDrivers equals: { driver driverId }! !!GAConnectionTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/17/2015 16:11'!testConnectionStringDriver	| driver |	"Test that we can create a driver from a connection string such as		opendbx:///Users/guillermopolito/work/temp/garage/memory?backend=sqlite3	or		 mysql:/localhost:3306/sodbxtest?user=sodbxtest&password=sodbxtest	"	driver := GADriver fromConnectionString: fixture connectionString.	self assert: driver driverId asLowercase equals: fixture connectionString asZnUrl scheme asLowercase.! !!GAConnectionTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 1/25/2015 11:12'!testConnectionsAreFinalizedOnCollection	| newConnection |	newConnection := fixture newConnection.	newConnection finalize.	self deny: newConnection isConnected.! !!GAConnectionTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/21/2015 17:28'!testConnectionsAreRegisteredForFinalization	| newConnection |	newConnection := fixture newConnection.	self assert: newConnection isRegisteredForFinalization.	newConnection close.! !!GAConnectionTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/27/2015 11:20'!testDefaultEncoding	self assert: conn encoder equals: ZnUTF8Encoder new.! !!GAConnectionTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/21/2015 17:28'!testGetConnectionFromConnectionStringDoesNotOpenConnection	| connection |	connection := GADriver fromConnectionString: fixture connectionString.	self deny: connection isConnected.! !!GAConnectionTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/21/2015 15:03'!testIsConnected	| newConnection |	[newConnection := fixture newConnection.	self assert: newConnection isConnected.]	ensure: [ newConnection close ]! !!GAConnectionTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 1/25/2015 11:03'!testNotConnected	| newConnection |	newConnection := fixture newConnection.	newConnection close.	self deny: newConnection isConnected! !!GADriverTest class methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/17/2015 16:31'!fixture: aFixture	Fixture := aFixture! !!GADriverTest methodsFor: 'configuration' stamp: 'GuillermoPolito 4/17/2015 16:35'!createFixture	"You should implement this method as a user of garage to make the tests run on your database.	This method should return an instance of GADriverTestFixture with two connection strings:	 - setupConnectionString is the connection string used to create the initial database (if needed)	 - connection string is the connection string used to manipulate the created database.		Examples can be found in class GAContinuousIntegrationConfiguration"		self shouldBeImplemented		"^ GADriverTestFixture 		setupConnectionString: SetupConnectionString		connectionString: ConnectionString"! !!GADriverTest methodsFor: 'running' stamp: 'GuillermoPolito 4/21/2015 14:33'!setUp	super setUp.	fixture := Fixture ifNil: [ self createFixture ].	fixture setUp.	conn := fixture connection.! !!GADriverTest methodsFor: 'running' stamp: 'GuillermoPolito 4/21/2015 17:23'!tearDown	fixture tearDown.	super tearDown.! !!GAEncodingTest class methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/27/2015 11:17'!isAbstract	^ self == GAEncodingTest ! !!GAEncodingTest methodsFor: 'accessing' stamp: 'GuillermoPolito 4/27/2015 11:16'!encoding	self subclassResponsibility! !!GAEncodingTest methodsFor: 'running' stamp: 'GuillermoPolito 4/29/2015 12:01'!performTest	(fixture driver supportsEncoding: self encoding) ifFalse: [ ^ self skip ].	^ super performTest.! !!GAEncodingTest methodsFor: 'running' stamp: 'GuillermoPolito 4/29/2015 11:53'!setUp	"super setUp."		fixture := Fixture ifNil: [ self createFixture ].		(fixture driver supportsEncoding: self encoding) ifFalse: [ ^ self skip ].		fixture setUp: {'encoding' -> self encoding} asDictionary.	conn := fixture connection.! !!GAEncodingTest methodsFor: 'tests' stamp: 'GuillermoPolito 4/28/2015 17:40'!testEncodeArgumentsInPreparedStatements	| characters result statement |		conn supportsPreparedStatements ifFalse: [ ^self skip ].		characters := ''.	statement := conn prepare: 'INSERT INTO student(id, description) VALUES(1, ?)'.	statement at: 1 bind: characters.	statement execute.		result := conn execute: 'SELECT description FROM student WHERE id=1'.	self assert: (result first at: 1) equals: characters.! !!GAEncodingTest methodsFor: 'tests' stamp: 'GuillermoPolito 4/27/2015 14:15'!testEncoder	self assert: conn encoder equals: (ZnCharacterEncoder newForEncoding: self encoding)! !!GAEncodingTest methodsFor: 'tests' stamp: 'GuillermoPolito 4/29/2015 11:54'!testSpecialCharacters	| characters result |				conn supportsAutomaticQueryEncoding ifTrue: [ ^ self skip ].			characters := ''.	conn execute: 'INSERT INTO student(id, description) VALUES(1, ''',  (conn encoder encodeString: characters) asString, ''')'.		result := conn execute: 'SELECT description FROM student WHERE id=1'.	self assert: (result first at: 1) equals: characters.! !!GAEncodingTest methodsFor: 'tests' stamp: 'GuillermoPolito 4/28/2015 17:36'!testSpecialCharacters2	| characters result |		conn supportsAutomaticQueryEncoding ifTrue: [ ^ self skip ].		characters := ' y g  UTF-8, it stores it'.	conn execute: 'INSERT INTO student(id, description) VALUES(1, ''', (conn encoder encodeString:characters) asString, ''')'.		result := conn execute: 'SELECT description FROM student WHERE id=1'.	self assert: (result first at: 1) equals: characters.!]lang[(421)0! !!GAEncodingTest methodsFor: 'tests' stamp: 'GuillermoPolito 4/28/2015 17:36'!testSpecialCharacters2WithoutQueryEncoding	| characters result |		conn supportsAutomaticQueryEncoding ifFalse: [ ^ self skip ].		characters := ' y g  UTF-8, it stores it'.	conn execute: 'INSERT INTO student(id, description) VALUES(1, ''', characters, ''')'.		result := conn execute: 'SELECT description FROM student WHERE id=1'.	self assert: (result first at: 1) equals: characters.!]lang[(405)0! !!GAEncodingTest methodsFor: 'tests' stamp: 'GuillermoPolito 4/28/2015 17:36'!testSpecialCharacters3	| characters result |		conn supportsAutomaticQueryEncoding ifTrue: [ ^ self skip ].		characters := ''.	conn execute: 'INSERT INTO student(id, description) VALUES(1, ''', (conn encoder encodeString:characters) asString, ''')'.		result := conn execute: 'SELECT description FROM student WHERE id=1'.	self assert: (result first at: 1) equals: characters.! !!GAEncodingTest methodsFor: 'tests' stamp: 'GuillermoPolito 4/28/2015 17:36'!testSpecialCharacters3WithoutQueryEncoding	| characters result |		conn supportsAutomaticQueryEncoding ifFalse: [ ^ self skip ].		characters := ''.	conn execute: 'INSERT INTO student(id, description) VALUES(1, ''', characters, ''')'.		result := conn execute: 'SELECT description FROM student WHERE id=1'.	self assert: (result first at: 1) equals: characters.! !!GAEncodingTest methodsFor: 'tests' stamp: 'GuillermoPolito 4/28/2015 17:36'!testSpecialCharactersWithoutQueryEncoding	| characters result |				conn supportsAutomaticQueryEncoding ifFalse: [ ^ self skip ].		characters := ''.	conn execute: 'INSERT INTO student(id, description) VALUES(1, ''', characters, ''')'.		result := conn execute: 'SELECT description FROM student WHERE id=1'.	self assert: (result first at: 1) equals: characters.! !!GAUTF16EncodingTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/27/2015 11:18'!encoding	^ 'utf16'! !!GAUTF8EncodingTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/27/2015 11:16'!encoding	^ 'utf8'! !!GAFetchTest methodsFor: 'running' stamp: 'GuillermoPolito 4/23/2015 16:53'!setUp	super setUp.	"We create a lot of students"	conn execute: 'INSERT INTO student(id) VALUES (1)'.	1 to: 200 do: [ :i | conn execute: 'INSERT INTO signature(code, name, observations, id_student) VALUES (', i asString ,', ''TADP'', ''Tecnicas Av'', 1)'].! !!GAFetchTest methodsFor: 'testing' stamp: 'GuillermoPolito 4/24/2015 10:06'!supportsCursoredFetch		^ conn supportsCursoredFetch! !!GAFetchTest methodsFor: 'tests' stamp: 'GuillermoPolito 4/24/2015 10:22'!testPrepareTheCursorTakesOneFetch	| statement counter resultSet |	self supportsCursoredFetch ifFalse: [ self skip ].	conn beginTransaction.		counter := GAFetchCounter new.	statement := conn createStatement: 'SELECT code, name, observations FROM signature'.	statement fetchListener: counter.	statement fetchSize: 20.	resultSet := statement execute.	self assert: counter fetches equals: 1 "cursor takes one fetch".! !!GAFetchTest methodsFor: 'tests' stamp: 'GuillermoPolito 4/24/2015 13:50'!testReadAllCursoredAtOnceFetchAllAtOnce	| statement rows counter resultSet |	counter := GAFetchCounter new.	statement := conn createStatement: 'SELECT code, name, observations FROM signature'.	statement fetchListener: counter.	resultSet := statement execute.	rows := resultSet readStream next: 200.	self assert: counter fetches equals: conn numberOfFetchesForSingleExecute.! !!GAFetchTest methodsFor: 'tests' stamp: 'GuillermoPolito 4/24/2015 10:15'!testReadAllFetchInParts	| statement rows counter resultSet |	self supportsCursoredFetch ifFalse: [ self skip ].	conn beginTransaction.		counter := GAFetchCounter new.	statement := conn createStatement: 'SELECT code, name, observations FROM signature'.	statement fetchListener: counter.	statement fetchSize: 20.	resultSet := statement execute.	rows := resultSet rows.	self assert: counter fetches equals: 12 "1 execute + 10 times * 20 rows + 1 to know the EOF".! !!GAFetchTest methodsFor: 'tests' stamp: 'GuillermoPolito 4/24/2015 13:50'!testReadInPartsFetchAllAtOnce	| statement rows counter resultSet |		counter := GAFetchCounter new.	statement := conn createStatement: 'SELECT code, name, observations FROM signature'.	statement fetchListener: counter.	resultSet := statement execute.	20 timesRepeat: [ rows := resultSet readStream next: 10 ].	self assert: counter fetches equals: conn numberOfFetchesForSingleExecute.! !!GAFetchTest methodsFor: 'tests' stamp: 'GuillermoPolito 4/24/2015 10:23'!testReadInPartsFetchInBiggerParts	| statement rows counter readStream |	conn supportsCursoredFetch ifFalse: [ self skip ].	conn beginTransaction.		counter := GAFetchCounter new.	statement := conn createStatement: 'SELECT code, name, observations FROM signature'.	statement fetchListener: counter.	statement fetchSize: 20.	readStream := statement execute readStream.	10 timesRepeat: [ rows := readStream next: 21 ].	self assert: counter fetches equals: 12 "1 create cursor + 10 times * 21 rows + 1 end".! !!GAFetchTest methodsFor: 'tests' stamp: 'GuillermoPolito 4/24/2015 10:23'!testReadInPartsFetchInParts	| statement rows counter readStream |	self supportsCursoredFetch ifFalse: [ self skip ].	conn beginTransaction.		counter := GAFetchCounter new.	statement := conn createStatement: 'SELECT code, name, observations FROM signature'.	statement fetchListener: counter.	statement fetchSize: 20.	readStream := statement execute readStream.	10 timesRepeat: [ rows := readStream next: 20 ].	self assert: counter fetches equals: 11 "1 create cursor + 10 times * 20 rows".! !!GAFetchTest methodsFor: 'tests' stamp: 'GuillermoPolito 4/24/2015 10:24'!testReadInPartsFetchInSmallerParts	| statement rows counter readStream |	conn supportsCursoredFetch ifFalse: [ self skip ].	conn beginTransaction.		counter := GAFetchCounter new.	statement := conn createStatement: 'SELECT code, name, observations FROM signature'.	statement fetchListener: counter.	statement fetchSize: 20.	readStream := statement execute readStream.	25 timesRepeat: [ rows := readStream next: 9 ].	self assert: counter fetches equals: 12 "1 create cursor + 10 times * 21 rows + 1 end".! !!GAFetchTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/24/2015 13:56'!testResultIterateResultStreamBigFetchWindow	" self debug: #testCursoredResult "	| select result statement row rows |	self supportsCursoredFetch ifFalse: [ self skip. ].		select:= 'SELECT code, name, observations FROM signature'.	conn beginTransaction.	[	statement := conn createStatement: select.	statement fetchSize: 100.	result := statement execute readStream.	rows := 0.	[ (row := result next) notNil ] whileTrue: [		rows := rows + 1.		self assert: (row at: 1) equals: rows.		self assert: (row at: 2) equals: 'TADP'.		self assert: (row at: 3) equals: 'Tecnicas Av'. ]	] ensure: [ conn rollbackTransaction ].	self assert: rows equals: 200.! !!GAFetchTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/24/2015 13:56'!testResultIterateResultStreamDefaultFetchWindow	" self debug: #testCursoredResult "	| select result row rows |	self supportsCursoredFetch ifFalse: [ self skip. ].	select:= 'SELECT code, name, observations FROM signature'.	result := (conn execute: select) readStream.	rows := 0.	[ (row := result next) notNil ] whileTrue: [		rows := rows + 1.		self assert: (row at: 1) equals: rows.		self assert: (row at: 2) equals: 'TADP'.		self assert: (row at: 3) equals: 'Tecnicas Av' ].	self assert: rows equals: 200.! !!GAFetchTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/24/2015 13:56'!testResultIterateResultStreamReallyBigFetchWindow	" self debug: #testCursoredResult "	| select result statement row rows |	self supportsCursoredFetch ifFalse: [ self skip. ].	select:= 'SELECT code, name, observations FROM signature'.	conn beginTransaction.	[	statement := conn createStatement: select.	statement fetchSize: 1000.	result := statement execute readStream.	rows := 0.	[ (row := result next) notNil ] whileTrue: [		rows := rows + 1.		self assert: (row at: 1) equals: rows.		self assert: (row at: 2) equals: 'TADP'.		self assert: (row at: 3) equals: 'Tecnicas Av'. ]	] ensure: [ conn rollbackTransaction ].	self assert: rows equals: 200.! !!GAFetchTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/24/2015 13:56'!testResultIterateesultStreamSmallFetchWindow	" self debug: #testCursoredResult "	| select result statement row rows |	self supportsCursoredFetch ifFalse: [ self skip. ].	select:= 'SELECT code, name, observations FROM signature'.	conn beginTransaction.	[	statement := conn createStatement: select.	statement fetchSize: 10.	result := statement execute readStream.	rows := 0.	[ (row := result next) notNil ] whileTrue: [		rows := rows + 1.		self assert: (row at: 1) equals: rows.		self assert: (row at: 2) equals: 'TADP'.		self assert: (row at: 3) equals: 'Tecnicas Av'. ]	] ensure: [ conn rollbackTransaction ].	self assert: rows equals: 200.! !!GAFetchTest methodsFor: 'tests' stamp: 'GuillermoPolito 4/29/2015 12:27'!testTryCursoredFetchFailsIfNotSupported	| statement |	self supportsCursoredFetch ifTrue: [ ^self skip ].	statement := conn createStatement: 'SELECT code, name, observations FROM signature'.	self should: [statement fetchSize: 20] raise: Error	! !!GAPreparedStamentTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/7/2015 17:00'!testBindQuestionMark	| result row statement |	conn supportsPreparedStatements ifFalse: [ ^self skip ].	conn execute: 'CREATE TABLE CATS (		name varchar(50),		owner varchar(50))'.	conn execute: 'INSERT INTO CATS(name,owner) VALUES(''lutz'',''julien'')'.		statement := conn prepare: 'SELECT * FROM CATS WHERE name=?'.	statement at: 1 bind: 'lutz'.	result := statement execute.	row := result first.		self assert: (row at: 1) equals: 'lutz'.	self assert: (row at: 2) equals: 'julien'.! !!GAPreparedStamentTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/24/2015 17:06'!testBindQuestionMarkFromExistingStatement	| result row statement |	conn supportsPreparedStatements ifFalse: [ ^self skip ].	statement := conn createStatement: 'CREATE TABLE CATS (		name varchar(50),		owner varchar(50))'.	statement execute.	statement := conn createStatement: 'INSERT INTO CATS(name,owner) VALUES(''lutz'',''julien'')'.	statement execute.		statement := conn createStatement: 'SELECT * FROM CATS WHERE name=?'.	statement prepare.	statement at: 1 bind: 'lutz'.	result := statement execute.	row := result first.		self assert: (row at: 1) equals: 'lutz'.	self assert: (row at: 2) equals: 'julien'.! !!GAPreparedStamentTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/24/2015 17:16'!testBindQuestionMarkFromExistingUninitializedStatement	| result row statement |	conn supportsPreparedStatements ifFalse: [ ^self skip ].	statement := conn createStatement.	statement statementString: 'CREATE TABLE CATS (		name varchar(50),		owner varchar(50))'.	statement execute.	statement := conn createStatement.	statement statementString: 'INSERT INTO CATS(name,owner) VALUES(''lutz'',''julien'')'.	statement execute.		statement := conn createStatement.	statement statementString: 'SELECT * FROM CATS WHERE name=' , (statement placeholderAt: 1).	statement prepare.	statement at: 1 bind: 'lutz'.	result := statement execute.	row := result first.		self assert: (row at: 1) equals: 'lutz'.	self assert: (row at: 2) equals: 'julien'.! !!GAPreparedStamentTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/24/2015 17:01'!testBindingFailsIfNotSupportedPrepare	| statement |	conn supportsPreparedStatements ifTrue: [ self skip ].	statement := conn createStatement.	statement statementString:  'SELECT * FROM CATS WHERE owner = ?'.	self should: [ statement at: 1 bind: 'guille' ] raise: Error.! !!GAPreparedStamentTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/7/2015 17:04'!testPrepareInsert	| result row preparedStatement |	conn supportsPreparedStatements ifFalse: [ ^self skip ].	conn execute: 'INSERT INTO student(id) VALUES (1)'.	preparedStatement := conn prepare: 'INSERT INTO signature(code, name, observations, id_student) VALUES (59, ''TADP'', ''Tecnicas Av'', 1)'.	preparedStatement execute.		result := conn execute: 'SELECT code, name, observations, id_student FROM signature'.	row := result first.		self assert: (row at: 1) equals: 59.	self assert: (row at: 2) equals: 'TADP'.	self assert: (row at: 3) equals: 'Tecnicas Av'.	self assert: (row at: 4) equals: 1.! !!GAPreparedStamentTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/24/2015 16:54'!testPrepareInsertFromExistingStatement	| result row preparedStatement statement |	conn supportsPreparedStatements ifFalse: [ ^self skip ].	conn execute: 'INSERT INTO student(id) VALUES (1)'.	statement := conn createStatement: 'INSERT INTO signature(code, name, observations, id_student) VALUES (59, ''TADP'', ''Tecnicas Av'', 1)'.	preparedStatement := statement prepare.	preparedStatement execute.		result := conn execute: 'SELECT code, name, observations, id_student FROM signature'.	row := result first.		self assert: (row at: 1) equals: 59.	self assert: (row at: 2) equals: 'TADP'.	self assert: (row at: 3) equals: 'Tecnicas Av'.	self assert: (row at: 4) equals: 1.! !!GAPreparedStamentTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/24/2015 17:02'!testPrepareInsertFromExistingUninitializedStatement	| result row preparedStatement statement |	conn supportsPreparedStatements ifFalse: [ ^self skip ].	conn execute: 'INSERT INTO student(id) VALUES (1)'.	statement := conn createStatement.	statement statementString: 'INSERT INTO signature(code, name, observations, id_student) VALUES (59, ''TADP'', ''Tecnicas Av'', 1)'.	preparedStatement := statement prepare.	preparedStatement execute.		result := conn execute: 'SELECT code, name, observations, id_student FROM signature'.	row := result first.		self assert: (row at: 1) equals: 59.	self assert: (row at: 2) equals: 'TADP'.	self assert: (row at: 3) equals: 'Tecnicas Av'.	self assert: (row at: 4) equals: 1.! !!GAPreparedStamentTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/7/2015 17:04'!testPrepareSelect	| result row preparedStatement |	conn supportsPreparedStatements ifFalse: [ ^self skip ].		conn execute: 'INSERT INTO student(id) VALUES (1)'.	conn execute: 'INSERT INTO signature(code, name, observations, id_student) VALUES (59, ''TADP'', ''Tecnicas Av'', 1)'.		preparedStatement := conn prepare: 'SELECT code, name, observations, id_student FROM signature'.	result := preparedStatement execute.	row := result first.		self assert: (row at: 1) equals: 59.	self assert: (row at: 2) equals: 'TADP'.	self assert: (row at: 3) equals: 'Tecnicas Av'.	self assert: (row at: 4) equals: 1.! !!GAPreparedStamentTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/24/2015 16:58'!testPrepareSelectFromExistingStatement	| result row statement |	conn supportsPreparedStatements ifFalse: [ ^self skip ].		conn execute: 'INSERT INTO student(id) VALUES (1)'.	conn execute: 'INSERT INTO signature(code, name, observations, id_student) VALUES (59, ''TADP'', ''Tecnicas Av'', 1)'.		statement := conn createStatement: 'SELECT code, name, observations, id_student FROM signature'.	result := statement prepare execute.	row := result first.		self assert: (row at: 1) equals: 59.	self assert: (row at: 2) equals: 'TADP'.	self assert: (row at: 3) equals: 'Tecnicas Av'.	self assert: (row at: 4) equals: 1.! !!GAPreparedStamentTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/24/2015 17:02'!testPrepareSelectFromExistingUninitializedStatement	| result row preparedStatement |	conn supportsPreparedStatements ifFalse: [ ^self skip ].		conn execute: 'INSERT INTO student(id) VALUES (1)'.	conn execute: 'INSERT INTO signature(code, name, observations, id_student) VALUES (59, ''TADP'', ''Tecnicas Av'', 1)'.		preparedStatement := conn createStatement.	preparedStatement statementString:  'SELECT code, name, observations, id_student FROM signature'.	preparedStatement prepare.	result := preparedStatement execute.	row := result first.		self assert: (row at: 1) equals: 59.	self assert: (row at: 2) equals: 'TADP'.	self assert: (row at: 3) equals: 'Tecnicas Av'.	self assert: (row at: 4) equals: 1.! !!GAPreparedStamentTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/7/2015 17:04'!testPrepareWithArgs	| result row preparedStatement |	conn supportsPreparedStatements ifFalse: [ ^self skip ].		conn execute: 'INSERT INTO student(id) VALUES (1)'.	preparedStatement := conn prepare: 'INSERT INTO signature(code, name, observations, id_student) VALUES (59, ''TADP'', ''Tecnicas Av'', ?)'.	preparedStatement at: 1 bind: 1.	preparedStatement execute.		preparedStatement := conn prepare: 'SELECT code, name, observations, id_student FROM signature WHERE id_student = ?'.	preparedStatement at: 1 bind: 1.	result := preparedStatement execute.	row := result first.		self assert: (row at: 1) equals: 59.	self assert: (row at: 2) equals: 'TADP'.	self assert: (row at: 3) equals: 'Tecnicas Av'.	self assert: (row at: 4) equals: 1.! !!GAPreparedStamentTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/24/2015 17:06'!testPrepareWithArgsFromExistingStatement	| result row preparedStatement |	conn supportsPreparedStatements ifFalse: [ ^self skip ].		conn execute: 'INSERT INTO student(id) VALUES (1)'.	preparedStatement := conn createStatement: 'INSERT INTO signature(code, name, observations, id_student) VALUES (59, ''TADP'', ''Tecnicas Av'', ?)'.	preparedStatement prepare.	preparedStatement at: 1 bind: 1.	preparedStatement execute.		preparedStatement := conn createStatement: 'SELECT code, name, observations, id_student FROM signature WHERE id_student = ?'.	preparedStatement prepare.	preparedStatement at: 1 bind: 1.	result := preparedStatement execute.	row := result first.		self assert: (row at: 1) equals: 59.	self assert: (row at: 2) equals: 'TADP'.	self assert: (row at: 3) equals: 'Tecnicas Av'.	self assert: (row at: 4) equals: 1.! !!GAPreparedStamentTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/24/2015 17:18'!testPrepareWithArgsFromExistingUninitializedStatement	| result row preparedStatement |	conn supportsPreparedStatements ifFalse: [ ^self skip ].		conn execute: 'INSERT INTO student(id) VALUES (1)'.	preparedStatement := conn prepare: 'INSERT INTO signature(code, name, observations, id_student) VALUES (59, ''TADP'', ''Tecnicas Av'', ?)'.	preparedStatement at: 1 bind: 1.	preparedStatement execute.		preparedStatement := conn createStatement.	preparedStatement statementString: 'SELECT code, name, observations, id_student FROM signature WHERE id_student = ',(preparedStatement placeholderAt: 1).	preparedStatement prepare.	preparedStatement at: 1 bind: 1.	result := preparedStatement execute.	row := result first.		self assert: (row at: 1) equals: 59.	self assert: (row at: 2) equals: 'TADP'.	self assert: (row at: 3) equals: 'Tecnicas Av'.	self assert: (row at: 4) equals: 1.! !!GAPreparedStamentTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/29/2015 12:26'!testPrepareWithUnboundArgsWithDriversThatChooseADefault	| preparedStatement |	conn supportsPreparedStatements ifFalse: [ ^self skip ].	conn notBoundArgumentsFail ifTrue: [ ^self skip ].	"Not bound arguments are taken as NULL"		preparedStatement := conn prepare: 'INSERT INTO signature(code, name, observations, id_student) VALUES (59, ''TADP'', ''Tecnicas Av'', ?)'.	preparedStatement execute.		(conn execute: 'SELECT id_student FROM signature') do: [ :r | self assert: (r at: 1) isNil ]! !!GAPreparedStamentTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/29/2015 12:27'!testPrepareWithUnboundArgsWithDriversThatChooseADefaultFromExistingStatement	| preparedStatement |	conn supportsPreparedStatements ifFalse: [ ^self skip ].	conn notBoundArgumentsFail ifTrue: [ ^self skip ].	"Not bound arguments are taken as NULL"		preparedStatement := conn createStatement: 'INSERT INTO signature(code, name, observations, id_student) VALUES (59, ''TADP'', ''Tecnicas Av'', ?)'.	preparedStatement prepare.	preparedStatement execute.		(conn execute: 'SELECT id_student FROM signature') do: [ :r | self assert: (r at: 1) isNil ]! !!GAPreparedStamentTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/29/2015 12:26'!testPrepareWithUnboundArgsWithDriversThatChooseADefaultFromExistingUninitializedStatement	| preparedStatement |	conn supportsPreparedStatements ifFalse: [ ^self skip ].	conn notBoundArgumentsFail ifTrue: [ ^self skip ].	"Not bound arguments are taken as NULL"		preparedStatement := conn createStatement.	preparedStatement statementString: 'INSERT INTO signature(code, name, observations, id_student) VALUES (59, ''TADP'', ''Tecnicas Av'', ?)'.	preparedStatement prepare.	preparedStatement execute.		(conn execute: 'SELECT id_student FROM signature') do: [ :r | self assert: (r at: 1) isNil ]! !!GAPreparedStamentTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/7/2015 17:04'!testPrepareWithWrongArgs	| preparedStatement |	conn supportsPreparedStatements ifFalse: [ ^self skip ].	conn notBoundArgumentsFail ifFalse: [ self skip ].		preparedStatement := conn prepare: 'INSERT INTO signature(code, name, observations, id_student) VALUES (59, ''TADP'', ''Tecnicas Av'', ?)'.	self should: [preparedStatement execute] raise: Error.! !!GAPreparedStamentTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/24/2015 16:59'!testPrepareWithWrongArgsFromExistingStatement	| preparedStatement |	conn supportsPreparedStatements ifFalse: [ ^self skip ].	conn notBoundArgumentsFail ifFalse: [ self skip ].		preparedStatement := conn createStatement: 'INSERT INTO signature(code, name, observations, id_student) VALUES (59, ''TADP'', ''Tecnicas Av'', ?)'.	preparedStatement prepare.	self should: [preparedStatement execute] raise: Error.! !!GAPreparedStamentTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/24/2015 17:17'!testPrepareWithWrongArgsFromExistingUninitializedStatement	| preparedStatement |	conn supportsPreparedStatements ifFalse: [ ^self skip ].	conn notBoundArgumentsFail ifFalse: [ self skip ].		preparedStatement := conn createStatement.	preparedStatement statementString: 'INSERT INTO signature(code, name, observations, id_student) VALUES (59, ''TADP'', ''Tecnicas Av'', ',(preparedStatement placeholderAt: 1),')'.	preparedStatement prepare.	self should: [preparedStatement execute] raise: Error.! !!GAPreparedStamentTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 2/9/2015 00:36'!testStatementNotPreparedIfNotSuported	"If we send non-sense, drivers that support prepared statements will fail on preparation and the others will fail on execute as there is no real preparation"	conn supportsPreparedStatements ifTrue: [ ^ self skip ].	self should: [conn prepare: 'SELECT 1+1'] raise: Error.! !!GAPreparedStamentTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/24/2015 17:00'!testStatementNotPreparedIfNotSuportedFromExistingStatement	"If we send non-sense, drivers that support prepared statements will fail on preparation and the others will fail on execute as there is no real preparation"	| preparedStatement |	conn supportsPreparedStatements ifTrue: [ ^ self skip ].	preparedStatement := conn createStatement: 'SELECT 1+1'.	self should: [ preparedStatement prepare ] raise: Error.! !!GAPreparedStamentTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/24/2015 17:26'!testStatementNotPreparedIfNotSuportedFromExistingUninitializedStatement	"If we send non-sense, drivers that support prepared statements will fail on preparation and the others will fail on execute as there is no real preparation"	| statement |	conn supportsPreparedStatements ifTrue: [ ^ self skip ].	statement := conn createStatement.	statement statementString: 'SELECT 1+1'.	self should: [ conn prepare ] raise: Error.! !!GAQueryTest methodsFor: 'tests' stamp: 'GuillermoPolito 4/27/2015 15:38'!testInsert	"self debug: #testInsert"	| result row |		conn execute: 'INSERT INTO student(id) VALUES (1)'.	conn execute: 'INSERT INTO signature(code, name, observations, id_student) VALUES (59, ''TADP'', ''Tecnicas Av'', 1)'.	result := conn execute: 'SELECT code, name, observations, id_student FROM signature'.	row := result first.		self assert: (row at: 1) equals: 59.	self assert: (row at: 2) equals: 'TADP'.	self assert: (row at: 3) equals: 'Tecnicas Av'.	self assert: (row at: 4) equals: 1.! !!GAQueryTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 1/21/2015 16:55'!testQuery	| select result |	select:= 'SELECT * FROM signature'.	result := conn execute: select.! !!GAQueryTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 2/8/2015 17:22'!testQueryResult	| select result |	select:= 'SELECT * FROM signature'.	result := conn execute: select.		self assert: result isEmpty.! !!GAQueryTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 2/8/2015 16:33'!testResultIterateAt	| select result |	conn execute: 'INSERT INTO student(id) VALUES (1)'.	conn execute: 'INSERT INTO student(id) VALUES (2)'.	conn execute: 'INSERT INTO signature(code, name, observations, id_student) VALUES (59, ''TADP'', ''Tecnicas Av'', 1)'.	conn execute: 'INSERT INTO signature(code, name, observations, id_student) VALUES (59, ''TADP'', ''Tecnicas Av'', 2)'.	select:= 'SELECT code, name, observations, id_student FROM signature'.	result := conn execute: select.	self assert: ((result at: 2) atIndex: 4) equals: 2.! !!GAQueryTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 2/8/2015 16:25'!testResultIterateCollect	| select result collected |	conn execute: 'INSERT INTO student(id) VALUES (1)'.	conn execute: 'INSERT INTO student(id) VALUES (2)'.	conn execute: 'INSERT INTO signature(code, name, observations, id_student) VALUES (59, ''TADP'', ''Tecnicas Av'', 1)'.	conn execute: 'INSERT INTO signature(code, name, observations, id_student) VALUES (59, ''TADP'', ''Tecnicas Av'', 2)'.	select:= 'SELECT code, name, observations, id_student FROM signature'.	result := conn execute: select.	collected := result collect: [ :row | row atIndex: 4].	self assert: collected asArray equals: #(1 2).! !!GAQueryTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 2/8/2015 16:25'!testResultIterateDo	| select result rows |	conn execute: 'INSERT INTO student(id) VALUES (1)'.	conn execute: 'INSERT INTO student(id) VALUES (2)'.	conn execute: 'INSERT INTO signature(code, name, observations, id_student) VALUES (59, ''TADP'', ''Tecnicas Av'', 1)'.	conn execute: 'INSERT INTO signature(code, name, observations, id_student) VALUES (59, ''TADP'', ''Tecnicas Av'', 2)'.	select:= 'SELECT code, name, observations FROM signature'.	result := conn execute: select.	rows := 0.	result do: [ :row |		self assert: (row at: 1) equals: 59.		self assert: (row at: 2) equals: 'TADP'.		self assert: (row at: 3) equals: 'Tecnicas Av'. 		rows := rows + 1 ].	self assert: rows equals: 2.! !!GAQueryTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 2/8/2015 16:33'!testResultIterateFirst	| select result |	conn execute: 'INSERT INTO student(id) VALUES (1)'.	conn execute: 'INSERT INTO student(id) VALUES (2)'.	conn execute: 'INSERT INTO signature(code, name, observations, id_student) VALUES (59, ''TADP'', ''Tecnicas Av'', 1)'.	conn execute: 'INSERT INTO signature(code, name, observations, id_student) VALUES (59, ''TADP'', ''Tecnicas Av'', 2)'.	select:= 'SELECT code, name, observations, id_student FROM signature'.	result := conn execute: select.	self assert: (result first atIndex: 4) equals: 1.! !!GAQueryTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 2/8/2015 16:25'!testResultIterateSelect	| select result selected |	conn execute: 'INSERT INTO student(id) VALUES (1)'.	conn execute: 'INSERT INTO student(id) VALUES (2)'.	conn execute: 'INSERT INTO signature(code, name, observations, id_student) VALUES (59, ''TADP'', ''Tecnicas Av'', 1)'.	conn execute: 'INSERT INTO signature(code, name, observations, id_student) VALUES (59, ''TADP'', ''Tecnicas Av'', 2)'.	select:= 'SELECT code, name, observations, id_student FROM signature'.	result := conn execute: select.	selected := result select: [ :row | (row atIndex: 4) = 2].	self assert: selected size equals: 1.! !!GAQueryTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 2/8/2015 16:29'!testResultIterateStream	| select result row rows |	conn execute: 'INSERT INTO student(id) VALUES (1)'.	conn execute: 'INSERT INTO student(id) VALUES (2)'.	conn execute: 'INSERT INTO signature(code, name, observations, id_student) VALUES (59, ''TADP'', ''Tecnicas Av'', 1)'.	conn execute: 'INSERT INTO signature(code, name, observations, id_student) VALUES (59, ''TADP'', ''Tecnicas Av'', 2)'.	select:= 'SELECT code, name, observations FROM signature'.	result := (conn execute: select) readStream.	rows := 0.	[ (row := result next) notNil ] whileTrue: [		self assert: (row at: 1) equals: 59.		self assert: (row at: 2) equals: 'TADP'.		self assert: (row at: 3) equals: 'Tecnicas Av'. 		rows := rows + 1. ].	self assert: rows equals: 2.! !!GAQueryTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 2/8/2015 16:54'!testResultIterateStreamNextColonIsNilWhenEmpty	| select result |	conn execute: 'INSERT INTO student(id) VALUES (1)'.	conn execute: 'INSERT INTO student(id) VALUES (2)'.	conn execute: 'INSERT INTO signature(code, name, observations, id_student) VALUES (59, ''TADP'', ''Tecnicas Av'', 1)'.	conn execute: 'INSERT INTO signature(code, name, observations, id_student) VALUES (59, ''TADP'', ''Tecnicas Av'', 2)'.	select:= 'SELECT code, name, observations FROM signature'.	result := (conn execute: select) readStream.	result next: 2.		self assert: (result next: 1) equals: #()! !!GAQueryTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 2/8/2015 16:56'!testResultIterateStreamNextColonReturnsOnlyWhatItHas	| select result |	conn execute: 'INSERT INTO student(id) VALUES (1)'.	conn execute: 'INSERT INTO student(id) VALUES (2)'.	conn execute: 'INSERT INTO signature(code, name, observations, id_student) VALUES (59, ''TADP'', ''Tecnicas Av'', 1)'.	conn execute: 'INSERT INTO signature(code, name, observations, id_student) VALUES (59, ''TADP'', ''Tecnicas Av'', 2)'.	select:= 'SELECT code, name, observations FROM signature'.	result := (conn execute: select) readStream.	self assert: (result next: 3) size equals: 2.! !!GAQueryTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 2/8/2015 16:47'!testResultIterateStreamNextIsNilWhenEmpty	| select result |	conn execute: 'INSERT INTO student(id) VALUES (1)'.	conn execute: 'INSERT INTO student(id) VALUES (2)'.	conn execute: 'INSERT INTO signature(code, name, observations, id_student) VALUES (59, ''TADP'', ''Tecnicas Av'', 1)'.	conn execute: 'INSERT INTO signature(code, name, observations, id_student) VALUES (59, ''TADP'', ''Tecnicas Av'', 2)'.	select:= 'SELECT code, name, observations FROM signature'.	result := (conn execute: select) readStream.	result next: 2.		self assert: result next isNil! !!GAQueryTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 2/8/2015 16:44'!testResultIterateStreamNextN	| select result rows |	conn execute: 'INSERT INTO student(id) VALUES (1)'.	conn execute: 'INSERT INTO student(id) VALUES (2)'.	conn execute: 'INSERT INTO signature(code, name, observations, id_student) VALUES (59, ''TADP'', ''Tecnicas Av'', 1)'.	conn execute: 'INSERT INTO signature(code, name, observations, id_student) VALUES (59, ''TADP'', ''Tecnicas Av'', 2)'.	select:= 'SELECT code, name, observations FROM signature'.	result := (conn execute: select) readStream.	rows := result next: 1.		self assert: rows size equals: 1.	self assert: (rows first at: 1) equals: 59.	self assert: (rows first at: 2) equals: 'TADP'.	self assert: (rows first at: 3) equals: 'Tecnicas Av'. 		rows := result next: 1.	self assert: rows size equals: 1.	self assert: (rows first at: 1) equals: 59.	self assert: (rows first at: 2) equals: 'TADP'.	self assert: (rows first at: 3) equals: 'Tecnicas Av'. ! !!GAQueryTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 2/8/2015 16:25'!testResultOfDDL		| result |	result := conn execute: 'CREATE TABLE CATS (		name varchar(50),		owner varchar(50))'.	self assert: result affectedRows = 0.! !!GAQueryTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 2/8/2015 16:25'!testResultOfDelete		| result |	conn execute: 'CREATE TABLE CATS (		name varchar(50),		owner varchar(50))'.	conn execute: 'INSERT INTO CATS(name,owner) VALUES(''lutz'',''julien'')'.	conn execute: 'INSERT INTO CATS(name,owner) VALUES(''camila'',''guille'')'.	conn execute: 'INSERT INTO CATS(name,owner) VALUES(''inuk'',''victor'')'.		result := conn execute: 'DELETE FROM CATS'.	self assert: result affectedRows = 3.! !!GAQueryTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 2/8/2015 16:25'!testResultOfDeleteWhere		| result |	conn execute: 'CREATE TABLE CATS (		name varchar(50),		owner varchar(50))'.	conn execute: 'INSERT INTO CATS(name,owner) VALUES(''lutz'',''julien'')'.	conn execute: 'INSERT INTO CATS(name,owner) VALUES(''camila'',''guille'')'.	conn execute: 'INSERT INTO CATS(name,owner) VALUES(''inuk'',''victor'')'.		result := conn execute: 'DELETE FROM CATS WHERE name !!= ''lutz'''.	self assert: result affectedRows = 2.! !!GAQueryTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 2/8/2015 16:25'!testResultOfInsert		| result |	conn execute: 'CREATE TABLE CATS (		name varchar(50),		owner varchar(50))'.	result := conn execute: 'INSERT INTO CATS(name,owner) VALUES(''lutz'',''julien'')'.	self assert: result affectedRows = 1.! !!GAQueryTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 2/8/2015 16:24'!testResultOfUpdate		| result |	conn execute: 'CREATE TABLE CATS (		name varchar(50),		owner varchar(50))'.	conn execute: 'INSERT INTO CATS(name,owner) VALUES(''lutz'',''julien'')'.	conn execute: 'INSERT INTO CATS(name,owner) VALUES(''camila'',''guille'')'.	conn execute: 'INSERT INTO CATS(name,owner) VALUES(''inuk'',''victor'')'.		result := conn execute: 'UPDATE CATS SET owner=''guille'''.	"Mysql only affects rows that he has to update"	conn affectsOnlyChangedRows ifTrue: [ 		self assert: result affectedRows = 2.	] ifFalse: [ 		self assert: result affectedRows = 3.	]! !!GAQueryTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 2/8/2015 16:24'!testResultOfUpdateWhere		| result |	conn execute: 'CREATE TABLE CATS (		name varchar(50),		owner varchar(50))'.	conn execute: 'INSERT INTO CATS(name,owner) VALUES(''lutz'',''julien'')'.	conn execute: 'INSERT INTO CATS(name,owner) VALUES(''camila'',''guille'')'.	conn execute: 'INSERT INTO CATS(name,owner) VALUES(''inuk'',''victor'')'.		result := conn execute: 'UPDATE CATS SET owner = ''guille'' WHERE owner !!= ''guille'''.	self assert: result affectedRows = 2.! !!GARowTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 2/8/2015 17:26'!testAccessRowByIndex	" self debug: #testCursoredResult "	| result catRow |	conn execute: 'CREATE TABLE CATS (		name varchar(50),		owner varchar(50))'.	conn execute: 'INSERT INTO CATS(name,owner) VALUES(''lutz'',''julien'')'.	result := conn execute: 'SELECT name AS catname, owner FROM CATS'.	catRow := result first.	self assert: (catRow atIndex: 1) equals: 'lutz'.	self assert: (catRow atIndex: 2) equals: 'julien'.! !!GARowTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 2/8/2015 17:26'!testAccessRowByNameString	" self debug: #testCursoredResult "	| result catRow |	conn execute: 'CREATE TABLE CATS (		name varchar(50),		owner varchar(50))'.	conn execute: 'INSERT INTO CATS(name,owner) VALUES(''lutz'',''julien'')'.	result := conn execute: 'SELECT name AS catname, owner FROM CATS'.	catRow := result first.	self assert: (catRow atName: 'catname') equals: 'lutz'.	self assert: (catRow atName: 'owner') equals: 'julien'.! !!GARowTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 2/8/2015 17:26'!testAccessRowByNameSymbol	" self debug: #testCursoredResult "	| result catRow |	conn execute: 'CREATE TABLE CATS (		name varchar(50),		owner varchar(50))'.	conn execute: 'INSERT INTO CATS(name,owner) VALUES(''lutz'',''julien'')'.	result := conn execute: 'SELECT name AS catname, owner FROM CATS'.	catRow := result first.	self assert: (catRow atName: #catname) equals: 'lutz'.	self assert: (catRow atName: #owner) equals: 'julien'.! !!GARowTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 2/8/2015 17:26'!testAccessUnamedFunctionsByName	" self debug: #testCursoredResult "	| result  |	conn execute: 'CREATE TABLE CATS (		name varchar(50),		owner varchar(50))'.	conn execute: 'INSERT INTO CATS(name,owner) VALUES(''lutz'',''julien'')'.	result := conn execute: 'SELECT COUNT(*) AS count FROM CATS'.	self assert: (result first atName: 'count') equals: 1.! !!GAStatementOptions methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/20/2015 16:42'!testGetInsertedKeys	| result statement generatedKey |	conn supportsRetrievingGeneratedKeys ifFalse: [ self skip ].		statement := conn createStatement: 'INSERT INTO student(username) VALUES (''guille'')'.	result := statement execute.	generatedKey := result generatedKey.		self assert: generatedKey equals: 1.! !!GAStatementTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 2/8/2015 20:15'!testCreateStatement	| statementString statement |	statementString := 'CREATE TABLE CATS (	name varchar(50),	owner varchar(50))'.	statement := conn createStatement: statementString.		self assert: statement notNil.	self assert: statement statementString equals: statementString.! !!GAStatementTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 2/8/2015 20:16'!testCreateStatementWithoutStatementString	| statementString statement |	statementString := 'CREATE TABLE CATS (	name varchar(50),	owner varchar(50))'.	statement := conn createStatement.	statement statementString: statementString.		self assert: statement notNil.	self assert: statement statementString equals: statementString.! !!GAStatementTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 2/8/2015 20:25'!testExecuteStatement	| statement result |	conn execute: 'CREATE TABLE CATS (	name varchar(50),	owner varchar(50))'.	conn execute: 'INSERT INTO CATS(name, owner) VALUES(''lutz'', ''julien'')'.	statement := conn createStatement: 'SELECT * FROM CATS'.	result := statement execute.	self assert: (result first at: 1) equals: 'lutz'.	self assert: (result first at: 2) equals: 'julien'.! !!GAStatementTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 3/25/2015 18:12'!testExecuteStatementTwice	| statement result |	conn execute: 'CREATE TABLE CATS (	name varchar(50),	owner varchar(50))'.	conn execute: 'INSERT INTO CATS(name, owner) VALUES(''lutz'', ''julien'')'.	statement := conn createStatement: 'SELECT * FROM CATS'.	result := statement execute.	self assert: (result first at: 1) equals: 'lutz'.	self assert: (result first at: 2) equals: 'julien'.		result := statement execute.	self assert: (result first at: 1) equals: 'lutz'.	self assert: (result first at: 2) equals: 'julien'.! !!GAStatementTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 2/19/2015 17:49'!testStatementDoesNotAcceptBindings	| statementString statement |	statementString := 'CREATE TABLE CATS (	name varchar(50),	owner varchar(50))'.	statement := conn createStatement: statementString.		self should: [ statement at: 1 bind: 'unbinded' ] raise: Error.! !!GATransactionTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/24/2015 14:08'!testAutocommit		self assert: conn hasAutoCommit equals: conn defaultValueAutoCommit! !!GATransactionTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 2/8/2015 17:22'!testCommit	| result row  |	conn beginTransaction.	conn execute: 'INSERT INTO student(id) VALUES (1)'.	conn execute: 'INSERT INTO signature(code, name, observations, id_student) VALUES (59, ''TADP'', ''Tecnicas Av'', 1)'.	result := conn execute: 'SELECT code, name, observations, id_student FROM signature'.	row := result first.		self assert: (row at: 1) equals: 59.	self assert: (row at: 2) equals: 'TADP'.	self assert: (row at: 3) equals: 'Tecnicas Av'.	self assert: (row at: 4) equals: 1.		conn commitTransaction.		result := conn execute: 'SELECT code, name, observations, id_student FROM signature'.	row := result first.		self assert: (row at: 1) equals: 59.	self assert: (row at: 2) equals: 'TADP'.	self assert: (row at: 3) equals: 'Tecnicas Av'.	self assert: (row at: 4) equals: 1.! !!GATransactionTest methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 2/8/2015 17:25'!testRollback	| result row |	"self debug: #testRollback"	conn beginTransaction.	conn execute: 'INSERT INTO student(id) VALUES (1)'.	conn execute: 'INSERT INTO signature(code, name, observations, id_student) VALUES (59, ''TADP'', ''Tecnicas Av'', 1)'.		result := conn execute: 'SELECT code, name, observations, id_student FROM signature'.	row := result first.		self assert: (row at: 1) equals: 59.	self assert: (row at: 2) equals: 'TADP'.	self assert: (row at: 3) equals: 'Tecnicas Av'.	self assert: (row at: 4) equals: 1.		conn rollbackTransaction.		result := conn execute: 'SELECT code, name, observations, id_student FROM signature'.	self assert: result isEmpty.! !!GAConnectionString class methodsFor: 'instance creation' stamp: 'GuillermoPolito 4/17/2015 14:22'!fromString: aString 		^ self new		initializeFromString: aString;		yourself! !!GAConnectionString methodsFor: 'private' stamp: 'GuillermoPolito 4/27/2015 14:42'!addOptions: aDictionaryOfOptions	self options addAll: aDictionaryOfOptions! !!GAConnectionString methodsFor: 'accessing' stamp: 'GuillermoPolito 4/17/2015 14:27'!database		^ connectionString path! !!GAConnectionString methodsFor: 'accessing' stamp: 'GuillermoPolito 4/17/2015 14:33'!driverId		^ connectionString scheme! !!GAConnectionString methodsFor: 'accessing' stamp: 'GuillermoPolito 4/17/2015 14:30'!host		^ connectionString host! !!GAConnectionString methodsFor: 'initialize - release' stamp: 'GuillermoPolito 4/17/2015 14:22'!initializeFromString: aString 		connectionString := aString asZnUrl! !!GAConnectionString methodsFor: 'accessing' stamp: 'GuillermoPolito 4/17/2015 14:29'!optionAt: aString 		^ self options at: aString ifAbsent: ''! !!GAConnectionString methodsFor: 'accessing' stamp: 'GuillermoPolito 4/17/2015 15:31'!optionAt: aString ifAbsent: aBlockClosure 		^ self options at: aString ifAbsent: aBlockClosure! !!GAConnectionString methodsFor: 'private' stamp: 'GuillermoPolito 4/27/2015 14:41'!options		^ options ifNil: [ options := connectionString query 		ifNil: [ Dictionary new ] ifNotNilDo: #asDictionary]! !!GAConnectionString methodsFor: 'accessing' stamp: 'GuillermoPolito 4/17/2015 14:28'!password		^ self optionAt: 'password'! !!GAConnectionString methodsFor: 'accessing' stamp: 'GuillermoPolito 4/17/2015 14:24'!port		^ connectionString port! !!GAConnectionString methodsFor: 'accessing' stamp: 'GuillermoPolito 4/17/2015 14:29'!user		^ self optionAt: 'user'! !!GAContinuousIntegrationConfiguration methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/17/2015 16:37'!configureFixtureWithConnectionString: aConnectionString andSetupConnectionString: aSetupConnectionString		GADriverTest fixture: (GADriverTestFixture 		setupConnectionString: aSetupConnectionString		connectionString: aConnectionString).! !!GAContinuousIntegrationConfiguration methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/17/2015 16:38'!configureMysql	self		configureFixtureWithConnectionString: 'mysql://localhost:3306/sodbxtest?user=sodbxtest&password=sodbxtest'		andSetupConnectionString: 'mysql://localhost:3306?user=sodbxtest&password=sodbxtest'.! !!GAContinuousIntegrationConfiguration methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/19/2015 23:19'!configureOpenDbxSqlite	self		configureFixtureWithConnectionString: 'opendbx://memory?backend=sqlite3'		andSetupConnectionString: 'opendbx://memory?backend=sqlite3'.! !!GAContinuousIntegrationConfiguration methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/19/2015 18:18'!configurePostgresql	self		configureFixtureWithConnectionString: 'postgresV2://localhost:5432/sodbxtest?user=sodbxtest&password=sodbxtest'		andSetupConnectionString: 'postgresV2://localhost:5432/postgres?user=postgres&password=postgres'.! !!GAContinuousIntegrationConfiguration methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/17/2015 16:40'!configureSqlite3	self		configureFixtureWithConnectionString: 'sqlite3://memory'		andSetupConnectionString: 'sqlite3://memory'.! !!GADriver class methodsFor: 'accessing' stamp: 'GuillermoPolito 5/5/2015 11:48'!availableDrivers		^ Drivers availableDrivers! !!GADriver class methodsFor: 'instance-creation' stamp: 'GuillermoPolito 2/8/2015 09:34'!connectToConnectionString: aConnectionString	| connection |	connection := self fromConnectionString: aConnectionString.	connection connect.	^ connection! !!GADriver class methodsFor: 'drivers' stamp: 'GuillermoPolito 5/5/2015 11:44'!driverAt: aDriverId		^ Drivers driverAt: aDriverId! !!GADriver class methodsFor: 'drivers' stamp: 'GuillermoPolito 1/21/2015 13:52'!driverId	^ self subclassResponsibility! !!GADriver class methodsFor: 'instance-creation' stamp: 'GuillermoPolito 4/27/2015 14:42'!fromConnectionString: string		| connectionString |	string isString ifTrue: [connectionString := GAConnectionString fromString: string]		ifFalse: [ connectionString := string ].	^ (self driverAt: connectionString driverId) fromConnectionString: connectionString! !!GADriver class methodsFor: 'initialize' stamp: 'GuillermoPolito 5/5/2015 11:44'!initialize	Drivers := GADriverManager new.! !!GADriver class methodsFor: 'drivers' stamp: 'GuillermoPolito 5/5/2015 11:48'!isAvailable: aKey		^ Drivers isAvailable: aKey! !!GADriver class methodsFor: 'tests' stamp: 'GuillermoPolito 4/17/2015 17:04'!newFixture	^ self subclassResponsibility! !!GADriver class methodsFor: 'tests' stamp: 'GuillermoPolito 4/19/2015 19:26'!newFixtureForConnectionString: aConnectionString	^ self newFixture! !!GADriver class methodsFor: 'drivers' stamp: 'GuillermoPolito 5/5/2015 11:47'!subscribeDriver	Drivers subscribeDriver: self! !!GADriver class methodsFor: 'testing' stamp: 'GuillermoPolito 4/29/2015 11:52'!supportsEncoding: anEncoding		self subclassResponsibility! !!GADriver methodsFor: 'testing' stamp: 'GuillermoPolito 5/5/2015 15:18'!affectsOnlyChangedRows	"Tests if the current database driver will inform the number of effectively affected rows during a INSERT/UPDATE/DELETE query or just all that were selected by the WHERE clause"	^ false! !!GADriver methodsFor: 'accessing' stamp: 'GuillermoPolito 1/21/2015 18:06'!backend		^ self subclassResponsibility! !!GADriver methodsFor: 'transactions' stamp: 'GuillermoPolito 5/5/2015 15:25'!beginTransaction	"Starts a database transaction"	self subclassResponsibility! !!GADriver methodsFor: 'connection' stamp: 'GuillermoPolito 5/5/2015 15:09'!close	"Closes the current connection"	self subclassResponsibility! !!GADriver methodsFor: 'transactions' stamp: 'GuillermoPolito 5/5/2015 15:25'!commitTransaction	"Commits the current database transaction"	self subclassResponsibility! !!GADriver methodsFor: 'connection' stamp: 'GuillermoPolito 5/5/2015 15:10'!connect	"Opens the connection to the configured database"	self subclassResponsibility! !!GADriver methodsFor: 'accessing' stamp: 'GuillermoPolito 4/27/2015 11:12'!connectionString		^ connectionString! !!GADriver methodsFor: 'accessing' stamp: 'GuillermoPolito 4/27/2015 11:14'!connectionString: aGAConnectionString 	connectionString := aGAConnectionString! !!GADriver methodsFor: 'statement' stamp: 'GuillermoPolito 5/5/2015 15:16'!createStatement		"Creates an empty statement object"	self subclassResponsibility! !!GADriver methodsFor: 'statement' stamp: 'GuillermoPolito 5/5/2015 15:16'!createStatement: aSQLString		"Creates a statement object from a sql query"	self subclassResponsibility! !!GADriver methodsFor: 'transactions' stamp: 'GuillermoPolito 5/5/2015 15:26'!defaultValueAutoCommit	"Retrieves the expected default value of autocommit for the current driver.	Autocommit should not be used in a general fashion: each database vendor implements it differently."	self subclassResponsibility! !!GADriver methodsFor: 'accessing' stamp: 'GuillermoPolito 4/17/2015 14:33'!driverId	^ self class driverId! !!GADriver methodsFor: 'encoding' stamp: 'GuillermoPolito 5/5/2015 15:11'!encoder		| theEncoding |	"Returns a Zn encoder corresponding to the configured encoding.	Default: 'utf8'"	theEncoding := (self encoding = 'utf8mb4') ifTrue: [ 'utf8' ] ifFalse: [ self encoding ].	^ ZnCharacterEncoder newForEncoding: theEncoding! !!GADriver methodsFor: 'encoding' stamp: 'GuillermoPolito 5/5/2015 15:11'!encoding		"Returns the configured encoding for this driver instance.	Default: 'utf8'"	^ encoding ifNil: [ encoding := connectionString optionAt: 'encoding' ifAbsent: 'utf8' ]! !!GADriver methodsFor: 'encoding' stamp: 'GuillermoPolito 5/5/2015 15:12'!encoding: anEncoding		"Sets an encoding for the current driver instance.	Accepted encodings are those supported by ZnCharacterEncoder"	encoding := anEncoding! !!GADriver methodsFor: 'query' stamp: 'GuillermoPolito 5/5/2015 15:15'!execute: aQuery	"Executes a SQL query against the database in one roundtrip"	self subclassResponsibility! !!GADriver methodsFor: 'finalization' stamp: 'GuillermoPolito 5/5/2015 15:14'!finalize	"Frees all associated resources of this driver instance"! !!GADriver methodsFor: 'transactions' stamp: 'GuillermoPolito 5/5/2015 15:27'!hasAutoCommit	"Tests if the current database driver has autocommit enabled or not"	self subclassResponsibility! !!GADriver methodsFor: 'testing' stamp: 'GuillermoPolito 5/5/2015 15:18'!isConnected	"Tests if the connection is alive and connected"	self subclassResponsibility! !!GADriver methodsFor: 'finalization' stamp: 'GuillermoPolito 5/5/2015 15:14'!isRegisteredForFinalization	"Tests if the current driver instance is registered in the weak registry for finalization or not"	^ WeakRegistry default includes: self! !!GADriver methodsFor: 'testing' stamp: 'GuillermoPolito 5/5/2015 15:19'!notBoundArgumentsFail		"Tests if the current database driver fails if a prepared statement contains arguments that are not bound. Some drivers such as Sqlite3 will default unbound arguments to NULL and not fail."	^ true! !!GADriver methodsFor: 'accessing' stamp: 'GuillermoPolito 5/5/2015 15:09'!numberOfFetchesForSingleExecute	"Returns the number of roundtrips a database driver does for a single execute command"	^ 1! !!GADriver methodsFor: 'options' stamp: 'GuillermoPolito 5/5/2015 15:14'!optionAt: aString 		"It allows to access the configuration options of this driver"	^ self connectionString optionAt: aString! !!GADriver methodsFor: 'statement' stamp: 'GuillermoPolito 5/5/2015 15:16'!prepare: aQuery	"Creates a statement object from a sql query and sends it for its preparation to the database server"	self subclassResponsibility! !!GADriver methodsFor: 'finalization' stamp: 'GuillermoPolito 5/5/2015 15:13'!register	"Registers the current driver into the weak registry for automatic memory management"	WeakRegistry default add: self! !!GADriver methodsFor: 'transactions' stamp: 'GuillermoPolito 5/5/2015 15:27'!rollbackTransaction	"Rollbacks the current database transaction"	self subclassResponsibility! !!GADriver methodsFor: 'testing' stamp: 'GuillermoPolito 5/5/2015 15:23'!supportsAutomaticQueryEncoding		"Tests if the current database driver supports not-encoded strings inside a sql query.	When true the driver will encode the full request into the configured encoding and the user does not have to manage it.	When false the driver does not support encoding the query and thus the user has to encode manually arguments if building a query by String concatenation.		Alternatively, use prepared statements when supported to avoid this issue"	self subclassResponsibility! !!GADriver methodsFor: 'testing' stamp: 'GuillermoPolito 5/5/2015 15:23'!supportsCursoredFetch	"Tests if the current database driver supports cursored fetches. i.e., bringing database rows in batch instead of all in a row."	^ self subclassResponsibility! !!GADriver methodsFor: 'encoding' stamp: 'GuillermoPolito 5/5/2015 15:12'!supportsEncoding: anEncoding		"Returns a boolean that indicates if the current driver supports a particular encoding"	^ self class supportsEncoding: anEncoding! !!GADriver methodsFor: 'testing' stamp: 'GuillermoPolito 5/5/2015 15:24'!supportsPreparedStatements	"Tests if the current database driver supports prepared statements"	^ false! !!GADriver methodsFor: 'testing' stamp: 'GuillermoPolito 5/5/2015 15:25'!supportsRetrievingGeneratedKeys	"Tests if the current database driver supports retrieving auto generated keys/ids without an extra query"	^ false! !!GADriver methodsFor: 'finalization' stamp: 'GuillermoPolito 5/5/2015 15:13'!unregister	"Unregisters the current driver from the weak registry. Calling this means that finalization will be manual"	WeakRegistry default remove: self ifAbsent: [  ]! !!GADriverManager methodsFor: 'accessing' stamp: 'GuillermoPolito 5/5/2015 16:05'!availableDrivers		"Returns the available database drivers"	self cleanUp.	^ drivers keys! !!GADriverManager methodsFor: 'cleanup' stamp: 'GuillermoPolito 5/5/2015 16:05'!cleanUp	| toClean |	"Private. Cleans up the current manager. If drivers were unloaded they will be removed from the manager on garbage collection."	Smalltalk garbageCollect.	toClean := drivers keys select: [ :key | (drivers at: key) isNil ].	toClean do: [:key | drivers removeKey: key ]! !!GADriverManager methodsFor: 'drivers' stamp: 'GuillermoPolito 5/5/2015 16:06'!driverAt: aDriverId		"Returns the available driver with the id given as argument. If no driver is available with such id, an exception is risen."	^ drivers at: aDriverId ifAbsent: [ self error: ('No driver configured with id {1}' format: { aDriverId }) ]! !!GADriverManager methodsFor: 'initialization' stamp: 'GuillermoPolito 5/5/2015 16:06'!initialize	super initialize.	drivers := WeakValueDictionary new.! !!GADriverManager methodsFor: 'testing' stamp: 'GuillermoPolito 5/5/2015 16:07'!isAvailable: aDriverId		"Tests if a driver is available with the id given as argument."	self cleanUp.	^ drivers includesKey: aDriverId asLowercase asSymbol! !!GADriverManager methodsFor: 'drivers' stamp: 'GuillermoPolito 5/5/2015 16:07'!subscribeDriver: aDriver	"Subscribes weakly the driver given as argument in the current manager"	drivers at: aDriver driverId asLowercase asSymbol put: aDriver! !!GADriverMysqlTestFixture methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/29/2015 09:50'!createDatabase	setupConnection execute: 'CREATE DATABASE sodbxtest	CHARACTER SET utf8mb4'.! !!GADriverMysqlTestFixture methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 1/30/2015 13:56'!createTables	self connection execute: 'CREATE TABLE IF NOT EXISTS student(	   id INTEGER AUTO_INCREMENT,	   username VARCHAR(10),	   pass VARCHAR(50),	   mail VARCHAR(50),	   name_surname VARCHAR(30),	   	   regular BOOLEAN,	   age SMALLINT,	   	   average_grade DECIMAL(9,3),	   sex CHARACTER(3),	   description VARCHAR(200),	   starting_hour TIME,	   sign_up_date DATETIME,	   born_date DATE,	   nullable_field VARCHAR(64) NULL,	  CONSTRAINT pk_students_id PRIMARY KEY (id)	) ENGINE = InnoDB ;'."The InnoDB engine is in order to have transaction in this table"		self connection execute: 'CREATE TABLE IF NOT EXISTS signature(	code INTEGER, 	id_student INTEGER,	name CHAR(100),	observations VARCHAR(255),	course_grade INTEGER,	final_grade INTEGER,	CONSTRAINT pk_signatures_code PRIMARY KEY (id_student, code)) ENGINE = InnoDB '."The InnoDB engine is in order to have transaction in this table"	self connection execute: 'CREATE TABLE IF NOT EXISTS course(	id_course INTEGER,	id_student INTEGER,	signature_code INTEGER,	starting_date DATE,	CONSTRAINT pk_courses_id_course PRIMARY KEY (id_student, signature_code)) ENGINE = InnoDB '."The InnoDB engine is in order to have transaction in this table"	self connection execute: 'ALTER TABLE signature	ADD CONSTRAINT se_st_fk FOREIGN KEY (id_student) REFERENCES student(id)'.! !!GADriverMysqlTestFixture methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/29/2015 12:02'!dropDatabase	setupConnection ifNil: [ ^ self ].	setupConnection execute: 'drop database if exists sodbxtest'.! !!GADriverMysqlTestFixture methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 1/23/2015 12:20'!dropTables	self connection execute: 'ALTER TABLE signature	DROP FOREIGN KEY se_st_fk'.	self connection execute: 'DROP TABLE IF EXISTS course CASCADE'.	self connection execute: 'DROP TABLE IF EXISTS signature CASCADE'. 	self connection execute: 'DROP TABLE IF EXISTS student CASCADE'.! !!GADriverPostgresqlTestFixture methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/21/2015 11:27'!createDatabase	setupConnection execute: 'CREATE DATABASE sodbxtest'.! !!GADriverPostgresqlTestFixture methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/21/2015 11:35'!createTables	self connection execute: 'CREATE TABLE student(   	   id SERIAL PRIMARY KEY,	   name_surname VARCHAR,		   username VARCHAR(10),         pass VARCHAR(200),	   mail VARCHAR(50),         regular BOOLEAN,	   age SMALLINT,	   	   average_grade DECIMAL(9,3),	   sex CHARACTER(3),	   description VARCHAR,	   starting_hour TIME,	   sign_up_date TIMESTAMP,	   born_date DATE,	   nullable_field VARCHAR(64) NULL	)'."The InnoDB engine is in order to have transaction in this table"		self connection execute: 'CREATE TABLE IF NOT EXISTS signature(	code INTEGER, 	id_student INTEGER,	name VARCHAR(100),	observations VARCHAR(255),	course_grade INTEGER,	final_grade INTEGER,	CONSTRAINT pk_signatures_code PRIMARY KEY (id_student, code))'."The InnoDB engine is in order to have transaction in this table"	self connection execute: 'CREATE TABLE IF NOT EXISTS course(	id_course INTEGER,	id_student INTEGER,	signature_code INTEGER,	starting_date DATE,	CONSTRAINT pk_courses_id_course PRIMARY KEY (id_student, signature_code))'."The InnoDB engine is in order to have transaction in this table"	self connection execute: 'ALTER TABLE signature	ADD CONSTRAINT se_st_fk FOREIGN KEY (id_student) REFERENCES student(id)'.! !!GADriverPostgresqlTestFixture methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/21/2015 11:27'!dropDatabase	setupConnection execute: 'DROP DATABASE IF EXISTS sodbxtest'.! !!GADriverPostgresqlTestFixture methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/21/2015 14:29'!dropTables	self connection execute: 'DROP TABLE IF EXISTS course CASCADE'.	self connection execute: 'DROP TABLE IF EXISTS signature CASCADE'. 	self connection execute: 'DROP TABLE IF EXISTS student CASCADE'.! !!GADriverSQLiteTestFixture methodsFor: 'as yet unclassified' stamp: 'Anonymous 4/19/2015 19:40'!connection		^ setupConnection! !!GADriverSQLiteTestFixture methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/27/2015 17:38'!createDatabase	"Nothing"	| encoding |		encoding := self connection encoding = 'utf8' ifTrue: [ 'UTF-8' ] ifFalse: ['UTF-16' ].	self connection execute: 'PRAGMA encoding = "',encoding,'"'.! !!GADriverSQLiteTestFixture methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 1/30/2015 15:51'!createTables	self connection execute: 'CREATE TABLE student(	   id INTEGER,	   name_surname CHARACTER VARYING(30),	   	   username VARCHAR(10),        pass VARCHAR(10),        mail VARCHAR(50),        regular BOOLEAN,	   age SMALLINT,	   	   average_grade DECIMAL(9,3),	   sex CHARACTER(3),	   description CHARACTER VARYING(200),	   starting_hour TIME,	   sign_up_date TIMESTAMP,	   born_date DATE,	   nullable_field VARCHAR(64) NULL,	  CONSTRAINT pk_students_id PRIMARY KEY (id)	)'.	self connection execute: 'CREATE TABLE signature(	code INTEGER,	id_student INTEGER,	name CHARACTER VARYING(50),	course_grade INTEGER,	final_grade INTEGER,	observations CHARACTER VARYING(255))'.	self connection execute: 'CREATE TABLE course(	id_course INTEGER,	id_student INTEGER,	code_signature INTEGER,	starting_date DATE,	CONSTRAINT pk_courses_id_course PRIMARY KEY (id_student, code_signature))'.! !!GADriverSQLiteTestFixture methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/19/2015 19:44'!dropDatabase	"We remove the database file"	self connection isMemory ifFalse: [ self connection database asFileReference delete ].! !!GADriverSQLiteTestFixture methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 1/30/2015 14:01'!dropTables	self connection execute: 'DROP TABLE course'.	self connection execute: 'DROP TABLE signature'.	self connection execute: 'DROP TABLE student'.! !!GADriverSQLiteTestFixture methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/27/2015 11:00'!newConnection: options	"We always create the connection for testing with the same options in sqlite by the moment"	^ setupConnection! !!GADriverSQLiteTestFixture methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 5/5/2015 15:00'!tearDown	setupConnection ifNotNilDo: #close.	setupConnection := nil.! !!GADriverTestFixture class methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/19/2015 19:29'!setupConnectionString: setupConnectionString connectionString: connectionString	| theConnectionString |	theConnectionString := GAConnectionString fromString: setupConnectionString.	^ ((GADriver driverAt: theConnectionString driverId)			newFixtureForConnectionString: theConnectionString)			setupConnectionString: setupConnectionString;			connectionString: connectionString;			yourself! !!GADriverTestFixture methodsFor: 'accessing' stamp: 'GuillermoPolito 4/21/2015 15:02'!connection		^ connection ifNil:[ connection := self newConnection ]! !!GADriverTestFixture methodsFor: 'accessing' stamp: 'GuillermoPolito 4/17/2015 16:04'!connectionString	^ connectionString! !!GADriverTestFixture methodsFor: 'accessing' stamp: 'GuillermoPolito 1/23/2015 11:18'!connectionString: aConnectionString	connectionString := aConnectionString! !!GADriverTestFixture methodsFor: 'setting up' stamp: 'GuillermoPolito 1/23/2015 10:49'!createDatabase	self subclassResponsibility! !!GADriverTestFixture methodsFor: 'setting up' stamp: 'GuillermoPolito 4/27/2015 14:40'!createSetupConnection	setupConnection := GADriver connectToConnectionString: 		((GAConnectionString fromString: setupConnectionString) addOptions: options).! !!GADriverTestFixture methodsFor: 'setting up' stamp: 'GuillermoPolito 1/23/2015 10:51'!createTables	self subclassResponsibility! !!GADriverTestFixture methodsFor: 'accessing' stamp: 'GuillermoPolito 4/29/2015 11:51'!driver		^ GADriver driverAt: (GAConnectionString fromString: setupConnectionString) driverId! !!GADriverTestFixture methodsFor: 'setting up' stamp: 'GuillermoPolito 1/23/2015 10:49'!dropDatabase	self subclassResponsibility! !!GADriverTestFixture methodsFor: 'setting up' stamp: 'GuillermoPolito 1/23/2015 10:50'!dropTables	self subclassResponsibility! !!GADriverTestFixture methodsFor: 'setting up' stamp: 'GuillermoPolito 4/27/2015 14:49'!newConnection	^ GADriver connectToConnectionString: 		((GAConnectionString fromString: connectionString) addOptions: options).! !!GADriverTestFixture methodsFor: 'setting up' stamp: 'GuillermoPolito 4/27/2015 14:40'!setUp	"We create the connection that will create the database. The other one will be created lazily"	self setUp: Dictionary new! !!GADriverTestFixture methodsFor: 'setting up' stamp: 'GuillermoPolito 4/27/2015 16:19'!setUp: someOptions	"We create the connection that will create the database. The other one will be created lazily"	options := someOptions.	connection := setupConnection := nil.	self createSetupConnection.	self dropDatabase.	self createDatabase.	self createTables.! !!GADriverTestFixture methodsFor: 'accessing' stamp: 'GuillermoPolito 4/17/2015 16:58'!setupConnectionString: aConnectionString	setupConnectionString := aConnectionString! !!GADriverTestFixture methodsFor: 'setting up' stamp: 'GuillermoPolito 4/29/2015 12:02'!tearDown	options := nil.	[connection ifNotNil: [ 		connection close.		connection := nil. ].]		ensure: [		[self dropDatabase.]			ensure: [			setupConnection ifNotNil: [			setupConnection close.			setupConnection := nil ]]]! !!GAFetchCounter methodsFor: 'events' stamp: 'GuillermoPolito 4/23/2015 17:23'!fetchOccurred		fetches := fetches + 1! !!GAFetchCounter methodsFor: 'accessing' stamp: 'GuillermoPolito 4/23/2015 17:00'!fetches		^ fetches! !!GAFetchCounter methodsFor: 'accessing' stamp: 'GuillermoPolito 4/23/2015 17:23'!initialize	super initialize.	fetches := 0! !!GAFetchHalter methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/23/2015 17:27'!fetchOccurred	self halt.! !!GAMockDriver methodsFor: 'accessing' stamp: 'GuillermoPolito 5/5/2015 11:39'!driverId		^ 'id'! !!GAResultSet methodsFor: 'testing' stamp: 'GuillermoPolito 5/5/2015 16:07'!at: anIndex		"Accesses the nth row of the result set"	self subclassResponsibility! !!GAResultSet methodsFor: 'iterating' stamp: 'GuillermoPolito 5/5/2015 16:07'!collect: aBlockClosure 		"A collect on the rows of the result set."	^ self subclassResponsibility! !!GAResultSet methodsFor: 'iterating' stamp: 'GuillermoPolito 5/5/2015 16:07'!do: aBlockClosure 		"A do on the rows of the result set."	^ self subclassResponsibility! !!GAResultSet methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 5/5/2015 16:08'!first		"returns the first row of the result set"	^ self subclassResponsibility! !!GAResultSet methodsFor: 'testing' stamp: 'GuillermoPolito 5/5/2015 16:12'!isEmpty		"Returns if the result set has no rows"	self subclassResponsibility! !!GAResultSet methodsFor: 'streaming' stamp: 'GuillermoPolito 5/5/2015 16:12'!readStream		"Returns a read stream for the current result set"	self subclassResponsibility! !!GAResultSet methodsFor: 'testing' stamp: 'GuillermoPolito 5/5/2015 16:13'!rowAt: anIndex		"Returns the nth row of the result set. Equivalent to #at:"	^ self at: anIndex! !!GAResultSet methodsFor: 'iterating' stamp: 'GuillermoPolito 5/5/2015 16:07'!select: aBlockClosure 		"A select on the rows of the result set."	^ self subclassResponsibility! !!GAResultSetReadStream class methodsFor: 'instance creation' stamp: 'GuillermoPolito 2/8/2015 16:08'!on: aResultSet	^ self new 		on: aResultSet;		yourself! !!GAResultSetReadStream methodsFor: 'accessing' stamp: 'GuillermoPolito 5/5/2015 16:15'!currentRow		"Gets the current row of the stream"	self flag: #possibleBug.	^ [ resultSet rowAt: position ] on: SubscriptOutOfBounds do: [ nil ]! !!GAResultSetReadStream methodsFor: 'initialization-release' stamp: 'GuillermoPolito 2/8/2015 16:10'!initialize		super initialize.	position := 0.! !!GAResultSetReadStream methodsFor: 'accessing' stamp: 'GuillermoPolito 5/5/2015 16:17'!next		"Advances the stream and retrieves the row at the current position. If no more rows are available, it returns nil."	position := position + 1.	^ self currentRow.! !!GAResultSetReadStream methodsFor: 'iterating' stamp: 'GuillermoPolito 5/5/2015 16:17'!next: anInteger		"Advances the stream and tries to retrieve the following N rows of the result set. If not enough rows are available, the retrieved array will contain only the available elements."	^ Array streamContents: [ :str | anInteger timesRepeat: [ 			self next ifNotNilDo: [ :next | str nextPut: next ] ] ]! !!GAResultSetReadStream methodsFor: 'initialization-release' stamp: 'GuillermoPolito 5/5/2015 16:17'!on: aResultSet 	resultSet := aResultSet! !!GAStatement class methodsFor: 'accessing' stamp: 'GuillermoPolito 1/30/2015 11:40'!onConnection: aPGConnection 		^ self new		connection: aPGConnection;		yourself! !!GAStatement methodsFor: 'bindings' stamp: 'GuillermoPolito 5/5/2015 16:24'!at: aColumn bind: anObject	"Binds a column at a particular index with an object. Objects are automatically transformed by the driver into the corresponding 	database representation."	self subclassResponsibility! !!GAStatement methodsFor: 'accessing' stamp: 'GuillermoPolito 1/21/2015 16:24'!connection: anOpenDBXConnection 		connection := anOpenDBXConnection! !!GAStatement methodsFor: 'execute' stamp: 'GuillermoPolito 5/5/2015 16:25'!execute	"It executes the current statement."	fetchListener ifNotNilDo: #fetchOccurred.	^ connection execute: statement.! !!GAStatement methodsFor: 'accessing' stamp: 'GuillermoPolito 5/5/2015 16:22'!fetchListener: aGAFetchListener		"Sets a fetch listener to listen when the statement performs a roundtrip to the database."	fetchListener := aGAFetchListener! !!GAStatement methodsFor: 'execute' stamp: 'GuillermoPolito 5/5/2015 16:25'!fetchSize: anInteger 		"It sets the fetch size or the current statement, for batch retrieving."	self subclassResponsibility! !!GAStatement methodsFor: 'initialize-release' stamp: 'GuillermoPolito 2/19/2015 16:02'!initialize	super initialize.	arguments := OrderedCollection new.	prepared := false.! !!GAStatement methodsFor: 'bindings' stamp: 'GuillermoPolito 5/5/2015 16:25'!placeholderAt: anInteger 		"Returns the placeholder that should correspond for a prepared statement at a given index.	This method is meant to handle compatibility between databases that accept '?' like placeholders and others that accept '$1' like placeholders."	^ '?'! !!GAStatement methodsFor: 'execute' stamp: 'GuillermoPolito 5/5/2015 16:26'!prepare	"It prepares the current statement if the driver supports prepared statements."	prepared ifTrue: [ self error: 'This statement is already prepared' ].	prepared := true.! !!GAStatement methodsFor: 'accessing' stamp: 'GuillermoPolito 5/5/2015 16:22'!propertyAt: aKey	"Obtains the property set at a key"	^ self propertyAt: aKey ifAbsent: [ self error: 'unexistent key: ', aKey ]! !!GAStatement methodsFor: 'accessing' stamp: 'GuillermoPolito 5/5/2015 16:22'!propertyAt: aKey ifAbsent: aBlock	"Obtains the property set at a key. If absent, aBlock is executed."	properties ifNil: [ ^ aBlock value ].	^ properties at: aKey ifAbsent: aBlock! !!GAStatement methodsFor: 'accessing' stamp: 'GuillermoPolito 5/5/2015 16:23'!propertyAt: aKey put: aValue	"Sets the property with the given key with the given value"	properties ifNil: [ properties := Dictionary new ].	properties at: aKey put: aValue! !!GAStatement methodsFor: 'accessing' stamp: 'GuillermoPolito 5/5/2015 16:23'!statementString		"Gets the SQL query string of the statement"	^ statement! !!GAStatement methodsFor: 'accessing' stamp: 'GuillermoPolito 5/5/2015 16:23'!statementString: queryStatement		"Sets the SQL query string of the statement"	statement := queryStatement! !"Garage"!!DBXNullTextConverter commentStamp: '<historical>' prior: 0!I don't do any conversion between the Strings (ByteArrays) I receive. I simply pass the data as it.Basically I am used to remove isNil checks.!!DBXBackend commentStamp: 'EL 8/16/2008 09:53' prior: 0!I am the platform abstraction layer. I comunicate directly with OpenDBX, and provide a fplatform specific abstraction layer. !!DBXFirebirdBackend commentStamp: 'TorstenBergmann 5/27/2014 10:28' prior: 0!A backend for the firebird database!!DBXMSSQLBackend commentStamp: 'TorstenBergmann 5/27/2014 10:29' prior: 0!A backend for the Microsoft SQL database!!DBXODBCMSSQLBackend commentStamp: 'TorstenBergmann 5/27/2014 10:29' prior: 0!A backend for the Microsoft SQL database via ODBC!!DBXMySQLBackend commentStamp: 'EL 8/16/2008 09:53' prior: 0!I am the MySQL specific platform definition. Instance Variables	handle:		<Object>handle	- xxxxx!!DBXMySQL4Backend commentStamp: 'TorstenBergmann 5/27/2014 10:29' prior: 0!A backend for the MySQL database (version 4)!!DBXOdbcBackend commentStamp: 'TorstenBergmann 5/27/2014 10:31' prior: 0!General ODBC backend!!DBXOracleBackend commentStamp: 'EL 8/16/2008 09:53' prior: 0!I am the Oracle specific platform definition. Instance Variables	handle:		<Object>handle	- xxxxx!!DBXPostgresBackend commentStamp: 'EL 8/16/2008 09:53' prior: 0!I am the PostgreSQL specific platform definition. Instance Variables!!DBXSqliteBackend commentStamp: 'TorstenBergmann 5/27/2014 10:31' prior: 0!Backend for SQLite database!!DBXConnection commentStamp: 'SantiagoBragagnolo 6/18/2011 22:25' prior: 0!Example: 	conn := DBXConnection new.backend := DBXPostgresBackend new.conn platform:  backend.conn settings: (DBXConnectionSettings host: 'localhost' port: '5432'  database:  'sodbxtest' userName: 'sodbxtest' userPassword: 'sodbxtest'  )   .conn connect.conn open.descriptions := conn tablesDescription .!!DBXAutomaticEncoding commentStamp: '<historical>' prior: 0!I am encoding strategy that asks the object about the encoding using message queryEncoding.!!DBXNoEncoding commentStamp: '<historical>' prior: 0!I am encoding strategy for the cases where no encoding is required.!!DBXStaticEncoding commentStamp: '<historical>' prior: 0!I am encoding strategy that simply returns predetermined TextConverter. Actually a copy of it.Instance Variables:	encoder	TextConverter which is copied when encoderFor: is called.!!DBXSpecialOptions commentStamp: 'TorstenBergmann 5/27/2014 10:32' prior: 0!Represents special options for the DBX interface!!DBXTypeNotSupported commentStamp: 'EL 8/3/2008 08:33' prior: 0!I'm an unsupported data typeInstance Variables!!NBOpenDBX_ApiH class methodsFor: 'nativeboost types' stamp: 'RocioAmaya 8/22/2013 06:34'!nbBindingOf: aTypeName	^ LibOpenDBXMap at: aTypeName! !!NBOpenDBX_ApiH class methodsFor: 'library path' stamp: 'RocioAmaya 8/22/2013 06:34'!nbLibraryNameOrHandle	^ LibOpenDBXMap libraryNameOrHandle! !!NBOpenDBX_ApiH methodsFor: 'foreign interface' stamp: 'RocioAmaya 8/22/2013 06:34'!odbx_bind: handle database: database who: who cred: cred method: method 	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^self call: #(NBInt32 odbx_bind(NBOpenDBX_OdbxTO handle, NBCharacterType * database, NBCharacterType * who, NBCharacterType * cred, NBInt32 method)) options: #(  )! !!NBOpenDBX_ApiH methodsFor: 'foreign interface' stamp: 'RocioAmaya 8/22/2013 06:34'!odbx_bind_simple: handle database: database username: username password: password 	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^self call: #(NBInt32 odbx_bind_simple(NBOpenDBX_OdbxTO handle, NBCharacterType * database, NBCharacterType * username, NBCharacterType * password)) options: #(  )! !!NBOpenDBX_ApiH methodsFor: 'foreign interface' stamp: 'RocioAmaya 8/22/2013 06:34'!odbx_capabilities: handle cap: cap 	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^self call: #(NBInt32 odbx_capabilities(NBOpenDBX_OdbxTO handle, NBUInt32 cap)) options: #(  )! !!NBOpenDBX_ApiH methodsFor: 'foreign interface' stamp: 'RocioAmaya 8/22/2013 06:34'!odbx_column_count: result 	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^self call: #(NBUInt32 odbx_column_count(NBOpenDBX_OdbxResultTO result)) options: #(  )! !!NBOpenDBX_ApiH methodsFor: 'foreign interface' stamp: 'RocioAmaya 8/22/2013 06:34'!odbx_column_name: result pos: pos 	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^self call: #(NBCharacterType * odbx_column_name(NBOpenDBX_OdbxResultTO result, NBUInt32 pos)) options: #(  )! !!NBOpenDBX_ApiH methodsFor: 'foreign interface' stamp: 'RocioAmaya 8/22/2013 06:34'!odbx_column_type: result pos: pos 	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^self call: #(NBInt32 odbx_column_type(NBOpenDBX_OdbxResultTO result, NBUInt32 pos)) options: #(  )! !!NBOpenDBX_ApiH methodsFor: 'foreign interface' stamp: 'RocioAmaya 8/22/2013 06:34'!odbx_error: handle error: error 	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^self call: #(NBCharacterType * odbx_error(NBOpenDBX_OdbxTO handle, NBInt32 error)) options: #(  )! !!NBOpenDBX_ApiH methodsFor: 'foreign interface' stamp: 'RocioAmaya 8/22/2013 06:34'!odbx_error_type: handle error: error 	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^self call: #(NBInt32 odbx_error_type(NBOpenDBX_OdbxTO handle, NBInt32 error)) options: #(  )! !!NBOpenDBX_ApiH methodsFor: 'foreign interface' stamp: 'RocioAmaya 8/22/2013 06:34'!odbx_escape: handle from: from fromlen: fromlen to: to tolen: tolen 	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^self call: #(NBInt32 odbx_escape(NBOpenDBX_OdbxTO handle, NBCharacterType * from, NBUInt32 fromlen, NBCharacterType * to, NBUInt32 * tolen)) options: #(  )! !!NBOpenDBX_ApiH methodsFor: 'foreign interface' stamp: 'RocioAmaya 8/22/2013 06:34'!odbx_field_length: result pos: pos 	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^self call: #(NBUInt32 odbx_field_length(NBOpenDBX_OdbxResultTO result, NBUInt32 pos)) options: #(  )! !!NBOpenDBX_ApiH methodsFor: 'foreign interface' stamp: 'RocioAmaya 8/22/2013 06:34'!odbx_field_value: result pos: pos 	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^self call: #(NBCharacterType * odbx_field_value(NBOpenDBX_OdbxResultTO result, NBUInt32 pos)) options: #(  )! !!NBOpenDBX_ApiH methodsFor: 'foreign interface' stamp: 'RocioAmaya 8/22/2013 06:34'!odbx_finish: handle 	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^self call: #(NBInt32 odbx_finish(NBOpenDBX_OdbxTO handle)) options: #(  )! !!NBOpenDBX_ApiH methodsFor: 'foreign interface' stamp: 'RocioAmaya 8/22/2013 06:34'!odbx_get_option: handle option: option value: value 	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^self call: #(NBInt32 odbx_get_option(NBOpenDBX_OdbxTO handle, NBUInt32 option, NBVoid * value)) options: #(  )! !!NBOpenDBX_ApiH methodsFor: 'foreign interface' stamp: 'RocioAmaya 8/22/2013 06:34'!odbx_init: handle backend: backend host: host port: port 	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^self call: #(NBInt32 odbx_init(NBOpenDBX_OdbxTO * handle, NBCharacterType * backend, NBCharacterType * host, NBCharacterType * port)) options: #(  )! !!NBOpenDBX_ApiH methodsFor: 'foreign interface' stamp: 'RocioAmaya 8/22/2013 06:34'!odbx_lo_close: lo 	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^self call: #(NBInt32 odbx_lo_close(NBOpenDBX_OdbxLoTO lo)) options: #(  )! !!NBOpenDBX_ApiH methodsFor: 'foreign interface' stamp: 'RocioAmaya 8/22/2013 06:34'!odbx_lo_open: result lo: lo value: value 	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^self call: #(NBInt32 odbx_lo_open(NBOpenDBX_OdbxResultTO result, NBOpenDBX_OdbxLoTO * lo, NBCharacterType * value)) options: #(  )! !!NBOpenDBX_ApiH methodsFor: 'foreign interface' stamp: 'RocioAmaya 8/22/2013 06:34'!odbx_lo_read: lo buffer: buffer buflen: buflen 	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^self call: #(ssize_t odbx_lo_read(NBOpenDBX_OdbxLoTO lo, NBVoid * buffer, NBInt32 buflen)) options: #(  )! !!NBOpenDBX_ApiH methodsFor: 'foreign interface' stamp: 'RocioAmaya 8/22/2013 06:34'!odbx_lo_write: lo buffer: buffer buflen: buflen 	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^self call: #(ssize_t odbx_lo_write(NBOpenDBX_OdbxLoTO lo, NBVoid * buffer, NBInt32 buflen)) options: #(  )! !!NBOpenDBX_ApiH methodsFor: 'foreign interface' stamp: 'RocioAmaya 8/22/2013 06:34'!odbx_query: handle query: query length: length 	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^self call: #(NBInt32 odbx_query(NBOpenDBX_OdbxTO handle, NBCharacterType * query, NBUInt32 length)) options: #(  )! !!NBOpenDBX_ApiH methodsFor: 'foreign interface' stamp: 'RocioAmaya 8/22/2013 06:34'!odbx_result: handle result: result timeout: timeout chunk: chunk 	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^self call: #(NBInt32 odbx_result(NBOpenDBX_OdbxTO handle, NBOpenDBX_OdbxResultTO * result, NBOpenDBX_TimevalS * timeout, NBUInt32 chunk)) options: #(  )! !!NBOpenDBX_ApiH methodsFor: 'foreign interface' stamp: 'RocioAmaya 8/22/2013 06:34'!odbx_result_finish: result 	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^self call: #(NBInt32 odbx_result_finish(NBOpenDBX_OdbxResultTO result)) options: #(  )! !!NBOpenDBX_ApiH methodsFor: 'foreign interface' stamp: 'RocioAmaya 8/22/2013 06:34'!odbx_result_free: result 	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^self call: #(NBVoid odbx_result_free(NBOpenDBX_OdbxResultTO result)) options: #(  )! !!NBOpenDBX_ApiH methodsFor: 'foreign interface' stamp: 'RocioAmaya 8/22/2013 06:34'!odbx_row_fetch: result 	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^self call: #(NBInt32 odbx_row_fetch(NBOpenDBX_OdbxResultTO result)) options: #(  )! !!NBOpenDBX_ApiH methodsFor: 'foreign interface' stamp: 'RocioAmaya 8/22/2013 06:34'!odbx_rows_affected: result 	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^self call: #(uint64_t odbx_rows_affected(NBOpenDBX_OdbxResultTO result)) options: #(  )! !!NBOpenDBX_ApiH methodsFor: 'foreign interface' stamp: 'RocioAmaya 8/22/2013 06:34'!odbx_set_option: handle option: option value: value 	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^self call: #(NBInt32 odbx_set_option(NBOpenDBX_OdbxTO handle, NBUInt32 option, NBVoid * value)) options: #(  )! !!NBOpenDBX_ApiH methodsFor: 'foreign interface' stamp: 'RocioAmaya 8/22/2013 06:34'!odbx_unbind: handle 	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^self call: #(NBInt32 odbx_unbind(NBOpenDBX_OdbxTO handle)) options: #(  )! !!NBOpenDBX_OdbxH class methodsFor: 'nativeboost types' stamp: 'RocioAmaya 8/22/2013 06:34'!nbBindingOf: aTypeName	^ LibOpenDBXMap at: aTypeName! !!NBOpenDBX_OdbxH class methodsFor: 'library path' stamp: 'RocioAmaya 8/22/2013 06:34'!nbLibraryNameOrHandle	^ LibOpenDBXMap libraryNameOrHandle! !!Number class methodsFor: '*Garage-OpenDBX' stamp: 'EL 8/2/2008 12:10'!fromDbxString: aString	^self readFrom: aString readStream! !!LibOpenDBXMap class methodsFor: 'class initialization' stamp: 'RocioAmaya 8/22/2013 06:34'!initialize	super initialize.	self initializeStructs.	self initializeEnums.	self initializeCallbacks.	self initializeArrays.	self initializeUnions.! !!LibOpenDBXMap class methodsFor: 'class initialization' stamp: 'RocioAmaya 8/22/2013 06:34'!initializeArrays! !!LibOpenDBXMap class methodsFor: 'class initialization' stamp: 'RocioAmaya 8/22/2013 06:34'!initializeCallbacks! !!LibOpenDBXMap class methodsFor: 'class initialization' stamp: 'RocioAmaya 8/22/2013 06:34'!initializeEnums! !!LibOpenDBXMap class methodsFor: 'class initialization' stamp: 'GuillermoPolito 1/14/2014 10:20'!initializeStructs	NBOpenDBX_TimevalS rebuildFieldAccessors.! !!LibOpenDBXMap class methodsFor: 'class initialization' stamp: 'RocioAmaya 8/22/2013 06:34'!initializeUnions! !!LibOpenDBXMap class methodsFor: 'library path' stamp: 'GuillermoPolito 1/13/2014 22:47'!libraryNameOrHandle	NativeBoost platformId = NativeBoostConstants linux32PlatformId		ifTrue:[^'libopendbx.so'].	NativeBoost platformId = NativeBoostConstants mac32PlatformId		ifTrue:[^'libopendbx.dylib'].	NativeBoost platformId = NativeBoostConstants win32PlatformId		ifTrue:[^'libopendbx-1.dll'].! !!LibOpenDBXMap class methodsFor: 'type map' stamp: 'RocioAmaya 8/22/2013 06:34'!typeMap	^#(__suseconds_t 'NBInt32'ssize_t 'NBInt32'odbx_t 'NBVoid'odbx_result_t 'NBVoid'uint64_t 'NBUInt64'__time_t 'NBInt32'odbx_lo_t 'NBVoid')! !!NBOpenDBX_OdbxLoTO class methodsFor: 'nativeboost types' stamp: 'RocioAmaya 8/22/2013 06:34'!nbBindingOf: aTypeName	^ LibOpenDBXMap at: aTypeName! !!NBOpenDBX_OdbxResultTO class methodsFor: 'nativeboost types' stamp: 'RocioAmaya 8/22/2013 06:34'!nbBindingOf: aTypeName	^ LibOpenDBXMap at: aTypeName! !!NBOpenDBX_OdbxTO class methodsFor: 'nativeboost types' stamp: 'RocioAmaya 8/22/2013 06:34'!nbBindingOf: aTypeName	^ LibOpenDBXMap at: aTypeName! !!GAOpenDBXStatement methodsFor: 'cursor' stamp: 'GuillermoPolito 4/24/2015 12:13'!ensureSettings	^ settings ifNil: [ settings := DBXQuerySettings default copy ].! !!GAOpenDBXStatement methodsFor: 'cursor' stamp: 'GuillermoPolito 4/24/2015 11:53'!execute	fetchListener ifNotNilDo: #fetchOccurred.	^ connection execute: statement querySettings: self settings.! !!GAOpenDBXStatement methodsFor: 'cursor' stamp: 'GuillermoPolito 4/24/2015 12:09'!fetchListener: aFetchListener	super fetchListener: aFetchListener.	self ensureSettings fetchListener: aFetchListener.! !!GAOpenDBXStatement methodsFor: 'cursor' stamp: 'GuillermoPolito 4/24/2015 12:38'!fetchSize: anInteger 		connection supportsCursoredFetch ifFalse: [ self error: 'this backend does not support cursored fetches' ].	self ensureSettings.	connection enablePagedResults.	settings pageSize: anInteger.! !!GAOpenDBXStatement methodsFor: 'cursor' stamp: 'GuillermoPolito 4/7/2015 17:06'!prepare	connection preparedStatementsNotSupportedError! !!GAOpenDBXStatement methodsFor: 'accessing' stamp: 'GuillermoPolito 4/24/2015 11:53'!settings	^ settings ifNil: [DBXQuerySettings default]! !!ByteArray class methodsFor: '*Garage-OpenDBX' stamp: 'MarianoMartinezPeck 2/12/2010 20:24'!fromDbxString: aString 	^ aString asByteArray ! !!ByteArray methodsFor: '*Garage-OpenDBX' stamp: 'MarianoMartinezPeck 2/13/2010 15:27'!asDbxString	self asString! !!DateAndTime class methodsFor: '*Garage-OpenDBX' stamp: 'EL 8/2/2008 11:29'!fromDbxString: aString 	^self readDbxFrom: aString readStream! !!DateAndTime class methodsFor: '*Garage-OpenDBX' stamp: 'EL 8/2/2008 11:30'!readDbxFrom: aStream	| year month day hour minute second |	year := (aStream upTo: $-) asInteger.	month := (aStream upTo: $-) asInteger.	day := (aStream upTo: Character space) asInteger.	hour := (aStream upTo: $:) asInteger.	minute := (aStream upTo: $:) asInteger.	second := (aStream upToEnd) asInteger.		^ self		year: year		month: month		day: day		hour: hour		minute: minute		second: second.! !!DateAndTime methodsFor: '*Garage-OpenDBX' stamp: 'EL 8/3/2008 08:29'!asDbxString	| stream |	stream := String new writeStream.	self printDbxOn: stream.	^ stream contents asDbxString! !!DateAndTime methodsFor: '*Garage-OpenDBX' stamp: 'EL 8/3/2008 08:30'!printDbxOn: aStream	aStream		nextPutAll: self year asString;		nextPut: $-;		nextPutAll: (self monthIndex asString padded: #left to: 2 with: $0);		nextPut: $-;		nextPutAll: (self dayOfMonth asString padded: #left to: 2 with: $0);		nextPut: Character space;			nextPutAll: (self hour asString padded: #left to: 2 with: $0);		nextPut: $:;		nextPutAll: (self minutes asString padded: #left to: 2 with: $0);		nextPut: $:;		nextPutAll: (self seconds asString padded: #left to: 2 with: $0).! !!False methodsFor: '*Garage-OpenDBX' stamp: 'EL 8/14/2008 09:18'!asDbxString	^'false'! !!Time class methodsFor: '*Garage-OpenDBX' stamp: 'EL 8/2/2008 10:36'!fromDbxString: aString 	^ self readDbxFrom: aString readStream! !!Time class methodsFor: '*Garage-OpenDBX' stamp: 'EL 8/2/2008 10:11'!readDbxFrom: aStream	| hour minute second |	hour := (aStream upTo: $:) asInteger.	minute := (aStream upTo: $:) asInteger.	second := (aStream upToEnd) asInteger.	^self hour: hour  		minute: minute 		second:  second! !!Time methodsFor: '*Garage-OpenDBX' stamp: 'EL 8/3/2008 08:24'!asDbxString	| stream |	stream := String new writeStream.	self printDbxOn: stream.		^ stream contents asDbxString! !!Time methodsFor: '*Garage-OpenDBX' stamp: 'EL 8/3/2008 08:24'!printDbxOn: aStream	aStream		nextPutAll: (self hour asString padded: #left to: 2 with: $0);		nextPut: $:;		nextPutAll: (self minutes asString padded: #left to: 2 with: $0);		nextPut: $:;		nextPutAll: (self seconds asString padded: #left to: 2 with: $0).! !!UndefinedObject methodsFor: '*Garage-OpenDBX' stamp: 'EL 8/3/2008 12:49'!asDbxString	^'NULL'! !!UndefinedObject methodsFor: '*Garage-OpenDBX' stamp: 'TestRunner 12/8/2009 22:21'!isResultSet	^ false.! !!DBXNullTextConverter class methodsFor: 'as yet unclassified' stamp: 'MarianoMartinezPeck 3/19/2011 11:01'!instance	^Instance ifNil:[Instance:=DBXNullTextConverter basicNew].! !!DBXNullTextConverter methodsFor: 'as yet unclassified' stamp: 'PanuSuominen 8/30/2010 21:36'!convertFromSystemString: aString	^aString.! !!DBXNullTextConverter methodsFor: 'as yet unclassified' stamp: 'PanuSuominen 8/30/2010 21:41'!convertToSystemString: aString	^aString.! !!DBXNullTextConverter methodsFor: 'as yet unclassified' stamp: 'PanuSuominen 8/31/2010 14:29'!nextFromStream: aStream	^aStream next.! !!DBXNullTextConverter methodsFor: 'as yet unclassified' stamp: 'PanuSuominen 8/30/2010 21:51'!nextPut: aChar toStream: aStream	aStream nextPut: aChar.! !!DBXError class methodsFor: 'private' stamp: 'HMC 10/14/2008 23:50'!header	self subclassRisponsability! !!DBXError class methodsFor: 'exceptionInstantiator' stamp: 'HMC 10/14/2008 23:40'!signal: signalerText 	super signal: self header , signalerText! !!OpenDBXDriverError class methodsFor: 'private' stamp: 'MarianoMartinezPeck 5/7/2011 18:46'!header	^ 'OpenDBXDriver: '! !!DBXFatalError class methodsFor: 'private' stamp: 'HMC 10/14/2008 23:52'!header	^'FATAL OpenDBX: '! !!DBXRecoverableError class methodsFor: 'private' stamp: 'HMC 10/14/2008 23:53'!header	^ 'RECOVERABLE OpenDBX: '! !!Boolean class methodsFor: '*Garage-OpenDBX' stamp: 'EL 8/2/2008 12:55'!fromDbxString: aString	aString = '1' ifTrue: [ ^true ].	aString = '0' ifTrue: [ ^false ].	DBXError signal: 'Invalid boolean input: ', aString! !!Date class methodsFor: '*Garage-OpenDBX' stamp: 'EL 8/2/2008 10:36'!fromDbxString: aString 	^ self readDbxFrom: aString readStream! !!Date class methodsFor: '*Garage-OpenDBX' stamp: 'EL 8/2/2008 10:09'!readDbxFrom: aStream	| year month day |	year := (aStream upTo: $-) asInteger.	month := (aStream upTo: $-) asInteger.	day := (aStream upToEnd) asInteger.	^self year: year 		month: month 		day: day! !!Date methodsFor: '*Garage-OpenDBX' stamp: 'EL 8/3/2008 08:27'!asDbxString	| stream |	stream := String new writeStream.	self printDbxOn: stream.	^ stream contents asDbxString ! !!Date methodsFor: '*Garage-OpenDBX' stamp: 'EL 8/3/2008 08:27'!printDbxOn: aStream	aStream		nextPutAll: self year asString;		nextPut: $-;		nextPutAll: (self monthIndex asString padded: #left to: 2 with: $0);		nextPut: $-;		nextPutAll: (self dayOfMonth asString padded: #left to: 2 with: $0).! !!True methodsFor: '*Garage-OpenDBX' stamp: 'EL 8/14/2008 09:18'!asDbxString	^'true'! !!GAOpenDBXDriver class methodsFor: 'drivers' stamp: 'GuillermoPolito 1/21/2015 14:30'!driverId	^ 'opendbx'! !!GAOpenDBXDriver class methodsFor: 'instance-creation' stamp: 'GuillermoPolito 4/27/2015 11:14'!fromConnectionString: aConnectionString		| backend backendName settings |	backendName := aConnectionString optionAt: #backend ifAbsent: [ self error: 'no backend specified for opendbx connection' ].	backend := (DBXBackend allSubclasses detect: [ :each | each new backend = backendName ]) new.	settings := backend connectionSettingsFromConnectionString: aConnectionString.	^ self new		connectionString: aConnectionString;		backend: backend;		settings: settings;		yourself! !!GAOpenDBXDriver class methodsFor: 'initialize' stamp: 'GuillermoPolito 4/17/2015 15:10'!initialize	self subscribeDriver! !!GAOpenDBXDriver class methodsFor: 'testing' stamp: 'GuillermoPolito 4/19/2015 19:27'!newFixtureForConnectionString: aConnectionString	| backend backendName |	backendName := aConnectionString optionAt: #backend ifAbsent: [ self error: 'no backend specified for opendbx connection' ].	backend := (DBXBackend allSubclasses detect: [ :each | each new backend = backendName ]) new.	^ backend newFixture! !!GAOpenDBXDriver class methodsFor: 'encoding' stamp: 'GuillermoPolito 4/29/2015 12:08'!supportsEncoding: aString 		"This should actually depend on the backend"	^ true! !!GAOpenDBXDriver methodsFor: 'accessing' stamp: 'GuillermoPolito 1/21/2015 15:01'!backend		^ 'opendbx'! !!GAOpenDBXDriver methodsFor: 'accessing' stamp: 'GuillermoPolito 1/21/2015 14:54'!backend: anOpenDBXBackend 		backend := anOpenDBXBackend! !!GAOpenDBXDriver methodsFor: 'transaction' stamp: 'GuillermoPolito 1/21/2015 15:02'!beginTransaction		odbxConnection startTransaction! !!GAOpenDBXDriver methodsFor: 'connect' stamp: 'GuillermoPolito 4/7/2015 16:49'!close		odbxConnection disconnect.! !!GAOpenDBXDriver methodsFor: 'transaction' stamp: 'GuillermoPolito 1/21/2015 15:16'!commitTransaction		odbxConnection commit! !!GAOpenDBXDriver methodsFor: 'connect' stamp: 'GuillermoPolito 4/7/2015 15:59'!connect		odbxConnection := DBXConnection 		platform: backend		settings: settings.		odbxConnection connect.	"Here, between the connect and open, we should put the extra flags"	odbxConnection open.	self register.! !!GAOpenDBXDriver methodsFor: 'statement' stamp: 'GuillermoPolito 4/16/2015 12:21'!createStatement		^ GAOpenDBXStatement onConnection: self! !!GAOpenDBXDriver methodsFor: 'statement' stamp: 'GuillermoPolito 4/16/2015 12:21'!createStatement: aString 		^ (GAOpenDBXStatement onConnection: self)		statementString: aString;		yourself! !!GAOpenDBXDriver methodsFor: 'accessing' stamp: 'GuillermoPolito 1/23/2015 12:30'!database		^ settings database! !!GAOpenDBXDriver methodsFor: 'transactions' stamp: 'GuillermoPolito 4/24/2015 15:04'!defaultValueAutoCommit		^ backend defaultValueAutoCommit! !!GAOpenDBXDriver methodsFor: 'special' stamp: 'GuillermoPolito 4/24/2015 12:25'!enablePagedResults		odbxConnection enablePagedResults! !!GAOpenDBXDriver methodsFor: 'query' stamp: 'GuillermoPolito 4/24/2015 11:47'!execute: aQuery		^ odbxConnection execute: aQuery! !!GAOpenDBXDriver methodsFor: 'query' stamp: 'GuillermoPolito 4/24/2015 11:53'!execute: aQuery querySettings: querySettings		^ odbxConnection execute: aQuery querySettings: querySettings! !!GAOpenDBXDriver methodsFor: 'accessing' stamp: 'GuillermoPolito 4/7/2015 16:50'!finalize	self isConnected ifTrue: [ self close ].! !!GAOpenDBXDriver methodsFor: 'transactions' stamp: 'GuillermoPolito 4/24/2015 15:03'!hasAutoCommit		^ backend testAutoCommitInConnection: self! !!GAOpenDBXDriver methodsFor: 'testing' stamp: 'GuillermoPolito 4/7/2015 16:11'!isConnected		^ odbxConnection isNotNil and: [ odbxConnection isConnected ]! !!GAOpenDBXDriver methodsFor: 'testing' stamp: 'GuillermoPolito 4/19/2015 19:44'!isMemory		^ self odbxbackend backend = 'sqlite3' and: [ settings database = ':memory:' ]! !!GAOpenDBXDriver methodsFor: 'accessing' stamp: 'GuillermoPolito 4/24/2015 13:50'!numberOfFetchesForSingleExecute	^ 2! !!GAOpenDBXDriver methodsFor: 'accessing' stamp: 'GuillermoPolito 1/21/2015 15:01'!odbxbackend		^ backend! !!GAOpenDBXDriver methodsFor: 'query' stamp: 'GuillermoPolito 4/7/2015 17:05'!prepare: aQuery		self preparedStatementsNotSupportedError! !!GAOpenDBXDriver methodsFor: 'query' stamp: 'GuillermoPolito 4/7/2015 17:05'!preparedStatementsNotSupportedError	self error: 'This driver does not support prepared statements'! !!GAOpenDBXDriver methodsFor: 'transaction' stamp: 'GuillermoPolito 1/21/2015 16:19'!rollbackTransaction		odbxConnection rollback! !!GAOpenDBXDriver methodsFor: 'accessing' stamp: 'GuillermoPolito 1/21/2015 14:55'!settings: openDBXConnectionSettings 		settings := openDBXConnectionSettings! !!GAOpenDBXDriver methodsFor: 'testing' stamp: 'GuillermoPolito 4/27/2015 17:42'!supportsAutomaticQueryEncoding		^ true! !!GAOpenDBXDriver methodsFor: 'testing' stamp: 'GuillermoPolito 4/24/2015 12:37'!supportsCursoredFetch		^ backend supportsCursoredFetch! !!GAOpenDBXResultSet class methodsFor: 'instance creation' stamp: 'MMP 6/1/2009 21:43'!new	self error: 'Use #on:handle:description:querySettings:'! !!GAOpenDBXResultSet class methodsFor: 'instance creation' stamp: 'MMP 1/31/2009 20:39'!on: aConnection handle: aNumber description: aDescription querySettings: aQuerySettings	^(self basicNew)		initializeConnection: aConnection 			handle: aNumber			description: aDescription			querySettings: aQuerySettings;		yourself.! !!GAOpenDBXResultSet methodsFor: 'enumerating' stamp: 'MMP 4/13/2009 01:10'!allRowsDo: aBlock 	"It will execute the block to each row from the collection. It is different from rowsDo: because allRowsDo, first obtain (query) all the rows and then iterates them and evaluates the block. On the other hand, rowsDo: goes row by row executing the block."	| rows |	rows := self rows.	rows do: aBlock! !!GAOpenDBXResultSet methodsFor: 'testing' stamp: 'GuillermoPolito 4/7/2015 16:04'!at: anInteger 		^ self rows at: anInteger! !!GAOpenDBXResultSet methodsFor: 'iterating' stamp: 'GuillermoPolito 4/7/2015 16:07'!collect: aBlockClosure 		^ self rows collect: aBlockClosure! !!GAOpenDBXResultSet methodsFor: 'accessing' stamp: 'MMP 6/1/2009 20:28'!columnCount	"Returns the number of columns affected in the query. It will be the number of columns you specify in the select statement"	^self description columnCount! !!GAOpenDBXResultSet methodsFor: 'accessing' stamp: 'DiogenesMoreira 6/24/2011 18:24'!columnDescriptionAt: anIndex	"Returns the column description at that index.	IMPORTANT: The index starts in 1."	|desc|	desc:=self description columnDescriptionAt: anIndex.	desc type isBehavior	ifTrue:[ ^ desc ]	ifFalse:[		^ self platform descriptionForColumn: (anIndex-1) handle: self handle on: self connection	]! !!GAOpenDBXResultSet methodsFor: 'accessing' stamp: 'MarianoMartinezPeck 5/7/2011 00:38'!columnDescriptionWithName: aName 	"Returns the column description with that name. If a column with that name was not in select statement a DBXError will be thrown"	^ [self columnDescriptions		detect: [:each | each name sameAs: aName]]		on: Error		do: [OpenDBXDriverError signal: 'A column with that name was not found' ]! !!GAOpenDBXResultSet methodsFor: 'accessing' stamp: 'MMP 8/16/2008 20:31'!columnDescriptions	"Returns the column description of ALL the affected columns"	^self description columnDescriptions! !!GAOpenDBXResultSet methodsFor: 'accessing' stamp: 'GuillermoPolito 4/7/2015 15:54'!connection	^ connection! !!GAOpenDBXResultSet methodsFor: 'accessing' stamp: 'DiogenesMoreira 6/24/2011 19:58'!dataTypeAt: aInteger	 ^ self platform dataTypeAt: aInteger! !!GAOpenDBXResultSet methodsFor: 'accessing' stamp: 'GuillermoPolito 4/7/2015 15:56'!description	^ description! !!GAOpenDBXResultSet methodsFor: 'initialization' stamp: 'DiogenesMoreira 6/24/2011 20:02'!detectNewTypes	self description detectNewTypes: self.	 ! !!GAOpenDBXResultSet methodsFor: 'iterating' stamp: 'GuillermoPolito 4/7/2015 16:07'!do: aBlockClosure 		^ self rows do: aBlockClosure! !!GAOpenDBXResultSet methodsFor: 'finalization' stamp: 'MMP 8/16/2008 20:47'!finalize	"Will finalize the DBXResultSet object"	self isOpen ifTrue: [ self finalizeResultSet ]! !!GAOpenDBXResultSet methodsFor: 'finalization' stamp: 'MMP 8/16/2008 20:46'!finalizeResultSet	"It will release resources and change internal state"	self platform releaseResultSet: self.	self internalBeClosed.! !!GAOpenDBXResultSet methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/7/2015 15:55'!first		^ self rows first! !!GAOpenDBXResultSet methodsFor: 'accessing' stamp: 'GuillermoPolito 4/7/2015 15:54'!handle	^ handle! !!GAOpenDBXResultSet methodsFor: 'initialization' stamp: 'GuillermoPolito 4/7/2015 15:54'!initializeConnection: aConnection handle: aNumber description: aDescription querySettings: aQuerySettings 	connection := aConnection.	handle := aNumber.	description := aDescription.	querySettings := aQuerySettings.	open := ValueHolder new contents: false.	self internalBeOpen.	aConnection platform class isAutomaticConnectionReleaseOnGC ifTrue: [		OpenDBXDriverSmalltalkDialect current addObjectToGarbageCollect: self].! !!GAOpenDBXResultSet methodsFor: 'private' stamp: 'EL 6/27/2008 09:01'!internalBeClosed	open contents: false! !!GAOpenDBXResultSet methodsFor: 'private' stamp: 'EL 6/27/2008 09:01'!internalBeOpen	open contents: true! !!GAOpenDBXResultSet methodsFor: 'testing' stamp: 'GuillermoPolito 4/7/2015 16:06'!isEmpty		^ self rows isEmpty! !!GAOpenDBXResultSet methodsFor: 'testing' stamp: 'MMP 8/16/2008 20:31'!isOpen	"Returns if the DBXResultSet is open or not."	^open contents! !!GAOpenDBXResultSet methodsFor: 'testing' stamp: 'GuillermoPolito 4/7/2015 15:55'!isResult		^ false! !!GAOpenDBXResultSet methodsFor: 'testing' stamp: 'MMP 6/4/2009 22:04'!isResultSet	^ true! !!GAOpenDBXResultSet methodsFor: 'accessing' stamp: 'MarianoMartinezPeck 5/7/2011 18:46'!nextRow	"it returns the next row of the resultSet. If there is no more row, it returns nil. 		VERY IMPORTANT THINGS:    * After doing a select query you should call nextRow till it returns nil. If you don't do this, you will get a segmentation fault in your next query. You have to do this no matter which number of rows you have got. Suppose you are looking for some record and you find it in the second one. The number of rows is 10. In this case, you should call nextRow 10 times, no matter you found the record in the second one. This limitation is in the database client library. We assume that someone has to do this (retrieve all results before execute another query): openDBX, database client library, OpenDBXDriver or OpenDBXDriver user. So, we decided OpenDBXDriver should do this. The other approach was the OpenDBXDriver user should do it and if it doesn't do it, OpenDBXDriver throws an error. In conclusion, you DON'T need to call nextRow till nil its returned, the framework will do it for you in your next query.    * Some queries return more than one resultSet. This situation will be transparent for OpenDBXDriver user. nextRow will automatically obtain next resultSet when needed. "	| row |	self isOpen		ifFalse: [ OpenDBXDriverError signal: 'The resultSet must be open to obtain the next row but it is closed' ].	row := self platform moveNext: self.	^ row! !!GAOpenDBXResultSet methodsFor: 'accessing' stamp: 'GuillermoPolito 4/7/2015 15:54'!platform		^ self connection platform! !!GAOpenDBXResultSet methodsFor: 'accessing' stamp: 'GuillermoPolito 4/7/2015 15:54'!querySettings	^ querySettings! !!GAOpenDBXResultSet methodsFor: 'streaming' stamp: 'GuillermoPolito 4/16/2015 12:20'!readStream		^ GAResultSetReadStream on: self! !!GAOpenDBXResultSet methodsFor: 'release' stamp: 'MMP 6/1/2009 20:04'!releaseResult	"It will release all the resources of all the resultsSets associated with a query."	self isOpen		ifTrue: [self platform releaseAllQueryResultSets: self.			self internalBeClosed]! !!GAOpenDBXResultSet methodsFor: 'accessing' stamp: 'GuillermoPolito 4/7/2015 16:56'!rows	"It returns in an OrderedCollection, ALL the rows of all the resultSets of a query"	| results |	rows ifNotNil: [ ^ rows ].		results := OrderedCollection new.	self rowsDo: [ :each| 		results add: each ].	^ rows := results! !!GAOpenDBXResultSet methodsFor: 'enumerating' stamp: 'MMP 8/16/2008 20:44'!rowsDo: aBlock	"It will execute the block to each row"	| row |	[ row := self nextRow.	  row notNil ] 	whileTrue: [ aBlock value: row ]! !!GAOpenDBXResultSet methodsFor: 'iterating' stamp: 'GuillermoPolito 4/7/2015 16:09'!select: aBlockClosure 		^ self rows select: aBlockClosure! !!DBXAuthenticationMethod class methodsFor: 'methods' stamp: 'MMP 8/16/2008 22:45'!usernamePassword	"Returns the method number of openDBX for username and password"	^0.! !!DBXBackend class methodsFor: 'logging' stamp: 'GuillermoPolito 8/10/2011 11:20'!allBackends	^backends ifNil: [ backends := self allSubclasses collect: [ :backendClass | backendClass new ] ]! !!DBXBackend class methodsFor: 'accessing' stamp: 'GuillermoPolito 5/3/2014 14:06'!backendName	^ self new backend! !!DBXBackend class methodsFor: 'accessing' stamp: 'GuillermoPolito 5/9/2012 07:43'!createDataTypesMap	"Creates and returns a map that maps Smalltalk classes to SQL datatypes.	The 16r means it is hexadecimal."	^Dictionary new		at: 16r00 put: Boolean; "BOOLEAN"		at: 16r01 put: Number; "SMALLINT"		at: 16r02 put: Number; "INTEGER"		at: 16r03 put: Number; "BIGINT"		at: 16r07 put: Number; "DECIMAL"		at: 16r08 put: Number; "REAL"		at: 16r09 put: Number; "DOUBLE"		at: 16r0F put: Number; "FLOAT"		at: 16r10 put: String; "CHAR"		at: 16r11 put: String; "NCHAR"		at: 16r12 put: String; "VARCHAR"		at: 16r13 put: String; "NVARCHAR"		at: 16r20 put: String; "CLOB"		at: 16r21 put: String; "NCLOB"		at: 16r22 put: String; "XML"		at: 16r2F put: ByteArray; "BLOB"		at: 16r30 put: Time; "TIME"		at: 16r31 put: Time; "TIMETZ"		at: 16r32 put: TimeStamp; "TIMESTAMP"		at: 16r33 put: TimeStamp; "TIMESTAMPTZ"		at: 16r34 put: Date; "DATE"		at: 16r35 put: (DBXTypeNotSupported type: #INTERVAL);		at: 16r40 put: (DBXTypeNotSupported type: #ARRAY);		at: 16r41 put: (DBXTypeNotSupported type: #MULTISET);		at: 16r50 put: (DBXTypeNotSupported type: #DATALINK);		at: 16rFF put: (DBXTypeNotSupported type: #UNKNOWN);		yourself! !!DBXBackend class methodsFor: 'accessing' stamp: 'DiogenesMoreira 6/24/2011 17:55'!dataTypeAt: aNumber	"Returns the Smalltalk class associated with a particular SQL type."	^self dataTypesMap at: aNumber ifAbsent: [ 		DBXTypeNotSupported code: aNumber ]! !!DBXBackend class methodsFor: 'accessing' stamp: 'MMP 6/4/2009 23:38'!dataTypesMap	"Returns a map that maps Smalltalk classes to SQL datatypes."	^dataTypesMap ifNil: [ dataTypesMap := self createDataTypesMap ]! !!DBXBackend class methodsFor: 'testing' stamp: 'MarianoMartinezPeck 9/1/2010 19:44'!disableAutomaticConnectionReleaseOnGC	self propertyAt: #automaticConnectionReleaseOnGC put: false! !!DBXBackend class methodsFor: 'testing' stamp: 'MMP 9/28/2008 21:13'!disableDebugMode	self propertyAt: #debugMode put: false! !!DBXBackend class methodsFor: 'testing' stamp: 'MarianoMartinezPeck 9/1/2010 19:44'!enableAutomaticConnectionReleaseOnGC	self propertyAt: #automaticConnectionReleaseOnGC put: true! !!DBXBackend class methodsFor: 'testing' stamp: 'MMP 9/28/2008 21:13'!enableDebugMode	self propertyAt: #debugMode put: true! !!DBXBackend class methodsFor: 'testing' stamp: 'MarianoMartinezPeck 9/1/2010 19:45'!isAutomaticConnectionReleaseOnGC	^self propertyAt: #automaticConnectionReleaseOnGC ifAbsentPut: [ true ]! !!DBXBackend class methodsFor: 'testing' stamp: 'EL 9/14/2008 08:44'!isDebugMode	^self propertyAt: #debugMode ifAbsentPut: [ false ]! !!DBXBackend class methodsFor: 'testing' stamp: 'EL 8/3/2008 08:53'!isLarge: aNumber	"Answer true if aNumber represents a large data object (BLOB, CLOB, NCLOB)"	^#(16r20 16r21 16r2F) includes: aNumber! !!DBXBackend class methodsFor: 'logging' stamp: 'MMP 1/5/2009 21:07'!log: messageBlockOrString	self isDebugMode ifTrue: [		Transcript show: messageBlockOrString value; cr.		    "self log info: messageBlockOrString." ].! !!DBXBackend class methodsFor: 'testing' stamp: 'EL 9/14/2008 08:46'!properties	^Properties ifNil: [ Properties := Dictionary new ]! !!DBXBackend class methodsFor: 'testing' stamp: 'EL 9/14/2008 08:46'!propertyAt: aSymbol	^self properties at: aSymbol! !!DBXBackend class methodsFor: 'testing' stamp: 'EL 9/14/2008 08:47'!propertyAt: aSymbol ifAbsent: aBlock	^self properties at: aSymbol ifAbsent: aBlock! !!DBXBackend class methodsFor: 'testing' stamp: 'EL 9/14/2008 08:47'!propertyAt: aSymbol ifAbsentPut: aBlock	^self properties at: aSymbol ifAbsentPut: aBlock! !!DBXBackend class methodsFor: 'testing' stamp: 'EL 9/14/2008 08:47'!propertyAt: aSymbol put: anObject	^self properties at: aSymbol put: anObject! !!DBXBackend class methodsFor: 'defaults' stamp: 'MMP 6/4/2009 23:32'!resetDataTypesMap	dataTypesMap := nil.! !!DBXBackend methodsFor: 'accessing' stamp: 'MMP 3/1/2009 15:46'!backend	"Returns the name of the backend that OpenDBX understands for each RDBMS"	^self subclassResponsibility! !!DBXBackend methodsFor: 'connection' stamp: 'MMP 6/4/2009 00:42'!closeConnection: aConnection	"Closes the connection and throws a DBXError if an error occurs"	| err |	err := OpenDBX current apiUnbind: aConnection handle.	self log: [ 'odbx_unbind called with values: handle = ', aConnection handle asString ].	self verifyError: err handle: aConnection handle.! !!DBXBackend methodsFor: 'transactional manage' stamp: 'MMP 6/4/2009 22:37'!commit	"If a certain backend doesn't use this sintax, it must subclass and override this method."	^ 'COMMIT'! !!DBXBackend methodsFor: 'transactional manage' stamp: 'MMP 6/4/2009 22:35'!commit: aConnection	"executes a commit statement on a connection"	^self executeStatement: self commit on: aConnection.! !!DBXBackend methodsFor: 'connection' stamp: 'RocioAmaya 8/22/2013 19:09'!createConnection: aConnection 	"It initializes and creates a handle for all further operations, and it is	used within the OpenDBX library to identify the connection and to	maintain connection information. Depending on the backend it can open	a connection to the database server but often this is done not until	performing authentication through 'openConnection:'	throws an error if needed"	| err handle |	handle :=  OpenDBX  current createOpenDBXHandle.	err := OpenDBX current				apiInitialize: handle				backend: self backend				host: aConnection host				port: aConnection port.	self log: [ 'odbx_init called with values: backend = ', self backend, ' host = ', aConnection host, ' port = ', aConnection port asString ].	handle := OpenDBX current  unpackOpenDBXHandle: handle.		"If it fails here, it means it couldn't connect, so we let the signal pass'"		self verifyError: err handle: handle.		^ handle! !!DBXBackend methodsFor: 'accessing' stamp: 'DiogenesMoreira 6/24/2011 20:05'!dataTypeAt: aSmallInteger 	^ self class dataTypeAt: aSmallInteger ! !!DBXBackend methodsFor: 'private' stamp: 'MarianoMartinezPeck 5/7/2011 00:38'!dbxSmallIntegerAsBoolean: aSmallInteger 	aSmallInteger = 1 ifTrue: [ ^ true ].	aSmallInteger = 0 ifTrue: [ ^ false ].	OpenDBXDriverError signal: 'Cannot convert form SmallInteger to Boolean'! !!DBXBackend methodsFor: 'testing' stamp: 'GuillermoPolito 4/24/2015 15:05'!defaultValueAutoCommit		self subclassResponsibility! !!DBXBackend methodsFor: 'description' stamp: 'GuillermoPolito 10/14/2013 22:52'!descriptionForColumn: anIndex handle: aHandle on: aConnection	"Returns a DBXColumnDescription of the column at anIndex from the resultset with aHandle from aConnection."	"anIndex is Zero based"	| columnName dbxType |	columnName := OpenDBX current apiQueryColumnName: aHandle index: anIndex.	"self log: 'apiQueryColumnName called with values: handle = ', aHandle asString, ' index = ', anIndex asString."	dbxType := OpenDBX current apiQueryColumnType: aHandle index: anIndex. 	"self log: 'apiQueryColumnType called with values: handle = ', aHandle asString, ' index = ', anIndex asString."	^DBXColumnDescription 		name: columnName		dbxType: dbxType		type: (self class dataTypeAt: dbxType).! !!DBXBackend methodsFor: 'description' stamp: 'MMP 6/4/2009 22:42'!descriptionForResult: aHandle on: aConnection	"Returns a DBXResultDescription of the query"	| rowsAffected |	rowsAffected := OpenDBX current apiQueryRowsAffected: aHandle.	self log: [ 'odbx_rows_affected: called with values: resultSet handle = ', aHandle asString ].	self  verifyError: rowsAffected on: aConnection. 	^DBXResultDescription new		rowsAffected: rowsAffected;		yourself.! !!DBXBackend methodsFor: 'description' stamp: 'MMP 6/4/2009 22:42'!descriptionForResultSet: aHandle on: aConnection 	"Returns a DBXResultSetDescription of the query"	| description columnCount |	columnCount := OpenDBX current apiQueryColumns: aHandle.	self log: [ 'odbx_column_count: called with values: resultSet handle = ', aHandle asString ].	self verifyError: columnCount on: aConnection.	description := DBXResultSetDescription new.	0 to: columnCount - 1		do: [:i | description				addColumnDescription: (self						descriptionForColumn: i						handle: aHandle						on: aConnection)].	^ description! !!DBXBackend methodsFor: 'connection' stamp: 'MMP 6/4/2009 00:52'!disconnectConnection: aConnection 	"It releases all the resources associated with a connection"	| err |	err := OpenDBX current apiFinalize: aConnection handle.	self log: 		[ 'odbx_finish: called with values: handle = ' , aConnection handle asString ].	self 		verifyError: err		handle: aConnection handle! !!DBXBackend methodsFor: 'resultSet' stamp: 'MMP 6/4/2009 23:09'!endDBXResult: aConnection querySettings: aQuerySettings	"Releases all query resultsSets a query may return by iterating them.	Each resultSet is Closed and all allocated memory by the OpenDBX	library is freed ."	| resultCode |		[self		nextResultSet: aConnection		querySettings:  aQuerySettings		onReturn: [:handle :code | 			code = OpenDBX resultWithRows				ifTrue: [ self releaseResultSet: handle connection: aConnection  ].			resultCode := code]]	doWhileFalse: [resultCode = OpenDBX resultDone].	! !!DBXBackend methodsFor: 'error handling' stamp: 'MMP 6/4/2009 23:11'!errorCode: err handle: aHandle	"This method manage errors that have occurred before a correct connection is created" 	| type description |	description := OpenDBX current apiError: aHandle number: err.	description ifNil: [ description := 'Uknown message' ].	type := OpenDBX current apiErrorType: aHandle number: err.	"This method should only be called when there is no DBXConnection yet created with a valid handle.	Because of this I don't have to release resultsets or things like that, just signal"	(DBXErrorSeverity isFatal: type)		ifTrue: [ DBXFatalError signal: description ].	(DBXErrorSeverity isRecoverable: type)		ifTrue: [ DBXRecoverableError signal: description ].! !!DBXBackend methodsFor: 'error handling' stamp: 'MMP 6/4/2009 23:11'!errorCode: err on: aConnection 	"This method manage errors that have occurred after a correct connection is created" 	| type description |	description := OpenDBX current apiError: aConnection handle number: err.	description ifNil: [ description := 'Uknown message' ].	type := OpenDBX current apiErrorType: aConnection handle number: err.	(DBXErrorSeverity isFatal: type)		ifTrue: [			"I have to close and disconnect the connection. They will also take care of releasing the results"			aConnection close.			aConnection disconnect.			DBXFatalError signal: description].	(DBXErrorSeverity isRecoverable: type)		ifTrue: [			"In this case I must free the resources of the results. 			It may be the case where we have an error in the first query on a connection. In this case, the result is in 			nil so I can use the default query setting."			aConnection result ifNil: [				self endDBXResult: aConnection querySettings: DBXQuerySettings default .			] ifNotNil: [				self endDBXResult: aConnection querySettings: aConnection result querySettings .			].		DBXRecoverableError signal: description.		].! !!DBXBackend methodsFor: 'multistatement' stamp: 'MMP 6/4/2009 00:22'!executeMultiStatement: aQuery on: aConnection 	"It executes a multistatement query using the connection and can be used to retrieve all resultsets. 	There are some important things:    * this method returns a DBXMultiStatementResultSetIterator    * The queries sent to the server must be understood by the DBMS because there is no translation done between the 	different dialects of SQL for example."	^self executeMultiStatement: aQuery on: aConnection querySettings: DBXQuerySettings default.! !!DBXBackend methodsFor: 'multistatement' stamp: 'PanuSuominen 9/1/2010 20:01'!executeMultiStatement: aString on: aConnection querySettings: aQuerySettings 	"This is similar to executeStatement: aString on: aConnection querySettings: aQuerySettings 	with the difference that in this case the SAME query settings is used for all the subqueries of	the multistatement query."	| err multiStatmentIterator encodedQuery|	encodedQuery := (aConnection encodeString: aString).	err := OpenDBX current 		apiQuery: aConnection handle		query: encodedQuery 		length: encodedQuery size.	self log: 'odbx_query: called with values: handle = ' , aConnection handle asString , ' query = ' , aString.	self 		verifyError: err		on: aConnection.	multiStatmentIterator := DBXMultiStatementResultSetIterator 		on: aConnection querySettings: aQuerySettings.	^ multiStatmentIterator! !!DBXBackend methodsFor: 'query' stamp: 'MMP 1/31/2009 20:30'!executeStatement: aQuery on: aConnection 	"It executes the query using the connection and retrieve al rows at once (no pagination is used). 	There are some important things:    * this method returns a DBXResultSet if it was a select statement and a DBXResult in case the query was an update, delete, insert, create, drop or any other DML query.    * The queries sent to the server must be understood by the DBMS because there is no translation done between the different dialects of SQL for example. But this is desired!! It adds no further level of complexity to the library and your program which slows down your real work. Usually only a few statements with varying values are used in programs and the easiest way make them adaptable to different databases by the users is to get them from a configuration file, strategy pattern or whatever. "	^self executeStatement: aQuery on: aConnection querySettings: DBXQuerySettings default.! !!DBXBackend methodsFor: 'query' stamp: 'GuillermoPolito 10/17/2013 00:37'!executeStatement: aString on: aConnection querySettings: aQuerySettings 	"After executing a query, we will then want to retrieve the results. It may be possible to retrieve all rows at once, one by one or more than one row at once. All positive values including zero are allowed as values for a page size. As this is a special option that not all the engines support you must enable this feature using DBXConnection #enablePagedResults. If paging (more than one row at once) is not supported by the backend, it will use 'one by one' or 'all at once' if this is the only option provided."	| err result encodedQuery |	encodedQuery := (aConnection encodeString: aString).	err := OpenDBX current				apiQuery: aConnection handle				query: encodedQuery				length: encodedQuery size.	self log: 'odbx_query: called with values: handle = ', aConnection handle asString, ' query = ', aString.	self verifyError: err on: aConnection.	result := self processNextResultSet: aConnection querySettings: aQuerySettings.	"If the result is a DBXResult, I must end the resultset. If the result is nil, it will probably 	be a query of transaction, like begin transaction or rollback"	(result isNil not and: [ result isResult]) 		ifTrue: [ self endDBXResult: aConnection querySettings: aQuerySettings. ].	^ result.! !!DBXBackend methodsFor: 'resultSet' stamp: 'PanuSuominen 9/2/2010 21:24'!fieldRawValue: anIndex on: aResultSet	"Returns the value of the column at anIndex of the current row from aResultSet"	| value |	value := OpenDBX current apiQueryFieldValue: (aResultSet handle) index: (anIndex - 1).	^value isNil ifTrue:[value] ifFalse:[aResultSet connection decodeString: value].! !!DBXBackend methodsFor: 'options' stamp: 'MMP 2/4/2009 23:44'!getOption: anOption on: aConnection 	"It asks the backend if an specific option is supported or not"	| err isSupported |	isSupported := WordArray with: 0.	err := OpenDBX current 		apiGetOption: aConnection handle		option: anOption		value: isSupported.	self 		verifyError: err		on: aConnection.	^ self dbxSmallIntegerAsBoolean: (isSupported first)! !!DBXBackend methodsFor: 'resultSet' stamp: 'MMP 6/4/2009 22:10'!largeFieldRawValue: anIndex on: aResultSet	self halt: 'not yet implemented'.! !!DBXBackend methodsFor: 'logging' stamp: 'EL 9/14/2008 08:49'!log: messageBlockOrString	self class log: messageBlockOrString! !!DBXBackend methodsFor: 'resultSet' stamp: 'MMP 6/4/2009 22:11'!moveNext: aResultSet 	"Moves the aResultSet one more row and this row is returned."	| err |	err := OpenDBX current apiQueryFetchRow: aResultSet handle.	self log: ['odbx_row_fetch: called with values: resultSet handle = ', aResultSet handle asString].	self log: ['odbx_row_fetch call returned ', err asString].	self verifyError: err on: aResultSet connection.	err = OpenDBX rowDone		ifTrue: [ ^ nil ]		ifFalse: [^ DBXRow on: aResultSet]! !!DBXBackend methodsFor: 'resultSet' stamp: 'MMP 6/4/2009 22:44'!nextResultSet: aResultSet ifDone: aBlock	"Returns the next resultSet from the last resultSet. When there is no more resultSets, 	the block is evaluated." 	^ self		nextResultSet: aResultSet connection		querySettings: aResultSet querySettings		onReturn: [:handle :code | code = OpenDBX resultDone				ifTrue: [aBlock value]]! !!DBXBackend methodsFor: 'resultSet' stamp: 'GuillermoPolito 4/24/2015 12:06'!nextResultSet: aConnection querySettings: aQuerySettings onReturn: aBlock 	"Returns the next resultSet from the last resultSet. When there is no more resultSets, 	the block is evaluated." 	| handle err |	handle := OpenDBX current createOpenDBXResultHandle.	aQuerySettings fetchListener ifNotNilDo: #fetchOccurred.	err := OpenDBX current				apiQueryResult: aConnection handle				handle: handle				timeout: aQuerySettings timeoutAsDBXTimeSpec				chunk: aQuerySettings pageSize.	self log: [		'odbx_result: called with values:',			' handle = ', aConnection handle asString, 			' chunk = ', aQuerySettings pageSize asString,			String cr, 		'odbx_result call return: ', err asString ].		self verifyError: err on: aConnection.	handle := OpenDBX current unpackOpenDBXHandle: handle.	self log: [ 'odbx_result resultSet handle returned: ', handle asString ].	aBlock notNil		ifTrue: [aBlock value: handle value: err].	^ handle! !!DBXBackend methodsFor: 'connection' stamp: 'MarianoMartinezPeck 10/5/2009 20:11'!openConnection: aConnection 	"'createConnection: should be called first'"	"It opens the connection, by associating the handle created by	'createConnection:' to a specific database after the server verified and	accepted the user credentials. All further operations will (normally)	only affect the tables and records within this database. The operations	may be limited to certain subset depending on the privileges granted to	the given user account. If 'openConnection:' succeeds, it also enables	compatibility to the ANSI SQL standard if this is possible for the database	server implementation."	| err |		self setNecessarySpecialOptions: aConnection. 		err := OpenDBX current 		apiBind: aConnection handle		database: aConnection database		name: aConnection userName		password: aConnection userPassword		method: aConnection authenticationMethod.	self log: 		[ 'odbx_bind: called with values:' , ' handle = ' , aConnection handle asString , ' database = ' , aConnection database , ' userName = ' , aConnection userName , ' userPassword = ' , aConnection userPassword ].	self 		verifyError: err		handle: aConnection handle.	^ true! !!DBXBackend methodsFor: 'printing' stamp: 'GuillermoPolito 1/6/2012 01:38'!printOn: aStream	aStream nextPutAll: self name.! !!DBXBackend methodsFor: 'resultSet' stamp: 'MarianoMartinezPeck 5/7/2011 00:38'!processNextResultSet: aConnection querySettings: aQuerySettings	"Gets the next resultSet of the query. Depending on the type of query, it will return a DBXResult or DBXResultSet.	If there is a timeout, it will cicle till this is finished."	| returnCode |	[self		nextResultSet: aConnection		querySettings: aQuerySettings		onReturn: [:handle :code | 			returnCode := code.			code = OpenDBX resultWithRows				ifTrue: [ ^ self processResultWithRows: aConnection					 resultHandle: handle 					querySettings: aQuerySettings].			code = OpenDBX resultWithoutRows				ifTrue: [ ^ self processResultWithoutRows: aConnection					 resultHandle: handle					 querySettings: aQuerySettings].			code = OpenDBX resultDone ifTrue: [^ nil].						(code = OpenDBX resultTimeout) ifTrue: [ (Delay forMilliseconds: (aQuerySettings timeout asMiliseconds)) wait  ].						]] 	doWhileTrue: [returnCode = OpenDBX resultTimeout].				OpenDBXDriverError signal: 'Uknown problem with executeStatement'.! !!DBXBackend methodsFor: 'resultSet' stamp: 'GuillermoPolito 4/17/2015 14:49'!processResultWithRows: aConnection resultHandle: aHandle querySettings: aQuerySettings		"Process a result with rows and returns a DBXResultSet"	| description |	description := self descriptionForResultSet: aHandle on: aConnection.	^ GAOpenDBXResultSet		on: aConnection		handle: aHandle		description: description		querySettings: aQuerySettings		! !!DBXBackend methodsFor: 'resultSet' stamp: 'MMP 6/4/2009 22:31'!processResultWithoutRows: aConnection resultHandle: aHandle querySettings: aQuerySettings		"Process a query with a result without rows and returns a DBXResult"	| description err |	description := self descriptionForResult: aHandle on: aConnection.	err := OpenDBX current apiQueryFinalize: aHandle.	self log: [ 'odbx_result_finish: called with values: resultSet handle = ', aHandle asString ].				self log: [ 'odbx_result_finish call returned ', err asString ].	^ DBXResult		on: aConnection		handle: aHandle		description: description		querySettings: aQuerySettings.! !!DBXBackend methodsFor: 'resultSet' stamp: 'MMP 6/4/2009 22:32'!queryDelimiter	" Returns the delimiter of the query. For example, ';' . But this depends on the backend"	^self subclassResponsibility! !!DBXBackend methodsFor: 'encoding' stamp: 'PanuSuominen 9/10/2010 09:55'!queryEncoding: aConnection	"Method should use platorm spesific way to determine what is the encoding used to talk with the server using.	Method should return the name of the encoding."	self subclassResponsibility.! !!DBXBackend methodsFor: 'resultSet' stamp: 'MMP 6/4/2009 22:34'!releaseAllQueryResultSets: aResultSet 	"Releases all query resultsSets a query may return by iterating them.	Each resultSet is Closed and all allocated memory by the OpenDBX	library is freed ."	self releaseResultSet: aResultSet.	self endDBXResult: aResultSet connection querySettings: aResultSet querySettings! !!DBXBackend methodsFor: 'resultSet' stamp: 'MMP 6/4/2009 23:06'!releaseResultSet: aResultSet 	"Closes a resultSet and all allocated memory by the OpenDBX library is	freed . In case you want to realese all query resultSets, yo must call	realeseAllQueryResultSets: "	self releaseResultSet: aResultSet handle connection: aResultSet connection! !!DBXBackend methodsFor: 'resultSet' stamp: 'MMP 6/4/2009 23:03'!releaseResultSet: aResultSetHandle connection: aConnection	"Closes a resultSet and all allocated memory by the OpenDBX library is	freed . In case you want to realese all query resultSets, yo must call	realeseAllQueryResultSets: "	| err |	err := OpenDBX current apiQueryFinalize: aResultSetHandle.	self log: [ 'odbx_result_finish: called with values: resultSet handle = ', aResultSetHandle asString ].	self verifyError: err on: aConnection! !!DBXBackend methodsFor: 'transactional manage' stamp: 'MMP 6/4/2009 22:37'!rollback	"If a certain backend doesn't use this sintax, it must subclass and override this method."	^ 'ROLLBACK'! !!DBXBackend methodsFor: 'transactional manage' stamp: 'MMP 6/4/2009 22:35'!rollback: aConnection	"executes a rollback statement on a connection"	^self executeStatement: self rollback on: aConnection.! !!DBXBackend methodsFor: 'private' stamp: 'DiogenesMoreira 12/7/2010 17:43'!setDateStyleOn: aDBXConnection 	"Do nothing, only is implemented in the platform where dbx need a special format"! !!DBXBackend methodsFor: 'options' stamp: 'mariano 5/7/2011 18:26'!setNecessarySpecialOptions: aConnection 	"This message will be called ALWAYS just before opening the connection. This can be used when you need to enable or disable ALWAYS a particular number of special options. The particular platform subclass can override this method to do this. For example, to get MySQL4 working, you always need to enable a special mode. Look for DBXMySQLBackend>>setNecessarySpecialOptions for an example"	! !!DBXBackend methodsFor: 'options' stamp: 'MMP 2/3/2009 01:25'!setOption: anOption value: anObject on: aConnection 	"It enables an specific option for a connection."	| err value |	(anObject class = True) ifTrue: [value := ByteArray with: anObject asBit ].	(anObject class = False) ifTrue: [value := ByteArray with: anObject asBit ].	(anObject class = SmallInteger) ifTrue: [value := ByteArray with: anObject].	(anObject class = ByteString) ifTrue: [value := anObject ].	err := OpenDBX current				apiSetOption: aConnection handle				option: anOption				value: value.	self verifyError: err on: aConnection! !!DBXBackend methodsFor: 'transactional manage' stamp: 'MMP 6/4/2009 22:36'!startTransaction	"It returns the start transaction statement most commonly used by the backends. If a certain backend	doesn't use this sintax, it must subclass and override this method."	^'START TRANSACTION'! !!DBXBackend methodsFor: 'transactional manage' stamp: 'MMP 6/4/2009 22:36'!startTransaction: aConnection	"Starts a transaction on a connection"	^self executeStatement: self startTransaction on: aConnection.! !!DBXBackend methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/24/2015 12:37'!supportsCursoredFetch	^ false! !!DBXBackend methodsFor: 'testing' stamp: 'GuillermoPolito 8/23/2011 11:35'!supportsLargeObjects	^true! !!DBXBackend methodsFor: 'testing' stamp: 'GuillermoPolito 4/24/2015 15:03'!testAutoCommitInConnection: aGAOpenDBXDriver 		self subclassResponsibility! !!DBXBackend methodsFor: 'error handling' stamp: 'MMP 6/4/2009 00:11'!verifyError: err handle: aHandle	"If verifies if a returned number of a call to an openDBX function, is an error or not. If true, a DBXError or any 	subclass is thrown with the associated openDBX message for that error.	Sometimes I don't have the DBXConnection object created or even with the handle set (for example when creating	the conenction. In this case, You should use this method. If you have the connection created and set a handle	you must use verifyError: err on: aConnection "	err < 0		ifTrue: [ self errorCode: err handle: aHandle]! !!DBXBackend methodsFor: 'error handling' stamp: 'MMP 6/3/2009 23:47'!verifyError: err on: aConnection 	"It verifies if a returned number of a call to an OpenDBX function, is an	error or not. If true, a DBXError or any subclass is thrown with the associated OpenDBX	message for that error."	err < 0		ifTrue: [self errorCode: err on: aConnection]! !!DBXFirebirdBackend methodsFor: 'accessing' stamp: 'mariano 12/19/2009 20:13'!backend	^ 'firebird'! !!DBXFirebirdBackend methodsFor: 'accessing' stamp: 'GuillermoPolito 1/6/2012 01:31'!name	^'Firebird'! !!DBXFirebirdBackend methodsFor: 'resultSet' stamp: 'Mariano 12/20/2009 15:54'!queryDelimiter	^';'! !!DBXFirebirdBackend methodsFor: 'transactional manage' stamp: 'Mariano 12/20/2009 15:37'!startTransaction	^'SET TRANSACTION READ WRITE'! !!DBXMSSQLBackend methodsFor: 'accessing' stamp: 'MMP 11/30/2008 21:10'!backend	^'mssql'! !!DBXMSSQLBackend methodsFor: 'accessing' stamp: 'GuillermoPolito 1/6/2012 01:32'!name	^'Microsoft SQL Server'! !!DBXMSSQLBackend methodsFor: 'resultSet' stamp: 'MMP 12/2/2008 00:00'!queryDelimiter	^';'! !!DBXMSSQLBackend methodsFor: 'transactional manage' stamp: 'MMP 6/4/2009 23:12'!startTransaction	"It returns the start transaction statement most commonly used by the backends"	^'BEGIN TRANSACTION'! !!DBXODBCMSSQLBackend methodsFor: 'accessing' stamp: 'GuillermoPolito 10/17/2013 00:22'!backend	^'odbc'! !!DBXMySQL4Backend methodsFor: 'accessing' stamp: 'GuillermoPolito 1/6/2012 01:38'!name	^'MySQL 4'! !!DBXMySQL4Backend methodsFor: 'options' stamp: 'MarianoMartinezPeck 10/5/2009 20:19'!setNecessarySpecialOptions: aConnection 	"To get MySQL4 working, you always need to enable a special mode with an empy string"	aConnection enableSpecialModes: ''. ! !!DBXMySQLBackend class methodsFor: 'defaults' stamp: 'MarianoMartinezPeck 2/12/2010 20:20'!createDataTypesMap	^super createDataTypesMap		at: 16r20 put: String; "CLOB"		at: 16r2F put: ByteArray;  "BLOB"		yourself		! !!DBXMySQLBackend methodsFor: 'accessing' stamp: 'EL 6/27/2008 20:30'!backend	^'mysql'! !!DBXMySQLBackend methodsFor: 'accessing' stamp: 'GuillermoPolito 1/6/2012 01:32'!name	^'MySQL'! !!DBXMySQLBackend methodsFor: 'resultSet' stamp: 'MMP 8/11/2008 23:15'!queryDelimiter	^';'! !!DBXOdbcBackend methodsFor: 'accessing' stamp: 'MMP 11/30/2008 21:30'!backend	^'odbc'! !!DBXOdbcBackend methodsFor: 'accessing' stamp: 'GuillermoPolito 1/6/2012 01:32'!name	^'ODBC'! !!DBXOdbcBackend methodsFor: 'resultSet' stamp: 'MMP 1/4/2009 23:47'!queryDelimiter	^';'! !!DBXOdbcBackend methodsFor: 'transactional manage' stamp: 'MMP 6/4/2009 23:12'!startTransaction	"It returns the start transaction statement most commonly used by the backends"	^'BEGIN TRAN'! !!DBXOracleBackend class methodsFor: 'defaults' stamp: 'GuillermoPolito 5/9/2012 07:28'!createDataTypesMap	^super createDataTypesMap		at: 16r20 put: (DBXTypeNotSupported type: #CLOB);		at: 16r21 put: (DBXTypeNotSupported type: #NCLOB);		at: 16r22 put: (DBXTypeNotSupported type: #XML);		at: 16r2F put: (DBXTypeNotSupported type: #BLOB);		yourself		! !!DBXOracleBackend methodsFor: 'accessing' stamp: 'MMP 8/6/2008 01:38'!backend	^'oracle'! !!DBXOracleBackend methodsFor: 'accessing' stamp: 'GuillermoPolito 1/6/2012 01:33'!name	^'Oracle'! !!DBXOracleBackend methodsFor: 'resultSet' stamp: 'MMP 8/11/2008 23:15'!queryDelimiter	^';'! !!DBXOracleBackend methodsFor: 'transactional manage' stamp: 'MMP 6/4/2009 23:12'!startTransaction	"This is a general approach for starting a transaction. If other approach is wanted, like SET TRANSACTION READ ONLY, you 	must do it manually like any other query."	^'SET TRANSACTION READ WRITE'! !!DBXOracleBackend methodsFor: 'transactional manage' stamp: 'GuillermoPolito 8/23/2011 11:36'!supportsLargeObjects	^false! !!DBXPostgresBackend class methodsFor: 'defaults' stamp: 'MarianoMartinezPeck 2/12/2010 18:18'!createDataTypesMap	^super createDataTypesMap		at: 16r20 put: String; "CLOB"		yourself		! !!DBXPostgresBackend methodsFor: 'accessing' stamp: 'EL 6/27/2008 20:30'!backend	^'pgsql'! !!DBXPostgresBackend methodsFor: 'accessing' stamp: 'GuillermoPolito 1/6/2012 01:33'!name	^'PostgreSQL'! !!DBXPostgresBackend methodsFor: 'resultSet' stamp: 'MMP 8/11/2008 23:15'!queryDelimiter	^';'! !!DBXPostgresBackend methodsFor: 'encoding' stamp: 'PanuSuominen 9/3/2010 21:02'!queryEncoding: aConnection	| result enc |	[ 	result := aConnection execute: 'SHOW CLIENT_ENCODING'.	enc := result nextRow rawValueAt: 1 ]		on: DBXRecoverableError do: [			Error signal: 'Querying encoding from Postgresql server failed!!'.			];		ensure: [ result ifNotNil: [ result releaseResult ] ].	^ enc! !!DBXPostgresBackend methodsFor: 'connection' stamp: 'DiogenesMoreira 12/7/2010 17:18'!setDateStyleOn: aConnection	aConnection execute:'SET DATESTYLE TO ISO'! !!DBXSqliteBackend class methodsFor: 'defaults' stamp: 'MarianoMartinezPeck 2/12/2010 22:18'!createDataTypesMap	^super createDataTypesMap		at: 16r20 put: String; "CLOB"		at: 16r2F put: ByteArray;  "BLOB"		yourself		! !!DBXSqliteBackend methodsFor: 'accessing' stamp: 'MMP 9/9/2008 01:39'!backend	^'sqlite3'! !!DBXSqliteBackend methodsFor: 'fromConnectionString' stamp: 'GuillermoPolito 4/27/2015 17:35'!connectionSettingsFromConnectionString: aConnectionString	^ (DBXConnectionSettings		host: (aConnectionString host = 'memory' 			ifTrue: [ '' ] 			ifFalse: [ ((aConnectionString database substrings: '/') allButLast joinUsing: '/'), '/' ])		port: ''		database: (aConnectionString host = 'memory'			ifTrue: [ ':memory:' ]			ifFalse: [ (aConnectionString database substrings: '/') last ])		userName: ''		userPassword: '')		encodingStrategy: (DBXStaticEncoding newForEncoding: (aConnectionString optionAt: 'encoding' ifAbsent: #utf8));		yourself! !!DBXSqliteBackend methodsFor: 'testing' stamp: 'GuillermoPolito 4/24/2015 15:05'!defaultValueAutoCommit		^ true! !!DBXSqliteBackend methodsFor: 'resultSet' stamp: 'DiogenesMoreira 6/24/2011 20:01'!moveNext: aResultSet 	"Moves the aResultSet one more row and this row is returned."	| err |	err := OpenDBX current apiQueryFetchRow: aResultSet handle.	self log: ['odbx_row_fetch: called with values: resultSet handle = ', aResultSet handle asString].	self log: ['odbx_row_fetch call returned ', err asString].	self verifyError: err on: aResultSet connection.	err = OpenDBX rowDone		ifTrue: [ ^ nil ]		ifFalse: [			^ DBXRow on: aResultSet detectNewTypes]! !!DBXSqliteBackend methodsFor: 'accessing' stamp: 'GuillermoPolito 1/6/2012 01:33'!name	^'SQLite'! !!DBXSqliteBackend methodsFor: 'testing' stamp: 'GuillermoPolito 4/17/2015 10:56'!newFixture		^ GADriverSQLiteTestFixture new! !!DBXSqliteBackend methodsFor: 'resultSet' stamp: 'MMP 9/17/2008 23:28'!queryDelimiter	^';'! !!DBXSqliteBackend methodsFor: 'transactional manage' stamp: 'MMP 9/16/2008 01:22'!startTransaction	^'BEGIN TRANSACTION'! !!DBXSqliteBackend methodsFor: 'testing' stamp: 'GuillermoPolito 4/24/2015 15:04'!testAutoCommitInConnection: aGAOpenDBXDriver 		^ true! !!DBXBaseResult class methodsFor: 'instance creation' stamp: 'HMC 9/27/2008 15:23'!new	self error: 'You must instanciate a subclass of DBXBaseResult'! !!DBXBaseResult methodsFor: 'accessing' stamp: 'HMC 9/27/2008 15:18'!connection	^ connection! !!DBXBaseResult methodsFor: 'accessing' stamp: 'MMP 5/27/2009 02:11'!connection: aConnection	connection := aConnection! !!DBXBaseResult methodsFor: 'accessing' stamp: 'HMC 9/27/2008 15:18'!description	^description! !!DBXBaseResult methodsFor: 'accessing' stamp: 'HMC 9/27/2008 15:18'!description: aDescription 	description := aDescription! !!DBXBaseResult methodsFor: 'accessing' stamp: 'HMC 9/27/2008 15:18'!handle	^handle! !!DBXBaseResult methodsFor: 'accessing' stamp: 'HMC 9/27/2008 15:18'!handle: aHandle 	handle := aHandle! !!DBXBaseResult methodsFor: 'initialization' stamp: 'MMP 2/2/2009 20:13'!initializeConnection: aConnection handle: aNumber description: aDescription querySettings: aQuerySettings 	super initialize.	connection := aConnection.	handle := aNumber.	description := aDescription.	querySettings := aQuerySettings.! !!DBXBaseResult methodsFor: 'testing' stamp: 'MMP 6/4/2009 22:04'!isDBXMultiStatementResultSetIterator	^ false! !!DBXBaseResult methodsFor: 'testing' stamp: 'MMP 6/4/2009 22:03'!isResult	^ false! !!DBXBaseResult methodsFor: 'testing' stamp: 'MMP 6/4/2009 22:03'!isResultSet	^ false! !!DBXBaseResult methodsFor: 'accessing' stamp: 'HMC 9/27/2008 15:19'!platform	^self connection platform! !!DBXBaseResult methodsFor: 'accessing' stamp: 'MMP 2/2/2009 20:12'!querySettings	^ querySettings! !!DBXBaseResult methodsFor: 'accessing' stamp: 'MMP 2/2/2009 20:12'!querySettings: anObject	querySettings := anObject! !!DBXBaseResult methodsFor: 'finalization' stamp: 'MMP 6/1/2009 20:23'!releaseResult	"It will release all the resources associated with a query, if there is any"	self subclassRisponsability! !!DBXMultiStatementResultSetIterator class methodsFor: 'instance creation' stamp: 'MMP 6/1/2009 21:43'!new	self error: 'Use #on:querySettings:'! !!DBXMultiStatementResultSetIterator class methodsFor: 'instance creation' stamp: 'MMP 5/27/2009 02:18'!on: aConnection querySettings: aQuerySettings	^(self basicNew)		initializeConnection: aConnection 			querySettings: aQuerySettings;		yourself.! !!DBXMultiStatementResultSetIterator methodsFor: 'enumerating' stamp: 'MMP 6/1/2009 20:34'!allResultsDo: aBlock	"For each result it evaluates the block"	| result |	[ result := self next.	  result notNil ] 	whileTrue: [ aBlock value: result ]! !!DBXMultiStatementResultSetIterator methodsFor: 'finalize' stamp: 'MMP 6/1/2009 20:25'!finalize	self isOpen ifTrue: [ self finalizeResults ]! !!DBXMultiStatementResultSetIterator methodsFor: 'finalize' stamp: 'MMP 5/27/2009 02:33'!finalizeResults	"It will release all the results of the multistatment query"	| result |	self isOpen		ifTrue: [[ result := self next.	  			result notNil ] 			whileTrue: [ result finalize ].			self internalBeClosed]! !!DBXMultiStatementResultSetIterator methodsFor: 'initialize' stamp: 'MMP 5/27/2009 02:30'!initializeConnection: aConnection querySettings: aQuerySettings	super initialize.	connection := aConnection.	querySettings := aQuerySettings.	open := ValueHolder new contents: false.	self internalBeOpen.! !!DBXMultiStatementResultSetIterator methodsFor: 'private' stamp: 'MMP 5/27/2009 02:22'!internalBeClosed	open contents: false! !!DBXMultiStatementResultSetIterator methodsFor: 'private' stamp: 'MMP 5/27/2009 02:22'!internalBeOpen	open contents: true! !!DBXMultiStatementResultSetIterator methodsFor: 'testing' stamp: 'MMP 6/4/2009 22:04'!isDBXMultiStatementResultSetIterator	^ true! !!DBXMultiStatementResultSetIterator methodsFor: 'testing' stamp: 'MMP 6/1/2009 20:25'!isOpen	"Returns if the DBXMultiStatementResultSetIterator is open or not."	^open contents! !!DBXMultiStatementResultSetIterator methodsFor: 'accessing' stamp: 'MMP 5/28/2009 00:35'!lastResult	^ lastResult! !!DBXMultiStatementResultSetIterator methodsFor: 'accessing' stamp: 'MMP 5/28/2009 00:35'!lastResult: anObject 	lastResult := anObject! !!DBXMultiStatementResultSetIterator methodsFor: 'processing' stamp: 'MMP 6/1/2009 20:35'!next	"Obtains the next DBXBaseResult of the multistatement query"	lastResult ifNotNil: [ 		"I must finalize the previous result (if there is) before processing the next one"		lastResult finalize ].	lastResult := self connection processNextResultSetMultiStatement: self querySettings.	^ lastResult! !!DBXMultiStatementResultSetIterator methodsFor: 'release' stamp: 'MMP 6/1/2009 20:09'!releaseResult	"It will release all the results of the multistatment query"	| result |	self isOpen		ifTrue: [[ result := self next.	  			result notNil ] 			whileTrue: [ result releaseResult ].			self internalBeClosed]! !!DBXResult class methodsFor: 'instance creation' stamp: 'MMP 8/16/2008 20:11'!new	self error: 'Use #on:handle:description:'! !!DBXResult class methodsFor: 'instance creation' stamp: 'MMP 2/2/2009 19:15'!on: aConnection handle: aNumber description: aDescription querySettings: aQuerySettings	^(self basicNew)		initializeConnection: aConnection 			handle: aNumber			description: aDescription			querySettings: aQuerySettings;		yourself.! !!DBXResult methodsFor: 'accessing' stamp: 'GuillermoPolito 4/7/2015 16:08'!affectedRows	^ self rowsAffected! !!DBXResult methodsFor: 'accessing' stamp: 'GuillermoPolito 4/20/2015 16:39'!generatedKey		^ self error: 'Generated keys cannot be retrieved automatically by the driver'! !!DBXResult methodsFor: 'testing' stamp: 'MMP 6/4/2009 22:04'!isResult	^ true! !!DBXResult methodsFor: 'release' stamp: 'MMP 6/1/2009 20:03'!releaseResult	"Maybe in a future this method could do something"! !!DBXResult methodsFor: 'accessing' stamp: 'MMP 5/31/2009 20:34'!rowsAffected	"Returns the number of rows that have been changed by the current statement. Affected rows are only returned for DELETE, INSERT or UPDATE statements and their concrete number depends on the database implementation. 		This value depends on the type of query:    * DDL query: It will always be zero.    * Insert query: It will always be one.    * Delete and update: Returns the number of rows that have been changed by the current statement. However, their concrete number depends on the database implementation. Instead returning the number of rows which are matched by the WHERE clause, MySQL for example does only count the rows whose values have really been changed. "		^self description rowsAffected! !!DBXColumnDescription class methodsFor: 'instance creation' stamp: 'DiogenesMoreira 6/24/2011 19:32'!name: aString dbxType: aNumber type: aType"this instantiates a new DBXColumnDescription with a type size of zero"	^self name: aString dbxType: aNumber type: aType size: 0 ! !!DBXColumnDescription class methodsFor: 'instance creation' stamp: 'DiogenesMoreira 6/24/2011 19:32'!name: aNameString dbxType: aNumber type: aTypeSymbol size: aTypeSizeNumber"this instantiates a new DBXColumnDescription, whitch will hold the name, data type and size of the data type the rows from the database have"	^(super new)		name: aNameString;		type: aTypeSymbol;		size: aTypeSizeNumber;		yourself.! !!DBXColumnDescription class methodsFor: 'instance creation' stamp: 'EL 3/31/2008 11:58'!new	self error: 'Use caption:type:'! !!DBXColumnDescription methodsFor: 'accessing' stamp: 'DiogenesMoreira 6/27/2011 12:46'!addTo: aDBXResultSetDescription	aDBXResultSetDescription addDescription: self.	type isBehavior ifFalse:[		aDBXResultSetDescription addNotSupportedDescription: self.	].! !!DBXColumnDescription methodsFor: 'accessing' stamp: 'HMC 8/16/2008 20:56'!dbxType"this is the data type of this column, according to its data type from the database"	^ dbxType! !!DBXColumnDescription methodsFor: 'accessing' stamp: 'EL 8/3/2008 08:45'!dbxType: anObject	dbxType := anObject! !!DBXColumnDescription methodsFor: 'testing' stamp: 'mariano 5/7/2011 18:23'!isLarge"see DBXBackend isLarge"	^DBXBackend isLarge: self dbxType! !!DBXColumnDescription methodsFor: 'accessing' stamp: 'HMC 8/16/2008 20:57'!name"this is the name of this column, according to its database name, "	^name! !!DBXColumnDescription methodsFor: 'accessing' stamp: 'EL 6/27/2008 19:49'!name: aString	name := aString! !!DBXColumnDescription methodsFor: 'printing' stamp: 'EL 6/27/2008 20:45'!printOn: aStream	aStream nextPut: $(.	self name printOn: aStream.	aStream nextPut: $:.	self type printOn: aStream.	aStream nextPut: $).! !!DBXColumnDescription methodsFor: 'accessing' stamp: 'HMC 8/16/2008 21:15'!size"size of the data type"	^size! !!DBXColumnDescription methodsFor: 'accessing' stamp: 'EL 6/27/2008 19:50'!size: aNumber	size := aNumber! !!DBXColumnDescription methodsFor: 'accessing' stamp: 'HMC 8/16/2008 20:59'!type"type of the data that a column description holds"	^ type! !!DBXColumnDescription methodsFor: 'accessing' stamp: 'EL 3/31/2008 11:24'!type: anObject	type := anObject! !!DBXConnection class methodsFor: 'initialization' stamp: 'MMP 4/15/2008 00:37'!initialize	"DBConnection initialize"	Smalltalk addToStartUpList: self.	Smalltalk addToShutDownList: self.! !!DBXConnection class methodsFor: 'logging' stamp: 'EL 5/12/2008 18:50'!log: message	Transcript show: message; cr.! !!DBXConnection class methodsFor: 'instance creation' stamp: 'EL 7/1/2008 16:51'!platform: aPlatform settings: aConnectionSettings	^self new		platform: aPlatform;		settings: aConnectionSettings;		yourself! !!DBXConnection class methodsFor: 'system startup' stamp: 'MarianoMartinezPeck 6/7/2012 17:41'!shutDown: quitting	quitting ifTrue: [ self allInstancesDo: [:each | each shutDown]]! !!DBXConnection class methodsFor: 'system startup' stamp: 'MarianoMartinezPeck 6/7/2012 17:44'!startUp: resumming	"The OpenDBX current has to be reinitialized just in case the same image is loaded in a different Operating System"	resumming ifTrue: [OpenDBX current: nil].! !!DBXConnection methodsFor: 'accessing' stamp: 'MMP 6/4/2009 00:33'!authenticationMethod	^ settings method! !!DBXConnection methodsFor: 'release' stamp: 'Mariano 3/28/2010 16:32'!cleanUp"It cleanUps all the necessary stuff from the connection so that it can be safetly used in another context, without needing to close it and open it again. For example, if the last query with this connection, did not finish to get all resultSets and raws, it will do it. If there was a transaction opened, it will be rollbacked.This methos is useful for a ConnectionPool. When someone gives to back a connection (because it is not used anymore) con can send this message and after this, the connection should be perfectly avaiable for another user."	self rollbackCurrentTransaction.	self releasePreviousResult.	! !!DBXConnection methodsFor: 'connection open/close' stamp: 'MarianoMartinezPeck 5/7/2011 00:38'!close	"It closes the connection releasing all the results. It will probably free tcp/ip database connection. You must re open it in order to execute more queries"	self isOpen		ifFalse: [OpenDBXDriverError signal: 'The connection is not open. Try opening it first'].	self releasePreviousResult.	self platform closeConnection: self.	transactionOpened := false.	self internalBeClosed! !!DBXConnection methodsFor: 'transactional manage' stamp: 'MarianoMartinezPeck 5/7/2011 00:38'!commit	"executes a commit statement"	| aResult |	self isOpen ifFalse: 		[ OpenDBXDriverError signal: 'You cannot commit if the connection is not open' ].	self result ifNotNil: [ self releaseResult ].	aResult := self platform commit: self.	transactionOpened := false.	self result: aResult.	^ self result! !!DBXConnection methodsFor: 'connection open/close' stamp: 'MarianoMartinezPeck 5/7/2011 00:39'!connect	"This is the first method that must be called to a connection. It connects to database host and creates all the data structure for a connection. After it, you can call open. You cannot connect an already connected connection"	self isConnected		ifTrue: [OpenDBXDriverError signal: 'You are already connected. Try disconnecting first' ].	self validateSettingsForConnect.	"WARNING This is the only place where we have direct access to	handles... "	handle := self platform createConnection: self.		self platform class isAutomaticConnectionReleaseOnGC ifTrue: [		OpenDBXDriverSmalltalkDialect current addObjectToGarbageCollect: self].		self internalBeConnected.	! !!DBXConnection methodsFor: 'connection open/close' stamp: 'MarianoMartinezPeck 5/7/2011 18:47'!connectAndOpen"Take into consideration that using this method you cannot specify special options because many of them should be called between connect and open operationsIn case you don't want to use any OpenDBXDriver special options, you can use this message. However, we recommend to use connect and open separately"		self connect.	self open.! !!DBXConnection methodsFor: 'accessing' stamp: 'MMP 6/4/2009 00:32'!database	^ settings database! !!DBXConnection methodsFor: 'encoding' stamp: 'PanuSuominen 9/10/2010 09:52'!decodeString: aByteArray	"Decodes system string from encoded representation."	^ encoder isNil ifTrue:[aByteArray ] ifFalse: [encoder convertFromSystemString: aByteArray].! !!DBXConnection methodsFor: 'connection open/close' stamp: 'MMP 12/22/2008 20:42'!disconnect	" Disconnect from database releasing all resultSets. No operation will be permitted after it. It must be call when you finish using the connection. If the connection wasn't close, it will do it. In order to do a disconnection, the connection must be connected'"	self isConnected		ifFalse: [^ nil].	self isOpen		ifTrue: [self close].	self releaseConnection.	self internalBeDisconnected.	handle := nil! !!DBXConnection methodsFor: 'options' stamp: 'MMP 8/12/2008 01:29'!enableCompression	"It tries to enable Compression option. If it can, it activates the option, returns true and you can use that option. If not, it will return false. So you must ask the return on this method in order to now what to do."	^self enableSpecialOption: DBXSpecialOptions compression.! !!DBXConnection methodsFor: 'options' stamp: 'MarianoMartinezPeck 2/24/2011 18:37'!enableEncryption: aEncryptionOption"It tries to enable Encryption option. If it can, it activates the option, returns true and you can use that option. If not, it will return false. So you must ask the return on this method in order to now what to do."	(self isOptionSupportedByPlattform: DBXSpecialOptions encryption) ifTrue: 		[ self platform 			setOption: DBXSpecialOptions encryption			value: aEncryptionOption			on: self.		^ true ].	^ false! !!DBXConnection methodsFor: 'options' stamp: 'MMP 8/12/2008 01:29'!enableMultipleStatements"It tries to enable Multiple Statements option. If it can, it activates the option, returns true and you can use that option. If not, it will return false. So you must ask the return on this method in order to now what to do."	^self enableSpecialOption: DBXSpecialOptions multipleStatements! !!DBXConnection methodsFor: 'options' stamp: 'MMP 8/12/2008 01:30'!enablePagedResults"It tries to enable paged results. If it can, it activates the option, returns true and you can use that option. If not, it will return false. So you must ask the return on this method in order to now what to do."	^self enableSpecialOption: DBXSpecialOptions pagedResults.! !!DBXConnection methodsFor: 'options' stamp: 'MMP 8/9/2009 16:56'!enableSpecialModes: modes 	"It tries to enable specific modes. For example MySQL special modes (http://dev.mysql.com/doc/refman/5.0/en/server-sql-mode.html). If it can, it activates the option, returns true and you can use that option. If not, it will return false. So you must ask the return on this method in order to now what to do."	(self isOptionSupportedByPlattform: DBXSpecialOptions specialModes) ifTrue: 		[ self platform 			setOption: DBXSpecialOptions specialModes			value: modes			on: self.		^ true ].	^ false! !!DBXConnection methodsFor: 'options' stamp: 'MMP 8/12/2008 01:34'!enableSpecialOption: specialOption 	"It returns if the specialOption could be enable or not.	Before enabling a specific option, I must be sure the current backend	support it"	(self isOptionSupportedByPlattform: specialOption)		ifTrue: [self platform				setOption: specialOption				value: true				on: self.				^true.].		^false.! !!DBXConnection methodsFor: 'encoding' stamp: 'PanuSuominen 9/10/2010 09:53'!encodeString: aString	"Encodes system string to some format"	^ encoder isNil ifTrue:[aString] ifFalse:[ encoder convertToSystemString: aString].! !!DBXConnection methodsFor: 'query' stamp: 'MarianoMartinezPeck 5/7/2011 00:38'!execute: aString 	"This message is used for ALL type of query: SQL, DML and DDL.	Depending on the type of query it will return DBXResult or	DBXResultSet. 	The queries sent to the server must be understood by the DBMS because	there is no translation done between the different dialects of SQL for	example. 	To execute a query you must be connected and open.	You DON'T need to call nextRow till nil its returned, the framework will	do it for you in your next query. 	If you want multistatement queries, you must use executeMultiStatement:		"	| aResult |	self isOpen ifFalse: 		[ OpenDBXDriverError signal: 'You cannot execute a query if the connection is not open' ].	self releasePreviousResult.	aResult := self platform 		executeStatement: aString		on: self.	self result: aResult.	^ self result! !!DBXConnection methodsFor: 'query' stamp: 'MarianoMartinezPeck 5/7/2011 18:46'!execute: aString querySettings: aQuerySettings 	"Same as execute, but it ads a query settings.	A query settigs has two things: pageSize and timeout.		Page size: Dependent on the native	database library, it may be possible to retrieve all rows at once (if the	page size parameter is zero), one by one or more than one row at once.	All positive values including zero are allowed as values for the page size If	paging (more than one row at once) is not supported by the backend, it	will use one by one or all at once if this is the only option provided.		Timeout: Restricts the time OpenDBXDriver is waiting for a result form the server. 	It may be nil to wait until a result arrives. Otherwise, it can contain any number 	of seconds and microseconds to wait for.		"	| aResult |	self isOpen ifFalse: 		[ OpenDBXDriverError signal: 'You cannot execute a query if the connection is not open' ].	self releasePreviousResult.	aResult := self platform 		executeStatement: aString		on: self		querySettings: aQuerySettings.	self result: aResult.	^ self result! !!DBXConnection methodsFor: 'query' stamp: 'MarianoMartinezPeck 5/7/2011 18:46'!executeDDLScript: aDDLScript "Its very common you need to execute a complete DDL script: create, drop or alter tables. In these cases, you don't have any interesting results from each query. In such a case, you should use this method. Remember OpenDBXDriver doesn't do any translation so your statement delimiter must be understood by the backend. In order to know which delimiter we use, you can see the message queryDelimiter of the current platform backend, for example DBXPostgresBackend.This message doesn't use the multistatements option of openDBX, it is all done by OpenDBXDriver so you don't have to care about it"	| ddlStatements |	ddlStatements := aDDLScript findTokens: self platform queryDelimiter.	ddlStatements		do: [:ddlStatement | self execute: ddlStatement]! !!DBXConnection methodsFor: 'query' stamp: 'MarianoMartinezPeck 5/7/2011 00:38'!executeMultiStatement: aString	"This message is used when you must use multistatement, stored procedures or functions.	It returns a DBXMultiStatementResultSetIterator. 	The queries sent to the server must be understood by the DBMS because	there is no translation done between the different dialects of SQL for	example. 	To execute a query you must be connected and open.		You DON'T need to call next till nil its returned, the framework will	do it for you in your next query.	"			| multiStatmentIterator |	self isOpen ifFalse: 		[ OpenDBXDriverError signal: 'You cannot execute a query if the connection is not open' ].	self result ifNotNil: [ self result releaseResult ].	multiStatmentIterator := self platform 		executeMultiStatement: aString		on: self.	self result: multiStatmentIterator.	^ self result! !!DBXConnection methodsFor: 'finalization' stamp: 'GuillermoPolito 4/7/2015 16:28'!finalize ^self! !!DBXConnection methodsFor: 'accessing' stamp: 'EL 3/30/2008 14:41'!handle	^handle! !!DBXConnection methodsFor: 'accessing' stamp: 'MMP 6/4/2009 00:18'!host	^ settings host! !!DBXConnection methodsFor: 'initialization' stamp: 'MarianoMartinezPeck 5/7/2011 18:46'!initialize	super initialize.	"These ValueHolder are very important and you cannot change them. If you instantiate a DBXConnection and never do the disconnect, OpenDBXDriver will do it whe the object is garbage collected. How OpenDBXDriver do that? DBXConnection is registered in the default WeakRegistry. So, when you call connect we add the object to that registry. In that moment a clone is generated from the original object. Suppose you then do the disconnect to the original object. If we don't use ValueHolder, the clone will have other objects for open and connected and because of this, the disconnect will be called twice, generating an openDBX error.' "	open := ValueHolder new contents: false.	connected := ValueHolder new contents: false.	result := nil.	transactionOpened := false.! !!DBXConnection methodsFor: 'initialization' stamp: 'EL 6/29/2008 09:59'!initializePlatform: aPlatform settings: aConnectionSettings handle: aNumber	platform := aPlatform.	settings := aConnectionSettings.	handle := aNumber.	self internalBeConnected.! !!DBXConnection methodsFor: 'private' stamp: 'EL 6/27/2008 08:58'!internalBeClosed	open contents: false! !!DBXConnection methodsFor: 'private' stamp: 'EL 6/27/2008 08:58'!internalBeConnected	connected contents: true.! !!DBXConnection methodsFor: 'private' stamp: 'EL 6/27/2008 08:58'!internalBeDisconnected	connected contents: false.! !!DBXConnection methodsFor: 'private' stamp: 'EL 6/27/2008 08:58'!internalBeOpen	open contents: true.! !!DBXConnection methodsFor: 'testing' stamp: 'MMP 4/25/2008 00:44'!isConnected	^connected contents.! !!DBXConnection methodsFor: 'testing' stamp: 'MMP 4/25/2008 00:44'!isOpen	^open contents.! !!DBXConnection methodsFor: 'options' stamp: 'MMP 8/12/2008 01:32'!isOptionSupportedByPlattform: specialOption "It returns if the specialOption is supported by the backend"	^self platform		getOption: specialOption		on: self.! !!DBXConnection methodsFor: 'connection open/close' stamp: 'MarianoMartinezPeck 5/7/2011 00:38'!open	"Opens the connection. You must first do a connect and you cannot call this method if the connection is already open.. This method will probably opens the tcp/ip database connection. After calling this method, you should be able to send queries"	self isConnected ifFalse: [		OpenDBXDriverError signal: 'You are not connected. Try connecting first'].	self isOpen ifTrue: [ 		OpenDBXDriverError signal: 'The connection is already open'].	self validateSettingsForOpen.	"If it's a fatal error, it means it couldn't open the connection, therefore, we just disconnect it and signal the error again"	[ self platform openConnection: self.] 		on: DBXFatalError 		do: [ :aFatalError | 			self disconnect.			aFatalError signal ].	self internalBeOpen.	self setEncoding.	self setDateStyle. ! !!DBXConnection methodsFor: 'accessing' stamp: 'MMP 6/10/2008 01:06'!platform	^platform! !!DBXConnection methodsFor: 'accessing' stamp: 'EL 7/1/2008 16:54'!platform: aPlatform	platform := aPlatform! !!DBXConnection methodsFor: 'accessing' stamp: 'MMP 6/4/2009 00:18'!port	^ settings port! !!DBXConnection methodsFor: 'query' stamp: 'MMP 6/4/2009 01:30'!processNextResultSetMultiStatement: aQuerySettings	"proccess and obtains the next resultset"	^ self platform processNextResultSet: self querySettings: aQuerySettings! !!DBXConnection methodsFor: 'encoding' stamp: 'PanuSuominen 9/2/2010 21:21'!queryEncoding	"I return prefered encoding for my self. I need the help of my platform to do it but it	is possible that the platform has no idea about the encoding. "	^(self platform queryEncoding: self).! !!DBXConnection methodsFor: 'connection open/close' stamp: 'MarianoMartinezPeck 5/7/2011 00:38'!reOpen: aConnectionSettings	"It simply do a close and an open with the new connectionSettings. 	Suppouse you have a DBXConnection connected and open. Sometimes it may be necessary to connect to a different database (schema) or re-authenticate using different credentials. In such a case you can use this message"	self isConnected ifFalse: [		OpenDBXDriverError signal: 'You are not connected. Try connecting first' ].	self isOpen ifFalse: [ 		OpenDBXDriverError signal: 'The connection must be open in order to reOpen it' ].	self close.	self settings: aConnectionSettings.	self open.! !!DBXConnection methodsFor: 'release' stamp: 'GuillermoPolito 4/7/2015 16:22'!releaseConnection ^self! !!DBXConnection methodsFor: 'finalization' stamp: 'Mariano 3/27/2010 22:06'!releasePreviousResult	"If there is, I must release the previous query"	self result ifNotNil: [ self result releaseResult ].	self result: nil.! !!DBXConnection methodsFor: 'release' stamp: 'MMP 6/1/2009 21:31'!releaseResult	 self result releaseResult ! !!DBXConnection methodsFor: 'accessing' stamp: 'MMP 2/2/2009 19:14'!result	^ result! !!DBXConnection methodsFor: 'accessing' stamp: 'MMP 2/2/2009 19:14'!result: anObject 	result := anObject! !!DBXConnection methodsFor: 'transactional manage' stamp: 'MarianoMartinezPeck 5/7/2011 00:38'!rollback	"executes a rollback statement"	| aResult |	self isOpen ifFalse: 		[ OpenDBXDriverError signal: 'You cannot rollback if the connection is not open' ].	self result ifNotNil: [ self releaseResult ].	aResult := self platform rollback: self.	transactionOpened := false.	self result: aResult.	^ self result! !!DBXConnection methodsFor: 'transactional manage' stamp: 'Mariano 3/27/2010 21:07'!rollbackCurrentTransaction	transactionOpened ifTrue: [self rollback].	transactionOpened := false.! !!DBXConnection methodsFor: 'initialization' stamp: 'DiogenesMoreira 12/7/2010 17:13'!setDateStyle	self platform setDateStyleOn: self.! !!DBXConnection methodsFor: 'encoding' stamp: 'GuillermoPolito 4/27/2015 17:42'!setEncoding	"Sets the encoding based on encoding strategy."	self settings encodingStrategy isNil		ifFalse: [ encoder := self settings encodingStrategy encoderFor: self ]! !!DBXConnection methodsFor: 'accessing' stamp: 'EL 6/29/2008 09:42'!settings	^ settings! !!DBXConnection methodsFor: 'accessing' stamp: 'EL 7/1/2008 16:54'!settings: aConnectionSettings	settings := aConnectionSettings! !!DBXConnection methodsFor: 'running' stamp: 'MMP 6/1/2009 21:22'!shutDown	"This message is called when the object is garbage collected. In case the connection was connected, but not disconnected, it will be disconnected"	 self isConnected ifTrue: [		 [self disconnect] on: Error do: [:e | Transcript show: e ] ]! !!DBXConnection methodsFor: 'transactional manage' stamp: 'MarianoMartinezPeck 5/7/2011 00:38'!startTransaction	"executes a start transaction statement"	| aResult |	self isOpen ifFalse: 		[ OpenDBXDriverError signal: 'You cannot start a transaction if the connection is not open' ].	self result ifNotNil: [ self releaseResult ].	aResult := self platform startTransaction: self.	transactionOpened := true.	self result: aResult.	^ self result! !!DBXConnection methodsFor: 'running' stamp: 'MMP 8/12/2008 01:54'!startUp	"till now, nothing is done on the startup"! !!DBXConnection methodsFor: 'accessing' stamp: 'Mariano 3/27/2010 21:39'!transactionOpened 	^ transactionOpened ! !!DBXConnection methodsFor: 'accessing' stamp: 'MMP 6/4/2009 00:32'!userName	^ settings userName! !!DBXConnection methodsFor: 'accessing' stamp: 'MMP 6/4/2009 00:33'!userPassword	^ settings userPassword! !!DBXConnection methodsFor: 'validating' stamp: 'MMP 7/10/2008 23:25'!validateSettingsForConnect	self settings validatePort.! !!DBXConnection methodsFor: 'validating' stamp: 'MMP 7/10/2008 23:25'!validateSettingsForOpen	self settings method.! !!DBXConnectionSettings class methodsFor: 'instance creation' stamp: 'EL 6/29/2008 09:13'!host: aHost port: aPort	^ self basicNew		initializeHost: aHost 			port: aPort;		yourself! !!DBXConnectionSettings class methodsFor: 'instance creation' stamp: 'PanuSuominen 9/10/2010 10:25'!host: aHost port: aPort database: aDatabase userName: aUsername userPassword: aPassword	^ self basicNew		initializeHost: aHost 			port: aPort 			database: aDatabase 			userName: aUsername  			userPassword: aPassword		yourself! !!DBXConnectionSettings class methodsFor: 'instance creation' stamp: 'PanuSuominen 9/10/2010 10:26'!host: aHost port: aPort database: aDatabase userName: aUsername userPassword: aPassword encodingStrategy: encodingStrategy	^ self basicNew		initializeHost: aHost 			port: aPort 			database: aDatabase 			userName: aUsername  			userPassword: aPassword;			encodingStrategy: encodingStrategy;		yourself! !!DBXConnectionSettings class methodsFor: 'instance creation' stamp: 'EL 6/29/2008 09:32'!host: aDatabase userName: aUsername userPassword: aPassword	^ self basicNew		initializeHost: aDatabase 			userName: aUsername  			userPassword: aPassword		yourself! !!DBXConnectionSettings methodsFor: 'accessing' stamp: 'EL 6/29/2008 09:07'!database	^ database! !!DBXConnectionSettings methodsFor: 'accessing' stamp: 'MMP 7/9/2008 23:38'!database: anObject	database := anObject! !!DBXConnectionSettings methodsFor: 'encoding' stamp: 'PanuSuominen 9/10/2010 10:29'!encodingStrategy	"See encodingStrategy:"	^encodingStrategy.! !!DBXConnectionSettings methodsFor: 'encoding' stamp: 'PanuSuominen 9/1/2010 18:35'!encodingStrategy: anObject	"Encoding strategy used to determine actaul TextConverter to be used with database connections. Encoding strategy must be able to respond #encoderFor: -message and return TextConverter."	encodingStrategy := anObject! !!DBXConnectionSettings methodsFor: 'accessing' stamp: 'MMP 6/10/2008 00:50'!host	^ host! !!DBXConnectionSettings methodsFor: 'accessing' stamp: 'MMP 7/9/2008 23:38'!host: anObject	host := anObject! !!DBXConnectionSettings methodsFor: 'initialization' stamp: 'EL 6/29/2008 09:11'!initializeHost: aHost port: aPort	self initialize.	host := aHost.	port := aPort! !!DBXConnectionSettings methodsFor: 'initialization' stamp: 'EL 6/29/2008 09:12'!initializeHost: aHost port: aPort database: aDatabaseName userName: aUserName userPassword: aPassword	self initialize.	host := aHost.	port := aPort.	database := aDatabaseName.	userName := aUserName.	userPassword := aPassword.! !!DBXConnectionSettings methodsFor: 'initialization' stamp: 'EL 6/29/2008 09:13'!initializeHost: aDatabaseName userName: aUserName userPassword: aPassword	self initialize.	database  := aDatabaseName.	userName := aUserName.	userPassword := aPassword.! !!DBXConnectionSettings methodsFor: 'accessing' stamp: 'MMP 7/11/2008 00:24'!method	^ method ifNil: [ method := DBXAuthenticationMethod usernamePassword ]! !!DBXConnectionSettings methodsFor: 'accessing' stamp: 'MMP 7/9/2008 23:38'!method: anObject	^ method := anObject! !!DBXConnectionSettings methodsFor: 'accessing' stamp: 'MMP 6/10/2008 00:50'!port	^ port! !!DBXConnectionSettings methodsFor: 'accessing' stamp: 'MMP 7/9/2008 23:38'!port: anObject	port := anObject! !!DBXConnectionSettings methodsFor: 'accessing' stamp: 'EL 6/29/2008 09:07'!userName	^ userName! !!DBXConnectionSettings methodsFor: 'accessing' stamp: 'MMP 7/9/2008 23:38'!userName: anObject	userName := anObject! !!DBXConnectionSettings methodsFor: 'accessing' stamp: 'EL 6/29/2008 09:07'!userPassword	^ userPassword! !!DBXConnectionSettings methodsFor: 'accessing' stamp: 'MMP 7/9/2008 23:38'!userPassword: anObject	userPassword := anObject! !!DBXConnectionSettings methodsFor: 'validating' stamp: 'MarianoMartinezPeck 5/7/2011 00:38'!validateMethod	self method notNil ifTrue: 		[ self method = DBXAuthenticationMethod usernamePassword ifFalse: [ OpenDBXDriverError signal: 'The only supported method is zero' ] ]! !!DBXConnectionSettings methodsFor: 'validating' stamp: 'MarianoMartinezPeck 5/7/2011 00:38'!validatePort	(self port notNil and: [ port ~= ''] )		ifTrue: [(self port asNumber > 0)			ifFalse: [OpenDBXDriverError signal: 'The port must be a positive number']]! !!DBXAutomaticEncoding methodsFor: 'as yet unclassified' stamp: 'MarianoMartinezPeck 9/25/2010 19:58'!encoderFor: aConnection 	| encoding |	encoding := aConnection queryEncoding.	^TextConverter newForEncoding: encoding.! !!DBXEncodingStrategy methodsFor: 'as yet unclassified' stamp: 'PanuSuominen 9/1/2010 18:21'!encoderFor: anObject	"I will return instance of TextConverter to convert data related to given object.	The method of deciding how to encode the data depends on the implementation."	self subclassResponsibility.! !!DBXEncodingStrategy methodsFor: 'as yet unclassified' stamp: 'PanuSuominen 9/1/2010 18:17'!encodingFor: anObject	"I will return instance of TextConverter to convert data related to given object.	The method of deciding how to encode the data depends on the implementation."	self subclassResponsibility.! !!DBXNoEncoding class methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 3/19/2011 14:31'!instance	^Instance ifNil: [Instance := self new].! !!DBXNoEncoding methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 3/19/2011 14:31'!encoderFor: anObject 	^DBXNullTextConverter instance.! !!DBXStaticEncoding class methodsFor: 'as yet unclassified' stamp: 'PanuSuominen 8/31/2010 20:52'!newForEncoding: nameOfEncoding	|o|	o := self basicNew.	o encoder: (TextConverter newForEncoding: nameOfEncoding).	^o.! !!DBXStaticEncoding methodsFor: 'as yet unclassified' stamp: 'PanuSuominen 8/31/2010 20:50'!encoder: aTextConverter 	encoder := aTextConverter.! !!DBXStaticEncoding methodsFor: 'as yet unclassified' stamp: 'PanuSuominen 8/31/2010 20:53'!encoderFor: anObject	^encoder copy.! !!DBXEncryptionValues class methodsFor: 'values' stamp: 'MMP 8/24/2008 16:58'!always	^2! !!DBXEncryptionValues class methodsFor: 'values' stamp: 'MMP 8/23/2008 21:01'!never	^0! !!DBXEncryptionValues class methodsFor: 'values' stamp: 'MMP 8/23/2008 21:01'!try	^1! !!DBXErrorSeverity class methodsFor: 'as yet unclassified' stamp: 'MMP 6/3/2009 23:59'!isFatal: aErrorType	^ aErrorType < 0! !!DBXErrorSeverity class methodsFor: 'as yet unclassified' stamp: 'MMP 6/4/2009 00:02'!isNotAnError: aErrorType	^ aErrorType = 0! !!DBXErrorSeverity class methodsFor: 'as yet unclassified' stamp: 'MMP 6/4/2009 00:02'!isRecoverable: aErrorType	^ aErrorType > 0! !!DBXLogger methodsFor: 'as yet unclassified' stamp: 'MMP 11/25/2008 01:32'!log	! !!DBXQuerySettings class methodsFor: 'default' stamp: 'MMP 6/1/2009 21:57'!default	"returns the default querySettings. This is used when you call DBXConnection>>execute:"	^ self pageSize: self defaultPageSize timeout: self defaultTimeout ! !!DBXQuerySettings class methodsFor: 'default' stamp: 'MMP 1/31/2009 20:30'!defaultPageSize	^ 0! !!DBXQuerySettings class methodsFor: 'default' stamp: 'MMP 7/1/2009 22:17'!defaultTimeout	"10 miliseconds"	^DBXQueryTimeout seconds: 0 microseconds: 10.! !!DBXQuerySettings class methodsFor: 'default' stamp: 'abc 8/30/2013 18:17'!noTimeout	"10 miliseconds"	^DBXQueryTimeout seconds: 0 microseconds: 0.! !!DBXQuerySettings class methodsFor: 'instance creation' stamp: 'MMP 4/6/2009 21:03'!pageSize: aPageSize	^(super new)		pageSize: aPageSize;		timeout: self defaultTimeout;		yourself.! !!DBXQuerySettings class methodsFor: 'instance creation' stamp: 'MMP 4/6/2009 01:52'!pageSize: aPageSize timeout: aQueryTimeout 	^(super new)		pageSize: aPageSize;		timeout: aQueryTimeout;		yourself.! !!DBXQuerySettings class methodsFor: 'instance creation' stamp: 'MMP 4/6/2009 21:02'!timeout: aQueryTimeout 	^(super new)		pageSize: self defaultPageSize;		timeout: aQueryTimeout;		yourself.! !!DBXQuerySettings methodsFor: 'accessing' stamp: 'GuillermoPolito 4/24/2015 12:06'!fetchListener	^ fetchListener! !!DBXQuerySettings methodsFor: 'accessing' stamp: 'GuillermoPolito 4/24/2015 12:06'!fetchListener: aFetchListener	fetchListener := aFetchListener! !!DBXQuerySettings methodsFor: 'accessing' stamp: 'MMP 1/31/2009 20:03'!pageSize	^ pageSize! !!DBXQuerySettings methodsFor: 'accessing' stamp: 'MMP 1/31/2009 20:03'!pageSize: anObject	pageSize := anObject! !!DBXQuerySettings methodsFor: 'accessing' stamp: 'abc 8/30/2013 18:17'!timeout	^ timeout ifNil: [ timeout := self class noTimeout ]! !!DBXQuerySettings methodsFor: 'accessing' stamp: 'MMP 4/6/2009 01:50'!timeout: anObject	timeout := anObject! !!DBXQuerySettings methodsFor: 'accessing' stamp: 'MMP 4/7/2009 00:17'!timeoutAsDBXTimeSpec	^self timeout ifNotNil: [self timeout asTimeSpec].! !!DBXQueryTimeout class methodsFor: 'instance creation' stamp: 'MMP 4/7/2009 00:08'!seconds: seconds 	^ self new		seconds: seconds;		microseconds: 0;		yourself! !!DBXQueryTimeout class methodsFor: 'instance creation' stamp: 'MMP 4/7/2009 00:07'!seconds: seconds microseconds: microseconds 	^ self new		seconds: seconds;		microseconds: microseconds;		yourself! !!DBXQueryTimeout methodsFor: 'accessing' stamp: 'MMP 6/29/2009 21:14'!asMiliseconds	^ (self seconds * 1000) + (((self microseconds / 1000) asFloat) integerPart asInteger )! !!DBXQueryTimeout methodsFor: 'accessing' stamp: 'RocioAmaya 8/22/2013 17:46'!asTimeSpec	^ OpenDBX current  createTimeSpecFromQueryTimeOut: self  	! !!DBXQueryTimeout methodsFor: 'accessing' stamp: 'MMP 4/6/2009 01:36'!microseconds	^ microseconds! !!DBXQueryTimeout methodsFor: 'accessing' stamp: 'MMP 4/6/2009 01:36'!microseconds: anObject	microseconds := anObject! !!DBXQueryTimeout methodsFor: 'accessing' stamp: 'MMP 4/6/2009 01:36'!seconds	^ seconds! !!DBXQueryTimeout methodsFor: 'accessing' stamp: 'MMP 4/6/2009 19:50'!seconds: anObject 	seconds := anObject! !!DBXResultDescription methodsFor: 'accessing' stamp: 'HMC 8/16/2008 21:02'!rowsAffected"number of rows that have been changed by the current statement"	^rowsAffected! !!DBXResultDescription methodsFor: 'accessing' stamp: 'EL 6/29/2008 12:52'!rowsAffected: aNumber	rowsAffected := aNumber ! !!DBXResultSetDescription methodsFor: 'initialization' stamp: 'DiogenesMoreira 6/27/2011 12:34'!addColumnDescription: aColumnDescription"it adds a new column description to the column descriptions collection"	aColumnDescription addTo: self.		! !!DBXResultSetDescription methodsFor: 'initialization' stamp: 'DiogenesMoreira 6/27/2011 12:44'!addDescription: aColumnDescription"it adds a new column description to the column descriptions collection"	columnDescriptions add: aColumnDescription		! !!DBXResultSetDescription methodsFor: 'initialization' stamp: 'DiogenesMoreira 6/27/2011 12:46'!addNotSupportedDescription: aDBXColumnDescription	notSupportedDescriptions at: self columnCount put: aDBXColumnDescription! !!DBXResultSetDescription methodsFor: 'accessing' stamp: 'DiogenesMoreira 6/27/2011 12:41'!columnCount"this allows you to know the number of columns for each row retrieved from the database"	^ columnDescriptions size! !!DBXResultSetDescription methodsFor: 'accessing' stamp: 'DiogenesMoreira 6/27/2011 12:42'!columnDescriptionAt: anIndex"returns the column description holded in 'anIndex' position"	^ columnDescriptions at: anIndex! !!DBXResultSetDescription methodsFor: 'accessing' stamp: 'DiogenesMoreira 6/27/2011 12:53'!columnDescriptions	^ columnDescriptions! !!DBXResultSetDescription methodsFor: 'initialization' stamp: 'DiogenesMoreira 6/27/2011 13:03'!detectNewTypes: aDBXResultSet	notSupportedDescriptions keysAndValuesDo:[ :index :desc | | dbxType |			dbxType := OpenDBX current apiQueryColumnType: aDBXResultSet handle index: (index - 1) .			desc type: (aDBXResultSet dataTypeAt: dbxType);  dbxType: dbxType.			desc type isBehavior ifTrue:[ 				notSupportedDescriptions removeKey: index ] ]! !!DBXResultSetDescription methodsFor: 'initialization' stamp: 'DiogenesMoreira 6/27/2011 12:47'!initialize"this DBXResultSetDescription will contain a collection of its own column descriptions, retrieved from the database"	super initialize.	columnDescriptions := OrderedCollection new.	notSupportedDescriptions := Dictionary new! !!DBXRow class methodsFor: 'instance creation' stamp: 'EL 3/31/2008 10:21'!new	self error: 'Use #onResultSet:'! !!DBXRow class methodsFor: 'instance creation' stamp: 'EL 6/29/2008 11:27'!on: aResultSet	^(self basicNew)		initializeResultSet: aResultSet;		yourself.		! !!DBXRow methodsFor: 'accessing' stamp: 'GuillermoPolito 1/21/2015 15:11'!at: anIndex	"It returns the value of the raw at the specified index. Each string returned from openDBX will be converted, if supported, to Squeak types"	^self valueAt: anIndex ! !!DBXRow methodsFor: 'accessing' stamp: 'GuillermoPolito 4/7/2015 16:06'!atIndex: anInteger 		^ self valueAt: anInteger! !!DBXRow methodsFor: 'accessing' stamp: 'GuillermoPolito 4/7/2015 16:09'!atName: aString 		^ self valueNamed: aString! !!DBXRow methodsFor: 'private' stamp: 'EL 6/27/2008 22:01'!columnDescriptionAt: anIndex	^self resultSet columnDescriptionAt: anIndex! !!DBXRow methodsFor: 'private' stamp: 'MarianoMartinezPeck 2/13/2010 15:24'!columnDescriptionType: anIndex	^(self columnDescriptionAt: anIndex) type! !!DBXRow methodsFor: 'private' stamp: 'MMP 8/23/2008 18:27'!columnDescriptionWithName: columnName	^self resultSet columnDescriptionWithName: columnName ! !!DBXRow methodsFor: 'private' stamp: 'MarianoMartinezPeck 5/7/2011 00:38'!columnIndex: aString 	self resultSet columnDescriptions		withIndexDo: [:each :index | (each name sameAs: aString)				ifTrue: [^ index]].	OpenDBXDriverError signal: 'A column with that name was not found'.! !!DBXRow methodsFor: 'private' stamp: 'EL 8/19/2008 13:38'!convertValueAt: anIndex 	^ (self rawValueAt: anIndex)		ifNotNilDo: [:columnValue | (self columnDescriptionType: anIndex)			fromDbxString: columnValue]! !!DBXRow methodsFor: 'initialization' stamp: 'MMP 8/16/2008 21:15'!initializeResultSet: aResultSet	"It initialize a Row receiving a result set. We need the result set in order to ask the information about the column descriptions"	super initialize.	resultSet := aResultSet.	self initializeRow.	! !!DBXRow methodsFor: 'initialization' stamp: 'GuillermoPolito 7/2/2011 08:42'!initializeRow	"Initialize the row. All the row values will be set."	rawValues := Array new: self resultSet columnCount.	self resultSet columnDescriptions withIndexDo: [ :each :i|			rawValues at: i put: (self platform fieldRawValue: i  on: self resultSet) ]! !!DBXRow methodsFor: 'private' stamp: 'EL 6/29/2008 12:19'!platform	^self resultSet platform! !!DBXRow methodsFor: 'accessing' stamp: 'MMP 8/16/2008 21:06'!rawValueAt: anIndex	"It returns the value of the raw at the specified index. No conversion is here, so all values will be String"	^rawValues at: anIndex! !!DBXRow methodsFor: 'accessing' stamp: 'MMP 8/16/2008 21:07'!rawValueNamed: aString	"It returns the value of the raw with the specified name. No conversion is here, so all values will be String"	^self rawValueAt: (self columnIndex: aString) ! !!DBXRow methodsFor: 'accessing' stamp: 'MMP 8/16/2008 21:07'!rawValues	"It returns the values of all the raw. No conversion is here, so all values will be String"	^rawValues! !!DBXRow methodsFor: 'enumerating' stamp: 'MMP 8/16/2008 21:09'!rawValuesDo: aBlock	"It will execute the block on all the row values. No conversion is here, so all values will be String"	^self rawValues do: aBlock! !!DBXRow methodsFor: 'accessing' stamp: 'EL 3/31/2008 10:22'!resultSet	^ resultSet! !!DBXRow methodsFor: 'accessing' stamp: 'MMP 8/16/2008 21:11'!valueAt: anIndex	"It returns the value of the raw at the specified index. Each string returned from openDBX will be converted, if supported, to Squeak types"	^self convertValueAt: anIndex ! !!DBXRow methodsFor: 'accessing' stamp: 'MMP 8/16/2008 21:11'!valueNamed: aString	"It returns the value of the raw with the specified name. Each string returned from openDBX will be converted, if supported, to Squeak types"	^self convertValueAt: (self columnIndex: aString).! !!DBXRow methodsFor: 'accessing' stamp: 'test 1/8/2009 18:08'!values	"It returns the all the values of the raw. Each string returned from openDBX will be converted, if supported, to Squeak types"	^self rawValues withIndexCollect: [ :each :index | 		each ifNotNil: [			(self columnDescriptionType: index) fromDbxString: each ] ]! !!DBXRow methodsFor: 'enumerating' stamp: 'MMP 8/16/2008 21:12'!valuesDo: aBlock	"It will execute the block on all the row values. Each string returned from openDBX will be converted, if supported, to Squeak types"	^self values do: aBlock! !!DBXSpecialOptions class methodsFor: 'options' stamp: 'MMP 7/18/2008 19:21'!compression	"0x0022 in hexadecimal in openDBX. But we need it as decimal"	^16r0022! !!DBXSpecialOptions class methodsFor: 'options' stamp: 'MMP 7/18/2008 19:21'!encryption	 "0x0010 in hexadecimal in openDBX. But we need it as decimal"	^16r0010! !!DBXSpecialOptions class methodsFor: 'options' stamp: 'MMP 7/18/2008 19:21'!multipleStatements	 "0x0020 in hexadecimal in openDBX. But we need it as decimal"	^16r0020! !!DBXSpecialOptions class methodsFor: 'options' stamp: 'MMP 7/18/2008 19:21'!pagedResults 	"0x0021 in hexadecimal in openDBX. But we need it as decimal"	^16r0021! !!DBXSpecialOptions class methodsFor: 'options' stamp: 'MMP 8/18/2008 16:19'!specialModes	"0x0023 in hexadecimal in openDBX. But we need it as decimal"	^16r0023! !!DBXTypeNotSupported class methodsFor: 'instance creation' stamp: 'EL 8/14/2008 09:33'!code: aNumber	^self new		code: aNumber;		yourself! !!DBXTypeNotSupported class methodsFor: 'instance creation' stamp: 'EL 8/14/2008 09:33'!type: aSymbol	^self new		type: aSymbol;		yourself! !!DBXTypeNotSupported methodsFor: 'accessing' stamp: 'EL 8/14/2008 09:32'!code	^ code! !!DBXTypeNotSupported methodsFor: 'accessing' stamp: 'EL 8/14/2008 09:32'!code: anObject	code := anObject! !!DBXTypeNotSupported methodsFor: 'dbx' stamp: 'MarianoMartinezPeck 5/7/2011 00:38'!fromDbxString: aString	self type 		ifNotNil: [ OpenDBXDriverError signal: ('Unsupported data type: {1}, trying to parse: {2}' format: {self type. aString}) ]		ifNil: [ OpenDBXDriverError signal: ('Unknown data type: {1}, trying to parse: {2}' format: {self code. aString}) ]			! !!DBXTypeNotSupported methodsFor: 'accessing' stamp: 'EL 8/14/2008 09:32'!type	^ type! !!DBXTypeNotSupported methodsFor: 'accessing' stamp: 'EL 8/14/2008 09:32'!type: anObject	type := anObject! !!Object class methodsFor: '*Garage-OpenDBX' stamp: 'EL 8/2/2008 12:09'!fromDbxString: aString	self subclassResponsibility! !!Object methodsFor: '*Garage-OpenDBX' stamp: 'EL 8/3/2008 08:18'!asDbxString	^ self printString! !!NBPharoOpenDBX class methodsFor: 'accessing' stamp: 'RocioAmaya 8/22/2013 18:24'!openDBXlib	^ NBOpenDBX_ApiH uniqueInstance! !!NBPharoOpenDBX methodsFor: 'api calls' stamp: 'RocioAmaya 8/22/2013 18:54'!apiBind: handle database: databaseName name: userName password: password method: method	"int odbx_bind(odbx_t* handle, const char* database, const char* who, const char* cred,int method )"	^self openDBXlib odbx_bind: handle database: databaseName asNBExternalString who: userName asNBExternalString cred: password asNBExternalString method: method ! !!NBPharoOpenDBX methodsFor: 'api calls' stamp: 'RocioAmaya 8/22/2013 18:44'!apiError: handle number: err	"long odbx_error(odbx_t*, int)"	^(self openDBXlib odbx_error: handle error: err) readString .! !!NBPharoOpenDBX methodsFor: 'api calls' stamp: 'RocioAmaya 8/4/2013 11:36'!apiErrorType: handle number: err 	"int odbx_error_type( odbx_t*, int )"	^ self openDBXlib odbx_error_type: handle error: err.! !!NBPharoOpenDBX methodsFor: 'api calls' stamp: 'RocioAmaya 8/4/2013 11:38'!apiFinalize: handle 	"long odbx_finish(odbx_t*)"	^self openDBXlib odbx_finish: handle ! !!NBPharoOpenDBX methodsFor: 'api calls' stamp: 'RocioAmaya 8/4/2013 11:40'!apiGetOption: handle option: anOption value: aValue	"int odbx_get_option(odbx_t* handle, unsigned int option,void* value)"	^self openDBXlib odbx_get_option: handle option:  anOption value: aValue.! !!NBPharoOpenDBX methodsFor: 'api calls' stamp: 'RocioAmaya 8/22/2013 18:50'!apiInitialize: handle backend: backend host: host port: port	"long odbx_init(odbx_t**, char*, char*, char*)"	^self openDBXlib odbx_init: handle backend: backend asNBExternalString host:  host asNBExternalString port: port asNBExternalString.! !!NBPharoOpenDBX methodsFor: 'api calls' stamp: 'RocioAmaya 8/4/2013 11:57'!apiOpenLarge: aResultSetHandleNumber handle: aLargeHandleWordArray value: aString	"int odbx_lo_open(odbx_result_t* result, odbx_lo_t** lo, const char* value)"	^self openDBXlib odbx_lo_open: aResultSetHandleNumber lo: aLargeHandleWordArray value: aString.! !!NBPharoOpenDBX methodsFor: 'api calls' stamp: 'abc 8/30/2013 18:12'!apiQuery: handle query: query length: length	"long odbx_query(odbx_t*, char*, ulong)"	^self openDBXlib odbx_query: handle query: query asNBExternalString length: length.! !!NBPharoOpenDBX methodsFor: 'api calls' stamp: 'RocioAmaya 8/4/2013 12:01'!apiQueryColumnLength: handle index: index	"unsigned long odbx_field_length( odbx_result_t* result, unsigned long pos ) "	"IMPORTANT: Index es zero-based"	^self openDBXlib odbx_field_length: handle pos: index.! !!NBPharoOpenDBX methodsFor: 'api calls' stamp: 'RocioAmaya 8/23/2013 07:09'!apiQueryColumnName: handle index: index	"char* odbx_column_name(odbx_result_t* result, unsigned long pos )"	"IMPORTANT: Index es zero-based"	^(self openDBXlib odbx_column_name: handle pos: index) readString.! !!NBPharoOpenDBX methodsFor: 'api calls' stamp: 'RocioAmaya 8/23/2013 07:15'!apiQueryColumnType: handle index: index	"int odbx_column_type( odbx_result_t* result, unsigned long pos )"	"IMPORTANT: Index es zero-based"	^self openDBXlib odbx_column_type: handle  pos: index ! !!NBPharoOpenDBX methodsFor: 'api calls' stamp: 'RocioAmaya 8/12/2013 10:52'!apiQueryColumns: handle	"int odbx_column_count(odbx_result_t* result )"	^self openDBXlib odbx_column_count: handle ! !!NBPharoOpenDBX methodsFor: 'api calls' stamp: 'RocioAmaya 8/12/2013 10:54'!apiQueryFetchRow: handle 	"int odbx_row_fetch( odbx_result_t* result )"	^self openDBXlib odbx_row_fetch: handle.! !!NBPharoOpenDBX methodsFor: 'api calls' stamp: 'RocioAmaya 8/23/2013 07:20'!apiQueryFieldValue: handle index: index	"const char* odbx_field_value( odbx_result_t* result, unsigned long pos )"	"IMPORTANT: Index es zero-based"			| result|	result:= (self openDBXlib odbx_field_value: handle pos: index).	result ifNotNil:[^ result readString].	^result! !!NBPharoOpenDBX methodsFor: 'api calls' stamp: 'RocioAmaya 8/12/2013 10:56'!apiQueryFinalize: handle	"int odbx_result_finish( odbx_result_t* result )"	^self openDBXlib odbx_result_finish: handle.! !!NBPharoOpenDBX methodsFor: 'api calls' stamp: 'RocioAmaya 8/23/2013 07:33'!apiQueryResult: connectionHandle handle: handle timeout: timeout chunk: chunk	"int odbx_result( odbx_t* handle, odbx_result_t** result, struct timeval* timeout, unsigned long chunk )"	^self openDBXlib odbx_result: connectionHandle result:  handle timeout: (timeout ifNil:[self emptyTimeSpec]) chunk: chunk! !!NBPharoOpenDBX methodsFor: 'api calls' stamp: 'RocioAmaya 8/12/2013 10:59'!apiQueryRowsAffected: handle	"uint64_t odbx_rows_affected(odbx_result_t* result )"	^self openDBXlib odbx_rows_affected: handle.! !!NBPharoOpenDBX methodsFor: 'api calls' stamp: 'RocioAmaya 8/23/2013 07:48'!apiSetOption: handle option: anOption value: aValue	"int odbx_set_option(odbx_t* handle, unsigned int option, void* value ) "	^self openDBXlib odbx_set_option: handle option: anOption value: aValue asNBOpenDBXExternalOption! !!NBPharoOpenDBX methodsFor: 'api calls' stamp: 'RocioAmaya 8/12/2013 11:01'!apiUnbind: handle 	"int odbx_unbind(odbx_t*)"	^self openDBXlib odbx_unbind: handle! !!NBPharoOpenDBX methodsFor: 'builders' stamp: 'RocioAmaya 8/22/2013 19:06'!createOpenDBXHandle	^ NBOpenDBX_OdbxTO new! !!NBPharoOpenDBX methodsFor: 'builders' stamp: 'RocioAmaya 8/23/2013 05:33'!createOpenDBXResultHandle	^ NBOpenDBX_OdbxResultTO new.! !!NBPharoOpenDBX methodsFor: 'builders' stamp: 'RocioAmaya 8/22/2013 18:00'!createTimeSpecFromQueryTimeOut: aQueryTimeOut	| timeval |	timeval := NBOpenDBX_TimevalS new.	timeval tv_sec: aQueryTimeOut seconds.	timeval tv_usec: aQueryTimeOut microseconds.	^ timeval! !!NBPharoOpenDBX methodsFor: 'builders' stamp: 'RocioAmaya 8/23/2013 07:33'!emptyTimeSpec 	^ NBOpenDBX_TimevalS new.		  ! !!NBPharoOpenDBX methodsFor: 'accessing' stamp: 'RocioAmaya 8/22/2013 18:29'!openDBXlib	^ self class openDBXlib! !!NBPharoOpenDBX methodsFor: 'builders' stamp: 'RocioAmaya 8/22/2013 19:09'!unpackOpenDBXHandle: handle	^ handle.! !!OpenDBX class methodsFor: 'constants' stamp: 'GuillermoPolito 4/17/2015 15:18'!current	^ Current ifNil: [ Current := NBPharoOpenDBX new ] ! !!OpenDBX class methodsFor: 'constants' stamp: 'MarianoMartinezPeck 10/8/2009 00:14'!current: anObject	^Current := anObject! !!OpenDBX class methodsFor: 'constants' stamp: 'MarianoMartinezPeck 10/1/2009 17:25'!currentOpenDBXVersion	^'1.4.4'! !!OpenDBX class methodsFor: 'installing' stamp: 'GuillermoPolito 1/13/2014 22:37'!installAsCurrent	CurrentLibraryFactory := self.	self current: nil.! !!OpenDBX class methodsFor: 'constants' stamp: 'MarianoMartinezPeck 3/25/2010 22:14'!reset	^Current := nil! !!OpenDBX class methodsFor: 'constants' stamp: 'EL 6/29/2008 11:19'!resultDone	"ODBX_RES_DONE"	^0! !!OpenDBX class methodsFor: 'constants' stamp: 'EL 6/29/2008 13:20'!resultTimeout	^1! !!OpenDBX class methodsFor: 'constants' stamp: 'EL 6/29/2008 13:21'!resultWithRows	^3! !!OpenDBX class methodsFor: 'constants' stamp: 'EL 6/29/2008 13:20'!resultWithoutRows	^2! !!OpenDBX class methodsFor: 'constants' stamp: 'EL 6/28/2008 09:11'!rowDone	"ODBX_ROW_DONE"	^0! !!OpenDBX class methodsFor: 'constants' stamp: 'EL 6/28/2008 09:10'!rowNext	"ODBX_ROW_NEXT"	^1! !!OpenDBX methodsFor: 'api calls' stamp: 'EL 8/6/2008 09:47'!apiBind: handle database: databaseName name: userName password: password method: method	"int odbx_bind(odbx_t* handle, const char* database, const char* who, const char* cred,int method )"	^self subclassResponsibility! !!OpenDBX methodsFor: 'api calls' stamp: 'EL 8/6/2008 09:47'!apiError: handle number: err	"long odbx_error(odbx_t*)"	^self subclassResponsibility! !!OpenDBX methodsFor: 'api calls' stamp: 'HMC 10/11/2008 10:41'!apiErrorType: handle number: err 	"int odbx_error_type( odbx_t* , int error )"	^ self subclassResponsibility! !!OpenDBX methodsFor: 'api calls' stamp: 'EL 8/6/2008 09:47'!apiFinalize: handle 	"long odbx_finish(odbx_t*)"	^self subclassResponsibility! !!OpenDBX methodsFor: 'api calls' stamp: 'EL 8/6/2008 09:47'!apiGetOption: handle option: anOption value: aValue	"int odbx_get_option(odbx_t* handle, unsigned int option,void* value)"	^self subclassResponsibility! !!OpenDBX methodsFor: 'api calls' stamp: 'EL 8/6/2008 09:47'!apiInitialize: handle backend: backend host: host port: port	"long odbx_init(odbx_t**, char*, char*, char*)"	^self subclassResponsibility! !!OpenDBX methodsFor: 'api calls' stamp: 'EL 8/6/2008 09:48'!apiOpenLarge: aResultSetHandleNumber handle: aLargeHandleWordArray value: aString	"int odbx_lo_open(odbx_result_t* result, odbx_lo_t** lo, const char* value)"	^self subclassResponsibility! !!OpenDBX methodsFor: 'api calls' stamp: 'EL 8/6/2008 09:48'!apiQuery: handle query: query length: length	"long odbx_query(odbx_t*, char*, ulong)"	^self subclassResponsibility! !!OpenDBX methodsFor: 'api calls' stamp: 'EL 8/6/2008 09:48'!apiQueryColumnLength: handle index: index	"unsigned long odbx_field_length( odbx_result_t* result, unsigned long pos ) "	"IMPORTANT: Index es zero-based"	^self subclassResponsibility! !!OpenDBX methodsFor: 'api calls' stamp: 'EL 8/6/2008 09:48'!apiQueryColumnName: handle index: index	"char* odbx_column_name(odbx_result_t* result, unsigned long pos )"	"IMPORTANT: Index es zero-based"	^self subclassResponsibility! !!OpenDBX methodsFor: 'api calls' stamp: 'EL 8/6/2008 09:48'!apiQueryColumnType: handle index: index	"char* odbx_column_type( odbx_result_t* result, unsigned long pos )"	"IMPORTANT: Index es zero-based"	^self subclassResponsibility! !!OpenDBX methodsFor: 'api calls' stamp: 'EL 8/6/2008 09:48'!apiQueryColumns: handle	"int odbx_column_count(odbx_result_t* result )"	^self subclassResponsibility! !!OpenDBX methodsFor: 'api calls' stamp: 'EL 8/6/2008 09:48'!apiQueryFetchRow: handle 	"int odbx_row_fetch( odbx_result_t* result )"	^self subclassResponsibility! !!OpenDBX methodsFor: 'api calls' stamp: 'EL 8/6/2008 09:48'!apiQueryFieldValue: handle index: index	"const char* odbx_field_value( odbx_result_t* result, unsigned long pos )"	"IMPORTANT: Index es zero-based"	^self subclassResponsibility! !!OpenDBX methodsFor: 'api calls' stamp: 'EL 8/6/2008 09:48'!apiQueryFinalize: handle	"int odbx_result_finish( odbx_result_t* result )"	^self subclassResponsibility! !!OpenDBX methodsFor: 'api calls' stamp: 'EL 8/6/2008 09:49'!apiQueryResult: connectionHandle handle: handle timeout: timeout chunk: chunk	"int odbx_result( odbx_t* handle, odbx_result_t** result, struct timeval* timeout, unsigned long chunk )"	^self subclassResponsibility! !!OpenDBX methodsFor: 'api calls' stamp: 'EL 8/6/2008 09:49'!apiQueryRowsAffected: handle	"uint64_t odbx_rows_affected(odbx_result_t* result )"	^self subclassResponsibility! !!OpenDBX methodsFor: 'api calls' stamp: 'EL 8/6/2008 09:49'!apiSetOption: handle option: anOption value: aValue	"int odbx_set_option(odbx_t* handle, unsigned int option, void* value ) "	^self subclassResponsibility	! !!OpenDBX methodsFor: 'api calls' stamp: 'EL 8/6/2008 09:49'!apiUnbind: handle 	"int odbx_unbind(odbx_t*)"	^self subclassResponsibility! !!OpenDBXDriverPharoDialect class methodsFor: 'accessing' stamp: 'MarianoMartinezPeck 10/8/2009 01:24'!addObjectToGarbageCollect: anObject	WeakRegistry default add: anObject.! !!OpenDBXDriverPharoDialect class methodsFor: 'accessing' stamp: 'MarianoMartinezPeck 10/8/2009 00:45'!connectionsToGarbageCollect	^ WeakRegistry default keys				select: [:each | each class = DBXConnection]! !!OpenDBXDriverSmalltalkDialect class methodsFor: 'garbage-collect' stamp: 'MarianoMartinezPeck 10/8/2009 00:44'!addObjectToGarbageCollect: anObject"Tells someway the garbage collect that anObject should "		^ self subclassResponsibility ! !!OpenDBXDriverSmalltalkDialect class methodsFor: 'garbage-collect' stamp: 'MarianoMartinezPeck 10/8/2009 00:44'!connectionsToGarbageCollect	^ self subclassResponsibility ! !!OpenDBXDriverSmalltalkDialect class methodsFor: 'accessing' stamp: 'MarianoMartinezPeck 5/7/2011 00:40'!current	^ Current ifNil: [ Current := OpenDBXDriverPharoDialect ] 	! !!OpenDBXDriverSmalltalkDialect class methodsFor: 'accessing' stamp: 'MarianoMartinezPeck 10/7/2009 23:48'!current: anObject	Current := anObject! !!String class methodsFor: '*Garage-OpenDBX' stamp: 'EL 8/2/2008 12:11'!fromDbxString: aString	^aString! !!String methodsFor: '*Garage-OpenDBX' stamp: 'MMP 2/4/2009 23:46'!asDbxString	^self class new writeStream		nextPut: $';		nextPutAll: self;		nextPut: $';		contents! !!NBOpenDBX_TimevalS class methodsFor: 'nativeboost mapping' stamp: 'RocioAmaya 8/22/2013 06:34'!asNBExternalType: gen	^NBExternalStructureType objectClass: self! !!NBOpenDBX_TimevalS class methodsFor: 'accessing' stamp: 'GuillermoPolito 1/13/2014 21:11'!fieldsDesc	^#(	__time_t tv_sec;	__suseconds_t tv_usec;	)! !!NBOpenDBX_TimevalS class methodsFor: 'nativeboost types' stamp: 'RocioAmaya 8/22/2013 06:34'!nbBindingOf: aTypeName	^ LibOpenDBXMap at: aTypeName! !!GAMysqlResultSet commentStamp: 'ah 3/5/2010 09:24' prior: 0!I am a simple facade on result set packets, although I behave as a MysqlPacketData. I don't perform a read or write; my clients compose me from specific rasult set packets. I am designed this way to facilitate use of similar metaphors at the connector protocol level. I also behave a multi-result type of packet.!!GAMysqlDriver commentStamp: 'GuillermoPolito 5/5/2015 10:12' prior: 0!I am a driver implementation to connect with Mysql databases.I use the binary and textual protocol of mysql, connecting to a database through a socket.!!GAMysqlBinReader commentStamp: 'GuillermoPolito 5/5/2015 10:55' prior: 0!I am a reader from the mysql binary protocol. I convert binary data sent by mysql into Pharo objects.!!GAMysqlCommandBase commentStamp: 'GuillermoPolito 5/5/2015 10:55' prior: 0!I am a basic mysql protocol command.!!GAMysqlResult commentStamp: 'ah 3/13/2010 10:21' prior: 0!I am simple logical grouping in the hierarchy that supports multi-results in response to multi-statement queries. The server indicates the presence of more result(set) using the server status flag of specific packets. This may mean that some of my subclasses may point to the next response in the chain if multi-results were sent by the server. Check selector #next and #next: for more.!!GAMysqlResultSet methodsFor: 'iterating' stamp: 'GuillermoPolito 4/23/2015 18:10'!at: anInteger 		[(self hasRowAt: anInteger) not and: [ self canFetchMoreRows ]]		whileTrue: [ self fetchMoreRows ].	^ self internalRows at: anInteger! !!GAMysqlResultSet methodsFor: 'cursor' stamp: 'GuillermoPolito 4/23/2015 17:39'!canFetchMoreRows	^ self hasOpenCursor and: [self hasLastRowSent not]! !!GAMysqlResultSet methodsFor: 'iterating' stamp: 'GuillermoPolito 4/23/2015 17:36'!collect: aBlockClosure 		^ self internalRows collect: aBlockClosure! !!GAMysqlResultSet methodsFor: 'iterating' stamp: 'GuillermoPolito 4/23/2015 17:36'!do: aBlockClosure 		self internalRows do: aBlockClosure! !!GAMysqlResultSet methodsFor: 'cursor' stamp: 'GuillermoPolito 4/23/2015 17:13'!fetchListener: aFetchListener			fetchListener := aFetchListener! !!GAMysqlResultSet methodsFor: 'cursor' stamp: 'GuillermoPolito 4/23/2015 17:42'!fetchMoreRows	statement fetchRows: statement fetchSize! !!GAMysqlResultSet methodsFor: 'accessing' stamp: 'ah 3/26/2010 17:13'!fields	^ fields ! !!GAMysqlResultSet methodsFor: 'accessing' stamp: 'ah 7/26/2009 01:17'!fields: flds	fields := flds! !!GAMysqlResultSet methodsFor: 'accessing' stamp: 'ah 4/8/2010 22:49'!fieldsEof	^ fieldsEof ! !!GAMysqlResultSet methodsFor: 'accessing' stamp: 'ah 2/8/2010 23:54'!fieldsEof: eofPkt 	fieldsEof := eofPkt! !!GAMysqlResultSet methodsFor: 'iterating' stamp: 'GuillermoPolito 4/23/2015 17:36'!first		^ self internalRows first! !!GAMysqlResultSet methodsFor: 'testing' stamp: 'ah 9/15/2011 22:43'!hasLastRowSent	"This is signaled during cursor based fetch for the rows. Therefore we	check for the singal in the eof field following the rows in the response."	^ rowsEof ifNil: [false] ifNotNil: [rowsEof hasLastRowSent]	! !!GAMysqlResultSet methodsFor: 'testing' stamp: 'ah 8/23/2011 01:55'!hasMoreResults	"Looks like the flag, when set, will be set by the server in both the	field eof and rowdata eof packets. We are only using field eof here, since	rowdata eof may not sometimes sent as part of the result set (e.g., cursor)."	^ fieldsEof hasMoreResults	! !!GAMysqlResultSet methodsFor: 'cursor' stamp: 'GuillermoPolito 4/23/2015 17:55'!hasOpenCursor	^ fieldsEof hasOpenCursor! !!GAMysqlResultSet methodsFor: 'iterating' stamp: 'GuillermoPolito 4/23/2015 18:10'!hasRowAt: anInteger		^ self internalRows size >= anInteger! !!GAMysqlResultSet methodsFor: 'accessing' stamp: 'ah 3/22/2010 23:09'!header	^ header! !!GAMysqlResultSet methodsFor: 'accessing' stamp: 'ah 7/26/2009 01:17'!header: hdr	header := hdr! !!GAMysqlResultSet methodsFor: 'initialization' stamp: 'GuillermoPolito 2/8/2015 17:17'!initialize	super initialize.	rows := OrderedCollection new.! !!GAMysqlResultSet methodsFor: 'accessing' stamp: 'GuillermoPolito 4/23/2015 17:36'!internalRows	^ rows! !!GAMysqlResultSet methodsFor: 'testing' stamp: 'GuillermoPolito 4/23/2015 17:36'!isEmpty		^ self internalRows isEmpty! !!GAMysqlResultSet methodsFor: 'testing' stamp: 'GuillermoPolito 4/7/2015 14:44'!isError		^ false! !!GAMysqlResultSet methodsFor: 'testing' stamp: 'ah 2/27/2010 11:08'!isResultSet	^ true! !!GAMysqlResultSet methodsFor: 'parsing' stamp: 'ah 6/4/2011 19:07'!parse	self shouldNotImplement	! !!GAMysqlResultSet methodsFor: 'streaming' stamp: 'GuillermoPolito 4/16/2015 12:20'!readStream		^ GAResultSetReadStream on: self! !!GAMysqlResultSet methodsFor: 'cursor' stamp: 'GuillermoPolito 4/23/2015 17:42'!rows	[ self canFetchMoreRows ] whileTrue: [ self fetchMoreRows ].	^ self internalRows! !!GAMysqlResultSet methodsFor: 'accessing' stamp: 'GuillermoPolito 4/23/2015 18:02'!rows: allRows	allRows ifNil: [ ^ self ].	rows addAll: allRows asOrderedCollection! !!GAMysqlResultSet methodsFor: 'accessing' stamp: 'ah 4/8/2010 22:49'!rowsEof	^ rowsEof ! !!GAMysqlResultSet methodsFor: 'accessing' stamp: 'ah 2/8/2010 23:53'!rowsEof: eofPkt	rowsEof := eofPkt! !!GAMysqlResultSet methodsFor: 'iterating' stamp: 'GuillermoPolito 4/23/2015 17:36'!select: aBlockClosure 		^ self internalRows select: aBlockClosure! !!GAMysqlResultSet methodsFor: 'accessing' stamp: 'ah 9/15/2011 22:01'!serverStatus	^ fieldsEof serverStatus	! !!GAMysqlResultSet methodsFor: 'accessing' stamp: 'GuillermoPolito 1/21/2015 17:28'!statement: aStatement 		statement := aStatement! !!GAMysqlStatement methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 5/5/2015 12:09'!at: anInteger bind: aValue		prepared ifFalse: [ self error: 'this statement is not prepared' ].	params at: anInteger put: (GAMysqlBindParam new connection: connection; bindValue: aValue)! !!GAMysqlStatement methodsFor: 'accessing' stamp: 'GuillermoPolito 5/5/2015 11:28'!close	| cmd |	cmd := GAMysqlCommandCloseStatement onSession: connection netSession driver: connection.	cmd statementId: stmtId.	^ cmd execute.	! !!GAMysqlStatement methodsFor: 'accessing' stamp: 'ah 9/15/2011 22:09'!cursoredFetch	^ cursoredFetch! !!GAMysqlStatement methodsFor: 'accessing' stamp: 'ah 9/15/2011 22:09'!cursoredFetch: aBoolean 	cursoredFetch := aBoolean! !!GAMysqlStatement methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 5/5/2015 11:32'!execute	| cmd resp |		cursoredFetch ifTrue: [ self prepare ].		prepared ifFalse: [ 		fetchListener ifNotNilDo: #fetchOccurred.		^ connection basicQuery: statement ].		resp := self resetStmt.	resp isError ifTrue: [ ^ resp ].	self sendLongData.	cmd := GAMysqlCommandExecute onSession: connection netSession driver: connection.	cmd driver: connection.	cmd		fetchListener: fetchListener;		cursoredFetch: cursoredFetch;		statementId: stmtId;		params: params values asArray.	resp := cmd execute.	resp isError ifTrue: [ self error: resp message ].			rsContext := resp isResultSet 		ifTrue: [ 			resp statement: self.			resp fetchListener: fetchListener.			resp ]		ifFalse: [ nil ].	^ resp! !!GAMysqlStatement methodsFor: 'accessing' stamp: 'GuillermoPolito 4/23/2015 17:06'!fetchListener: aGAFetchListener	fetchListener := aGAFetchListener! !!GAMysqlStatement methodsFor: 'accessing' stamp: 'GuillermoPolito 5/5/2015 11:27'!fetchRows: num	| cmd |	cmd := GAMysqlCommandFetchRows onSession: connection netSession driver: connection.	cmd driver: connection.	cmd		fetchListener: fetchListener;		resultSetContext: rsContext;		statementId: stmtId;		numRows: num.			^ cmd execute	 ! !!GAMysqlStatement methodsFor: 'accessing' stamp: 'GuillermoPolito 1/21/2015 17:35'!fetchSize		^ fetchSize! !!GAMysqlStatement methodsFor: 'cursor' stamp: 'GuillermoPolito 1/21/2015 17:34'!fetchSize: anInteger 		self cursoredFetch: true.	fetchSize := anInteger! !!GAMysqlStatement methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 5/5/2015 11:32'!initialize	super initialize.	params := Dictionary new.	cursoredFetch := false.! !!GAMysqlStatement methodsFor: 'accessing' stamp: 'ah 9/14/2011 07:20'!params: bindParams	params := bindParams	! !!GAMysqlStatement methodsFor: 'accessing' stamp: 'GuillermoPolito 4/24/2015 16:06'!prepare	| response |	super prepare.	response := connection basicPrepare: statement.	response isError ifTrue: [ self error: response message ].	self stmtId: response prepareOkay stmtHandlerId.	^ self! !!GAMysqlStatement methodsFor: 'accessing' stamp: 'GuillermoPolito 5/5/2015 11:27'!resetStmt	| cmd |	cmd := GAMysqlCommandResetStatement onSession: connection netSession driver: connection.	cmd statementId: stmtId.	^ cmd execute.	! !!GAMysqlStatement methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 2/9/2015 01:13'!sendLongData	params keysAndValuesDo: [ :indx :aParam |		aParam isLongData ifTrue: [			self sendLongParam: aParam withNum: indx - 1. "first param index is 0"			aParam sentAsLongData: true "mark that it has been sent as long data"]]	! !!GAMysqlStatement methodsFor: 'private' stamp: 'GuillermoPolito 5/5/2015 11:27'!sendLongParam: aParam withNum: paramNum	| cmd dataStream dataPart |		dataStream := ReadStream on: aParam stringOrBlobBytesRaw.	[		dataPart := dataStream next: 1048576. "1 MB; default"		cmd := GAMysqlCommandSendLongData onSession: connection netSession driver: connection.		cmd 			paramNum: paramNum;			statementId: stmtId; 			dataBytes: dataPart.		cmd execute] doWhileFalse: [dataStream atEnd]	! !!GAMysqlStatement methodsFor: 'accessing' stamp: 'ah 9/14/2011 07:16'!stmtId: anId	stmtId := anId	! !!GAMysqlDriver class methodsFor: 'drivers' stamp: 'GuillermoPolito 1/21/2015 13:51'!driverId	^ 'mysql'! !!GAMysqlDriver class methodsFor: 'instance-creation' stamp: 'GuillermoPolito 4/27/2015 11:13'!fromConnectionString: aConnectionString		| connection |	connection := self new.	connection connectionString: aConnectionString.	connection host: aConnectionString host.	connection port: aConnectionString port.	connection database: aConnectionString database.	connection user: aConnectionString user.	connection password: aConnectionString password.	^ connection! !!GAMysqlDriver class methodsFor: 'initialize' stamp: 'GuillermoPolito 1/21/2015 13:51'!initialize	self subscribeDriver! !!GAMysqlDriver class methodsFor: 'tests' stamp: 'GuillermoPolito 4/17/2015 17:45'!newFixture		^ GADriverMysqlTestFixture new! !!GAMysqlDriver class methodsFor: 'encoding' stamp: 'GuillermoPolito 4/29/2015 11:52'!supportsEncoding: aString 		"Mysql only supports in the client encodings that are compatible with ascii.	Cite: ucs2, utf16, and utf32 cannot be used as a client character set, which means that they do not work for SET NAMES or SET CHARACTER SET."		" check 	  https://dev.mysql.com/doc/refman/5.5/en/charset-charsets.html	  https://dev.mysql.com/doc/refman/5.5/en/charset-connection.html"	^ 'utf8' = aString! !!GAMysqlDriver methodsFor: 'testing' stamp: 'GuillermoPolito 2/8/2015 11:29'!affectsOnlyChangedRows	^ true! !!GAMysqlDriver methodsFor: 'connection' stamp: 'GuillermoPolito 5/5/2015 11:19'!assertConnection	self isConnected ifFalse: [^ GAMysqlNoConnectionError signal: 'Driver is not connected'].! !!GAMysqlDriver methodsFor: 'connection' stamp: 'GuillermoPolito 5/5/2015 11:19'!authenticate	| auth response |	handshakeInfo := GAMysqlHandshake from: netSession read.	handshakeInfo supportsProtocol41 		ifFalse: [ GAMysqlUnsupportedProtocolError signal: 'Server does not support protocol version 41' ].		auth := GAMysqlClientAuth new		serverCaps: handshakeInfo serverCaps;		charset: handshakeInfo serverLang;		user: self user;		password: self password;		database: self database;		scrambleBuff: handshakeInfo scrambleBuff ;		scrambleBuffMore: handshakeInfo scrambleBuffMore;		yourself.	netSession write: auth write.	response := self peekPacket.		response isEof ifTrue: [ | scrmblPkt |		"Read the send short hash indicator: sinsgle eof(254) byte)"		GAMysqlPacket from: netSession read.		"This is an indication that comes from server if the password for this user		follows the old style (short hash) instead of the new style (long hash). 		We need to send back the 323 scramble"		scrmblPkt := GAMysql323Scramble new.		scrmblPkt password: self password; scrambleBuff: handshakeInfo scrambleBuff.		netSession write: scrmblPkt write.		response := self peekPacket ].	^ response! !!GAMysqlDriver methodsFor: 'accessing' stamp: 'GuillermoPolito 1/21/2015 14:00'!backend		^ 'mysql'! !!GAMysqlDriver methodsFor: 'statements' stamp: 'GuillermoPolito 5/5/2015 11:28'!basicPrepare: aQuery	| prepStmt prepResp |	self assertConnection.			prepStmt := GAMysqlCommandPrepareStatement onSession: netSession driver: self.	prepStmt queryString: aQuery.	prepResp := prepStmt execute. "error or prepare reponse"	^ prepResp! !!GAMysqlDriver methodsFor: 'private' stamp: 'GuillermoPolito 5/5/2015 11:28'!basicQuery: queryString		| response qry |	self assertConnection.			qry := GAMysqlCommandQuery onSession: netSession driver: self.	qry driver: self.	qry queryString: queryString.	response := qry execute.	response isError ifTrue: [ self error: response message ].		^ response! !!GAMysqlDriver methodsFor: 'transaction' stamp: 'GuillermoPolito 1/21/2015 13:25'!beginTransaction		self basicQuery: 'BEGIN'! !!GAMysqlDriver methodsFor: 'connection' stamp: 'GuillermoPolito 5/5/2015 11:28'!close	self assertConnection.	(GAMysqlCommandQuit  onSession: netSession driver: self) execute.	netSession disconnect.	! !!GAMysqlDriver methodsFor: 'transaction' stamp: 'GuillermoPolito 1/21/2015 13:27'!commitTransaction		self basicQuery: 'COMMIT'! !!GAMysqlDriver methodsFor: 'connection' stamp: 'GuillermoPolito 5/5/2015 12:08'!connect	| response |	self isConnected ifTrue: [^ GAMysqlDriverError signal: 'Driver is already connected'].	netSession := GAMysqlNetSession new						toHost: self host andPort: self port;						yourself.	response := self authenticate.	response isError ifTrue: [ GAMysqlDriverError signal: 'Failed to connect to server: ', (GAMysqlError from: netSession read) message ].	"We tell the database the encoding we will be using. We could do it in the authenticate but we should have on the client side a table with all possible encodings and values"	self basicQuery: 'SET NAMES ', self encoding.		self register.	^ GAMysqlOkay from: netSession read! !!GAMysqlDriver methodsFor: 'statements' stamp: 'GuillermoPolito 4/24/2015 16:09'!createStatement		^ GAMysqlStatement onConnection: self.	! !!GAMysqlDriver methodsFor: 'statements' stamp: 'GuillermoPolito 4/24/2015 16:09'!createStatement: aSqlStatement		^ self createStatement		statementString: aSqlStatement;		yourself! !!GAMysqlDriver methodsFor: 'accessing' stamp: 'GuillermoPolito 1/21/2015 14:03'!database		^ connectionSpec db! !!GAMysqlDriver methodsFor: 'accessing' stamp: 'GuillermoPolito 1/16/2015 17:30'!database: aDatabase		connectionSpec database: aDatabase! !!GAMysqlDriver methodsFor: 'transaction' stamp: 'GuillermoPolito 4/24/2015 14:57'!defaultValueAutoCommit		^ true! !!GAMysqlDriver methodsFor: 'accessing' stamp: 'GuillermoPolito 1/21/2015 14:00'!driverId		^ 'mysql'! !!GAMysqlDriver methodsFor: 'encoding' stamp: 'GuillermoPolito 4/29/2015 12:25'!encoding		| encoding |	encoding := connectionString optionAt: 'encoding' ifAbsent: 'utf8mb4'.	^ (encoding = 'utf8') ifTrue: [ 'utf8mb4' ] ifFalse: [ encoding ]! !!GAMysqlDriver methodsFor: 'query' stamp: 'GuillermoPolito 4/27/2015 14:54'!execute: aQuery	^ self basicQuery: aQuery! !!GAMysqlDriver methodsFor: 'finalization' stamp: 'GuillermoPolito 5/5/2015 10:38'!finalize	self isConnected ifTrue: [ self close ].! !!GAMysqlDriver methodsFor: 'testing' stamp: 'GuillermoPolito 4/24/2015 14:15'!hasAutoCommit		^ ((self execute: 'SHOW SESSION VARIABLES LIKE ''autocommit''')		first atName: 'Value') = 'ON'.! !!GAMysqlDriver methodsFor: 'accessing' stamp: 'GuillermoPolito 1/21/2015 14:01'!host		^ connectionSpec host! !!GAMysqlDriver methodsFor: 'accessing' stamp: 'GuillermoPolito 1/16/2015 17:24'!host: aHost	connectionSpec host: aHost! !!GAMysqlDriver methodsFor: 'initialization' stamp: 'GuillermoPolito 5/5/2015 11:06'!initialize	super initialize.	connectionSpec := GAMysqlConnectionData new! !!GAMysqlDriver methodsFor: 'testing' stamp: 'GuillermoPolito 5/5/2015 10:42'!isConnected		^ netSession isNil not and: [netSession connected]! !!GAMysqlDriver methodsFor: 'private' stamp: 'GuillermoPolito 5/5/2015 10:43'!netSession		^ netSession! !!GAMysqlDriver methodsFor: 'instance creation' stamp: 'GuillermoPolito 4/17/2015 10:55'!newFixture	^ GADriverMysqlTestFixture new! !!GAMysqlDriver methodsFor: 'accessing' stamp: 'GuillermoPolito 1/21/2015 14:04'!password		^ connectionSpec password! !!GAMysqlDriver methodsFor: 'accessing' stamp: 'GuillermoPolito 1/16/2015 17:24'!password: aPort	connectionSpec password: aPort! !!GAMysqlDriver methodsFor: 'connection' stamp: 'GuillermoPolito 5/5/2015 11:18'!peekPacket	^ GAMysqlPacket from: netSession peek! !!GAMysqlDriver methodsFor: 'accessing' stamp: 'GuillermoPolito 1/21/2015 14:02'!port		^ connectionSpec port! !!GAMysqlDriver methodsFor: 'accessing' stamp: 'GuillermoPolito 1/16/2015 17:24'!port: aPort	connectionSpec port: aPort! !!GAMysqlDriver methodsFor: 'query' stamp: 'GuillermoPolito 4/24/2015 16:09'!prepare: aQuery		^ (self createStatement: aQuery) prepare! !!GAMysqlDriver methodsFor: 'transaction' stamp: 'GuillermoPolito 1/21/2015 13:39'!rollbackTransaction		self basicQuery: 'ROLLBACK'! !!GAMysqlDriver methodsFor: 'testing' stamp: 'GuillermoPolito 4/27/2015 17:30'!supportsAutomaticQueryEncoding		^ false! !!GAMysqlDriver methodsFor: 'testing' stamp: 'GuillermoPolito 4/23/2015 18:20'!supportsCursoredFetch	^ true! !!GAMysqlDriver methodsFor: 'testing' stamp: 'GuillermoPolito 1/21/2015 16:37'!supportsPreparedStatements	^ true! !!GAMysqlDriver methodsFor: 'testing' stamp: 'GuillermoPolito 4/20/2015 16:42'!supportsRetrievingGeneratedKeys	^ true! !!GAMysqlDriver methodsFor: 'accessing' stamp: 'GuillermoPolito 1/21/2015 14:04'!user		^ connectionSpec user! !!GAMysqlDriver methodsFor: 'accessing' stamp: 'GuillermoPolito 1/23/2015 15:07'!user: username	connectionSpec user: username! !!GAMysqlBinReader class methodsFor: 'as yet unclassified' stamp: 'ah 9/17/2011 23:38'!default	defaultInstance isNil ifTrue: [ defaultInstance := self new ].	^ defaultInstance! !!GAMysqlBinReader methodsFor: 'integer' stamp: 'ah 6/18/2011 01:05'!bigIntFrom: aStream	^ aStream next + (aStream next << 8) + (aStream next << 16) + (aStream next << 24) + 		(aStream next << 32) + (aStream next << 40) + (aStream next << 48) + (aStream next << 56)		! !!GAMysqlBinReader methodsFor: 'time' stamp: 'ah 7/6/2011 00:21'!dateFrom: aStream "ByteStream"	"Ref: libmysql.c >> read_binary_date"	| len year month day |		len := aStream next.	len = 0 ifTrue: [^ nil].	year := month := day := 0.	year := self smallIntFrom: aStream.	month := self tinyIntFrom: aStream.	day := self tinyIntFrom: aStream.	aStream next: (len - 4). "ignore rest of fields even if present"	^ Date year: year month: month day: day	! !!GAMysqlBinReader methodsFor: 'time' stamp: 'ah 7/6/2011 00:18'!dateTimeFrom: aStream "ByteStream"	"Ref: libmysql.c >> read_binary_datetime"	"length(1) + year(2) + month(1) + day(1) + hh(1) + mm(1) + ss(1) + micoSeconds(4)"		| length year month day hh mm ss ns |	length := aStream next.	length = 0 ifTrue: [^ nil].		year := self smallIntFrom: aStream.	month := self tinyIntFrom: aStream..	day := self tinyIntFrom: aStream..		hh := mm:= ss := ns := 0.	length > 4 ifTrue: [		hh := self tinyIntFrom: aStream..		mm := self tinyIntFrom: aStream.		ss := self tinyIntFrom: aStream.].		length > 7 ifTrue: [ns := (self longIntFrom: aStream) * 1000].	^ DateAndTime 		year: year month: month day: day 		hour: hh minute: mm second: ss 		nanoSecond: ns offset: 0 hours		! !!GAMysqlBinReader methodsFor: 'real' stamp: 'GuillermoPolito 5/5/2015 12:09'!decimalWithScale: scale from: aStream	| valueString |	valueString := (GAMysqlHelper decodeLcsFrom: aStream) asString, 's', scale asString.	^ valueString asNumber	! !!GAMysqlBinReader methodsFor: 'real' stamp: 'ah 6/18/2011 01:08'!doubleFrom: aStream	| num |	num := Float new: 2.	num at: 2 put: (self longIntFrom: aStream).	num at: 1 put: (self longIntFrom: aStream).	^ num	! !!GAMysqlBinReader methodsFor: 'real' stamp: 'ah 6/18/2011 01:09'!floatFrom: aStream	^ Float fromIEEE32Bit: (self longIntFrom: aStream)	! !!GAMysqlBinReader methodsFor: 'integer' stamp: 'ah 6/18/2011 01:01'!longIntFrom: aStream	^ aStream next + (aStream next << 8) + (aStream next << 16) + (aStream next << 24)	! !!GAMysqlBinReader methodsFor: 'integer' stamp: 'ah 6/18/2011 10:05'!mediumIntFrom: aStream	"int24 is sent as 4 bytes int"	"Ref: libmysql.c >> fetch_result_with_conversion()"	^ self longIntFrom: aStream	! !!GAMysqlBinReader methodsFor: 'integer' stamp: 'ah 6/26/2011 17:36'!smallIntFrom: aStream	^ aStream next + (aStream next << 8) 		! !!GAMysqlBinReader methodsFor: 'time' stamp: 'ah 9/17/2011 23:50'!timeFrom: aStream 	"ByteStream"	"length(1) + sign(1) + days(4) + hh(1) + mm(1) + ss(1) + subSeconds(4)"	"According to the mySQL docs, it deos not store the fraction part of the seconds."	| length sign days hh mm ss timeDuration timeOfDay ns |	length := aStream next.	length = 0 ifTrue: [ ^ Time midnight ].	sign := aStream next = 0 		ifTrue: [ 1 ]		ifFalse: [ 1 negated ].	days := self longIntFrom: aStream.	hh := mm := ss := ns := 0.	length > 5 ifTrue: 		[ hh := self tinyIntFrom: aStream.		mm := self tinyIntFrom: aStream.		ss := self tinyIntFrom: aStream ].	length > 8 ifTrue: [ ns := 1000 * (self longIntFrom: aStream) ].	timeDuration := Duration 		days: days		hours: hh		minutes: mm		seconds: ss		nanoSeconds: ns.	timeOfDay := Time 		hour: hh		minute: mm		second: ss		nanoSecond: ns.	sign < 0 ifTrue: [ ^ timeDuration negated ].	days > 0 		ifTrue: [ ^ timeDuration ]		ifFalse: [ ^ timeOfDay ]! !!GAMysqlBinReader methodsFor: 'time' stamp: 'ah 7/6/2011 05:48'!timeStampFrom: aStream "ByteStream"	| dt |	dt := self dateTimeFrom: aStream.	^ dt ifNil: [nil] ifNotNil: [dt asTimeStamp]	! !!GAMysqlBinReader methodsFor: 'integer' stamp: 'ah 6/18/2011 01:00'!tinyIntFrom: aStream	^ aStream next 		! !!GAMysqlBinReader methodsFor: 'blob' stamp: 'GuillermoPolito 5/5/2015 12:09'!varBlobFrom: aStream	^ GAMysqlHelper decodeLcsFrom: aStream 		! !!GAMysqlBinReader methodsFor: 'string' stamp: 'ah 6/18/2011 10:09'!varStringFrom: aStream	^ (self varBlobFrom: aStream) asString 		! !!GAMysqlBinReader methodsFor: 'time' stamp: 'ah 6/29/2011 00:06'!yearFrom: aStream "ByteStream"	^ self smallIntFrom: aStream		! !!GAMysqlBindParam class methodsFor: 'as yet unclassified' stamp: 'ah 9/18/2011 01:11'!listOfSize: count forDescriptors: fields	| params |	params := (1 to: count) collect: [:each |  			(self new 				declaredUnsigned: (fields at: each) isUnsigned; 				yourself)].	^ params	! !!GAMysqlBindParam class methodsFor: 'as yet unclassified' stamp: 'ah 7/3/2011 00:56'!withValue: aValue	^ self new		bindValue: aValue;		yourself	! !!GAMysqlBindParam methodsFor: 'private' stamp: 'ah 7/12/2011 19:41'!bigIntRange	^ self isDeclaredUnsigned 		ifTrue: [16r0000000000000000 to: 16rFFFFFFFFFFFFFFFF] 		ifFalse: [-16r8000000000000000 to: 16r7FFFFFFFFFFFFFFF].! !!GAMysqlBindParam methodsFor: 'accessing' stamp: 'GuillermoPolito 5/5/2015 12:10'!bindValue: aValue 	| boundType |	paramValue := aValue.	(boundType := self detectParamType) ~= paramType 		ifTrue: [			paramType := boundType.			newParamBound := true].	GAMysqlTypes typeVARSTRING = paramType ifTrue: [ paramValue := connection encoder encodeString: paramValue ].	unsignedFlag := self detectParamSign.	! !!GAMysqlBindParam methodsFor: 'accessing' stamp: 'GuillermoPolito 4/28/2015 16:37'!connection: aConnection	connection := aConnection! !!GAMysqlBindParam methodsFor: 'writes' stamp: 'ah 9/18/2011 01:38'!dateTimeBytes	| dt year length micros |	ByteArray streamContents: [:strm |		dt := paramValue asDateAndTime.		length := 0.		strm nextPut: length. "will re-adjust this as different conditions are found"						year := dt year.		strm 			nextPut: (year digitAt: 1); nextPut: (year digitAt: 2); "year"			nextPut: (dt month digitAt: 1); nextPut: (dt dayOfMonth digitAt: 1).		strm			nextPut: (dt hour digitAt: 1); nextPut: (dt minute digitAt: 1); 			nextPut: (dt second digitAt: 1). 				micros := dt nanoSecond // 1000.		strm 			nextPut: (micros digitAt: 1); nextPut: (micros digitAt: 2);			nextPut: (micros digitAt: 3); nextPut: (micros digitAt: 4).				"Update the length field now."		length := 11.		micros = 0 ifTrue: [			length := 7. "no sub-seconds to send"			(((dt hour = 0) and: [dt minute = 0]) and: [dt second = 0]) ifTrue: [				"no hh:mm:ss to send"				length := 4.								((dt year = 0) and: [dt month = 0 and: [dt day = 0]]) ifTrue: [					"no yy-mm-dd to send"					length := 0]]].				strm reset; nextPut: length; setToEnd.		^ strm contents first: (length + 1) "remember to send the length byte itself" ]	! !!GAMysqlBindParam methodsFor: 'writes' stamp: 'ah 5/11/2011 00:28'!decimalBytes	"For scaled decimal"	ByteArray streamContents: [:strm |		strm nextPutAll: (paramValue abs printString allButLast:2) asByteArray.		^ strm contents]	! !!GAMysqlBindParam methodsFor: 'accessing' stamp: 'ah 7/12/2011 19:34'!declaredUnsigned: aBoolean	declaredUnsigned := aBoolean	! !!GAMysqlBindParam methodsFor: 'accessing' stamp: 'ah 9/11/2011 13:33'!detectParamSign	"true is unsigned, false if signed"	^ (((paramValue isKindOf: Number) or: [paramValue isKindOf: Duration]) and: [paramValue negative]) not	! !!GAMysqlBindParam methodsFor: 'accessing' stamp: 'GuillermoPolito 5/5/2015 12:10'!detectParamType	"Corresponding database type needs to be inferred from the bound value"	paramValue ifNil: [ ^ GAMysqlTypes typeNULL ].	(paramValue isKindOf: Boolean) ifTrue: [ ^ GAMysqlTypes typeTINY ].	(paramValue isKindOf: Integer) ifTrue: [		(self tinyIntRange includes: paramValue) ifTrue: [^ GAMysqlTypes typeTINY].		(self smallIntRange includes: paramValue) ifTrue: [^ GAMysqlTypes typeSHORT].		(self longIntRange includes: paramValue) ifTrue: [^ GAMysqlTypes typeLONG].		(self bigIntRange includes: paramValue) ifTrue: [^ GAMysqlTypes typeLONGLONG].		^ GAMysqlBindError signal: 'Supplied integer does not have a matching database type'].	(paramValue isKindOf: ScaledDecimal) ifTrue: [ ^ GAMysqlTypes typeDECIMAL ].	((paramValue isKindOf: Float) or:  [paramValue isKindOf: Fraction]) 		ifTrue: [				(paramValue asFloat at: 2) = 0 				ifTrue: [^ GAMysqlTypes typeFLOAT]				ifFalse: [^ GAMysqlTypes typeDOUBLE] ].	(paramValue isKindOf: Character) ifTrue: [ ^ GAMysqlTypes typeSTRING ].	((paramValue isKindOf: String) or: [paramValue isKindOf: Text]) 		ifTrue: [ ^ GAMysqlTypes typeVARSTRING ].	(paramValue isMemberOf: DateAndTime) ifTrue: [ ^ GAMysqlTypes typeDATETIME ].	(paramValue isKindOf: TimeStamp) ifTrue: [ ^ GAMysqlTypes typeTIMESTAMP ].	((paramValue isKindOf: Time) or: [paramValue isKindOf: Duration]) 		ifTrue: [ ^ GAMysqlTypes typeTIME ].	(paramValue isKindOf: Date) ifTrue: [ ^ GAMysqlTypes typeDATE ].	(paramValue isKindOf: ByteArray) ifTrue: [ 		paramValue size < 16r100 ifTrue: [ ^ GAMysqlTypes typeTINYBLOB ].		paramValue size < 16r10000 ifTrue: [ ^ GAMysqlTypes typeBLOB ].		paramValue size < 16r1000000 ifTrue: [ ^ GAMysqlTypes typeMEDIUMBLOB ].		^ GAMysqlTypes typeLONGBLOB ].		^ GAMysqlBindError signal: 'Unsupported data type for param binding'	! !!GAMysqlBindParam methodsFor: 'writes' stamp: 'ah 5/11/2011 00:10'!doubleBytes 	| storable |	ByteArray streamContents: [:strm |		storable := paramValue asFloat at: 1.		strm 			nextPut: (storable digitAt: 1); nextPut: (storable digitAt: 2);			nextPut: (storable digitAt: 3); nextPut: (storable digitAt: 4).		storable := paramValue asFloat at: 2.		strm 			nextPut: (storable digitAt: 1); nextPut: (storable digitAt: 2);			nextPut: (storable digitAt: 3); nextPut: (storable digitAt: 4).					^ strm contents]! !!GAMysqlBindParam methodsFor: 'writes' stamp: 'ah 9/18/2011 00:46'!floatBytes 	| storable |	ByteArray streamContents: [:strm |		storable := paramValue asFloat at: 1. "indexed accedd into a Float"		strm 			nextPut: (storable digitAt: 1); nextPut: (storable digitAt: 2);			nextPut: (storable digitAt: 3); nextPut: (storable digitAt: 4).		^ strm contents]	! !!GAMysqlBindParam methodsFor: 'initialize-release' stamp: 'GuillermoPolito 5/5/2015 12:10'!initialize	newParamBound := false.	paramType := GAMysqlTypes typeNULL.	unsignedFlag := declaredUnsigned := false.	sentAsLongData := false	! !!GAMysqlBindParam methodsFor: 'writes' stamp: 'ah 7/11/2011 23:31'!integerBytes: size 	| storable |	ByteArray streamContents: [:strm |		storable := self storableIntegerValueOfSize: size.		1 to: size do: [:ii | strm nextPut: (storable digitAt: ii)].		^ strm contents]	! !!GAMysqlBindParam methodsFor: 'testing' stamp: 'ah 7/12/2011 19:41'!isDeclaredUnsigned	^ declaredUnsigned  	! !!GAMysqlBindParam methodsFor: 'testing' stamp: 'GuillermoPolito 5/5/2015 12:10'!isLongData	| typeRange |	"We also send varchar types as long data"	self paramType = GAMysqlTypes typeVARCHAR ifTrue: [^ true].	typeRange := (GAMysqlTypes typeTINYBLOB to: GAMysqlTypes typeSTRING).	^ typeRange includes: self paramType 	! !!GAMysqlBindParam methodsFor: 'testing' stamp: 'GuillermoPolito 5/5/2015 12:10'!isNull	^ paramType = GAMysqlTypes typeNULL	! !!GAMysqlBindParam methodsFor: 'testing' stamp: 'ah 5/30/2011 19:09'!isRebound	^ newParamBound 	! !!GAMysqlBindParam methodsFor: 'testing' stamp: 'ah 5/9/2011 08:47'!isUnsigned	^ unsignedFlag 	! !!GAMysqlBindParam methodsFor: 'private' stamp: 'ah 7/12/2011 19:42'!longIntRange	^ self isDeclaredUnsigned 		ifTrue: [16r00000000 to: 16rFFFFFFFF] 		ifFalse: [-16r80000000 to: 16r7FFFFFFF].! !!GAMysqlBindParam methodsFor: 'accessing' stamp: 'ah 5/9/2011 08:47'!paramType	^ paramType 	! !!GAMysqlBindParam methodsFor: 'accessing' stamp: 'ah 5/30/2011 19:15'!resetReboundFlag	newParamBound := false	! !!GAMysqlBindParam methodsFor: 'testing' stamp: 'ah 8/31/2011 21:47'!sentAsLongData	^ sentAsLongData	! !!GAMysqlBindParam methodsFor: 'accessing' stamp: 'ah 8/31/2011 21:47'!sentAsLongData: aBoolean	sentAsLongData := aBoolean	! !!GAMysqlBindParam methodsFor: 'private' stamp: 'ah 7/12/2011 19:42'!smallIntRange	^ self isDeclaredUnsigned ifTrue: [16r0000 to: 16rFFFF] ifFalse: [-16r8000 to: 16r7FFF].! !!GAMysqlBindParam methodsFor: 'writes' stamp: 'ah 5/11/2011 23:18'!storableIntegerValueOfSize: size 	(paramValue isKindOf: Boolean) ifTrue: [^ paramValue ifTrue: [1] ifFalse: [0]].	^ paramValue negative 		ifTrue: [ (1 << (size * 8)) + paramValue ]		ifFalse: [ paramValue ]! !!GAMysqlBindParam methodsFor: 'accessing' stamp: 'GuillermoPolito 5/5/2015 12:10'!storeBinaryOn: aStream			paramType 	caseOf: {		[GAMysqlTypes typeNULL]->[].		[GAMysqlTypes typeTINY]->[aStream nextPutAll: (self integerBytes: 1)].		[GAMysqlTypes typeSHORT]->[aStream nextPutAll: (self integerBytes: 2)].		[GAMysqlTypes typeLONG]->[aStream nextPutAll: (self integerBytes: 4)].				[GAMysqlTypes typeLONGLONG]->[aStream nextPutAll: (self integerBytes: 8)].			[GAMysqlTypes typeFLOAT]->[aStream nextPutAll: (self floatBytes)].		[GAMysqlTypes typeDOUBLE]->[aStream nextPutAll: (self doubleBytes)].		[GAMysqlTypes typeTIME]->[aStream nextPutAll: self timeBytes].		[GAMysqlTypes typeDATE]->[aStream nextPutAll: self dateTimeBytes].		[GAMysqlTypes typeTIMESTAMP]->[aStream nextPutAll: self dateTimeBytes].		[GAMysqlTypes typeDATETIME]->[aStream nextPutAll: self dateTimeBytes].			[GAMysqlTypes typeDECIMAL]->[aStream nextPutAll: self decimalBytes]		} 	otherwise: [aStream nextPutAll: self stringOrBlobBytes]	! !!GAMysqlBindParam methodsFor: 'writes' stamp: 'GuillermoPolito 5/5/2015 12:09'!stringOrBlobBytes			ByteArray streamContents: [:strm |		GAMysqlHelper encodeLcs: self stringOrBlobBytesRaw on: strm.		^ strm contents]	! !!GAMysqlBindParam methodsFor: 'writes' stamp: 'ah 9/17/2011 23:50'!stringOrBlobBytesRaw	| mappedValue |	mappedValue := ((paramValue isKindOf: Character) or: [ paramValue isKindOf: Text ]) 		ifTrue: [ paramValue asString ]		ifFalse: [ paramValue ].	^ mappedValue asByteArray! !!GAMysqlBindParam methodsFor: 'writes' stamp: 'ah 9/18/2011 01:40'!timeBytes	| dur days length micros |	ByteArray streamContents: [:strm |		dur := paramValue asDuration.		length := 0.		strm nextPut: length. "will re-adjust this as different conditions are found"						dur negative ifTrue: [strm nextPut: 1] ifFalse: [strm nextPut: 0].		days := dur days.		strm 			nextPut: (days digitAt: 1); nextPut: (days digitAt: 2);			nextPut: (days digitAt: 3); nextPut: (days digitAt: 4).				strm 			nextPut: (dur hours digitAt: 1); nextPut: (dur minutes digitAt: 1); 			nextPut: (dur seconds asInteger digitAt: 1).				micros := dur nanoSeconds // 1000.		strm 			nextPut: (micros digitAt: 1); nextPut: (micros digitAt: 2);			nextPut: (micros digitAt: 3); nextPut: (micros digitAt: 4).				"Update the length field now."		length := 11.		micros = 0 ifTrue: [			length := 7. "no sub-seconds to send"			((dur hours = 0) and: [dur minutes = 0 and: [dur seconds = 0]]) ifTrue: [				"no hh:mm:ss to send"				length := 4.				dur days = 0 ifTrue: [length := 0]]].		 		length > 0 ifTrue: [length := length + 1 "include sign byte"].		strm reset; nextPut: length; setToEnd.		^ strm contents first: (length + 1)] "length byte plus rest"	! !!GAMysqlBindParam methodsFor: 'private' stamp: 'ah 7/12/2011 19:41'!tinyIntRange	^ self isDeclaredUnsigned ifTrue: [16r00 to: 16rFF] ifFalse: [-16r80 to: 16r7F].! !!GAMysqlCommandBase class methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 1/23/2015 12:03'!initialize	"self initialize"		ComSleep := 16r00.	ComQuit := 16r01.	ComInitDb := 16r02.	ComQuery := 16r03.	ComFieldList := 16r04.	ComStat := 16r09.	ComDebug := 16r0D.	ComPing := 16r0E.	ComChangeUser := 16r11.	ComStmtPrepare := 16r16.	ComStmtExecute := 16r17.	ComStmtSendLongData := 16r18.	ComStmtClose := 16r19.	ComStmtReset := 16r1A.	ComSetOption := 16r1B.	ComStmtFetch := 16r1C.! !!GAMysqlCommandBase class methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 5/5/2015 11:27'!onSession: ioSession driver: aDriver	^ self new		session: ioSession;		driver: aDriver;		yourself! !!GAMysqlCommandBase methodsFor: 'command configuration' stamp: 'ah 11/25/2009 01:42'!commandArg	self subclassResponsibility ! !!GAMysqlCommandBase methodsFor: 'command configuration' stamp: 'ah 11/25/2009 01:18'!commandCode	self subclassResponsibility ! !!GAMysqlCommandBase methodsFor: 'accessing' stamp: 'GuillermoPolito 4/27/2015 15:30'!driver: aMysqlDriver 	driver := aMysqlDriver! !!GAMysqlCommandBase methodsFor: 'execute' stamp: 'GuillermoPolito 4/23/2015 17:21'!execute	| resp cmd |	session resetSequence.	cmd := self prepare.	self send: cmd.	resp := self readResponse.	fetchListener ifNotNilDo: #fetchOccurred.	^ resp! !!GAMysqlCommandBase methodsFor: 'accessing' stamp: 'GuillermoPolito 4/23/2015 17:20'!fetchListener: aFetchListener	fetchListener := aFetchListener! !!GAMysqlCommandBase methodsFor: 'communication' stamp: 'GuillermoPolito 5/5/2015 11:10'!gotEof	^ driver peekPacket isEof ! !!GAMysqlCommandBase methodsFor: 'execute' stamp: 'GuillermoPolito 5/5/2015 12:02'!prepare	| cmd |	cmd := GAMysqlCommand new.	cmd command: self commandCode arg: self commandArg.	^ cmd! !!GAMysqlCommandBase methodsFor: 'communication' stamp: 'GuillermoPolito 5/5/2015 12:08'!readResponse	| resp |	resp := driver peekPacket.	resp isError ifTrue: [^ GAMysqlError from: session read].	resp isOkay ifTrue: [^ GAMysqlOkay from: session read].	^ resp "Response type unknown at this point"! !!GAMysqlCommandBase methodsFor: 'communication' stamp: 'GuillermoPolito 5/5/2015 10:56'!send: cmd	session write: cmd write.! !!GAMysqlCommandBase methodsFor: 'accessing' stamp: 'ah 7/25/2009 19:30'!session: ioSession	session := ioSession! !!GAMysqlCommandChangeUser methodsFor: 'accessing' stamp: 'ah 11/26/2009 00:21'!charset: cset 	charset := cset! !!GAMysqlCommandChangeUser methodsFor: 'command configuration' stamp: 'GuillermoPolito 5/5/2015 11:18'!commandArg	| buffStream |	buffStream := WriteStream on: ByteArray new.	buffStream		nextPutAll: user asByteArray;		nextPut: 0.	GAMysqlPacket new 		encodeLcs: scrambledPassword asByteArray		on: buffStream.	buffStream		nextPutAll: (database 				ifNil: [ '' asByteArray ]				ifNotNil: [ database asByteArray ]);		nextPut: 0.	buffStream		nextPut: (charset digitAt: 1);		nextPut: (charset digitAt: 2).	^ buffStream contents! !!GAMysqlCommandChangeUser methodsFor: 'command configuration' stamp: 'ah 11/26/2009 00:38'!commandCode	^ ComChangeUser ! !!GAMysqlCommandChangeUser methodsFor: 'accessing' stamp: 'ah 11/25/2009 23:58'!database: dbName	database := dbName! !!GAMysqlCommandChangeUser methodsFor: 'accessing' stamp: 'ah 11/25/2009 23:56'!password: pwd	password := pwd! !!GAMysqlCommandChangeUser methodsFor: 'execute' stamp: 'GuillermoPolito 5/5/2015 11:16'!readResponse	| pkt |	pkt := super readResponse.	pkt isOkayOrError 		ifTrue: [^ pkt].			pkt isEof ifTrue: [		"Absorb the response"		session read.		"For old (short) hash style passwords"		self send323Scramble.		pkt := super readResponse.		pkt isOkayOrError 			ifTrue: [^ pkt]].			GAMysqlDriverError signal: 'Unrecognized response for command'	! !!GAMysqlCommandChangeUser methodsFor: 'accessing' stamp: 'ah 10/1/2011 22:43'!scrambleBuff: seed	scrambleBuff := seed	! !!GAMysqlCommandChangeUser methodsFor: 'accessing' stamp: 'ah 10/1/2011 22:54'!scrambledPassword: pwd	scrambledPassword := pwd	! !!GAMysqlCommandChangeUser methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 5/5/2015 11:19'!send323Scramble	| scrmblPkt |	scrmblPkt := GAMysql323Scramble new.	scrmblPkt password: password; scrambleBuff: scrambleBuff.	self send: scrmblPkt	! !!GAMysqlCommandChangeUser methodsFor: 'accessing' stamp: 'ah 11/25/2009 23:56'!user: userName	user := userName! !!GAMysqlCommandCloseStatement methodsFor: 'as yet unclassified' stamp: 'ah 8/23/2011 21:45'!commandArg	ByteArray streamContents: [:strm |		strm 		nextPut: (statementId digitAt: 1);		nextPut: (statementId digitAt: 2);		nextPut: (statementId digitAt: 3);		nextPut: (statementId digitAt: 4).				^ strm contents]! !!GAMysqlCommandCloseStatement methodsFor: 'as yet unclassified' stamp: 'ah 8/23/2011 21:45'!commandCode	^ ComStmtClose	! !!GAMysqlCommandCloseStatement methodsFor: 'as yet unclassified' stamp: 'ah 8/23/2011 22:15'!readResponse	^ nil	! !!GAMysqlCommandCloseStatement methodsFor: 'as yet unclassified' stamp: 'ah 8/23/2011 21:45'!statementId: idValue "4 byte integer"	statementId := idValue		! !!GAMysqlCommandExecute methodsFor: 'as yet unclassified' stamp: 'ah 9/17/2011 23:39'!commandArg	| paramType nonLongs |	ByteArray streamContents: 		[ :strm | 		strm			nextPut: (stmtId digitAt: 1);			nextPut: (stmtId digitAt: 2);			nextPut: (stmtId digitAt: 3);			nextPut: (stmtId digitAt: 4).		cursoredFetch 			ifTrue: [ strm nextPut: 1	"flags => READ_CURSOR" ]			ifFalse: [ strm nextPut: 0	"flags => NO_CURSOR" ].		strm			nextPut: 1;			nextPut: 0;			nextPut: 0;			nextPut: 0.	"iterationCount"		strm nextPutAll: self nullBitMap.		self hasNewParamBound 			ifTrue: 				[ strm nextPut: 1.	"new params bound <- true"				params do: 					[ :each | 					paramType := each paramType.					strm						nextPut: (paramType digitAt: 1);						nextPut: (paramType digitAt: 2) ] ]			ifFalse: [ strm nextPut: 0 ].	"new params bound <- false"		nonLongs := params 			ifNil: [ Array new ]			ifNotNil: [ params reject: [ :each | each isLongData ] ].		nonLongs do: [ :each | each storeBinaryOn: strm ].		^ strm contents ]! !!GAMysqlCommandExecute methodsFor: 'as yet unclassified' stamp: 'ah 11/27/2010 15:41'!commandCode	^ ComStmtExecute 	! !!GAMysqlCommandExecute methodsFor: 'as yet unclassified' stamp: 'ah 9/15/2011 22:12'!cursoredFetch: aBoolean 	cursoredFetch := aBoolean	! !!GAMysqlCommandExecute methodsFor: 'as yet unclassified' stamp: 'ah 7/2/2011 00:13'!execute	| resp |	"Remember to send long data for the longdata params before calling here"	resp := super execute.	self resetNewParamBound.	^ resp	! !!GAMysqlCommandExecute methodsFor: 'as yet unclassified' stamp: 'ah 9/1/2011 06:26'!hasNewParamBound	^ params anySatisfy: [:each | each isRebound]	! !!GAMysqlCommandExecute methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 5/5/2015 11:32'!initialize	super initialize.	cursoredFetch := false.! !!GAMysqlCommandExecute methodsFor: 'as yet unclassified' stamp: 'ah 7/2/2011 00:09'!nullBitMap	| nullBitMap mapByte byteIndex bitMask |	nullBitMap := ByteArray new: (params size + 7) // 8.	params doWithIndex: [:each :paramIndex |		each isNull ifTrue: [			byteIndex := (paramIndex + 7) // 8.			bitMask := 1 bitShift: (paramIndex + 7) \\ 8.			mapByte := nullBitMap at: byteIndex.			mapByte := mapByte bitOr: bitMask.			nullBitMap at: byteIndex put: mapByte.		]	].	^ nullBitMap 	! !!GAMysqlCommandExecute methodsFor: 'as yet unclassified' stamp: 'ah 5/1/2011 15:28'!params: inParams	params := inParams.	! !!GAMysqlCommandExecute methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 5/5/2015 12:03'!readEof	^ GAMysqlEof from: session read! !!GAMysqlCommandExecute methodsFor: 'as yet unclassified' stamp: 'ah 6/11/2011 13:17'!readFields	| respFields field |	respFields := OrderedCollection new.		[self gotEof] whileFalse:[ 		"Read each field and save it"		field := self readOneField.		respFields add: field ].			^ respFields asArray			! !!GAMysqlCommandExecute methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 5/5/2015 12:03'!readOneField	^ GAMysqlField from: session read.! !!GAMysqlCommandExecute methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 5/5/2015 11:49'!readOneRow: fields 	| parser |	parser := GAMysqlBinaryRowDataParser new.	parser driver: driver.	parser columnDescriptors: fields.	^ parser read: session read.! !!GAMysqlCommandExecute methodsFor: 'as yet unclassified' stamp: 'ah 9/12/2011 07:56'!readResponse	| resp |	resp := self readResult.	"We do not need to look for multi-result responses in statement execute; so the following	line of code is commented out. Check COM_QUERY response handling for multi-result"	"resp hasMoreResults ifTrue: [resp next: self readResponse]."	^ resp	! !!GAMysqlCommandExecute methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 5/5/2015 12:09'!readResult	| resultSetHdr pkt fieldsEof rows fields rowsEof |	pkt := super readResponse.	pkt isOkayOrError ifTrue: [^ pkt].		resultSetHdr := GAMysqlResultSetHeader from: session read.	fields := self readFields.	fieldsEof := self readEof.	"eof"	fieldsEof hasOpenCursor ifFalse: [			rows := self readRowData: fields.		rowsEof := self readEof. "eof"].		^ GAMysqlResultSet new		header: resultSetHdr;		fields: fields;		fieldsEof: fieldsEof;		rows: rows;		rowsEof: rowsEof;		yourself! !!GAMysqlCommandExecute methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/27/2015 15:35'!readRowData: fields 	| respRows row |	respRows := OrderedCollection new.	[self gotEof] whileFalse: [ 		"Read each row and save it"		row := self readOneRow: fields.		respRows add: row].			^ respRows asArray! !!GAMysqlCommandExecute methodsFor: 'as yet unclassified' stamp: 'ah 7/2/2011 00:10'!resetNewParamBound	params do: [:each | each resetReboundFlag]	! !!GAMysqlCommandExecute methodsFor: 'as yet unclassified' stamp: 'ah 5/30/2011 23:45'!statementId: id	stmtId := id	! !!GAMysqlCommandFetchRows methodsFor: 'as yet unclassified' stamp: 'ah 9/12/2011 21:54'!commandArg	| |	ByteArray streamContents: 		[ :strm | 		strm			nextPut: (stmtId digitAt: 1);			nextPut: (stmtId digitAt: 2);			nextPut: (stmtId digitAt: 3);			nextPut: (stmtId digitAt: 4);			nextPut: (numRows digitAt: 1);			nextPut: (numRows digitAt: 2);			nextPut: (numRows digitAt: 3);			nextPut: (numRows digitAt: 4).					^ strm contents ]! !!GAMysqlCommandFetchRows methodsFor: 'as yet unclassified' stamp: 'ah 9/12/2011 22:10'!commandCode	^ ComStmtFetch 	! !!GAMysqlCommandFetchRows methodsFor: 'as yet unclassified' stamp: 'ah 9/12/2011 21:55'!numRows: count	numRows := count	! !!GAMysqlCommandFetchRows methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 5/5/2015 12:03'!readEof	^ GAMysqlEof from: session read! !!GAMysqlCommandFetchRows methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 5/5/2015 11:50'!readOneRow: fields 	| parser |	parser := GAMysqlBinaryRowDataParser new.	parser driver: driver.	parser columnDescriptors: fields.	^ parser read: session read.! !!GAMysqlCommandFetchRows methodsFor: 'as yet unclassified' stamp: 'ah 9/12/2011 22:44'!readResponse	| resp |	resp := self readResult.	^ resp	! !!GAMysqlCommandFetchRows methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 5/5/2015 12:08'!readResult	| pkt fieldsEof rows fields rowsEof |	pkt := driver peekPacket.	pkt isError ifTrue: [^ GAMysqlError from: session read].		"If not error then zero or more row data packets followed by eof packet"	fields := resultSetContext fields.	fieldsEof := resultSetContext fieldsEof.	fieldsEof hasOpenCursor ifTrue: [			rows := self readRowData: fields.		rowsEof := self readEof. "eof"].		^ resultSetContext		rows: rows asOrderedCollection;		rowsEof: rowsEof;		yourself		! !!GAMysqlCommandFetchRows methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/27/2015 15:35'!readRowData: fields 	| respRows row |	respRows := OrderedCollection new.	[self gotEof] whileFalse: [ 		"Read each row and save it"		row := self readOneRow: fields.		respRows add: row].			^ respRows asArray! !!GAMysqlCommandFetchRows methodsFor: 'as yet unclassified' stamp: 'ah 9/12/2011 22:03'!resultSetContext: partialResultSet	resultSetContext := partialResultSet 	! !!GAMysqlCommandFetchRows methodsFor: 'as yet unclassified' stamp: 'ah 9/12/2011 21:49'!statementId: id	stmtId := id	! !!GAMysqlCommandPing methodsFor: 'as yet unclassified' stamp: 'ah 11/25/2009 01:42'!commandArg	^ nil! !!GAMysqlCommandPing methodsFor: 'as yet unclassified' stamp: 'ah 11/25/2009 02:11'!commandCode	^ ComPing ! !!GAMysqlCommandPing methodsFor: 'as yet unclassified' stamp: 'ah 6/4/2011 18:51'!readResponse	| pkt |	pkt := super readResponse.	pkt isOkayOrError 		ifTrue: [^ pkt] 		ifFalse: [self error: 'Unrecognized response for command']		! !!GAMysqlCommandPrepareStatement methodsFor: 'as yet unclassified' stamp: 'ah 11/25/2010 15:54'!commandArg	^ query 	! !!GAMysqlCommandPrepareStatement methodsFor: 'as yet unclassified' stamp: 'ah 11/24/2010 22:37'!commandCode	^ ComStmtPrepare 	! !!GAMysqlCommandPrepareStatement methodsFor: 'as yet unclassified' stamp: 'ah 11/25/2010 15:54'!queryString: queryString 	query := queryString	! !!GAMysqlCommandPrepareStatement methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 5/5/2015 12:03'!readColumnDescr	^ GAMysqlField from: session read.! !!GAMysqlCommandPrepareStatement methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 5/5/2015 12:03'!readEof	^ GAMysqlEof from: session read	! !!GAMysqlCommandPrepareStatement methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 5/5/2015 12:03'!readParamDescr	^ GAMysqlField from: session read.! !!GAMysqlCommandPrepareStatement methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 5/5/2015 12:04'!readPrepareOkay	| prepOkay params columns paramEof columnEof indx |		prepOkay := GAMysqlPrepareOkay from: session read.	params := Array new: prepOkay numParams.	columns := Array new: prepOkay numColumns.		prepOkay numParams > 0 ifTrue: [		indx := 1.			[self gotEof] whileFalse: [			params at: indx put: self readParamDescr.			indx := indx + 1 ].		paramEof := self readEof "eof"].	prepOkay numColumns > 0 ifTrue: [			indx := 1.		[self gotEof ] whileFalse: [			columns at: indx put: self readColumnDescr.			indx := indx + 1 ].		columnEof := self readEof "eof"].			^ GAMysqlPrepareResponse new		prepareOkay: prepOkay;		paramDescriptors: params;		paramEof: paramEof;		columnDescriptors: columns;		columnEof: columnEof;		yourself	! !!GAMysqlCommandPrepareStatement methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 5/5/2015 12:08'!readResponse	| resp |	resp := driver peekPacket.	resp isError ifTrue: [^ GAMysqlError from: session read].	resp isOkay ifTrue: [^ self readPrepareOkay]! !!GAMysqlCommandQuery methodsFor: 'as yet unclassified' stamp: 'ah 11/25/2009 01:21'!commandArg	^ query ! !!GAMysqlCommandQuery methodsFor: 'as yet unclassified' stamp: 'ah 11/25/2009 01:21'!commandCode	^ ComQuery ! !!GAMysqlCommandQuery methodsFor: 'as yet unclassified' stamp: 'ah 11/25/2009 00:15'!queryString: queryString 	query := queryString! !!GAMysqlCommandQuery methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 5/5/2015 12:03'!readEof	^ GAMysqlEof from: session read! !!GAMysqlCommandQuery methodsFor: 'as yet unclassified' stamp: 'ah 6/11/2011 13:17'!readFields	| respFields field |	respFields := OrderedCollection new.		[self gotEof] whileFalse:[ 		"Read each field and save it"		field := self readOneField.		respFields add: field ].			^ respFields asArray	! !!GAMysqlCommandQuery methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 5/5/2015 12:03'!readOneField	^ GAMysqlField from: session read	! !!GAMysqlCommandQuery methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 5/5/2015 11:58'!readOneRow: fields	| parser |	parser := GAMysqlTextRowDataParser new.	parser driver: driver.	parser columnDescriptors: fields.	^ parser read: session read.	! !!GAMysqlCommandQuery methodsFor: 'as yet unclassified' stamp: 'ah 6/10/2011 16:28'!readResponse	| resp |	resp := self readResult.	resp hasMoreResults ifTrue: [resp nextResult: self readResponse].	^ resp! !!GAMysqlCommandQuery methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/24/2015 16:40'!readResult	| fields fieldsEof rows rowsEof resultSetHdr pkt |	pkt := super readResponse.	pkt isOkayOrError 		ifTrue: [ ^ pkt ]		ifFalse: [ resultSetHdr := self readRsHeader ].	fields := self readFields.	fieldsEof := self readEof.	rows := self readRowData: fields.	rowsEof := self readEof.	^ GAMysqlResultSet new		header: resultSetHdr;		fields: fields;		fieldsEof: fieldsEof;		rows: rows;		rowsEof: rowsEof;		yourself! !!GAMysqlCommandQuery methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/27/2015 15:34'!readRowData: fields 	| respRows row |	respRows := OrderedCollection new.	[self gotEof] whileFalse: [ 		"Read each field and save it"		row := self readOneRow: fields.		respRows add: row].			^ respRows asArray	! !!GAMysqlCommandQuery methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 5/5/2015 12:09'!readRsHeader	^ GAMysqlResultSetHeader from: session read	! !!GAMysqlCommandQuit methodsFor: 'as yet unclassified' stamp: 'ah 11/25/2009 01:30'!commandArg	^ nil! !!GAMysqlCommandQuit methodsFor: 'as yet unclassified' stamp: 'ah 11/25/2009 01:29'!commandCode	^ ComQuit ! !!GAMysqlCommandQuit methodsFor: 'as yet unclassified' stamp: 'ah 6/4/2011 18:52'!readResponse	^ nil		! !!GAMysqlCommandResetStatement methodsFor: 'as yet unclassified' stamp: 'ah 4/30/2011 23:05'!commandArg	ByteArray streamContents: [:strm |		strm 		nextPut: (statementId digitAt: 1);		nextPut: (statementId digitAt: 2);		nextPut: (statementId digitAt: 3);		nextPut: (statementId digitAt: 4).				^ strm contents]! !!GAMysqlCommandResetStatement methodsFor: 'as yet unclassified' stamp: 'ah 4/30/2011 23:02'!commandCode	^ ComStmtReset 	! !!GAMysqlCommandResetStatement methodsFor: 'as yet unclassified' stamp: 'ah 6/4/2011 18:54'!readResponse	| pkt |	pkt := super readResponse.	pkt isOkayOrError 		ifTrue: [^ pkt] 		ifFalse: [self error: 'Unrecognized response for command']		! !!GAMysqlCommandResetStatement methodsFor: 'as yet unclassified' stamp: 'ah 4/30/2011 23:14'!statementId: idValue "4 byte integer"	statementId := idValue		! !!GAMysqlCommandSendLongData methodsFor: 'as yet unclassified' stamp: 'ah 8/27/2011 19:28'!commandArg	ByteArray streamContents: [:strm |		strm 			nextPut: (statementId digitAt: 1);			nextPut: (statementId digitAt: 2);			nextPut: (statementId digitAt: 3);			nextPut: (statementId digitAt: 4).		strm 			nextPut: (paramNum digitAt: 1);			nextPut: (paramNum digitAt: 2).		strm nextPutAll: dataBytes.		^ strm contents]	! !!GAMysqlCommandSendLongData methodsFor: 'as yet unclassified' stamp: 'ah 4/30/2011 23:34'!commandCode	^ ComStmtSendLongData 	! !!GAMysqlCommandSendLongData methodsFor: 'as yet unclassified' stamp: 'ah 5/30/2011 23:38'!dataBytes: aByteArray	dataBytes := aByteArray 	! !!GAMysqlCommandSendLongData methodsFor: 'as yet unclassified' stamp: 'ah 4/30/2011 23:42'!paramNum: aNumber	paramNum := aNumber	! !!GAMysqlCommandSendLongData methodsFor: 'as yet unclassified' stamp: 'ah 8/28/2011 19:32'!readResponse	"This command does not hae any response from server"	^ nil	! !!GAMysqlCommandSendLongData methodsFor: 'as yet unclassified' stamp: 'ah 4/30/2011 23:41'!statementId: anId	statementId := anId	! !!GAMysqlConnectionData methodsFor: 'accessing' stamp: 'ah 11/24/2009 23:52'!database: dbName	database := dbName! !!GAMysqlConnectionData methodsFor: 'accessing' stamp: 'ah 8/20/2011 13:59'!db	^ database! !!GAMysqlConnectionData methodsFor: 'convenience' stamp: 'ah 8/20/2011 14:00'!db: dbName	database := dbName! !!GAMysqlConnectionData methodsFor: 'accessing' stamp: 'ah 11/24/2009 23:53'!host	^ host! !!GAMysqlConnectionData methodsFor: 'accessing' stamp: 'ah 11/24/2009 23:49'!host: server	host := server! !!GAMysqlConnectionData methodsFor: 'accessing' stamp: 'ah 11/27/2009 23:09'!options: driverOptions	options := driverOptions! !!GAMysqlConnectionData methodsFor: 'accessing' stamp: 'ah 11/24/2009 23:53'!password	^ password! !!GAMysqlConnectionData methodsFor: 'accessing' stamp: 'ah 11/24/2009 23:52'!password: userPassword	password := userPassword! !!GAMysqlConnectionData methodsFor: 'accessing' stamp: 'ah 11/24/2009 23:53'!port	^ port! !!GAMysqlConnectionData methodsFor: 'accessing' stamp: 'ah 11/24/2009 23:50'!port: serverPort	port := serverPort! !!GAMysqlConnectionData methodsFor: 'accessing' stamp: 'ah 11/24/2009 23:53'!user	^ user! !!GAMysqlConnectionData methodsFor: 'accessing' stamp: 'ah 11/24/2009 23:51'!user: userName	user := userName! !!GAMysqlHelper class methodsFor: 'as yet unclassified' stamp: 'ah 7/12/2011 23:50'!bytesFromHexString: hexString	| strm bytes aByte ii high low hexAlphabet |	(hexString size \\ 2 = 0) ifFalse: [self error: 'Not proper hex encoding'].	strm := ReadStream on: hexString.		bytes := ByteArray new: (hexString size // 2).	hexAlphabet := '0123456789ABCDEF'.	ii := 1.	[strm atEnd] whileFalse: [		high := (hexAlphabet indexOf: (strm next asUppercase)) - 1.		low := (hexAlphabet indexOf: (strm next asUppercase)) - 1.		aByte :=   high * 16 + low.		bytes at: ii put: aByte.		ii := ii + 1].	^ bytes	! !!GAMysqlHelper class methodsFor: 'as yet unclassified' stamp: 'ah 6/16/2009 00:48'!bytesFromSha1Hash: num 	| index bytes |	index := 0.	bytes := ByteArray new: (num digitLength max: 20).	"gurantee 20 bytes; required for authentication"			(20 - num digitLength) to: 1 by: -1 do: [ :i | bytes at: (index := index + 1) put: (0 digitAt: 1) ].	"filler 0 from msbyte"	num digitLength to: 1 by: -1 do: [ :i | bytes at: (index := index + 1) put: (num digitAt: i) ].	^ bytes! !!GAMysqlHelper class methodsFor: 'as yet unclassified' stamp: 'ah 6/1/2011 10:52'!decodeLcbFrom: byteStream 	"parse length coded binary"	| first |	first := byteStream next.	(first 		between: 0		and: 250) ifTrue: [ ^ first ].	first = 251 ifTrue: [ ^ -1 ].	"column value is NULL; applicable for row data packet only"	first = 252 ifTrue: [ ^ byteStream next + (byteStream next bitShift: 8) ].	"value of following 2 bytes"	first = 253 ifTrue: 		[ ^ byteStream next + (byteStream next bitShift: 8) + (byteStream next bitShift: 16) ].	"value of following 3 bytes"	first = 254 ifTrue: 		[ ^ byteStream next + (byteStream next bitShift: 8 * 1) + (byteStream next bitShift: 8 * 2) + (byteStream next bitShift: 8 * 3) + (byteStream next bitShift: 8 * 4) + (byteStream next bitShift: 8 * 5) + (byteStream next bitShift: 8 * 6) + (byteStream next bitShift: 8 * 7) ].	"value of following 8 bytes"	^ nil! !!GAMysqlHelper class methodsFor: 'as yet unclassified' stamp: 'ah 6/1/2011 10:53'!decodeLcsFrom: aStream 	"parses length coded string"	| len |	len := self decodeLcbFrom: aStream.	len = -1 ifTrue: [^ 'NULL'].	^ aStream next: len.	! !!GAMysqlHelper class methodsFor: 'as yet unclassified' stamp: 'ah 9/18/2011 00:19'!encodeLcb: value on: aStream 	value < -1 ifTrue: 		[ self error: 'Can not encode value' , value asString , ' to length coded binary' ].	value = -1 ifTrue: 		[ "represents null column value"		^ aStream nextPut: 251 ].	(value 		between: 0		and: 250) ifTrue: [ ^ aStream nextPut: (value digitAt: 1) ].	value <= 65535 ifTrue: 		[ ^ aStream			nextPut: 252;			nextPut: (value digitAt: 1);			nextPut: (value digitAt: 2) ].	value <= 16777215 ifTrue: 		[ ^ aStream			nextPut: 253;			nextPut: (value digitAt: 1);			nextPut: (value digitAt: 2);			nextPut: (value digitAt: 3)			yourself].	^ aStream		nextPut: 254;		nextPut: (value digitAt: 1);		nextPut: (value digitAt: 2);		nextPut: (value digitAt: 3);		nextPut: (value digitAt: 4);		nextPut: (value digitAt: 5);		nextPut: (value digitAt: 6);		nextPut: (value digitAt: 7);		nextPut: (value digitAt: 8);		yourself! !!GAMysqlHelper class methodsFor: 'as yet unclassified' stamp: 'ah 6/1/2011 10:53'!encodeLcs: bytes on: aStream	| len |	len := bytes size .	self encodeLcb: len on: aStream .	aStream nextPutAll: bytes .	! !!GAMysqlHelper class methodsFor: 'private' stamp: 'ah 10/1/2011 19:22'!hash: message	"Computes a hash form byte strings,	Returns an array of large positive integers.	Used in pre-4.1 authentication scheme"	"118 {119   register ulong nr=1345345333L, add=7, nr2=0x12345671L;120   ulong tmp;121   const char *password_end= password + password_len;122   for (; password < password_end; password++)123   {124     if (*password == ' ' || *password == '\t')125       continue;                                 /* skip space in password */126     tmp= (ulong) (uchar) *password;127     nr^= (((nr & 63)+add)*tmp)+ (nr << 8);128     nr2+=(nr2 << 8) ^ nr;129     add+=tmp;130   }131   result[0]=nr & (((ulong) 1L << 31) -1L); /* Don't use sign bit (str2int) */;132   result[1]=nr2 & (((ulong) 1L << 31) -1L);133 }"	| nr add nr2 tmp |	nr := 1345345333. add := 7. nr2 := 16r12345671.	message do: [:each |		((each = Character space) or: [each = Character tab]) ifTrue: [] ifFalse: [			tmp := each.			nr := nr bitXor: ((((nr bitAnd: 63) + add) * tmp asInteger) + (nr bitShift: 8)).			nr2 := nr2 + ((nr2 bitShift: 8) bitXor: nr).			add := add + tmp asInteger.		]].		^Array with:(nr bitAnd: ((1 bitShift: 31) - 1)) with: (nr2 bitAnd: ((1 bitShift: 31) - 1))! !!GAMysqlHelper class methodsFor: 'as yet unclassified' stamp: 'ah 9/11/2011 12:31'!hexStringFromBytes: aByteArray	^ aByteArray inject: '' into: [:result :each | 		result, (each printPaddedWith: $0 to: 2 base: 16)].! !!GAMysqlHelper class methodsFor: 'private' stamp: 'ah 10/1/2011 18:57'!myRandom	seedOne := (seedOne * 3 + seedTwo) \\ maxValue.	seedTwo := (seedOne + seedTwo + 33) \\ maxValue.		^ (seedOne / maxValue) asFloat	! !!GAMysqlHelper class methodsFor: 'private' stamp: 'ah 4/17/2009 23:18'!randomInitWith: seedValue1 and: seedValue2	maxValue := 16r3FFFFFFF.	seedOne := seedValue1 \\ maxValue.	seedTwo := seedValue2 \\ maxValue.! !!GAMysqlHelper class methodsFor: 'public' stamp: 'ah 10/1/2011 23:19'!scramble323: message with: password 	"Scamble the bytestring message with password."	"Return a srambled byte string."	"Used in pre-4.1 authentication scheme"	| hashPass hashMessage outMessage extra byteValue rnd msgUsed |	password isEmptyOrNil ifTrue: [ ^ '' ].	msgUsed := message first: (self scramble323MessageLimit min: message size).	hashPass := self hash: password.	hashMessage := self hash: msgUsed. "323 size limit"			self 		randomInitWith: ((hashPass first) bitXor: (hashMessage first))		and: ((hashPass at: 2) bitXor: (hashMessage at: 2)).	outMessage := ByteArray new: msgUsed size.	1 to: outMessage size do: [ :indx | 		rnd := self myRandom.		byteValue := ((rnd * 31) floor + 64) bitAnd: 255.		outMessage at: indx 	put: byteValue].	rnd := self myRandom.	extra := (rnd * 31) floor bitAnd: 255.	1 to: outMessage size		do: 			[ :indx | 			byteValue := (outMessage at: indx) asInteger bitXor: extra.			outMessage at: indx 	put: byteValue ].	^ outMessage	! !!GAMysqlHelper class methodsFor: 'as yet unclassified' stamp: 'ah 10/1/2011 21:15'!scramble323MessageLimit	^ 8	! !!GAMysqlHelper class methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 5/8/2014 20:09'!secureScramble: seed with: password 	| sha1 hashStage1 hashStage2 hash3 reply |	sha1 := SHA1 new.	hashStage1 := (sha1 hashMessage: password) asInteger.	hashStage2 := (sha1 hashMessage: (self bytesFromSha1Hash: hashStage1)) asInteger.	hash3 := (sha1 hashMessage: seed asByteArray , (self bytesFromSha1Hash: hashStage2)) asInteger.	reply := self bytesFromSha1Hash: (hashStage1 bitXor: hash3).	^ reply! !!GAMysqlNetPacket class methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 1/23/2015 12:03'!initialize	"self initialize"	MaxPacketLength := 16rFFFFFF.! !!GAMysqlNetPacket class methodsFor: 'as yet unclassified' stamp: 'ah 2/25/2010 00:26'!maxLength	^ MaxPacketLength! !!GAMysqlNetPacket methodsFor: 'accessing' stamp: 'ah 1/24/2010 15:29'!data	^ data! !!GAMysqlNetPacket methodsFor: 'accessing' stamp: 'ah 2/9/2010 22:08'!data: buffer "should be ByteArray"	data := buffer! !!GAMysqlNetPacket methodsFor: 'testing' stamp: 'ah 1/24/2010 22:45'!isOfMaxLength	^ length = MaxPacketLength! !!GAMysqlNetPacket methodsFor: 'accessing' stamp: 'ah 1/24/2010 15:28'!length	^ length ! !!GAMysqlNetPacket methodsFor: 'accessing' stamp: 'ah 1/24/2010 23:29'!length: size	length := size! !!GAMysqlNetPacket methodsFor: 'accessing' stamp: 'ah 1/24/2010 23:09'!maxLength	^ MaxPacketLength! !!GAMysqlNetPacket methodsFor: 'accessing' stamp: 'ah 1/24/2010 15:28'!number	^ number! !!GAMysqlNetPacket methodsFor: 'accessing' stamp: 'ah 1/24/2010 23:30'!number: num	number := num! !!GAMysqlNetPacket methodsFor: 'reading' stamp: 'ah 7/6/2011 22:18'!readFrom: aStream	length := aStream next + (aStream next << 8) + (aStream next << 16).	number := aStream next.	data := aStream next: length.! !!GAMysqlNetPacket methodsFor: 'writing' stamp: 'ah 7/6/2011 22:21'!writeTo: aStream	length = data size ifFalse: [self error: 'Mismatch between packet length and data size'].	aStream 		nextPut: (length digitAt: 1);		nextPut: (length digitAt: 2);		nextPut: (length digitAt: 3).			aStream nextPut: (number digitAt: 1)	.		(aStream respondsTo: #nextPutAllFlush:)  "socket streams respond to this"		ifTrue: [aStream nextPutAllFlush: data] "this one avoids some data copy"		ifFalse: [aStream nextPutAll: data; flush]! !!GAMysqlNetSession methodsFor: 'testing' stamp: 'ah 3/3/2010 23:03'!connected	^ theStream ifNil: [false] ifNotNil: [theStream isConnected] ! !!GAMysqlNetSession methodsFor: 'accessing' stamp: 'ah 7/16/2009 01:06'!disconnect	theStream isConnected ifTrue: [theStream close] .! !!GAMysqlNetSession methodsFor: 'sequence numbering' stamp: 'ah 1/24/2010 16:43'!getSequence	^ nextPacketNumber ! !!GAMysqlNetSession methodsFor: 'initialize-release' stamp: 'ah 1/24/2010 23:48'!initialize	self resetSequence.! !!GAMysqlNetSession methodsFor: 'reading' stamp: 'ah 7/6/2011 22:04'!peek	"Look ahead; don't remove the packet until next read"	peekData ifNil: [peekData := self readPacketData].	^ peekData! !!GAMysqlNetSession methodsFor: 'reading' stamp: 'ah 7/6/2011 22:05'!read	| data |	"Return packet from look ahead buffer if any. Clear look ahead buffer"	peekData ifNotNil: [data := peekData. peekData := nil. ^ data].	^ self readPacketData	! !!GAMysqlNetSession methodsFor: 'reading' stamp: 'GuillermoPolito 5/5/2015 12:10'!readNetPacket	| pkt |	pkt := GAMysqlNetPacket new.	pkt readFrom: theStream.	self validatePacket: pkt.	^ pkt! !!GAMysqlNetSession methodsFor: 'reading' stamp: 'ah 9/11/2011 12:18'!readPacketData	"Read all packets until there is no more packets of data."	| dataPackets pkt totalSize buffer ii |	dataPackets := OrderedCollection new.		[ pkt := self readNetPacket.	dataPackets add: pkt ] doWhileTrue: [ pkt isOfMaxLength	"indicates more packets to follow" ].	"Gather data from all packets and return. Avoid another copy where possible"	dataPackets size = 1 ifTrue: [ ^ dataPackets first data ].	"only one pcaket"	(dataPackets size = 2 and: [ dataPackets last length = 0 ]) 		ifTrue: [ ^ dataPackets first data ].	"second packet is empty"	"Multiple packets; put the data together before returning"	totalSize := dataPackets inject: 0 into: [:total :each | total + each length].	buffer := ByteArray new: totalSize.	ii := 1.	^ dataPackets 		inject: buffer		into: [ :result :packet | 			result replaceFrom: ii to: (ii + packet length - 1) with: packet data startingAt: 1.			ii := ii + packet length.			result]! !!GAMysqlNetSession methodsFor: 'sequence numbering' stamp: 'ah 6/11/2009 00:15'!resetSequence	nextPacketNumber := 0! !!GAMysqlNetSession methodsFor: 'accessing' stamp: 'ah 5/4/2013 01:05'!stream: aStream	theStream := aStream	! !!GAMysqlNetSession methodsFor: 'accessing' stamp: 'GuillermoPolito 5/5/2015 12:11'!toHost: host andPort: port 	| aStream |	self resetSequence.	[aStream := SocketStream 		openConnectionToHostNamed: host		port: port.	"Turn off Nagle algorithm, else response time to short packets would suffer. Thanks to	Goran Krampe for studying the issue in Ubuntu linux and figure out the details. Ref:	http://developers.slashdot.org/comments.pl?sid=174457&threshold=1&commentsort=0&mode=thread&cid=14515105 for comments from John Nagle himself."	aStream socket setOption: 'TCP_NODELAY' value: true.	aStream binary. 	self stream: aStream] 		on: NameLookupFailure 		do: [:ex | GAMysqlNameLookupFailure signal: ex messageText] ! !!GAMysqlNetSession methodsFor: 'sequence numbering' stamp: 'ah 6/11/2009 00:15'!updateSequence	nextPacketNumber := (nextPacketNumber + 1) bitAnd: 255! !!GAMysqlNetSession methodsFor: 'reading' stamp: 'ah 8/28/2011 13:44'!validatePacket: pkt	"Validate a network packet unit. Currently we validate the sequence number."	"Update sequence if validation passes"	(self validateSequence: pkt number)		ifTrue: [self updateSequence]		ifFalse: [^ self error: 'Packet sequence validation error']	! !!GAMysqlNetSession methodsFor: 'sequence numbering' stamp: 'ah 6/11/2009 00:15'!validateSequence: pktNumber 	^ pktNumber = nextPacketNumber! !!GAMysqlNetSession methodsFor: 'writing' stamp: 'ah 1/24/2010 23:27'!write: data 	self writePacketData: data! !!GAMysqlNetSession methodsFor: 'writing' stamp: 'ah 7/6/2011 21:59'!writeNetPacket: pkt	"Write a network packet unit to the underlying stream".	pkt writeTo: theStream	! !!GAMysqlNetSession methodsFor: 'writing' stamp: 'GuillermoPolito 5/5/2015 12:10'!writePacketData: data 	| pkt nextPktStart dataLen |		nextPktStart := 1.	dataLen := data size.	[	pkt := GAMysqlNetPacket new.		pkt length: (dataLen min: pkt maxLength);			number: self getSequence;			data: (data copyFrom: nextPktStart  to: (nextPktStart + pkt length - 1)).					self updateSequence.		dataLen := dataLen - pkt length.		nextPktStart := nextPktStart + pkt length.				self writeNetPacket: pkt	] doWhileTrue: [ pkt isOfMaxLength ]! !!GAMysql323Scramble methodsFor: 'as yet unclassified' stamp: 'ah 9/29/2011 22:47'!password: pwd	password := pwd	! !!GAMysql323Scramble methodsFor: 'as yet unclassified' stamp: 'ah 9/29/2011 22:29'!scrambleBuff: scramble	scrambleBuff := scramble 	! !!GAMysql323Scramble methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 5/5/2015 12:09'!write	| scrmbl buffStream |	buffStream := WriteStream on: (ByteArray new: 256).	scrmbl := password isEmptyOrNil 		ifTrue: [ '' asByteArray ]		ifFalse: 	[ 			GAMysqlHelper 				scramble323: scrambleBuff				with: password ].	"Server expects just the scramble, null terminated and nothing else"	buffStream nextPutAll: scrmbl.	buffStream nextPut: 0.	^ buffStream contents 	! !!GAMysqlClientAuth methodsFor: 'as yet unclassified' stamp: 'ah 6/13/2009 11:12'!charset: csNum	charset := csNum! !!GAMysqlClientAuth methodsFor: 'as yet unclassified' stamp: 'ah 6/13/2009 10:40'!database: db	database := db! !!GAMysqlClientAuth methodsFor: 'as yet unclassified' stamp: 'ah 3/26/2010 14:31'!initialize	clientCaps := CapLongFlag + CapTransactions + CapLongPassword + CapConnectWithDb.	clientCaps := clientCaps + CapProtocol41 + CapSecureConnection.! !!GAMysqlClientAuth methodsFor: 'as yet unclassified' stamp: 'ah 6/13/2009 10:39'!password: pwd	password := pwd.! !!GAMysqlClientAuth methodsFor: 'as yet unclassified' stamp: 'ah 5/16/2009 17:40'!scrambleBuff: buffer	scrambleBuff := buffer.! !!GAMysqlClientAuth methodsFor: 'as yet unclassified' stamp: 'ah 6/14/2009 23:53'!scrambleBuffMore: more	scrambleBuffMore := more! !!GAMysqlClientAuth methodsFor: 'as yet unclassified' stamp: 'ah 6/14/2009 23:23'!serverCaps: caps 	serverCaps := caps! !!GAMysqlClientAuth methodsFor: 'as yet unclassified' stamp: 'ah 6/13/2009 10:39'!user: userName	user := userName! !!GAMysqlClientAuth methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 5/5/2015 12:09'!write	| flags scrmbl buffStream maxNetPacketLength |	buffStream := WriteStream on: (ByteArray new: 1024).	flags := serverCaps bitAnd: clientCaps.	flags := flags bitOr: CapMultiStatements + CapMultiResults.	buffStream		nextPut: (flags digitAt: 1);		nextPut: (flags digitAt: 2);		nextPut: (flags digitAt: 3);		nextPut: (flags digitAt: 4).	maxNetPacketLength := self class maxNetPacketLength.	buffStream		nextPut: (maxNetPacketLength digitAt: 1);		nextPut: (maxNetPacketLength digitAt: 2);		nextPut: (maxNetPacketLength digitAt: 3);		nextPut: (maxNetPacketLength digitAt: 4).	buffStream nextPut: (charset digitAt: 1).	buffStream nextPutAll: (ByteArray 			new: 23			withAll: 0).	"filler"	buffStream nextPutAll: user asByteArray.	buffStream nextPut: 0.	"null terminated"	scrmbl := password isEmptyOrNil 		ifTrue: [ '' asByteArray ]		ifFalse: 			[ GAMysqlHelper 				secureScramble: scrambleBuff , scrambleBuffMore				with: password ].	self 		encodeLcs: scrmbl		on: buffStream.		((flags bitAnd: CapConnectWithDb) = CapConnectWithDb) ifTrue: [		database isEmptyOrNil not ifTrue: [			buffStream nextPutAll: database asByteArray].		buffStream nextPut: 0	"null terminated" ].		^ buffStream contents! !!GAMysqlCommand methodsFor: 'as yet unclassified' stamp: 'ah 6/6/2009 18:52'!command: cmd arg: text	command := cmd.	arg := text.	! !!GAMysqlCommand methodsFor: 'as yet unclassified' stamp: 'ah 3/18/2010 22:45'!write	| buffStream |	buffStream := WriteStream on: ByteArray new.	buffStream nextPut: command.	arg isEmptyOrNil ifFalse: [ buffStream nextPutAll: arg asByteArray ].	^ buffStream contents! !!GAMysqlEof methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 5/5/2015 12:10'!hasLastRowSent	^ (serverStatus bitAnd: GAMysqlServerStatusConstants statusLastRowSent) ~= 0	! !!GAMysqlEof methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 5/5/2015 12:10'!hasMoreResults	^ (serverStatus bitAnd: GAMysqlServerStatusConstants moreResultsExist) ~= 0	! !!GAMysqlEof methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 5/5/2015 12:10'!hasOpenCursor	^ (serverStatus bitAnd: GAMysqlServerStatusConstants statusCursorExists) ~= 0	! !!GAMysqlEof methodsFor: 'as yet unclassified' stamp: 'ah 2/8/2010 22:37'!isEof	^ true! !!GAMysqlEof methodsFor: 'as yet unclassified' stamp: 'ah 6/4/2011 17:14'!parse	fieldCount := inStream next.	warningCount := inStream next + (inStream next bitShift: 8).	serverStatus := inStream next + (inStream next bitShift: 8).! !!GAMysqlEof methodsFor: 'as yet unclassified' stamp: 'ah 3/26/2010 15:45'!serverStatus	^ serverStatus ! !!GAMysqlEof methodsFor: 'as yet unclassified' stamp: 'ah 7/26/2009 15:38'!warningCount	^ warningCount ! !!GAMysqlField class methodsFor: 'as yet unclassified' stamp: 'ah 12/25/2010 16:01'!initBitMasksForFlags	NotNullFlag := 16r0001.	PrimaryKeyFlag := 16r0002.	UniqueKeyFlag := 16r0004.	MultiKeyFlag := 16r0008.	BlobFlag := 16r0010.	UnsignedFlag := 16r0020.	ZeroFillFlag := 16r0040.	BinaryFlag := 16r0080.	EnumFlag := 16r0100.	AutoIncrFlag := 16r0200.	TimestampFlag := 16r0400.	SetFlag := 16r0800.		! !!GAMysqlField class methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 1/23/2015 12:03'!initialize	"self initialize"	self initBitMasksForFlags.	! !!GAMysqlField methodsFor: 'as yet unclassified' stamp: 'ah 9/20/2011 23:19'!db	^ db	! !!GAMysqlField methodsFor: 'as yet unclassified' stamp: 'ah 12/9/2010 00:28'!decimals	^ decimals ! !!GAMysqlField methodsFor: 'as yet unclassified' stamp: 'ah 9/21/2011 21:31'!isAutoIncrement	^ (flags bitAnd: AutoIncrFlag) = AutoIncrFlag   	! !!GAMysqlField methodsFor: 'as yet unclassified' stamp: 'ah 9/21/2011 22:47'!isNullable	^ (flags bitAnd: NotNullFlag) ~= NotNullFlag  	! !!GAMysqlField methodsFor: 'as yet unclassified' stamp: 'ah 9/21/2011 21:30'!isPrimaryKey	^ (flags bitAnd: PrimaryKeyFlag) = PrimaryKeyFlag  	! !!GAMysqlField methodsFor: 'as yet unclassified' stamp: 'ah 12/25/2010 16:02'!isUnsigned	^ (flags bitAnd: UnsignedFlag) = UnsignedFlag 	! !!GAMysqlField methodsFor: 'as yet unclassified' stamp: 'ah 12/25/2010 15:42'!length	^ length 	! !!GAMysqlField methodsFor: 'as yet unclassified' stamp: 'ah 11/28/2010 15:54'!name	^ name	! !!GAMysqlField methodsFor: 'as yet unclassified' stamp: 'ah 6/4/2011 17:00'!parse	catalog := (self decodeLcsFrom: inStream) asString.	db := (self decodeLcsFrom: inStream) asString.	table := (self decodeLcsFrom: inStream) asString.	orgTable := (self decodeLcsFrom: inStream) asString.	name := (self decodeLcsFrom: inStream) asString.	orgName := (self decodeLcsFrom: inStream) asString.	inStream next. "filler"	charSet := inStream next + (inStream next bitShift: 8).	length := inStream next + (inStream next bitShift: 8) + 		(inStream next bitShift: 16) + (inStream next bitShift: 24).	type := inStream next.	flags := inStream next + (inStream next bitShift: 8).	decimals := inStream next.	inStream next; next. "2 filler"	"The field default only appears for table definitions, not for normal resultsets"	inStream atEnd ifFalse: [default := self decodeLcbFrom: inStream].	! !!GAMysqlField methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/24/2015 14:14'!printOn: aStream	aStream		nextPutAll: self class name;		nextPut: $(;		nextPutAll: self name;		nextPut: $).! !!GAMysqlField methodsFor: 'as yet unclassified' stamp: 'ah 9/21/2011 08:57'!table	^ table	! !!GAMysqlField methodsFor: 'as yet unclassified' stamp: 'ah 11/28/2010 15:54'!type	^ type	! !!GAMysqlHandshake methodsFor: 'as yet unclassified' stamp: 'ah 6/4/2011 17:02'!parse 	protocolVer := inStream next.	serverVer := (inStream upTo: 0) asString.	threadId := inStream next + (inStream next bitShift: 8) + 		(inStream next bitShift: 16) + (inStream next bitShift: 24).	scrambleBuff := inStream next: 8.	inStream skip: 1.	"always 0"	serverCap := inStream next + (inStream next bitShift: 8).	serverLang := inStream next.	serverStatus := inStream next + (inStream next bitShift: 8).	inStream skip: 13.	"filler"	self supportsProtocol41 ifFalse: [ ^ self ].	scrambleBuffMore := inStream next: 12.	inStream skip: 1	"always 0"! !!GAMysqlHandshake methodsFor: 'accessing' stamp: 'ah 6/13/2009 21:43'!scrambleBuff		^ scrambleBuff		"self supports41 		ifTrue: [^ scrambleBuff, scrambleBuffMore]		ifFalse: [^ scrambleBuff]."! !!GAMysqlHandshake methodsFor: 'as yet unclassified' stamp: 'ah 6/14/2009 23:54'!scrambleBuffMore	^scrambleBuffMore ! !!GAMysqlHandshake methodsFor: 'accessing' stamp: 'ah 6/13/2009 10:43'!serverCaps	^ serverCap! !!GAMysqlHandshake methodsFor: 'accessing' stamp: 'ah 4/20/2009 23:28'!serverLang	^ serverLang! !!GAMysqlHandshake methodsFor: 'accessing' stamp: 'ah 4/20/2009 23:28'!serverStatus	^ serverStatus! !!GAMysqlHandshake methodsFor: 'accessing' stamp: 'ah 4/20/2009 23:28'!serverVer	^ serverVer! !!GAMysqlHandshake methodsFor: 'as yet unclassified' stamp: 'ah 6/14/2009 22:36'!supportsProtocol41	^ (serverCap bitAnd: CapProtocol41) = CapProtocol41! !!GAMysqlPacket class methodsFor: 'as yet unclassified' stamp: 'ah 6/10/2011 00:19'!from: data	^ self new 		read: data	! !!GAMysqlPacket class methodsFor: 'as yet unclassified' stamp: 'ah 3/4/2010 22:59'!initCapabilititesFlags	CapLongPassword := 1.	CapFoundRows := 1 bitShift: 1.	CapLongFlag := 1 bitShift: 2.	CapConnectWithDb := 1 bitShift: 3.	CapNoSchema := 1 bitShift: 4.	CapCompress := 1 bitShift: 5.	CapOdbc := 1 bitShift: 6.	CapLocalFiles := 1 bitShift: 7.	CapIgnoreSpace := 1 bitShift: 8.	CapProtocol41 := 1 bitShift: 9.	CapInteractive := 1 bitShift: 10.	CapSsl := 1 bitShift: 11.	CapIgnoreSigpipe := 1 bitShift: 12.	CapTransactions := 1 bitShift: 13.	CapReserved := 1 bitShift: 14.	CapSecureConnection := 1 bitShift: 15.	CapMultiStatements := 1 bitShift: 16.	CapMultiResults := 1 bitShift: 17.! !!GAMysqlPacket class methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 1/23/2015 12:03'!initialize	"	self initialize	"	self initCapabilititesFlags.! !!GAMysqlPacket class methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 5/5/2015 11:29'!maxNetPacketLength	^ GAMysqlNetPacket maxLength! !!GAMysqlPacket methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 5/5/2015 12:09'!decodeLcbFrom: byteStream 	^ GAMysqlHelper decodeLcbFrom: byteStream 	! !!GAMysqlPacket methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 5/5/2015 12:09'!decodeLcsFrom: aStream 	^ GAMysqlHelper decodeLcsFrom: aStream 	! !!GAMysqlPacket methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 5/5/2015 12:09'!encodeLcb: value on: aStream 	^ GAMysqlHelper encodeLcb: value on: aStream 	! !!GAMysqlPacket methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 5/5/2015 12:09'!encodeLcs: bytes on: aStream	GAMysqlHelper encodeLcs: bytes on: aStream	! !!GAMysqlPacket methodsFor: 'as yet unclassified' stamp: 'ah 6/11/2011 17:08'!isEof	^ (discriminator = 16rFE) and: [inStream size < 9]! !!GAMysqlPacket methodsFor: 'as yet unclassified' stamp: 'ah 6/11/2011 17:09'!isError	^ discriminator = 16rFF! !!GAMysqlPacket methodsFor: 'as yet unclassified' stamp: 'ah 6/11/2011 17:09'!isOkay	^ discriminator = 16r00! !!GAMysqlPacket methodsFor: 'as yet unclassified' stamp: 'ah 2/8/2010 00:48'!isOkayOrError	^ self isOkay or: [self isError]! !!GAMysqlPacket methodsFor: 'as yet unclassified' stamp: 'ah 11/25/2010 17:33'!isPrepareResponse	^ false	! !!GAMysqlPacket methodsFor: 'as yet unclassified' stamp: 'ah 2/27/2010 11:08'!isResultSet	^ false! !!GAMysqlPacket methodsFor: 'as yet unclassified' stamp: 'ah 6/30/2011 22:01'!parse	"Default implementation; required for reading a generic (yet unknown) type of packet"	"No parsing here; subclasses implement packet specific parsing"	! !!GAMysqlPacket methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 5/5/2015 11:55'!read: buffer	discriminator := buffer first.	inStream := ReadStream on: buffer.	^ self parse! !!GAMysqlPacket methodsFor: 'as yet unclassified' stamp: 'ah 8/2/2009 16:07'!write	self subclassResponsibility ! !!GAMysqlPrepareOkay methodsFor: 'as yet unclassified' stamp: 'ah 11/25/2010 15:16'!isOkay	^ true	! !!GAMysqlPrepareOkay methodsFor: 'as yet unclassified' stamp: 'ah 4/23/2011 23:08'!numColumns	^ numColumns! !!GAMysqlPrepareOkay methodsFor: 'as yet unclassified' stamp: 'ah 4/23/2011 23:09'!numParams	^ numParams! !!GAMysqlPrepareOkay methodsFor: 'as yet unclassified' stamp: 'ah 6/4/2011 17:06'!parse 	inStream next.	"always 0, marker for oaky pakcet"	stmtId := inStream next + (inStream next bitShift: 8) + 			(inStream next bitShift: 16) + (inStream next bitShift: 24).	numColumns := inStream next + (inStream next bitShift: 8).	numParams := inStream next + (inStream next bitShift: 8).	inStream next.	"filler, always 0"	warningCount := inStream next + (inStream next bitShift: 8)	! !!GAMysqlPrepareOkay methodsFor: 'as yet unclassified' stamp: 'ah 4/23/2011 23:10'!stmtHandlerId	^ stmtId! !!GAMysqlPrepareOkay methodsFor: 'as yet unclassified' stamp: 'ah 11/25/2010 15:31'!warningCount	^ warningCount	! !!GAMysqlError methodsFor: 'as yet unclassified' stamp: 'ah 7/26/2009 15:37'!errNo	^ errNo ! !!GAMysqlError methodsFor: 'as yet unclassified' stamp: 'ah 2/7/2010 23:49'!isError	^ true! !!GAMysqlError methodsFor: 'as yet unclassified' stamp: 'ah 7/26/2009 16:25'!message	^ message ! !!GAMysqlError methodsFor: 'as yet unclassified' stamp: 'ah 6/4/2011 17:13'!parse	fieldCount := inStream next. "always 0xFF"	errNo := inStream next + (inStream next bitShift: 8).		sqlStateMarker := inStream next asCharacter. "always #"	sqlState := (inStream next: 5) asString .	message := inStream upToEnd asString.! !!GAMysqlError methodsFor: 'as yet unclassified' stamp: 'ah 7/26/2009 15:37'!sqlState	^ sqlState ! !!GAMysqlOkay methodsFor: 'as yet unclassified' stamp: 'ah 3/26/2010 18:18'!affectedRows	^ affectedRows ! !!GAMysqlOkay methodsFor: 'accessing' stamp: 'GuillermoPolito 4/20/2015 16:29'!generatedKey		^ insertId! !!GAMysqlOkay methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 5/5/2015 12:10'!hasMoreResults	^ (serverStatus bitAnd: GAMysqlServerStatusConstants moreResultsExist) ~= 0	! !!GAMysqlOkay methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 5/5/2015 12:10'!inTransaction	| autoCommit inTx |	autoCommit := (serverStatus bitAnd: GAMysqlServerStatusConstants statusInTransaction) ~= 0.	inTx := (serverStatus bitAnd: GAMysqlServerStatusConstants statusInTransaction) ~= 0.	^ autoCommit and: inTx	! !!GAMysqlOkay methodsFor: 'as yet unclassified' stamp: 'ah 3/2/2010 23:58'!insertId	^ insertId ! !!GAMysqlOkay methodsFor: 'as yet unclassified' stamp: 'ah 2/7/2010 23:49'!isOkay	^ true! !!GAMysqlOkay methodsFor: 'as yet unclassified' stamp: 'ah 3/13/2010 15:58'!message	^ message ! !!GAMysqlOkay methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 5/5/2015 12:07'!nextResult	^ nextResult ! !!GAMysqlOkay methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 5/5/2015 12:07'!nextResult: aResult	nextResult := aResult 	! !!GAMysqlOkay methodsFor: 'as yet unclassified' stamp: 'ah 6/4/2011 17:15'!parse 	fieldCount := self decodeLcbFrom: inStream . "always 0"	affectedRows := self decodeLcbFrom: inStream .	insertId := self decodeLcbFrom: inStream .	serverStatus := inStream next + (inStream next bitShift: 8) .	warningCount := inStream next + (inStream next bitShift: 8) .	message := (inStream upToEnd) asString.	! !!GAMysqlOkay methodsFor: 'as yet unclassified' stamp: 'ah 3/26/2010 15:13'!serverStatus	^ serverStatus ! !!GAMysqlOkay methodsFor: 'as yet unclassified' stamp: 'ah 7/28/2009 23:46'!warningCount	^ warningCount ! !!GAMysqlPrepareResponse methodsFor: 'as yet unclassified' stamp: 'ah 11/25/2010 17:46'!columnDescriptors	^ columnDescriptors	! !!GAMysqlPrepareResponse methodsFor: 'as yet unclassified' stamp: 'ah 11/25/2010 14:57'!columnDescriptors: fields	columnDescriptors := fields 	! !!GAMysqlPrepareResponse methodsFor: 'as yet unclassified' stamp: 'ah 11/25/2010 00:12'!columnEof: anEof	columnEof := anEof	! !!GAMysqlPrepareResponse methodsFor: 'as yet unclassified' stamp: 'ah 4/30/2011 20:36'!isOkay	^ prepareOkay isOkay 	! !!GAMysqlPrepareResponse methodsFor: 'as yet unclassified' stamp: 'ah 11/25/2010 17:33'!isPrepareResponse	^ true	! !!GAMysqlPrepareResponse methodsFor: 'as yet unclassified' stamp: 'ah 11/25/2010 17:38'!paramDescriptors	^ paramDescriptors	 	! !!GAMysqlPrepareResponse methodsFor: 'as yet unclassified' stamp: 'ah 11/25/2010 14:58'!paramDescriptors: fields	paramDescriptors := fields 	! !!GAMysqlPrepareResponse methodsFor: 'as yet unclassified' stamp: 'ah 11/25/2010 00:10'!paramEof: anEof	paramEof := anEof 	! !!GAMysqlPrepareResponse methodsFor: 'as yet unclassified' stamp: 'ah 11/25/2010 17:35'!prepareOkay	^ prepareOkay	! !!GAMysqlPrepareResponse methodsFor: 'as yet unclassified' stamp: 'ah 11/25/2010 17:00'!prepareOkay: prepOkay	prepareOkay := prepOkay	! !!GAMysqlResult methodsFor: 'as yet unclassified' stamp: 'ah 6/10/2011 16:48'!hasMoreResults	^ false ! !!GAMysqlResultSetHeader methodsFor: 'as yet unclassified' stamp: 'ah 7/25/2009 23:50'!fieldCount	^ fieldCount ! !!GAMysqlResultSetHeader methodsFor: 'as yet unclassified' stamp: 'ah 6/4/2011 19:04'!parse	fieldCount := self decodeLcbFrom: inStream.	"exrta field may appear for some results (like show column)"	inStream atEnd ifFalse: [extra := self decodeLcbFrom: inStream]	! !!GAMysqlBinaryRowDataParser methodsFor: 'testing' stamp: 'ah 6/30/2011 22:09'!isColumnNullAt: index	| byteIndex bitsToShift bitMask |	byteIndex := index + 9 // 8.	bitsToShift := index + 9 \\ 8.	bitMask := 1 << bitsToShift.		^ ((nullBitMap at: byteIndex) bitAnd: bitMask) ~= 0		! !!GAMysqlBinaryRowDataParser methodsFor: 'parsing' stamp: 'GuillermoPolito 5/5/2015 11:49'!parse	| col row |	inStream next.	"header: always 0"	row := GAMysqlRow new.	row columnDescriptors: columnDescriptors.		nullBitMap := inStream next: (columnDescriptors size + 9) // 8.	columnDescriptors doWithIndex: 		[ :colDescr :indx | 		col := (self isColumnNullAt: indx) 			ifTrue: [ nil ]			ifFalse: [ self 					readColumnFrom: inStream					perDescrption: colDescr ].		row			at: indx			put: col ].			^ row! !!GAMysqlBinaryRowDataParser methodsFor: 'parsing' stamp: 'GuillermoPolito 5/5/2015 12:10'!readColumnFrom: aStream perDescrption: columnDescr	| reader value mask |	reader := GAMysqlBinReader default.	value := columnDescr type 		caseOf: {		[GAMysqlTypes typeTINY]->[mask := 16r80. reader tinyIntFrom: aStream].		[GAMysqlTypes typeSHORT]->[mask := 16r8000. reader smallIntFrom: aStream].		[GAMysqlTypes typeINT24]->[mask := 16r80000000. reader mediumIntFrom: aStream].			[GAMysqlTypes typeLONG]->[mask := 16r80000000. reader longIntFrom: aStream].			[GAMysqlTypes typeLONGLONG]->[			mask := 16r8000000000000000. 			reader bigIntFrom: aStream].		[GAMysqlTypes typeFLOAT]->[reader floatFrom: aStream].		[GAMysqlTypes typeDOUBLE]->[reader doubleFrom: aStream].		[GAMysqlTypes typeDECIMAL]->[reader decimalWithScale: columnDescr decimals from: aStream].		[GAMysqlTypes typeNEWDECIMAL]->[reader decimalWithScale: columnDescr decimals from: aStream].			[GAMysqlTypes typeSTRING]->[ (driver encoder decodeBytes: (reader varBlobFrom: aStream)) ].		[GAMysqlTypes typeVARCHAR]->[ (driver encoder decodeBytes: (reader varBlobFrom: aStream)) ].		[GAMysqlTypes typeVARSTRING]->[ (driver encoder decodeBytes: (reader varBlobFrom: aStream)) ].			[GAMysqlTypes typeTIME]->[reader timeFrom: aStream].		[GAMysqlTypes typeDATE]->[reader dateFrom: aStream].		[GAMysqlTypes typeDATETIME]->[reader dateTimeFrom: aStream].		[GAMysqlTypes typeTIMESTAMP]->[reader timeStampFrom: aStream].		[GAMysqlTypes typeYEAR]->[reader yearFrom: aStream].		[GAMysqlTypes typeNEWDATE]->[reader shouldBeImplemented].			[GAMysqlTypes typeTINYBLOB]->[reader varBlobFrom: aStream].		[GAMysqlTypes typeBLOB]->[reader varBlobFrom: aStream].		[GAMysqlTypes typeMEDIUMBLOB]->[reader varBlobFrom: aStream].		[GAMysqlTypes typeLONGBLOB]->[reader varBlobFrom: aStream].				[GAMysqlTypes typeNULL]->[self shouldBeImplemented].			[GAMysqlTypes typeGEOMETRY]->[self shouldBeImplemented].		[GAMysqlTypes typeSET]->[self shouldBeImplemented].		[GAMysqlTypes typeENUM]->[self shouldBeImplemented].		[GAMysqlTypes typeBIT]->[self shouldBeImplemented].		} 		otherwise: [^ self error: 'Unknown mysql type'].			(value isInteger and: [columnDescr isUnsigned not and: [(value bitAnd: mask) ~= 0]]) 	  ifTrue: [		value  := value - (mask << 1) "if msb is set and field is signed, then negative"].	^ value	! !!GAMysqlRowDataParser methodsFor: 'accessing' stamp: 'GuillermoPolito 5/5/2015 11:48'!columnDescriptors: aCollection	columnDescriptors := aCollection! !!GAMysqlRowDataParser methodsFor: 'accessing' stamp: 'GuillermoPolito 4/27/2015 15:31'!driver: aGAMysqlDriver 		driver := aGAMysqlDriver! !!GAMysqlRowDataParser methodsFor: 'parsing' stamp: 'ah 7/18/2011 09:04'!parse	self subclassResponsibility 	! !!GAMysqlTextRowDataParser methodsFor: 'preparing' stamp: 'GuillermoPolito 5/5/2015 11:57'!parse	|indx value row |	row := GAMysqlRow new.	row columnDescriptors: columnDescriptors.	indx := 1.	[inStream atEnd] whileFalse: [		value := (self decodeLcsFrom: inStream) asString.		value := self parseColumnValue: value byDescription: (columnDescriptors at: indx).		row at: indx put: value.		indx := indx + 1].	^ row! !!GAMysqlTextRowDataParser methodsFor: 'parsing' stamp: 'GuillermoPolito 5/5/2015 12:10'!parseColumnValue: aString byDescription: columnDescr		| reader value |	reader := nil.	value := columnDescr type 		caseOf: {		[GAMysqlTypes typeTINY]->[ aString asNumber ].		[GAMysqlTypes typeSHORT]->[ aString asNumber ].		[GAMysqlTypes typeINT24]->[ aString asNumber ].		[GAMysqlTypes typeLONG]->[ aString asNumber ].		[GAMysqlTypes typeLONGLONG]->[ aString asNumber ].		[GAMysqlTypes typeFLOAT]->[ aString asNumber ].		[GAMysqlTypes typeDOUBLE]->[ aString asNumber ].		[GAMysqlTypes typeDECIMAL]->[ aString asNumber ].		[GAMysqlTypes typeNEWDECIMAL]->[ aString asNumber ].			[GAMysqlTypes typeSTRING]->[ driver encoder decodeBytes: aString asByteArray ].		[GAMysqlTypes typeVARCHAR]->[ driver encoder decodeBytes: aString asByteArray ].		[GAMysqlTypes typeVARSTRING]->[ driver encoder decodeBytes: aString asByteArray ].			[GAMysqlTypes typeTIME]->[ Time fromString: aString].		[GAMysqlTypes typeDATE]->[ Date fromString: aString].		[GAMysqlTypes typeDATETIME]->[ DateAndTime fromString: aString ].		[GAMysqlTypes typeTIMESTAMP]->[ DateAndTime fromString: aString ].		[GAMysqlTypes typeYEAR]->[ aString asNumber ].		[GAMysqlTypes typeNEWDATE]->[ Date fromString: aString ].			[GAMysqlTypes typeTINYBLOB]->[ aString asByteArray ].		[GAMysqlTypes typeBLOB]->[ aString asByteArray ].		[GAMysqlTypes typeMEDIUMBLOB]->[ aString asByteArray ].		[GAMysqlTypes typeLONGBLOB]->[ aString asByteArray ].				[GAMysqlTypes typeNULL]->[ nil ].			[GAMysqlTypes typeGEOMETRY]->[self shouldBeImplemented].		[GAMysqlTypes typeSET]->[self shouldBeImplemented].		[GAMysqlTypes typeENUM]->[self shouldBeImplemented].		[GAMysqlTypes typeBIT]->[self shouldBeImplemented].	} 	otherwise: [^ self error: 'Unknown mysql type'].	^ value! !!GAMysqlRow methodsFor: 'accessing' stamp: 'GuillermoPolito 5/5/2015 11:42'!at: index		^ self atIndex: index! !!GAMysqlRow methodsFor: 'accessing' stamp: 'GuillermoPolito 5/5/2015 11:54'!at: index put: aValue		^ columnValues at: index put: aValue! !!GAMysqlRow methodsFor: 'accessing' stamp: 'GuillermoPolito 5/5/2015 11:53'!atIndex: indx	^ columnValues at: indx ifAbsent: [GAMysqlInvalidRowAccess signal: 'No data at this index']! !!GAMysqlRow methodsFor: 'accessing' stamp: 'GuillermoPolito 5/5/2015 11:53'!atName: aString 		^ columnValues		at: ((columnDescriptors collect: #name) indexOf: aString asString)		ifAbsent: [GAMysqlInvalidRowAccess signal: 'No data at name: ', aString asString]! !!GAMysqlRow methodsFor: 'initializing' stamp: 'GuillermoPolito 5/5/2015 11:42'!columnDescriptors: aCollection 		columnDescriptors := aCollection.	self initializeColumnValues: aCollection size.! !!GAMysqlRow methodsFor: 'initializing' stamp: 'GuillermoPolito 5/5/2015 11:42'!initializeColumnValues: aCount	columnValues := Array new: aCount 	! !!GAMysqlServerStatusConstants class methodsFor: 'as yet unclassified' stamp: 'ah 6/9/2011 22:50'!initFlags	ServerStatusInTranssaction := 1. 		"transaction has started"	ServerStatusAutoCommit := 2. 		"in autocommit mode"	ServerMoreResultsExist := 8.			"multiple result sets for multi-query"	ServerQueryNoGoodIndexUsed := 16.	ServerQueryNoIndexUsed := 32.		"The server was able to fulfill the clients request and opened a	read-only non-scrollable cursor for a query. This flag comes	in reply to COM_STMT_EXECUTE and COM_STMT_FETCH commands."	ServerStatusCursorExists := 64.		"This flag is sent when a read-only cursor is exhausted, in reply to	COM_STMT_FETCH command."	ServerStatusLastRowSent := 128.	ServerStatusDbDropped := 256. 		"a database was dropped"	ServerStatusNoBackslashEscapes := 512.	! !!GAMysqlServerStatusConstants class methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 1/23/2015 12:04'!initialize	"self initialize"	self initFlags.	! !!GAMysqlServerStatusConstants class methodsFor: 'as yet unclassified' stamp: 'ah 6/9/2011 23:14'!moreResultsExist	^ ServerMoreResultsExist	! !!GAMysqlServerStatusConstants class methodsFor: 'as yet unclassified' stamp: 'ah 6/9/2011 23:03'!statusAutoCommit	^ ServerStatusAutoCommit! !!GAMysqlServerStatusConstants class methodsFor: 'as yet unclassified' stamp: 'ah 8/23/2011 01:49'!statusCursorExists	^ ServerStatusCursorExists	! !!GAMysqlServerStatusConstants class methodsFor: 'as yet unclassified' stamp: 'ah 6/9/2011 23:03'!statusInTransaction	^ ServerStatusInTranssaction! !!GAMysqlServerStatusConstants class methodsFor: 'as yet unclassified' stamp: 'ah 8/23/2011 01:49'!statusLastRowSent	^ ServerStatusLastRowSent	! !!GAMysqlServerStatusConstants class methodsFor: 'as yet unclassified' stamp: 'ah 6/9/2011 23:03'!statusNoIndexUsed	^ ServerQueryNoIndexUsed! !!GAMysqlTypes class methodsFor: 'as yet unclassified' stamp: 'ah 5/2/2011 22:59'!blobTypes	blobTypes ifNil: [		blobTypes := Array 			with: TypeTINYBLOB with: TypeMEDIUMBLOB with: TypeBLOB with: TypeLONGBLOB ].	^ blobTypes	! !!GAMysqlTypes class methodsFor: 'as yet unclassified' stamp: 'ah 5/2/2011 22:54'!dateTimeTypes	dateTimeTypes ifNil: [		dateTimeTypes := Array 			with: TypeDATE with: TypeDATETIME with: TypeNEWDATE with: TypeTIME			with: TypeTIMESTAMP with: TypeYEAR		].	^ dateTimeTypes	! !!GAMysqlTypes class methodsFor: 'as yet unclassified' stamp: 'ah 5/2/2011 22:32'!initFieldTypes 	TypeBIT := 16. 	TypeBLOB := 252. 	TypeDATE := 10. 	TypeDATETIME := 12. 	TypeDECIMAL := 0. 	TypeDOUBLE := 5. 	TypeENUM := 247. 	TypeFLOAT := 4. 	TypeGEOMETRY := 255. 	TypeINT24 := 9. 	TypeLONG := 3. 	TypeLONGLONG := 8. 	TypeLONGBLOB := 251. 	TypeMEDIUMBLOB := 250. 	TypeNEWDATE := 14. 	TypeNEWDECIMAL := 246. 	TypeNULL := 6. 	TypeSET := 248. 	TypeSHORT := 2. 	TypeSTRING := 254. 	TypeTIME := 11. 	TypeTIMESTAMP := 7. 	TypeTINY := 1. 	TypeTINYBLOB := 249. 	TypeVARCHAR := 15. 	TypeVARSTRING := 253. 	TypeYEAR := 13.! !!GAMysqlTypes class methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 1/23/2015 12:04'!initialize	"self initialize"	self initFieldTypes.! !!GAMysqlTypes class methodsFor: 'as yet unclassified' stamp: 'ah 5/2/2011 22:41'!integerTypes	integerTypes ifNil: [		integerTypes := Array 			with: TypeTINY with: TypeSHORT with: TypeINT24 with: TypeLONG 			with: TypeLONGLONG].	^ integerTypes	! !!GAMysqlTypes class methodsFor: 'as yet unclassified' stamp: 'ah 5/2/2011 23:26'!isBigInt: type	^ type = TypeLONGLONG	! !!GAMysqlTypes class methodsFor: 'as yet unclassified' stamp: 'ah 5/2/2011 23:25'!isLongInt: type	^ type = TypeLONG	! !!GAMysqlTypes class methodsFor: 'as yet unclassified' stamp: 'ah 5/2/2011 23:25'!isMediumInt: type	^ type = TypeINT24	! !!GAMysqlTypes class methodsFor: 'as yet unclassified' stamp: 'ah 5/2/2011 23:24'!isSmallInt: type	^ type = TypeSHORT	! !!GAMysqlTypes class methodsFor: 'as yet unclassified' stamp: 'ah 5/2/2011 23:23'!isTinyInt: type	^ type = TypeTINY	! !!GAMysqlTypes class methodsFor: 'as yet unclassified' stamp: 'ah 5/2/2011 23:15'!realTypes	realTypes ifNil: [		realTypes := Array 			with: TypeFLOAT with: TypeDOUBLE with: TypeDECIMAL with: TypeNEWDECIMAL].	^ realTypes	! !!GAMysqlTypes class methodsFor: 'as yet unclassified' stamp: 'ah 5/2/2011 22:56'!stringTypes	stringTypes ifNil: [		stringTypes := Array with: TypeSTRING with: TypeVARCHAR with: TypeVARSTRING ].	^ stringTypes	! !!GAMysqlTypes class methodsFor: 'as yet unclassified' stamp: 'ah 6/26/2011 19:38'!typeBIT	^ TypeBIT	! !!GAMysqlTypes class methodsFor: 'as yet unclassified' stamp: 'ah 5/4/2011 23:50'!typeBLOB	^ TypeBLOB	! !!GAMysqlTypes class methodsFor: 'as yet unclassified' stamp: 'ah 5/4/2011 23:28'!typeDATE	^ TypeDATE	! !!GAMysqlTypes class methodsFor: 'as yet unclassified' stamp: 'ah 5/4/2011 23:25'!typeDATETIME	^ TypeDATETIME	! !!GAMysqlTypes class methodsFor: 'as yet unclassified' stamp: 'ah 5/4/2011 23:32'!typeDECIMAL	^ TypeDECIMAL	! !!GAMysqlTypes class methodsFor: 'as yet unclassified' stamp: 'ah 5/4/2011 22:40'!typeDOUBLE	^ TypeDOUBLE	! !!GAMysqlTypes class methodsFor: 'as yet unclassified' stamp: 'ah 6/26/2011 19:38'!typeENUM	^ TypeENUM	! !!GAMysqlTypes class methodsFor: 'as yet unclassified' stamp: 'ah 5/6/2011 08:40'!typeFLOAT	^ TypeFLOAT	! !!GAMysqlTypes class methodsFor: 'as yet unclassified' stamp: 'ah 6/26/2011 19:38'!typeGEOMETRY	^ TypeGEOMETRY	! !!GAMysqlTypes class methodsFor: 'as yet unclassified' stamp: 'ah 6/26/2011 17:48'!typeINT24	^ TypeINT24	! !!GAMysqlTypes class methodsFor: 'as yet unclassified' stamp: 'ah 5/4/2011 22:18'!typeLONG	^ TypeLONG	! !!GAMysqlTypes class methodsFor: 'as yet unclassified' stamp: 'ah 5/4/2011 23:51'!typeLONGBLOB	^ TypeLONGBLOB	! !!GAMysqlTypes class methodsFor: 'as yet unclassified' stamp: 'ah 5/4/2011 22:31'!typeLONGLONG	^ TypeLONGLONG	! !!GAMysqlTypes class methodsFor: 'as yet unclassified' stamp: 'ah 5/4/2011 23:50'!typeMEDIUMBLOB	^ TypeMEDIUMBLOB	! !!GAMysqlTypes class methodsFor: 'as yet unclassified' stamp: 'ah 6/26/2011 17:52'!typeNEWDATE	^ TypeNEWDATE	! !!GAMysqlTypes class methodsFor: 'as yet unclassified' stamp: 'ah 6/26/2011 17:50'!typeNEWDECIMAL	^ TypeNEWDECIMAL! !!GAMysqlTypes class methodsFor: 'as yet unclassified' stamp: 'ah 5/4/2011 22:13'!typeNULL	^ TypeNULL	! !!GAMysqlTypes class methodsFor: 'as yet unclassified' stamp: 'ah 6/26/2011 19:38'!typeSET	^ TypeSET	! !!GAMysqlTypes class methodsFor: 'as yet unclassified' stamp: 'ah 5/6/2011 01:22'!typeSHORT	^ TypeSHORT	! !!GAMysqlTypes class methodsFor: 'as yet unclassified' stamp: 'ah 5/4/2011 22:49'!typeSTRING	^ TypeSTRING	! !!GAMysqlTypes class methodsFor: 'as yet unclassified' stamp: 'ah 5/4/2011 23:27'!typeTIME	^ TypeTIME	! !!GAMysqlTypes class methodsFor: 'as yet unclassified' stamp: 'ah 5/4/2011 23:24'!typeTIMESTAMP	^ TypeTIMESTAMP	! !!GAMysqlTypes class methodsFor: 'as yet unclassified' stamp: 'ah 5/4/2011 22:42'!typeTINY	^ TypeTINY	! !!GAMysqlTypes class methodsFor: 'as yet unclassified' stamp: 'ah 5/4/2011 23:49'!typeTINYBLOB	^ TypeTINYBLOB	! !!GAMysqlTypes class methodsFor: 'as yet unclassified' stamp: 'ah 5/4/2011 23:49'!typeVARCHAR	^ TypeVARCHAR	! !!GAMysqlTypes class methodsFor: 'as yet unclassified' stamp: 'ah 6/26/2011 17:51'!typeVARSTRING	^ TypeVARSTRING	! !!GAMysqlTypes class methodsFor: 'as yet unclassified' stamp: 'ah 6/26/2011 17:52'!typeYEAR	^ TypeYEAR	! !"Garage-Mysql"!!PGAsciiRow methodsFor: '*Garage-Postgres' stamp: 'GuillermoPolito 1/23/2015 17:10'!at: index	^ self data at: index! !!PGAsciiRow methodsFor: '*Garage-Postgres' stamp: 'GuillermoPolito 2/8/2015 13:03'!atIndex: anInteger 		^ self data at: anInteger! !!PGAsciiRow methodsFor: '*Garage-Postgres' stamp: 'GuillermoPolito 2/8/2015 13:03'!atName: aString 		^ self atIndex: (self indexOfColumnName: aString)! !!PGAsciiRow methodsFor: '*Garage-Postgres' stamp: 'GuillermoPolito 2/8/2015 13:06'!indexOfColumnName: aString 		^ description columnDescriptionDictionary at: aString asSymbol! !!PGResult methodsFor: '*Garage-Postgres' stamp: 'GuillermoPolito 2/8/2015 11:36'!affectedRows		^ self resultSets first completedResponse value substrings last asInteger ifNil: [ 0 ]! !!PGResult methodsFor: '*Garage-Postgres' stamp: 'GuillermoPolito 2/8/2015 17:39'!at: anIndex		^ self resultSets first at: anIndex! !!PGResult methodsFor: '*Garage-Postgres' stamp: 'GuillermoPolito 2/8/2015 17:41'!collect: aBlock		^ self resultSets first collect: aBlock! !!PGResult methodsFor: '*Garage-Postgres' stamp: 'GuillermoPolito 2/8/2015 17:44'!do: aBlock		^ self resultSets first do: aBlock! !!PGResult methodsFor: '*Garage-Postgres' stamp: 'GuillermoPolito 2/8/2015 17:39'!first		^ self at: 1! !!PGResult methodsFor: '*Garage-Postgres' stamp: 'GuillermoPolito 2/8/2015 17:42'!isEmpty		^ self resultSets first isEmpty! !!PGResult methodsFor: '*Garage-Postgres' stamp: 'GuillermoPolito 1/29/2015 16:13'!nextRow	self rows ifEmpty:[ ^ nil ].	^ self rows removeFirst! !!PGResult methodsFor: '*Garage-Postgres' stamp: 'GuillermoPolito 2/8/2015 17:46'!readStream		^ self resultSets first readStream! !!PGResult methodsFor: '*Garage-Postgres' stamp: 'GuillermoPolito 2/8/2015 17:41'!select: aBlock		^ self resultSets first select: aBlock! !!PGResultSet methodsFor: '*Garage-Postgres' stamp: 'GuillermoPolito 2/8/2015 17:40'!at: anIndex		^ rows at: anIndex! !!PGResultSet methodsFor: '*Garage-Postgres' stamp: 'GuillermoPolito 2/8/2015 17:42'!collect: aBlock		^ rows collect: aBlock! !!PGResultSet methodsFor: '*Garage-Postgres' stamp: 'GuillermoPolito 2/8/2015 17:45'!do: aBlock		^ rows do: aBlock! !!PGResultSet methodsFor: '*Garage-Postgres' stamp: 'GuillermoPolito 2/8/2015 17:36'!first		^ rows first! !!PGResultSet methodsFor: '*Garage-Postgres' stamp: 'GuillermoPolito 2/8/2015 17:42'!isEmpty		^ rows isEmpty! !!PGResultSet methodsFor: '*Garage-Postgres' stamp: 'GuillermoPolito 4/16/2015 12:20'!readStream		^ GAResultSetReadStream on: self! !!PGResultSet methodsFor: '*Garage-Postgres' stamp: 'GuillermoPolito 2/8/2015 17:54'!rowAt: anIndex		^ self at: anIndex! !!PGResultSet methodsFor: '*Garage-Postgres' stamp: 'GuillermoPolito 2/8/2015 17:42'!select: aBlock		^ rows select: aBlock! !!PGConnection methodsFor: '*Garage-Postgres' stamp: 'GuillermoPolito 1/23/2015 17:02'!close	self terminate! !!PGConnection methodsFor: '*Garage-Postgres' stamp: 'GuillermoPolito 1/23/2015 17:19'!prepare: sqlString named: aName	trace >= 2 ifTrue: [self log: 'execute' text: sqlString].	self isConnected ifFalse: [ self error: 'Connection not valid' ].	sql := 'PREPARE ', aName ,' AS ', sqlString convertToWithConverter: receivingTextConverter. "sqlStringConverter value: sqlString."	self queueEvent: #Query.	self saProcessEventsUntil: #(ReadyForQuery ConnectionFailed).	"There's an extra result set, so nuke it here."	result resultSets size > 0		ifTrue: [ result resultSets removeLast ].	^ result! !!GAPostgresV2Statement methodsFor: 'bindings' stamp: 'GuillermoPolito 1/23/2015 17:36'!addBinding: anObject		arguments add: anObject.! !!GAPostgresV2Statement methodsFor: 'bindings' stamp: 'GuillermoPolito 2/19/2015 17:54'!at: anInteger bind: anObject		prepared ifFalse: [ self error: 'A statement should be prepared to bind arguments' ].	arguments add: anObject.! !!GAPostgresV2Statement methodsFor: 'accessing' stamp: 'GuillermoPolito 1/23/2015 17:25'!connection: aPGConnection 	connection := aPGConnection! !!GAPostgresV2Statement methodsFor: 'execute' stamp: 'GuillermoPolito 4/24/2015 10:22'!execute		^ fetchSize ifNil: [		fetchListener ifNotNilDo: #fetchOccurred.		connection execute: self executionStatement.	] ifNotNil: [		^ GAPostgresV2CursoredResult new			connection: connection;			fetchListener: fetchListener;			fetchSize: fetchSize;			statement: self;			declare;			yourself	]! !!GAPostgresV2Statement methodsFor: 'execute' stamp: 'GuillermoPolito 2/19/2015 17:26'!executionStatement		| argumentsString |	prepared ifFalse: [ ^ statement ].		"If not it means by the moment that we are a named prepared statement and we execute that"	argumentsString := arguments		ifEmpty: [ '' ]		ifNotEmpty: [ '(''', (''', ''' join: (arguments collect: #asString)), ''')' ].	^ 'EXECUTE ', (self propertyAt: #statementId), argumentsString! !!GAPostgresV2Statement methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 1/29/2015 16:25'!fetchSize: anInteger 		fetchSize := anInteger! !!GAPostgresV2Statement methodsFor: 'initialize - release' stamp: 'GuillermoPolito 1/23/2015 17:37'!initialize	super initialize.	arguments := OrderedCollection new.! !!GAPostgresV2Statement methodsFor: 'accessing' stamp: 'GuillermoPolito 4/24/2015 17:16'!placeholderAt: anInteger 		^ '$', anInteger asString! !!GAPostgresV2Statement methodsFor: 'execute' stamp: 'GuillermoPolito 2/19/2015 16:22'!prepare	| statementId |	super prepare.		statementId := 'preparedStmt', UUID new asString36.	connection basicQuery: 'PREPARE ', statementId, ' AS ', self statementString.	self propertyAt: #statementId put: statementId.		^ self! !!GAPostgresV2Statement methodsFor: 'accessing' stamp: 'GuillermoPolito 2/19/2015 16:08'!statement	^ statement! !!GAPostgresV2Driver class methodsFor: 'drivers' stamp: 'GuillermoPolito 1/23/2015 15:00'!driverId	^ 'postgresV2'! !!GAPostgresV2Driver class methodsFor: 'instance-creation' stamp: 'GuillermoPolito 4/27/2015 11:13'!fromConnectionString: aConnectionString		| connection |	connection := self new.	connection connectionString: aConnectionString.	connection host: aConnectionString host.	connection port: aConnectionString port.	connection database: aConnectionString database.	connection user: aConnectionString user.	connection password: aConnectionString password.	^ connection! !!GAPostgresV2Driver class methodsFor: 'initialize' stamp: 'GuillermoPolito 1/23/2015 15:00'!initialize	self subscribeDriver! !!GAPostgresV2Driver class methodsFor: 'tests' stamp: 'GuillermoPolito 4/17/2015 17:06'!newFixture		^ GADriverPostgresqlTestFixture new! !!GAPostgresV2Driver class methodsFor: 'encoding' stamp: 'GuillermoPolito 4/29/2015 12:08'!supportsEncoding: aString 		"Check: http://www.postgresql.org/docs/9.2/static/multibyte.html"	^ true! !!GAPostgresV2Driver methodsFor: 'accessing' stamp: 'GuillermoPolito 1/23/2015 15:03'!backend		^ 'postgresql'! !!GAPostgresV2Driver methodsFor: 'private' stamp: 'GuillermoPolito 1/23/2015 18:06'!basicQuery: aQuery		^ driver executeAndCheckResult: aQuery.! !!GAPostgresV2Driver methodsFor: 'transactions' stamp: 'GuillermoPolito 1/23/2015 15:00'!beginTransaction		self basicQuery: 'BEGIN'! !!GAPostgresV2Driver methodsFor: 'connection' stamp: 'GuillermoPolito 4/17/2015 13:33'!close	driver ifNotNilDo: #close! !!GAPostgresV2Driver methodsFor: 'transactions' stamp: 'GuillermoPolito 1/23/2015 15:00'!commitTransaction		self basicQuery: 'COMMIT'! !!GAPostgresV2Driver methodsFor: 'connection' stamp: 'GuillermoPolito 4/27/2015 15:54'!connect	| response |	driver := PGConnection new		connectionArgs: connectionSpec;		clientEncoding: self encoding asSymbol;		yourself.	response := driver startup.	(response errorResponse isKindOf: PGErrorResponse)		ifTrue: [ self error: response errorResponse value ].	self register.! !!GAPostgresV2Driver methodsFor: 'statements' stamp: 'GuillermoPolito 4/16/2015 12:22'!createStatement		^ GAPostgresV2Statement onConnection: self.! !!GAPostgresV2Driver methodsFor: 'query' stamp: 'GuillermoPolito 4/16/2015 12:22'!createStatement: aQuery		| statement pgGoodQuery |	pgGoodQuery := self pgGoodQuery: aQuery.	statement := GAPostgresV2Statement onConnection: self.	statement statementString: pgGoodQuery.	^ statement! !!GAPostgresV2Driver methodsFor: 'accessing' stamp: 'GuillermoPolito 1/23/2015 15:06'!database		^ connectionSpec databaseName! !!GAPostgresV2Driver methodsFor: 'accessing' stamp: 'GuillermoPolito 1/23/2015 15:06'!database: aDatabase		connectionSpec databaseName: aDatabase! !!GAPostgresV2Driver methodsFor: 'transactions' stamp: 'GuillermoPolito 4/24/2015 17:17'!defaultValueAutoCommit		^ true! !!GAPostgresV2Driver methodsFor: 'accessing' stamp: 'GuillermoPolito 4/17/2015 13:09'!driverId		^ self class driverId! !!GAPostgresV2Driver methodsFor: 'query' stamp: 'GuillermoPolito 1/23/2015 16:05'!execute: aQuery	^ driver executeAndCheckResult: aQuery! !!GAPostgresV2Driver methodsFor: 'finalization' stamp: 'GuillermoPolito 1/25/2015 11:28'!finalize	self isConnected ifTrue: [ self close ].	driver := nil! !!GAPostgresV2Driver methodsFor: 'transactions' stamp: 'GuillermoPolito 4/24/2015 17:17'!hasAutoCommit		^ true! !!GAPostgresV2Driver methodsFor: 'accessing' stamp: 'GuillermoPolito 1/23/2015 15:06'!host		^ connectionSpec hostname! !!GAPostgresV2Driver methodsFor: 'accessing' stamp: 'GuillermoPolito 1/23/2015 15:37'!host: aHost	connectionSpec hostname: aHost! !!GAPostgresV2Driver methodsFor: 'initialization' stamp: 'GuillermoPolito 1/23/2015 15:05'!initialize	super initialize.	connectionSpec := PGConnectionArgs new! !!GAPostgresV2Driver methodsFor: 'testing' stamp: 'GuillermoPolito 1/25/2015 11:19'!isConnected		^ driver notNil and: [ driver isConnected ]! !!GAPostgresV2Driver methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/17/2015 10:55'!newFixture	^ GADriverPostgresqlTestFixture new! !!GAPostgresV2Driver methodsFor: 'accessing' stamp: 'GuillermoPolito 1/23/2015 15:00'!password		^ connectionSpec password! !!GAPostgresV2Driver methodsFor: 'accessing' stamp: 'GuillermoPolito 1/23/2015 15:00'!password: aPort	connectionSpec password: aPort! !!GAPostgresV2Driver methodsFor: 'conversion' stamp: 'GuillermoPolito 1/23/2015 18:00'!pgGoodQuery: aQuery		| goodQuery next index lastIndex |	goodQuery := ''.	lastIndex := 0.	next := 1.	[index := aQuery findString: '?' startingAt: lastIndex + 1 caseSensitive: true. index = 0] 		whileFalse: [			goodQuery := goodQuery , (aQuery copyFrom: lastIndex + 1 to: index -1).			goodQuery := goodQuery , '$', next asString.			lastIndex := index.			next := next + 1 ].	goodQuery := goodQuery , (aQuery copyFrom: lastIndex + 1 to: aQuery size).	^ goodQuery! !!GAPostgresV2Driver methodsFor: 'accessing' stamp: 'GuillermoPolito 1/23/2015 15:06'!port		^ connectionSpec portno! !!GAPostgresV2Driver methodsFor: 'accessing' stamp: 'GuillermoPolito 1/23/2015 15:06'!port: aPort	connectionSpec portno: aPort! !!GAPostgresV2Driver methodsFor: 'query' stamp: 'GuillermoPolito 2/19/2015 16:08'!prepare: aQuery	^ (self createStatement: aQuery) prepare! !!GAPostgresV2Driver methodsFor: 'transactions' stamp: 'GuillermoPolito 1/23/2015 15:00'!rollbackTransaction		self basicQuery: 'ROLLBACK'! !!GAPostgresV2Driver methodsFor: 'testing' stamp: 'GuillermoPolito 4/27/2015 16:35'!supportsAutomaticQueryEncoding		^ true! !!GAPostgresV2Driver methodsFor: 'testing' stamp: 'GuillermoPolito 4/24/2015 10:14'!supportsCursoredFetch		^ true! !!GAPostgresV2Driver methodsFor: 'testing' stamp: 'GuillermoPolito 1/23/2015 15:00'!supportsPreparedStatements	^ true! !!GAPostgresV2Driver methodsFor: 'accessing' stamp: 'GuillermoPolito 1/23/2015 15:06'!user		^ connectionSpec userName! !!GAPostgresV2Driver methodsFor: 'accessing' stamp: 'GuillermoPolito 1/23/2015 15:07'!user: username	connectionSpec userName: username! !!GAPostgresV2CursoredResult methodsFor: 'accessing' stamp: 'GuillermoPolito 2/8/2015 17:49'!allRows	self fetchAllRows.	^ rows! !!GAPostgresV2CursoredResult methodsFor: 'iterating' stamp: 'GuillermoPolito 2/8/2015 17:51'!at: anIndex		"Ok we should optimize it later"	self fetchWhile: [ rows size < anIndex ].	^ rows at: anIndex! !!GAPostgresV2CursoredResult methodsFor: 'cursor management' stamp: 'GuillermoPolito 1/29/2015 16:37'!close	connection executeAndCheckResult: 'CLOSE ', name! !!GAPostgresV2CursoredResult methodsFor: 'iterating' stamp: 'GuillermoPolito 2/8/2015 17:51'!collect: aBlockClosure 		"Ok we should optimize it later"	^ self allRows collect: aBlockClosure! !!GAPostgresV2CursoredResult methodsFor: 'accessing' stamp: 'GuillermoPolito 1/29/2015 16:25'!connection	^ connection! !!GAPostgresV2CursoredResult methodsFor: 'accessing' stamp: 'GuillermoPolito 1/29/2015 16:25'!connection: anObject	connection := anObject! !!GAPostgresV2CursoredResult methodsFor: 'cursor management' stamp: 'GuillermoPolito 4/24/2015 10:19'!declare	connection execute: 'DECLARE ', name, ' CURSOR FOR ', statement executionStatement.	fetchListener ifNotNilDo: #fetchOccurred.! !!GAPostgresV2CursoredResult methodsFor: 'iterating' stamp: 'GuillermoPolito 2/8/2015 17:51'!do: aBlockClosure 		"Ok we should optimize it later"	^ self allRows do: aBlockClosure! !!GAPostgresV2CursoredResult methodsFor: 'cursor' stamp: 'GuillermoPolito 2/8/2015 17:49'!fetchAllRows	[ self hasMoreRowsInServer ] whileTrue: [ self fetchMoreRows ]! !!GAPostgresV2CursoredResult methodsFor: 'accessing' stamp: 'GuillermoPolito 4/24/2015 10:17'!fetchListener: aFetchListener	fetchListener := aFetchListener! !!GAPostgresV2CursoredResult methodsFor: 'cursor' stamp: 'GuillermoPolito 4/24/2015 10:17'!fetchMoreRows		| result obtained |	result := connection execute: 'FETCH FORWARD ', fetchSize asString, ' FROM ', name.	obtained := result resultSets first rows.	rows addAll: obtained.	fetchListener ifNotNilDo: #fetchOccurred.	finished := obtained isEmpty or: [ obtained size < fetchSize ].! !!GAPostgresV2CursoredResult methodsFor: 'cursor' stamp: 'GuillermoPolito 2/8/2015 18:01'!fetchRows		| result obtained |	result := connection execute: 'FETCH FORWARD ', fetchSize asString, ' FROM ', name.	obtained := result resultSets first rows.	rows addAll: obtained.	finished := obtained isEmpty or: [ obtained size < fetchSize ].! !!GAPostgresV2CursoredResult methodsFor: 'accessing' stamp: 'GuillermoPolito 1/29/2015 16:25'!fetchSize	^ fetchSize! !!GAPostgresV2CursoredResult methodsFor: 'accessing' stamp: 'GuillermoPolito 1/29/2015 16:25'!fetchSize: anObject	fetchSize := anObject! !!GAPostgresV2CursoredResult methodsFor: 'cursor' stamp: 'GuillermoPolito 2/8/2015 17:51'!fetchWhile: aBlock	[ self hasMoreRowsInServer and: aBlock ] whileTrue: [ self fetchMoreRows ]! !!GAPostgresV2CursoredResult methodsFor: 'iterating' stamp: 'GuillermoPolito 2/8/2015 17:51'!first		^ self at: 1! !!GAPostgresV2CursoredResult methodsFor: 'testing' stamp: 'GuillermoPolito 2/8/2015 17:50'!hasMoreRowsInServer		^ finished not! !!GAPostgresV2CursoredResult methodsFor: 'initialize - release' stamp: 'GuillermoPolito 2/8/2015 17:58'!initialize	super initialize.	name := 'cursorpgv2', UUID new asString36.	rows := OrderedCollection new.	finished := false.	! !!GAPostgresV2CursoredResult methodsFor: 'testing' stamp: 'GuillermoPolito 2/8/2015 17:51'!isEmpty		^ rows isEmptyOrNil		and: [ self hasMoreRowsInServer not ]! !!GAPostgresV2CursoredResult methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 2/8/2015 17:50'!nextRow		self halt.	(rows isEmpty and: [ finished not ])		ifTrue: [ self fetchRows ].	^ rows isEmpty		ifTrue: [ nil ]		ifFalse: [ rows removeFirst ]! !!GAPostgresV2CursoredResult methodsFor: 'iterating' stamp: 'GuillermoPolito 4/16/2015 12:20'!readStream	^ GAResultSetReadStream on: self! !!GAPostgresV2CursoredResult methodsFor: 'iterating' stamp: 'GuillermoPolito 2/8/2015 17:55'!rowAt: anIndex		^ self at: anIndex! !!GAPostgresV2CursoredResult methodsFor: 'iterating' stamp: 'GuillermoPolito 4/24/2015 10:16'!rows	^ self allRows! !!GAPostgresV2CursoredResult methodsFor: 'iterating' stamp: 'GuillermoPolito 2/8/2015 17:52'!select: aBlockClosure 		"Ok we should optimize it later"	^ self allRows select: aBlockClosure! !!GAPostgresV2CursoredResult methodsFor: 'accessing' stamp: 'GuillermoPolito 1/29/2015 16:25'!statement	^ statement! !!GAPostgresV2CursoredResult methodsFor: 'accessing' stamp: 'GuillermoPolito 1/29/2015 16:25'!statement: anObject	statement := anObject! !"Garage-Postgres"!!GASQLite3Constants commentStamp: 'GuillermoPolito 4/17/2015 14:05' prior: 0!I provide SQLIte's constants.!!GASqlite3Statement commentStamp: '<historical>' prior: 0!I represent an SQLite prepared statement.!!GASqlite3Error commentStamp: '<historical>' prior: 0!I represent an SQLite non-ok condition.!!GASqlite3Busy commentStamp: '<historical>' prior: 0!I represent the SQLITE_BUSY condition.!!GASqlite3Locked commentStamp: '<historical>' prior: 0!I represent the SQLITE_LOCKED condition.!!GASqlite3Misuse commentStamp: 'PierceNg 4/6/2014 00:01' prior: 0!I represent the SQLITE_MISUSE condition.!!GASqlite3NotOpen commentStamp: 'PierceNg 3/29/2014 20:17' prior: 0!I am signalled when operations are invoked on a database that is not open.!!GASQLite3DatabaseExternalObject commentStamp: 'GuillermoPolito 4/17/2015 14:05' prior: 0!I represent the SQLite API 'sqlite3' C-level type.!!GASQLite3StatementExternalObject commentStamp: 'GuillermoPolito 4/17/2015 14:05' prior: 0!I represent the SQLite API 'sqlite3_stmt' C-level type.!!GASqlite3FFI commentStamp: '<historical>' prior: 0!I am the FFI interface to SQLite.!!GASQLite3Constants class methodsFor: 'initialization' stamp: 'GuillermoPolito 4/17/2015 14:05'!initialize	OK := 0.	INTEGER := 1.	FLOAT := 2.	TEXT := 3.	BLOB := 4.	BUSY := 5.	NULL := 5.	LOCKED := 6.	MISUSE := 21.! !!GASqlite3Statement class methodsFor: 'instance finalization' stamp: 'PierceNg 4/13/2014 17:00'!finalizeResourceData: aHandle	NBSQLite3FFI current apiFinalize: aHandle.! !!GASqlite3Statement methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/16/2015 12:22'!at: aColumn bind: anObject	| result |	result := self basicBind: aColumn toObject: anObject.	GASqlite3FFI current checkForOk: result on: connection handle.! !!GASqlite3Statement methodsFor: 'public' stamp: 'GuillermoPolito 4/16/2015 12:22'!at: aColumn putByteArray: anObject	^ GASqlite3FFI current with: handle at: aColumn putBlob: anObject! !!GASqlite3Statement methodsFor: 'public' stamp: 'GuillermoPolito 4/16/2015 12:22'!at: aColumn putFloat: aFloat	^ GASqlite3FFI current with: handle at: aColumn putFloat: aFloat! !!GASqlite3Statement methodsFor: 'public' stamp: 'GuillermoPolito 4/16/2015 12:22'!at: aColumn putInteger: anInteger	^ GASqlite3FFI current with: handle at: aColumn putInteger: anInteger! !!GASqlite3Statement methodsFor: 'public' stamp: 'GuillermoPolito 4/16/2015 12:22'!at: aColumn putNil: anObject	"Goofy interface note - anObject is ignored here. When used by NBSQLite3Connection, anObject will always be nil."	^ GASqlite3FFI current with: handle putNullAt: aColumn! !!GASqlite3Statement methodsFor: 'public' stamp: 'GuillermoPolito 4/16/2015 12:22'!at: aColumn putObject: anObject	^ GASqlite3FFI current with: handle at: aColumn putBlob: (FLSerializer serializeToByteArray: anObject)! !!GASqlite3Statement methodsFor: 'public' stamp: 'GuillermoPolito 4/16/2015 12:22'!at: aColumn putString: aString	^ GASqlite3FFI current with: handle at: aColumn putString: aString! !!GASqlite3Statement methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 3/25/2015 17:45'!basicBind: aColumn toObject: anObject	(anObject isKindOf: ByteString)		ifTrue: [ ^ self at: aColumn putString: anObject ].	(anObject isKindOf: Float)		ifTrue: [ ^ self at: aColumn putFloat: anObject ].	(anObject isKindOf: ByteArray)		ifTrue: [ ^ self at: aColumn putByteArray: anObject ].	(anObject isNil)		ifTrue: [ ^ self at: aColumn putNil: anObject ].	(anObject isKindOf: Integer)		ifTrue: [ ^ self at: aColumn putInteger: anObject ].	^ self at: aColumn putObject: anObject! !!GASqlite3Statement methodsFor: 'public' stamp: 'PierceNg 4/12/2014 23:35'!basicExecute: aBlock	| ret |		ret := self step. 	(ret = 101) " == SQLITE_DONE, meaning step should not be sent again."		ifTrue: [ aBlock value: self ]		ifFalse: [			[ ret = 100 ] whileTrue: [ " == SQLITE_ROW, meaning another row is available."				aBlock value: self.				ret := self step ]]! !!GASqlite3Statement methodsFor: 'public' stamp: 'GuillermoPolito 4/16/2015 12:22'!bindParameterCount	^ GASqlite3FFI current bindParameterCount: handle! !!GASqlite3Statement methodsFor: 'public' stamp: 'GuillermoPolito 4/16/2015 12:22'!bindParameterIndex: aName	^ GASqlite3FFI current bindParameterIndex: handle for: aName! !!GASqlite3Statement methodsFor: 'public' stamp: 'GuillermoPolito 4/16/2015 12:22'!byteArrayAt: aColumn	^ GASqlite3FFI current blobFrom: handle at: aColumn! !!GASqlite3Statement methodsFor: 'public' stamp: 'PierceNg 1/4/2014 21:47'!clearBindings	connection clearBindings: self! !!GASqlite3Statement methodsFor: 'accessing' stamp: 'GuillermoPolito 4/16/2015 12:22'!columnCount	^ GASqlite3FFI current columnCount: handle! !!GASqlite3Statement methodsFor: 'private' stamp: 'PierceNg 1/3/2014 15:50'!connection: anObject	connection := anObject! !!GASqlite3Statement methodsFor: 'public' stamp: 'PierceNg 9/25/2014 06:42'!dataTypeForObject: anObject	anObject ifNil: [ ^#at:putNil: ].	(anObject isKindOf: Integer)		ifTrue: [ ^#at:putInteger: ].			(anObject isKindOf: Float)		ifTrue: [ ^#at:putFloat: ].			(anObject isKindOf: String)		ifTrue: [ ^#at:putString: ].			(anObject isKindOf: ByteArray)		ifTrue: [ ^#at:putByteArray: ].			^ #at:putObject: ! !!GASqlite3Statement methodsFor: 'public' stamp: 'GuillermoPolito 4/16/2015 12:22'!dataValuesAvailable	^ GASqlite3FFI current dataValuesAvailable: handle! !!GASqlite3Statement methodsFor: 'execute' stamp: 'GuillermoPolito 4/24/2015 17:09'!execute		prepared ifFalse: [ self prepare ].		self reset.	self basicExecute: [ :theStatement | | generatedKey |		generatedKey := GASqlite3FFI current lastInsertRowId: connection handle.		fetchListener ifNotNilDo: #fetchOccurred.		^ GASqlite3ResultSet new			statement: theStatement;			generatedKey: generatedKey;			yourself.		 ]! !!GASqlite3Statement methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/24/2015 11:20'!fetchSize: anInteger 		"We do not care, it is sqlite"	self error: 'This driver does not support cursored fetches'! !!GASqlite3Statement methodsFor: 'public' stamp: 'PierceNg 9/20/2014 17:13'!finalize 	connection finalize: self.	handle := nil	! !!GASqlite3Statement methodsFor: 'public' stamp: 'GuillermoPolito 4/16/2015 12:22'!floatAt: aColumn	^ GASqlite3FFI current floatFrom: handle at: aColumn! !!GASqlite3Statement methodsFor: 'private' stamp: 'PierceNg 1/3/2014 16:31'!handle	^ handle! !!GASqlite3Statement methodsFor: 'initialize-release' stamp: 'GuillermoPolito 4/17/2015 14:19'!initialize	super initialize.	handle := GASQLite3StatementExternalObject new.! !!GASqlite3Statement methodsFor: 'public' stamp: 'GuillermoPolito 4/16/2015 12:22'!integerAt: aColumn	^ GASqlite3FFI current integerFrom: handle at: aColumn! !!GASqlite3Statement methodsFor: 'public' stamp: 'GuillermoPolito 4/16/2015 12:22'!nameOfColumn: aColumn	^ GASqlite3FFI current nameFor: handle at: aColumn! !!GASqlite3Statement methodsFor: 'public' stamp: 'PierceNg 3/30/2014 16:50'!nilAt: aColumn	^ nil! !!GASqlite3Statement methodsFor: 'public' stamp: 'GuillermoPolito 4/16/2015 12:22'!objectAt: aColumn	^ FLMaterializer materializeFromByteArray: (GASqlite3FFI current blobFrom: handle at: aColumn)! !!GASqlite3Statement methodsFor: 'execute' stamp: 'GuillermoPolito 4/27/2015 15:43'!prepare	super prepare.	GASqlite3FFI current prepare: handle on: connection handle with: self statementString.! !!GASqlite3Statement methodsFor: 'public' stamp: 'GuillermoPolito 4/16/2015 12:22'!putNilAt: aColumn	^ GASqlite3FFI current with: handle putNullAt: aColumn! !!GASqlite3Statement methodsFor: 'public' stamp: 'GuillermoPolito 4/16/2015 12:22'!reset	GASqlite3FFI current reset: handle on: connection handle! !!GASqlite3Statement methodsFor: 'public' stamp: 'GuillermoPolito 4/16/2015 12:22'!step	^ GASqlite3FFI current step: handle! !!GASqlite3Statement methodsFor: 'public' stamp: 'GuillermoPolito 4/27/2015 11:25'!stringAt: aColumn	 	^ connection encoder decodeBytes: (GASqlite3FFI current stringFrom: handle at: aColumn) asByteArray! !!GASqlite3Statement methodsFor: 'public' stamp: 'GuillermoPolito 4/16/2015 12:22'!typeOfColumn: aColumn	^ GASqlite3FFI current typeFor: handle at: aColumn! !!GASqlite3Statement methodsFor: 'public' stamp: 'PierceNg 3/30/2014 17:18'!valueOfColumn: aColumn	^ self perform: (self typeOfColumn: aColumn) with: aColumn! !!GASqlite3Error methodsFor: 'accessing' stamp: 'PierceNg 2/27/2014 22:11'!resultCode	^ resultCode! !!GASqlite3Error methodsFor: 'accessing' stamp: 'PierceNg 2/27/2014 22:11'!resultCode: anObject	resultCode := anObject! !!GASqlite3ResultSet methodsFor: 'accessing' stamp: 'GuillermoPolito 3/25/2015 17:35'!affectedRows		^ affectedRows! !!GASqlite3ResultSet methodsFor: 'testing' stamp: 'GuillermoPolito 3/25/2015 16:34'!at: anIndex		^ self rowAt: anIndex! !!GASqlite3ResultSet methodsFor: 'iterating' stamp: 'GuillermoPolito 3/25/2015 16:36'!collect: aBlockClosure 		^ self rows collect: aBlockClosure! !!GASqlite3ResultSet methodsFor: 'iterating' stamp: 'GuillermoPolito 3/25/2015 16:31'!do: aBlockClosure 		^ self rows do: aBlockClosure! !!GASqlite3ResultSet methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/20/2015 17:55'!execute: anSQLText with: anObject on: aDb	| obj |	db := aDb.	obj := anObject isNil ifTrue: [ #() ] ifFalse: [ anObject ].	(obj isCollection)		ifTrue: [ self execute: anSQLText withCollection: obj ]		ifFalse: [			(anObject respondsTo: #keysAndValuesDo:)				ifTrue: [ self execute: anSQLText withKeysAndValues: obj ]				ifFalse: [ GASqlite3Error signal: 'Unable to execute SQL on instance of ', obj class asString ]].	affectedRows := GASqlite3FFI current changes: db handle.! !!GASqlite3ResultSet methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 3/25/2015 16:11'!execute: anSQLText withCollection: aCollection	| i |	self prepareStatement: anSQLText.	i := 1.	aCollection do: [ :v | i := self execute: statement withIndex: i withValue: v ].	moreRows := (statement step) = 100. " == SQLITE_ROW "! !!GASqlite3ResultSet methodsFor: 'iterating' stamp: 'GuillermoPolito 3/25/2015 16:28'!first		^ self rowAt: 1! !!GASqlite3ResultSet methodsFor: 'accessing' stamp: 'GuillermoPolito 4/20/2015 17:50'!generatedKey	^ generatedKey! !!GASqlite3ResultSet methodsFor: 'accessing' stamp: 'GuillermoPolito 4/20/2015 17:56'!generatedKey: anInteger 	generatedKey := anInteger! !!GASqlite3ResultSet methodsFor: 'accessing' stamp: 'GuillermoPolito 3/25/2015 16:30'!indexOfColumnName: aName	^ columnNames keyAtValue: aName! !!GASqlite3ResultSet methodsFor: 'initialization' stamp: 'GuillermoPolito 3/25/2015 16:27'!initialize	"Initializes the receiver"		super initialize.	moreRows := true.	columnNames := Dictionary new.	columnTypes := Dictionary new.! !!GASqlite3ResultSet methodsFor: 'testing' stamp: 'GuillermoPolito 3/25/2015 16:33'!isEmpty		^ moreRows not and: [ rows isEmptyOrNil ]! !!GASqlite3ResultSet methodsFor: 'iterating' stamp: 'GuillermoPolito 4/16/2015 12:23'!next	| nc rr |	statement ifNil: [ GASqlite3Misuse signal: 'This result set does not contain a prepared statement.' ].		moreRows ifTrue: [			nc := statement dataValuesAvailable.		(nc = 0)			ifTrue: [ ^ nil ] 			ifFalse: [ 				rr := GASqlite3Row new.				rr resultSet: self.				0 to: nc - 1 do: [ :c | rr at: c + 1 put: (statement valueOfColumn: c) ].				"statement clearBindings." "XXX With this, the Glorp result set fails its test..."				moreRows := (statement step) = 100. " == SQLITE_ROW "				^ rr ]].			^ nil! !!GASqlite3ResultSet methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 3/25/2015 16:12'!prepareStatement: anSQLText	statement isNil		ifTrue: [ statement := db prepare: anSQLText ]		ifFalse: [ statement clearBindings; reset ].	1 to: statement columnCount do: [ :i |		columnNames at: i put: (statement nameOfColumn: i -1 ).		columnTypes at: i put: (statement typeOfColumn: i -1)].! !!GASqlite3ResultSet methodsFor: 'streaming' stamp: 'GuillermoPolito 4/16/2015 12:20'!readStream		^ GAResultSetReadStream on: self! !!GASqlite3ResultSet methodsFor: 'testing' stamp: 'GuillermoPolito 3/25/2015 16:28'!rowAt: anIndex		^ self rows at: anIndex! !!GASqlite3ResultSet methodsFor: 'iterating' stamp: 'GuillermoPolito 3/25/2015 16:28'!rows	| row |	"we cache the result"	rows ifNotNil: [ ^ rows ].		rows := OrderedCollection new.	[ row := self next. row notNil ] whileTrue: [ rows add: row ].	^ rows! !!GASqlite3ResultSet methodsFor: 'iterating' stamp: 'GuillermoPolito 3/25/2015 16:36'!select: aBlockClosure 		^ self rows select: aBlockClosure! !!GASqlite3ResultSet methodsFor: 'accessing' stamp: 'GuillermoPolito 3/25/2015 18:04'!statement: aStatement	statement := aStatement! !!GASqlite3FFI class methodsFor: 'factory' stamp: 'PierceNg 1/3/2014 14:46'!current	^ Singleton ifNil: [ Singleton := self basicNew ]! !!GASqlite3FFI class methodsFor: 'class initialization' stamp: 'PierceNg 3/30/2014 17:09'!initialize	self initializeTypeMap.	self initializeDataTypeMap.! !!GASqlite3FFI class methodsFor: 'class initialization' stamp: 'PierceNg 4/12/2014 00:25'!initializeDataTypeMap	DataTypeMap := Dictionary newFromPairs: #(		1			#integerAt: 		2			#floatAt:		3			#stringAt:		4			#byteArrayAt:		5			#nilAt:	)! !!GASqlite3FFI class methodsFor: 'class initialization' stamp: 'GuillermoPolito 4/17/2015 14:09'!initializeTypeMap	TypeMap := Dictionary newFromPairs: #(		sqlite3		      GASQLite3DatabaseExternalObject		sqlite3_stmt			GASQLite3StatementExternalObject		sqlite_int64			NBInt64	)! !!GASqlite3FFI class methodsFor: 'factory' stamp: 'PierceNg 1/3/2014 12:35'!nbBindingOf: aTypeName	^ TypeMap at: aTypeName ifAbsent: [ super nbBindingOf: aTypeName ]! !!GASqlite3FFI class methodsFor: 'class initialization' stamp: 'PierceNg 4/5/2014 18:13'!reset	Singleton := nil! !!GASqlite3FFI methodsFor: 'private' stamp: 'PierceNg 2/23/2014 20:10'!apiBindBlob: aStatement atColumn: aColumn with: aByteArray with: anInteger with: aPointer	"int sqlite3_bind_blob(sqlite3_stmt*, int, const void *, int, void(*)(void*))"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^ self nbCall: #(int sqlite3_bind_blob (sqlite3_stmt aStatement, int aColumn, ByteArray aByteArray, int anInteger, int aPointer)) "SQLITE_TRANSIENT"		module: self library! !!GASqlite3FFI methodsFor: 'private' stamp: 'PierceNg 3/30/2014 17:06'!apiBindDouble: aStatement atColumn: aColumn with: aFloat	"int sqlite3_bind_double(sqlite3_stmt*, int, double)"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^ self nbCall: #(int sqlite3_bind_double (sqlite3_stmt aStatement, int aColumn, double aFloat))		module: self library! !!GASqlite3FFI methodsFor: 'private' stamp: 'PierceNg 2/16/2014 00:31'!apiBindInteger: aStatement atColumn: aColumn with: anInteger	"int sqlite3_bind_int64(sqlite3_stmt*, int, sqlite_int64)"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^ self nbCall: #(int sqlite3_bind_int64 (sqlite3_stmt aStatement, int aColumn, sqlite_int64 anInteger))		module: self library! !!GASqlite3FFI methodsFor: 'private' stamp: 'PierceNg 4/11/2014 23:39'!apiBindNull: aStatement atColumn: aColumn	"int sqlite3_bind_null(sqlite3_stmt*, int)"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^ self nbCall: #(int sqlite3_bind_null (sqlite3_stmt aStatement, int aColumn))		module: self library! !!GASqlite3FFI methodsFor: 'private' stamp: 'PierceNg 4/11/2014 21:40'!apiBindParameterCount: aStatement	"int sqlite3_bind_parameter_count(sqlite3_stmt*)"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^ self nbCall: #(int sqlite3_bind_parameter_count (sqlite3_stmt aStatement))		module: self library! !!GASqlite3FFI methodsFor: 'private' stamp: 'PierceNg 4/12/2014 09:13'!apiBindParameterIndex: aStatement for: aName	"int sqlite3_bind_parameter_index(sqlite3_stmt*, const char* zName)"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^ self nbCall: #(int sqlite3_bind_parameter_index (sqlite3_stmt aStatement, String aName))		module: self library! !!GASqlite3FFI methodsFor: 'private' stamp: 'PierceNg 1/4/2014 21:42'!apiBindString: aStatement atColumn: aColumn with: aString with: anInteger with: anotherInteger	"int sqlite3_bind_text(sqlite3_stmt*, int, const char*, int, void(*)(void*))"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^ self nbCall: #(int sqlite3_bind_text (sqlite3_stmt aStatement, int aColumn, String aString, int anInteger, int anotherInteger))		module: self library! !!GASqlite3FFI methodsFor: 'private' stamp: 'PierceNg 7/31/2014 20:34'!apiChanges: handle	"int sqlite3_changes(sqlite3*)"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^ self nbCall: #(int sqlite3_changes (sqlite3 handle))		module: self library! !!GASqlite3FFI methodsFor: 'private' stamp: 'PierceNg 1/4/2014 21:35'!apiClearBindings: aStatement	"int sqlite3_clear_bindings(sqlite3_stmt*)"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^ self nbCall: #(int sqlite3_clear_bindings (sqlite3_stmt aStatement))		module: self library! !!GASqlite3FFI methodsFor: 'private' stamp: 'PierceNg 1/4/2014 21:07'!apiClose: handle	"int sqlite3_close_v2(sqlite3*)"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^ self nbCall: #(int sqlite3_close_v2 (sqlite3 handle))		module: self library! !!GASqlite3FFI methodsFor: 'private' stamp: 'PierceNg 2/23/2014 20:12'!apiColumnBlob: aStatement atColumn: aColumn	"const void *sqlite3_column_blob(sqlite3_stmt*, int)"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^ self nbCall: #(const void *sqlite3_column_blob (sqlite3_stmt aStatement, int aColumn))		module: self library! !!GASqlite3FFI methodsFor: 'private' stamp: 'PierceNg 1/4/2014 22:42'!apiColumnBytes: aStatement atColumn: aColumn	"int sqlite3_column_bytes(sqlite3_stmt*, int)"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^ self nbCall: #(int sqlite3_column_bytes (sqlite3_stmt aStatement, int aColumn))		module: self library! !!GASqlite3FFI methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 1/21/2015 19:10'!apiColumnCount: handle	"int sqlite3_column_count(sqlite3_stmt*)"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^ self nbCall: #(int sqlite3_column_count (sqlite3_stmt handle))		module: self library! !!GASqlite3FFI methodsFor: 'private' stamp: 'PierceNg 3/30/2014 17:07'!apiColumnDouble: aStatement atColumn: aColumn	"double sqlite3_column_double(sqlite3_stmt*, int)"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^ self nbCall: #(double sqlite3_column_double (sqlite3_stmt aStatement, int aColumn))		module: self library! !!GASqlite3FFI methodsFor: 'private' stamp: 'PierceNg 1/4/2014 23:31'!apiColumnInt: aStatement atColumn: aColumn	"int sqlite3_column_int(sqlite3_stmt*, int)"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^ self nbCall: #(int sqlite3_column_int (sqlite3_stmt aStatement, int aColumn))		module: self library! !!GASqlite3FFI methodsFor: 'private' stamp: 'PierceNg 3/30/2014 16:08'!apiColumnName: aStatement atColumn: aColumn	"const char *sqlite3_column_name(sqlite3_stmt*, int)"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^ self nbCall: #(String sqlite3_column_name (sqlite3_stmt aStatement, int aColumn))		module: self library! !!GASqlite3FFI methodsFor: 'private' stamp: 'PierceNg 1/4/2014 22:41'!apiColumnText: aStatement atColumn: aColumn	"const unsigned char *sqlite3_column_text(sqlite3_stmt*, int)"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^ self nbCall: #(String sqlite3_column_text (sqlite3_stmt aStatement, int aColumn))		module: self library! !!GASqlite3FFI methodsFor: 'private' stamp: 'PierceNg 3/30/2014 16:07'!apiColumnType: aStatement atColumn: aColumn	"int sqlite3_column_type(sqlite3_stmt*, int)"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^ self nbCall: #(int sqlite3_column_type (sqlite3_stmt aStatement, int aColumn))		module: self library! !!GASqlite3FFI methodsFor: 'private' stamp: 'PierceNg 3/30/2014 15:47'!apiDataCount: handle	"int sqlite3_data_count(sqlite3_stmt*)"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^ self nbCall: #(int sqlite3_data_count (sqlite3_stmt handle))		module: self library! !!GASqlite3FFI methodsFor: 'private' stamp: 'PierceNg 9/20/2014 16:23'!apiEnableSharedCache: int	"int sqlite3_enable_shared_cache(int)"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^ self nbCall: #(int sqlite3_enable_shared_cache (int))		module: self library! !!GASqlite3FFI methodsFor: 'private' stamp: 'GuillermoPolito 4/27/2015 13:56'!apiErrorMessage16: handle 	"const char *sqlite3_errmsg(sqlite3*)"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^ self nbCall: #(String sqlite3_errmsg16 (sqlite3 handle))		module: self library	! !!GASqlite3FFI methodsFor: 'private' stamp: 'GuillermoPolito 4/27/2015 13:58'!apiErrorMessage: handle 	"const char *sqlite3_errmsg(sqlite3*)"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^ self nbCall: #(String sqlite3_errmsg (sqlite3 handle))		module: self library	! !!GASqlite3FFI methodsFor: 'private' stamp: 'GuillermoPolito 4/27/2015 14:05'!apiExec: dbHandle withSQLText: anSQLText with: callback with: callbackData with: errorMessageBuffer	"int sqlite3_exec(sqlite3*, const char*, int (*callback), void*, char **)"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^ self nbCall: #(int sqlite3_exec (sqlite3 dbHandle, String anSQLText, void *callback, void *callbackData, char **errorMessageBuffer))		module: self library! !!GASqlite3FFI methodsFor: 'private' stamp: 'PierceNg 1/4/2014 21:06'!apiFinalize: handle	"int sqlite3_finalize(sqlite3_stmt*)"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^ self nbCall: #(int sqlite3_finalize (sqlite3_stmt handle))		module: self library! !!GASqlite3FFI methodsFor: 'private' stamp: 'GuillermoPolito 4/24/2015 14:25'!apiGetAutocommit: handle	"int sqlite3_get_autocommit(sqlite3*);"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^ self nbCall: #(int sqlite3_get_autocommit (sqlite3 handle))		module: self library! !!GASqlite3FFI methodsFor: 'private' stamp: 'GuillermoPolito 4/20/2015 17:48'!apiLastInsertRowId: handle 	"sqlite3_int64 sqlite3_last_insert_rowid(sqlite3*);"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^ self nbCall: #(int sqlite3_last_insert_rowid (sqlite3 handle))		module: self library	! !!GASqlite3FFI methodsFor: 'private' stamp: 'GuillermoPolito 4/27/2015 13:40'!apiOpen: filename via: handle	"int sqlite3_open(const char*, sqlite3**)"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^ self nbCall: #(int sqlite3_open (String filename, sqlite3* handle))		module: self library! !!GASqlite3FFI methodsFor: 'private' stamp: 'GuillermoPolito 4/27/2015 13:36'!apiPrepare: dbHandle withSQLText16: anSQLText with: textSize with: sHandle with: tail	"int sqlite3_prepare_v2(sqlite3*, const char*, int, sqlite3_stmt**, const char **)"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^ self nbCall: #(int sqlite3_prepare16_v2 (sqlite3 dbHandle, String anSQLText, int textSize, sqlite3_stmt* sHandle, const char** tail))		module: self library	! !!GASqlite3FFI methodsFor: 'private' stamp: 'PierceNg 1/4/2014 21:25'!apiPrepare: dbHandle withSQLText: anSQLText with: textSize with: sHandle with: tail	"int sqlite3_prepare_v2(sqlite3*, const char*, int, sqlite3_stmt**, const char **)"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^ self nbCall: #(int sqlite3_prepare_v2 (sqlite3 dbHandle, String anSQLText, int textSize, sqlite3_stmt* sHandle, const char** tail))		module: self library	! !!GASqlite3FFI methodsFor: 'private' stamp: 'PierceNg 1/4/2014 23:13'!apiReset: handle	"int sqlite3_reset(sqlite3_stmt*)"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^ self nbCall: #(int sqlite3_reset (sqlite3_stmt handle))		module: self library! !!GASqlite3FFI methodsFor: 'private' stamp: 'PierceNg 1/4/2014 23:12'!apiStep: handle	"int sqlite3_step(sqlite3_stmt*)"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^ self nbCall: #(int sqlite3_step (sqlite3_stmt handle))		module: self library! !!GASqlite3FFI methodsFor: 'private' stamp: 'PierceNg 2/26/2014 21:14'!apiThreadsafe	"int sqlite3_threadsafe(void)"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^ self nbCall: #(int sqlite3_threadsafe ())		module: self library! !!GASqlite3FFI methodsFor: 'private' stamp: 'PierceNg 7/31/2014 20:38'!apiTotalChanges: handle	"int sqlite3_total_changes(sqlite3*)"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^ self nbCall: #(int sqlite3_total_changes (sqlite3 handle))		module: self library! !!GASqlite3FFI methodsFor: 'private' stamp: 'PierceNg 8/2/2014 09:27'!apiTrace: handle with: callback with: appdata	"void *sqlite3_trace(sqlite3* void(*)(void*, const char*), void*)"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>	^ self nbCallout 		options: #( optMayGC );		function: #(void* sqlite3_trace (sqlite3 handle, NBSQLite3TraceCallback callback, NBExternalAddress appdata))		module: self library! !!GASqlite3FFI methodsFor: 'public API' stamp: 'PierceNg 4/11/2014 21:41'!bindParameterCount: aStatementHandle	^ self apiBindParameterCount: aStatementHandle	! !!GASqlite3FFI methodsFor: 'public API' stamp: 'PierceNg 4/12/2014 09:14'!bindParameterIndex: aStatementHandle for: aName	^ self apiBindParameterIndex: aStatementHandle for: aName	! !!GASqlite3FFI methodsFor: 'public API' stamp: 'PierceNg 2/23/2014 20:14'!blobFrom: aStatement at: aColumn	| address size |		address := self apiColumnBlob: aStatement atColumn: aColumn.	size := self apiColumnBytes: aStatement atColumn: aColumn.	^ (((NBExternalArray ofType: NBCharacterType) onAddress: address size: size) postCopy; yourself) address! !!GASqlite3FFI methodsFor: 'public API' stamp: 'PierceNg 7/31/2014 20:35'!changes: aHandle		^ self apiChanges: aHandle	! !!GASqlite3FFI methodsFor: 'private' stamp: 'GuillermoPolito 4/16/2015 12:23'!checkForOk: aValue on: aHandle	(aValue = OK)		ifFalse: [ 			(aValue = BUSY)				ifTrue: [ self signal: GASqlite3Busy with: aValue on: aHandle ].			(aValue = LOCKED)				ifTrue: [ self signal: GASqlite3Locked with: aValue on: aHandle ].			(aValue = MISUSE)				ifTrue: [ self signal: GASqlite3Misuse with: aValue on: aHandle ].							self signal: GASqlite3Error with: aValue on: aHandle ].		^ OK! !!GASqlite3FFI methodsFor: 'public API' stamp: 'PierceNg 4/5/2014 13:38'!clearBindings: sHandle on: dbHandle		^ self checkForOk: (self apiClearBindings: sHandle) on: dbHandle	! !!GASqlite3FFI methodsFor: 'public API' stamp: 'PierceNg 4/5/2014 13:38'!close: aHandle		^ self checkForOk: (self apiClose: aHandle) on: aHandle	! !!GASqlite3FFI methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 1/21/2015 19:10'!columnCount: aStatementHandle	^ self apiColumnCount: aStatementHandle	! !!GASqlite3FFI methodsFor: 'public API' stamp: 'PierceNg 3/30/2014 16:10'!columnNameFrom: aStatement at: aColumn	^ self apiColumnType: aStatement atColumn: aColumn! !!GASqlite3FFI methodsFor: 'public API' stamp: 'PierceNg 3/30/2014 16:10'!columnTypeFrom: aStatement at: aColumn	^ self apiColumnType: aStatement atColumn: aColumn! !!GASqlite3FFI methodsFor: 'public API' stamp: 'PierceNg 3/30/2014 15:55'!dataValuesAvailable: aStatementHandle	^ self apiDataCount: aStatementHandle	! !!GASqlite3FFI methodsFor: 'public API' stamp: 'PierceNg 2/24/2014 20:44'!execute: anSQLText on: aDBHandle	| null |		null := NBExternalAddress null.	^ self checkForOk: (self apiExec: aDBHandle 							withSQLText: anSQLText							with: null							with: null							with: null)		 on: aDBHandle	! !!GASqlite3FFI methodsFor: 'public API' stamp: 'PierceNg 4/5/2014 13:38'!finalize: aStatementHandle on: aDBHandle		^ self checkForOk: (self apiFinalize: aStatementHandle) on: aDBHandle	! !!GASqlite3FFI methodsFor: 'public API' stamp: 'PierceNg 3/30/2014 16:54'!floatFrom: aStatement at: aColumn	^ self apiColumnDouble: aStatement atColumn: aColumn! !!GASqlite3FFI methodsFor: 'public API' stamp: 'GuillermoPolito 4/24/2015 14:26'!getAutoCommit: aHandle	^ self apiGetAutocommit: aHandle! !!GASqlite3FFI methodsFor: 'public API' stamp: 'GuillermoPolito 4/24/2015 14:25'!getAutocommit: aHandle	^ self apiGetAutocommit: aHandle! !!GASqlite3FFI methodsFor: 'public API' stamp: 'PierceNg 1/4/2014 22:53'!integerFrom: aStatement at: aColumn	^ self apiColumnInt: aStatement atColumn: aColumn! !!GASqlite3FFI methodsFor: 'public API' stamp: 'GuillermoPolito 4/20/2015 17:48'!lastInsertRowId: aHandle		^ self apiLastInsertRowId: aHandle	! !!GASqlite3FFI methodsFor: 'accessing' stamp: 'PierceNg 1/3/2014 14:01'!library	| platform |		platform := NativeBoost forCurrentPlatform class.	platform = NativeBoostMac32 ifTrue: [ ^ #sqlite3 ].	^ 'sqlite3'! !!GASqlite3FFI methodsFor: 'public API' stamp: 'PierceNg 3/30/2014 16:12'!nameFor: aStatement at: aColumn	^ self apiColumnName: aStatement atColumn: aColumn! !!GASqlite3FFI methodsFor: 'public API' stamp: 'PierceNg 4/5/2014 13:37'!open: aFilename via: aHandle		^ self checkForOk: (self apiOpen: aFilename via: aHandle) on: aHandle	! !!GASqlite3FFI methodsFor: 'private - conversion' stamp: 'TorstenBergmann 1/17/2015 00:11'!pharoStringToUTF8: aPharoString	"Converts from Pharo Multibyte Characters to SQLite3 UTF-8 storage format"		^ZnUTF8Encoder new encodeString: aPharoString! !!GASqlite3FFI methodsFor: 'public API' stamp: 'PierceNg 4/5/2014 13:39'!prepare: aStatementHandle on: aDBHandle with: anSQLText	^ self checkForOk: (self apiPrepare: aDBHandle 							withSQLText: anSQLText							with: (anSQLText size)							with: aStatementHandle							with: (NBExternalAddress null))		 on: aDBHandle	! !!GASqlite3FFI methodsFor: 'public API' stamp: 'GuillermoPolito 4/27/2015 13:51'!prepare: aStatementHandle on: aDBHandle withUTF16String: aSQLText	^ self checkForOk: (self apiPrepare: aDBHandle 							withSQLText16: aSQLText							with: (aSQLText size)							with: aStatementHandle							with: (NBExternalAddress null))		 on: aDBHandle	! !!GASqlite3FFI methodsFor: 'public API' stamp: 'PierceNg 4/5/2014 13:39'!reset: aStatementHandle on: aDBHandle		^ self checkForOk: (self apiReset: aStatementHandle) on: aDBHandle	! !!GASqlite3FFI methodsFor: 'private' stamp: 'PierceNg 2/27/2014 22:21'!signal: exceptionClass with: value on: handle	exceptionClass new resultCode: value; signal: (self apiErrorMessage: handle)! !!GASqlite3FFI methodsFor: 'public API' stamp: 'PierceNg 1/4/2014 23:22'!step: aStatementHandle		^ self apiStep: aStatementHandle	! !!GASqlite3FFI methodsFor: 'public API' stamp: 'GuillermoPolito 4/27/2015 11:24'!stringFrom: aStatement at: aColumn	^ self apiColumnText: aStatement atColumn: aColumn! !!GASqlite3FFI methodsFor: 'accessing' stamp: 'PierceNg 2/26/2014 21:15'!threadsafe	^ self apiThreadsafe! !!GASqlite3FFI methodsFor: 'public API' stamp: 'PierceNg 7/31/2014 20:39'!totalChanges: aHandle		^ self apiTotalChanges: aHandle	! !!GASqlite3FFI methodsFor: 'public API' stamp: 'PierceNg 8/2/2014 09:27'!trace: handle with: callback with: appdata	^ self apiTrace: handle with: callback with: appdata! !!GASqlite3FFI methodsFor: 'public API' stamp: 'PierceNg 4/12/2014 00:07'!typeFor: aStatement at: aColumn	^ DataTypeMap at: (self apiColumnType: aStatement atColumn: aColumn)! !!GASqlite3FFI methodsFor: 'public API' stamp: 'PierceNg 2/23/2014 16:15'!with: aStatement at: aColumn putBlob: aByteArray	^ self apiBindBlob: aStatement atColumn: aColumn with: aByteArray with: aByteArray size with: -1 ! !!GASqlite3FFI methodsFor: 'public API' stamp: 'PierceNg 3/30/2014 16:57'!with: aStatement at: aColumn putFloat: aFloat	^ self apiBindDouble: aStatement atColumn: aColumn with: aFloat! !!GASqlite3FFI methodsFor: 'public API' stamp: 'PierceNg 1/4/2014 21:39'!with: aStatement at: aColumn putInteger: anInteger	^ self apiBindInteger: aStatement atColumn: aColumn with: anInteger   ! !!GASqlite3FFI methodsFor: 'public API' stamp: 'TorstenBergmann 1/17/2015 00:14'!with: aStatement at: aColumn putString: aString	^ self apiBindString: aStatement atColumn: aColumn with: (self pharoStringToUTF8: aString) with: -1 with: -1 ! !!GASqlite3FFI methodsFor: 'public API' stamp: 'PierceNg 4/11/2014 23:41'!with: aStatement putNullAt: aColumn 	^ self apiBindNull: aStatement atColumn: aColumn! !!GASqlite3Row methodsFor: 'accessing' stamp: 'GuillermoPolito 4/7/2015 14:00'!at: aKey 	^ self at: aKey ifAbsent: [  ]! !!GASqlite3Row methodsFor: 'accessing' stamp: 'GuillermoPolito 4/7/2015 14:00'!at: aKey ifAbsent: aBlock	^ data at: aKey ifAbsent: aBlock! !!GASqlite3Row methodsFor: 'accessing' stamp: 'GuillermoPolito 4/7/2015 14:00'!at: aKey put: anObject	data at: aKey put: anObject! !!GASqlite3Row methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/7/2015 14:00'!atIndex: anInteger 		^ self at: anInteger! !!GASqlite3Row methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/7/2015 14:00'!atName: aKey 	^ self at: (resultSet indexOfColumnName: aKey) ifAbsent: [  ]! !!GASqlite3Row methodsFor: 'reflective operations' stamp: 'GuillermoPolito 4/7/2015 14:00'!doesNotUnderstand: aMessage	^self 		at: aMessage selector asString 		ifAbsent: [ super doesNotUnderstand: aMessage ]! !!GASqlite3Row methodsFor: 'initialization' stamp: 'GuillermoPolito 4/7/2015 14:00'!initialize	"Initializes the receiver"		super initialize.	data := Dictionary new! !!GASqlite3Row methodsFor: 'as yet unclassified' stamp: 'GuillermoPolito 4/7/2015 14:00'!resultSet: aResultSet	resultSet := aResultSet! !!GASqlite3Driver class methodsFor: 'drivers' stamp: 'GuillermoPolito 1/21/2015 17:58'!driverId	^ 'sqlite3'! !!GASqlite3Driver class methodsFor: 'instance-creation' stamp: 'GuillermoPolito 4/27/2015 11:14'!fromConnectionString: aConnectionString	| database |	database := aConnectionString host.	^ self new		connectionString: aConnectionString;		database: (database = 'memory' ifTrue: [ ':memory:' ] ifFalse: [ database ]);		yourself! !!GASqlite3Driver class methodsFor: 'initialize' stamp: 'GuillermoPolito 4/17/2015 14:15'!initialize	self subscribeDriver! !!GASqlite3Driver class methodsFor: 'tests' stamp: 'GuillermoPolito 4/17/2015 17:37'!newFixture		^ GADriverSQLiteTestFixture new! !!GASqlite3Driver class methodsFor: 'encoding' stamp: 'GuillermoPolito 4/29/2015 12:08'!supportsEncoding: anEncoding		^ (ZnCharacterEncoder newForEncoding: anEncoding) = ZnUTF8Encoder new! !!GASqlite3Driver methodsFor: 'accessing' stamp: 'GuillermoPolito 1/21/2015 18:11'!backend		^ 'sqlite3'! !!GASqlite3Driver methodsFor: 'public' stamp: 'GuillermoPolito 4/16/2015 12:22'!basicExecute: anSQLText	^ GASqlite3FFI current execute: anSQLText on: handle! !!GASqlite3Driver methodsFor: 'transactions' stamp: 'GuillermoPolito 3/25/2015 16:38'!beginTransaction	^ self basicExecute: 'begin'! !!GASqlite3Driver methodsFor: 'connection' stamp: 'GuillermoPolito 4/16/2015 12:22'!close	handle isNil ifFalse: [ GASqlite3FFI current close: handle ].	self unregister.	handle := nil.	isOpen := false! !!GASqlite3Driver methodsFor: 'transactions' stamp: 'GuillermoPolito 3/25/2015 16:38'!commitTransaction	^ self basicExecute: 'commit'! !!GASqlite3Driver methodsFor: 'connection' stamp: 'GuillermoPolito 4/16/2015 12:22'!connect		((GASqlite3FFI current open: database via: handle) = 0) 		ifTrue: [ 			isOpen := true.			self register.			^ self ]		ifFalse: [			| err |			err := GASqlite3FFI current apiErrorMessage: handle.			GASqlite3FFI current apiClose: handle.			GASqlite3Error signal: err ]! !!GASqlite3Driver methodsFor: 'query' stamp: 'GuillermoPolito 4/16/2015 12:22'!createStatement	^ GASqlite3Statement new connection: self; yourself! !!GASqlite3Driver methodsFor: 'query' stamp: 'GuillermoPolito 4/24/2015 17:10'!createStatement: aString 		^ self createStatement		statementString: aString;		yourself! !!GASqlite3Driver methodsFor: 'accessing' stamp: 'GuillermoPolito 1/23/2015 11:07'!database	^ database! !!GASqlite3Driver methodsFor: 'accessing' stamp: 'GuillermoPolito 1/21/2015 18:03'!database: aDatabase		database := aDatabase! !!GASqlite3Driver methodsFor: 'transactions' stamp: 'GuillermoPolito 4/24/2015 16:53'!defaultValueAutoCommit		^ true! !!GASqlite3Driver methodsFor: 'query' stamp: 'GuillermoPolito 3/25/2015 16:04'!execute: aQuery	^ self execute: aQuery with: #()! !!GASqlite3Driver methodsFor: 'query' stamp: 'GuillermoPolito 4/16/2015 12:22'!execute: aQuery with: anObject	^ GASqlite3ResultSet new execute: aQuery with: anObject on: self! !!GASqlite3Driver methodsFor: 'finalization' stamp: 'GuillermoPolito 3/25/2015 16:58'!finalize	self isConnected ifTrue: [ self close ].! !!GASqlite3Driver methodsFor: 'accessing' stamp: 'GuillermoPolito 3/25/2015 16:14'!handle	^ handle! !!GASqlite3Driver methodsFor: 'transactions' stamp: 'GuillermoPolito 4/24/2015 14:26'!hasAutoCommit		^ (GASqlite3FFI current getAutoCommit: self handle) == 1! !!GASqlite3Driver methodsFor: 'initialize-release' stamp: 'GuillermoPolito 4/17/2015 14:18'!initialize	super initialize.	handle := GASQLite3DatabaseExternalObject new.	isOpen := false.! !!GASqlite3Driver methodsFor: 'testing' stamp: 'GuillermoPolito 3/25/2015 16:44'!isConnected	^ handle isNotNil and: [ isOpen ]! !!GASqlite3Driver methodsFor: 'testing' stamp: 'GuillermoPolito 1/23/2015 11:08'!isMemory		^ self database = ':memory:'! !!GASqlite3Driver methodsFor: 'test-support' stamp: 'GuillermoPolito 4/17/2015 10:56'!newFixture	^ GADriverSQLiteTestFixture new! !!GASqlite3Driver methodsFor: 'testing' stamp: 'GuillermoPolito 1/30/2015 16:08'!notBoundArgumentsFail		^ false! !!GASqlite3Driver methodsFor: 'query' stamp: 'GuillermoPolito 3/25/2015 16:13'!prepare: anSQLText 	| s |		s := self createStatement.	s statementString: anSQLText.	s prepare.	^ s! !!GASqlite3Driver methodsFor: 'transactions' stamp: 'GuillermoPolito 3/25/2015 16:39'!rollbackTransaction	^ self basicExecute: 'rollback'! !!GASqlite3Driver methodsFor: 'testing' stamp: 'GuillermoPolito 4/27/2015 17:28'!supportsAutomaticQueryEncoding		^ false! !!GASqlite3Driver methodsFor: 'testing' stamp: 'GuillermoPolito 4/24/2015 11:19'!supportsCursoredFetch		^ false! !!GASqlite3Driver methodsFor: 'testing' stamp: 'GuillermoPolito 1/23/2015 11:05'!supportsPreparedStatements	^ true! !!GASqlite3Driver methodsFor: 'testing' stamp: 'GuillermoPolito 4/20/2015 17:51'!supportsRetrievingGeneratedKeys	^ true! !"Garage-Sqlite3"!----QUIT----2017-04-30T20:57:31.699785+02:00 Pharo5.0.image priorSource: 723889!----QUIT----2017-05-03T02:00:18.165936+02:00 Pharo5.0.image priorSource: 2276486!!WebService methodsFor: 'connection' stamp: 'Anonymous 5/3/2017 02:56' prior: 34022430!restRoute	"route the method"|teapot| 	teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 5432. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');		GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; start.! !!WebService methodsFor: 'connection' stamp: 'Anonymous 5/3/2017 02:57' prior: 35831172!restRoute	"route the method"|teapot| 	teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');		GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; start.! !!WebService methodsFor: 'connection' stamp: 'Anonymous 5/3/2017 14:29' prior: 34022430!restRoute	"route the method"|teapot| 	teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');		GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)];start.! !!WebService methodsFor: 'connection' stamp: 'Anonymous 5/3/2017 15:00' prior: 35832532!restRoute	"route the method"|teapot| 	teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');		GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		PUT: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'INSERT INTO Emprunt (id_materiel, id_emprunteur, dateEmprunt, heureEmprunt, etatEmprunt) VALUES (1,1,12/12/17,12:00,neuf)'];start.! !!WebService methodsFor: 'connection' stamp: 'Anonymous 5/3/2017 15:02' prior: 35833453!restRoute	"route the method"|teapot| 	teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');		GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		PUT: '/materiel/<id>/<id_materiel>' -> [ :req |      (WebService new) sqlQuery: 'INSERT INTO Emprunt (id_materiel, id_emprunteur, dateEmprunt, heureEmprunt, etatEmprunt) VALUES (1,1,12/12/17,12:00,neuf)'];start.! !!WebService methodsFor: 'connection' stamp: 'Anonymous 5/3/2017 15:04' prior: 35834329!restRoute	"route the method"|teapot| 	teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');		GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		PUT: '/materielll' -> [ :req |      (WebService new) sqlQuery: 'INSERT INTO Emprunt (id_materiel, id_emprunteur, dateEmprunt, heureEmprunt, etatEmprunt) VALUES (1,1,12/12/17,12:00,neuf)'];start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 15:05' prior: 35835219!restRoute	"route the method"|teapot| 	teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');		GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		PUT: '/materiel/<id>/<id_materiel>' -> [ :req |      (WebService new) sqlQuery: 'INSERT INTO Emprunt (id_materiel, id_emprunteur, dateEmprunt, heureEmprunt, etatEmprunt) VALUES (1,1,12/12/17,12:00,neuf)'];start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 15:17' prior: 35836097!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');		GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		PUT: '/materiel/<id>/<id_materiel>' -> [:req | | emprunt |			emprunt := {'1' -> (req at: #id).			'1994' -> (req at: #id_emprunteur)} asDictionary.			emprunts at: (req at: #id) put: emprunt];start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 15:19' prior: 35836992!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');		GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		PUT: '/materiel/<id>' -> [:req | | emprunt |			emprunt := {'1' -> (req at: #id).			'1994' -> (req at: #id_emprunteur)} asDictionary.			emprunts at: (req at: #id) put: emprunt];start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 15:23' prior: 35837914!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');		GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		PUT: '/materiel/<id>' -> [:req | | emprunt |			emprunt := {'id' -> (req at: #id).			'id_emprunteur' -> (req at: #id_emprunteur)} asDictionary.			emprunts at: (req at: #id) put: emprunt];start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 15:25' prior: 35838822!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');		GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		PUT: '/materiel/<id>' -> [:req | | emprunt |			emprunt := {'id' -> (req at: #id).			'id_emprunteur' -> (req at: #id_emprunteur)} asDictionary.			emprunts at: (req at: #id) put: emprunt]; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 15:32' prior: 35839740!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');		GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> emprunts;		PUT: '/emprunts/<id>' -> [:req | | emprunt |			emprunt := {'id' -> (req at: #id).			'id_emprunteur' -> (req at: #id_emprunteur)} asDictionary.			emprunts at: (req at: #id) put: emprunt]; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 15:34' prior: 35840659!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> emprunts;		PUT: '/emprunts/<id>' -> [:req | | emprunt |			emprunt := {'id' -> (req at: #id).			'id_emprunteur' -> (req at: #id_emprunteur)} asDictionary.			emprunts at: (req at: #id) put: emprunt]; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 15:37' prior: 35841609!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> emprunts;				PUT: '/emprunts/<id>' -> [:req | | emprunt |			emprunt := {'id' -> (req at: #id).			'id_emprunteur' -> (req at: #id_emprunteur)} asDictionary.			emprunts at: (req at: #id) put: emprunt]; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 15:41' prior: 35842365!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> emprunts;				PUT: '/emprunts/<id>' -> [:req | | emprunt |			emprunt := {'id' -> (req at: #id).			'id_emprunteur' -> (req at: #id_emprunteur)} asDictionary.			emprunts at: (req at: #id) put: emprunt]; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 15:47' prior: 35843323!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> emprunts;				PUT: '/emprunts/<id>' -> [:req | | emprunt |			emprunt := {'id' -> (req at: #id)} asDictionary.			emprunts at: (req at: #id) put: emprunt]; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 15:47' prior: 35844280!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> emprunts;				PUT: '/emprunts/<id>' -> [:req | | emprunt |			emprunt := {			'id_emprunteur' -> (req at: #id_emprunteur)} asDictionary.			emprunts at: (req at: #id) put: emprunt]; start.! !----QUIT----2017-05-03T15:48:12.186647+02:00 Pharo5.0.image priorSource: 2276568!!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 16:17' prior: 35845189!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from Emprunt');				PUT: '/emprunts/<id>' -> [:req | | emprunt |			emprunt := {			'id_emprunteur' -> (req at: #id_emprunteur)} asDictionary.			emprunts at: (req at: #id) put: emprunt]; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 16:19' prior: 35846207!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				PUT: '/emprunts/<id>' -> [:req | | emprunt |			emprunt := {			'id_emprunteur' -> (req at: #id_emprunteur)} asDictionary.			emprunts at: (req at: #id) put: emprunt]; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 16:28' prior: 35847186!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				PUT: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'INSERT INTO (id, id_emprunteur) VALUES (1,1994)']; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 16:29' prior: 35848167!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				PUT: '/emprunts/<id>' -> [ :req |      (WebService new) sqlQuery: 'INSERT INTO (id, id_emprunteur) VALUES (1,1994)']; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 16:31' prior: 35849099!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				PUT: '/emprunts' -> [ :req |      (WebService new) sqlQuery: 'INSERT INTO (id, id_emprunteur) VALUES (1,1994)']; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 16:31' prior: 35850031!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				PUT: '/emprunt' -> [ :req |      (WebService new) sqlQuery: 'INSERT INTO (id, id_emprunteur) VALUES (1,1994)']; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 16:44' prior: 35850958!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				PUT: '/emprunt   ' ->       ((WebService new) sqlQuery: 'INSERT INTO (id, id_emprunteur) VALUES (1,1994)'); start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 16:45' prior: 35851884!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				PUT: '/emprunt' ->       ((WebService new) sqlQuery: 'INSERT INTO (id, id_emprunteur) VALUES (1,1994)'); start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 16:47' prior: 35852806!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				PUT: '/emprunt' ->       ((WebService new) sqlQuery: 'INSERT INTO (id, id_emprunteur) VALUES (1,1994)'); start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 16:48' prior: 35853725!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				PUT: '/emprunt' ->       ((WebService new) sqlQuery: 'INSERT INTO (id, id_emprunteur) VALUES (1,1994)'); start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 16:48' prior: 35854644!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				PUT: '/emprunt' ->       ((WebService new) sqlQuery: 'INSERT INTO (id, id_emprunteur) VALUES (1,1994)'); start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 16:49' prior: 35855563!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				PUT: '/emprunt' ->       ((WebService new) sqlQuery: 'INSERT INTO (id, id_emprunteur) VALUES (1,1994)'); start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 16:55' prior: 35856482!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				PUT: '/emprunt' ->       ((WebService new) sqlQuery: 'INSERT INTO (id, id_emprunteur) VALUES (''1'',''1994'')'); start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 16:57' prior: 35857401!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				PUT: '/emprunt' ->       ((WebService new) sqlQuery: 'INSERT INTO (id_emprunteur) VALUES (''1994'')'); start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 16:58' prior: 35858328!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				PUT: '/emprunt' ->       ((WebService new) sqlQuery: 'INSERT INTO Emprunt (id_emprunteur) VALUES (''1994'')'); start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 16:59' prior: 35859245!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				PUT: '/emprunt' ->       ((WebService new) sqlQuery: 'INSERT INTO Emprunt (id_emprunteur) VALUES (''1994'');'); start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 16:59' prior: 35860170!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				PUT: '/emprunt' ->       ((WebService new) sqlQuery: 'INSERT INTO Emprunt (id_emprunteur) VALUES (1994);'); start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 17:00' prior: 35861096!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				PUT: '/emprunt' ->       ((WebService new) sqlQuery: 'INSERT INTO Emprunt (id_emprunteur) VALUES (1994)'); start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 17:01' prior: 35862018!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				PUT: '/emprunt' ->       ((WebService new) sqlQuery: 'INSERT INTO Emprunt (id_emprunteur) VALUES (''1994'')'); start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 17:01' prior: 35862939!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				PUT: '/emprunt' -> ((WebService new) sqlQuery: 'INSERT INTO Emprunt (id_emprunteur) VALUES (''1994'')'); start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 17:07' prior: 35863864!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				PUT: '/emprunt' -> ((WebService new) sqlQuery: 'INSERT INTO Emprunt (id_emprunteur) VALUES ("1994")'); start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 17:07' prior: 35864782!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				PUT: '/emprunt' -> ((WebService new) sqlQuery: 'INSERT INTO Emprunt (id_emprunteur) VALUES ("1994")'); start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 17:07' prior: 35865698!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				PUT: '/emprunt' -> ((WebService new) sqlQuery: 'INSERT INTO Emprunt (id_emprunteur) VALUES ("1994")'); start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 17:07' prior: 35866614!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				PUT: '/emprunt' -> ((WebService new) sqlQuery: 'INSERT INTO Emprunt (id_emprunteur) VALUES ("1994")'); start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 17:08' prior: 35867530!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				PUT: '/emprunt' -> ((WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id_emprunteur) VALUES ("1994")'); start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 17:08' prior: 35868446!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				PUT: '/emprunt' -> ((WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id_emprunteur) VALUES (''1994'')'); start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 17:13' prior: 35869364!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				PUT: '/emprunt' -> ((WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_emprunteur) VALUES (''1'',''1994'')'); start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 17:16' prior: 35870284!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				PUT: '/emprunt/<id>' -> ((WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_emprunteur) VALUES (''1'',''1994'')'); start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 17:16' prior: 35871213!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				PUT: '/emprunt/<id>' -> [ :req |			(WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_emprunteur) VALUES (''1'',''1994'')']; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 17:17' prior: 35872147!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				PUT: '/emprunt/<id>' -> [ :req |			(WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_emprunteur) VALUES (''2'',''1994'')']; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 17:18' prior: 35873092!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				PUT: '/emprunt' -> [ :req |			(WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_emprunteur) VALUES (''2'',''1994'')']; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 17:23' prior: 35874037!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				PUT: '/emprunt' -> [ :req |			(WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_emprunteur) VALUES (''2'',''1994'')']; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 17:24' prior: 35874977!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				PUT: '/emprunt/<id>' -> [ :req |			(WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_emprunteur) VALUES (''2'',''1994'')']; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 17:24' prior: 35875917!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				PUT: '/emprunt/<id>' -> [ :req |			(WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_emprunteur) VALUES (''', (req at: #id) , ''',''1994'')']; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 17:27' prior: 35876862!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				PUT: '/emprunt/<id>' -> [ :req |			(WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_emprunteur) VALUES (''', (req at: #id) , ''',''1994'')']; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 17:33' prior: 35877826!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				GET: '/emprunt/<id>' -> [ :req |			(WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_emprunteur) VALUES (''', (req at: #id) , ''',''1994'')']; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 18:15' prior: 35878790!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				GET: '/emprunt/<id>/<id_materiel>/<id_emprunteur>/<dateEmprunt>/<heureEmprunt>/<etatEmprunt>' -> [ :req |			(WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_emprunteur) VALUES (''', (req at: #id) , ''',''1994'')']; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 18:18' prior: 35879754!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				GET: '/emprunt/<id>/<id_materiel>/<id_emprunteur>/<dateEmprunt>/<heureEmprunt>/<etatEmprunt>' -> [ :req |			(WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_emprunteur) VALUES (''', (req at: #id) , ''',''',(req at: #id),''',''',(req at: #id),''',''',(req at: #id),''',''',(req at: #id),''',''',(req at: #id),''')']; start.! !----SNAPSHOT----2017-05-03T18:19:04.756296+02:00 Pharo5.0.image priorSource: 2291598!!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 18:20' prior: 35880791!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				GET: '/emprunt/<id>/<id_materiel>/<id_emprunteur>/<dateEmprunt>/<heureEmprunt>/<etatEmprunt>' -> [ :req |			(WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_emprunteur) VALUES (''', (req at: #id) , ''',''',(req at: #id_materiel),''',''',(req at: #id_emprunteur),''',''',(req at: #dateEmprunt),''',''',(req at: #heureEmprunt),''',''',(req at: #etatEmprunt),''')']; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 18:36' prior: 35882016!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				GET: '/emprunt/<id>/<id_materiel>/<id_emprunteur>/<dateEmprunt>/<heureEmprunt>/<etatEmprunt>' -> [ :req |			(WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_materiel,id_emprunteur,dateEmprunt,heureEmprunt,heureEmprunt,etatEmprunt) VALUES (''', (req at: #id) , ''',''',(req at: #id_materiel),''',''',(req at: #id_emprunteur),''',''',(req at: #dateEmprunt),''',''',(req at: #heureEmprunt),''',''',(req at: #etatEmprunt),''')']; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 18:40' prior: 35883202!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				GET: '/emprunt/<id>/<id_materiel>/<id_emprunteur>/<dateEmprunt>/<heureEmprunt>/<etatEmprunt>' -> [ :req |			(WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_materiel,id_emprunteur,dateEmprunt,heureEmprunt,etatEmprunt) VALUES (''', (req at: #id) , ''',''',(req at: #id_materiel),''',''',(req at: #id_emprunteur),''',''',(req at: #dateEmprunt),''',''',(req at: #heureEmprunt),''',''',(req at: #etatEmprunt),''')']; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 18:43' prior: 35880791!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				GET: '/emprunt/<id>/<id_materiel>/<id_emprunteur>/<dateEmprunt>/<heureEmprunt>/<etatEmprunt>' -> [ :req |			(WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_materiel,id_Emprunteur,dateEmprunt,heureEmprunt,etatEmprunt) VALUES (''', (req at: #id) , ''',''',(req at: #id),''',''',(req at: #id),''',''',(req at: #id),''',''',(req at: #id),''',''',(req at: #id),''')']; start.! !----SNAPSHOT----2017-05-03T18:43:32.662727+02:00 Pharo5.0.image priorSource: 2327403!!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 18:44' prior: 35885685!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				GET: '/emprunt/<id>/<id_materiel>/<id_emprunteur>/<dateEmprunt>/<heureEmprunt>/<etatEmprunt>' -> [ :req |			(WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_materiel,id_emprunteur,dateEmprunt,heureEmprunt,etatEmprunt) VALUES (''', (req at: #id) , ''',''',(req at: #id),''',''',(req at: #id),''',''',(req at: #id),''',''',(req at: #id),''',''',(req at: #id),''')']; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 18:45' prior: 35886959!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				GET: '/emprunt/<id>/<id_materiel>/<id_emprunteur>/<dateEmprunt>/<heureEmprunt>/<etatEmprunt>' -> [ :req |			(WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_materiel,id_emprunteur,dateEmprunt,heureEmprunt,etatEmprunt) VALUES (''', (req at: #id) , ''',''',(req at: #id_materiel),''',''',(req at: #id_emprunteur),''',''',(req at: #dateEmprunt),''',''',(req at: #heureEmprunt),''',''',(req at: #etatEmprunt),''')']; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 18:47' prior: 35885685!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				GET: '/emprunt/<id>/<id_materiel>/<id_emprunteur>/<dateEmprunt>/<heureEmprunt>/<etatEmprunt>' -> [ :req |			(WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_materiel,id_Emprunteur,dateEmprunt,heureEmprunt,etatEmprunt) VALUES (''', (req at: #id) , ''',''',(req at: #id_materiel),''',''',(req at: #id_Emprunteur),''',''',(req at: #dateEmprunt),''',''',(req at: #heureEmprunt),''',''',(req at: #etatEmprunt),''')']; start.! !----SNAPSHOT----2017-05-03T18:47:20.988984+02:00 Pharo5.0.image priorSource: 2332346!!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 18:56' prior: 35889381!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				GET: '/emprunt/<id>/<id_materiel>/<id_emprunteur>/<dateEmprunt>/<heureEmprunt>/<etatEmprunt>' -> [ :req |			(WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_materiel,id_emprunteur,dateEmprunt,heureEmprunt,etatEmprunt) VALUES (''', (req at: #id) , ''',''',(req at: #id_materiel),''',''',(req at: #id_Emprunteur),''',''',(req at: #dateEmprunt),''',''',(req at: #heureEmprunt),''',''',(req at: #etatEmprunt),''')']; start.! !----SNAPSHOT----2017-05-03T18:56:37.4841+02:00 Pharo5.0.image priorSource: 2336090!!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 18:57' prior: 35890703!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				GET: '/emprunt/<id>/<id_materiel>/<id_emprunteur>/<dateEmprunt>/<heureEmprunt>/<etatEmprunt>' -> [ :req |			(WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_materiel,id_emprunteur,dateEmprunt,heureEmprunt,etatEmprunt) VALUES (''', (req at: #id) , ''',''',(req at: #id_materiel),''',''',(req at: #id_emprunteur),''',''',(req at: #dateEmprunt),''',''',(req at: #heureEmprunt),''',''',(req at: #etatEmprunt),''')']; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 19:30' prior: 35892023!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				GET: '/emprunt/<id>/<id_materiel>/<id_emprunteur>/<heureEmprunt>/<etatEmprunt>' -> [ :req |			(WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_materiel,id_emprunteur,heureEmprunt,etatEmprunt) VALUES (''', (req at: #id) , ''',''',(req at: #id_materiel),''',''',(req at: #id_emprunteur),''',''',(req at: #dateEmprunt),''',''',(req at: #heureEmprunt),''',''',(req at: #etatEmprunt),''')']; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 19:31' prior: 35893258!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				GET: '/emprunt/<id>/<id_materiel>/<id_emprunteur>/<heureEmprunt>/<etatEmprunt>' -> [ :req |			(WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_materiel,id_emprunteur,heureEmprunt,etatEmprunt) VALUES (''', (req at: #id) , ''',''',(req at: #id_materiel),''',''',(req at: #id_emprunteur),''',''',(req at: #heureEmprunt),''',''',(req at: #etatEmprunt),''')']; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 19:33' prior: 35894467!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				GET: '/emprunt/<id>/<id_materiel>/<id_emprunteur>/<etatEmprunt>' -> [ :req |			(WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_materiel,id_emprunteur,etatEmprunt) VALUES (''', (req at: #id) , ''',''',(req at: #id_materiel),''',''',(req at: #id_emprunteur),''',''',(req at: #etatEmprunt),''')']; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 19:46' prior: 35895645!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				GET: '/emprunt/<id>/<id_materiel>/<id_emprunteur>/<etatEmprunt>' -> [ :req |			(WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_materiel,id_emprunteur,etatEmprunt) VALUES (''', (req at: #id) , ''',''',(req at: #id_materiel),''',''',(req at: #id_emprunteur),''',''',(req at: #etatEmprunt)]; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 19:54' prior: 35896763!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				GET: '/emprunt/<id>/<id_materiel>/<id_emprunteur>/<etatEmprunt>' -> [ :req |			(WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_materiel,id_emprunteur,etatEmprunt) VALUES (''', (req at: #id) , ''',''',(req at: #id_materiel),''',''',(req at: #id_emprunteur),''',''',(req at: #etatEmprunt),''')']; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 19:59' prior: 35897875!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				GET: '/emprunt/<id>/<id_materiel>/<id_emprunteur>/<etatEmprunt>' -> [ :req |			(WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_materiel,id_emprunteur,etatEmprunt) VALUES (', (req at: #id) , ',' ,(req at: #id_materiel),',',(req at: #id_emprunteur),',''',(req at: #etatEmprunt),''')']; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 20:04' prior: 35898993!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				GET: '/emprunt/<id>/<id_materiel>/<id_emprunteur>/<etatEmprunt>' -> [ :req |			(WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_materiel,id_emprunteur,etatEmprunt) VALUES (', (req at: #id) , ',' ,(req at: #id_materiel),',',(req at: #id_emprunteur),',''',(req at: #etatEmprunt),''')']; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 20:16' prior: 35900100!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				GET: '/emprunt/<id>/<id_materiel>/<id_emprunteur>/<etatEmprunt>' -> [ :req |			(WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_materiel,id_emprunteur,etatEmprunt) VALUES (', (req at: #id) , ',' ,(req at: #id_materiel),',',(req at: #id_emprunteur),')']; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 20:16' prior: 35901207!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				GET: '/emprunt/<id>/<id_materiel>/<id_emprunteur>' -> [ :req |			(WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_materiel,id_emprunteur,etatEmprunt) VALUES (', (req at: #id) , ',' ,(req at: #id_materiel),',',(req at: #id_emprunteur),')']; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 20:17' prior: 35902283!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				GET: '/emprunt/<id>/<id_materiel>/<id_emprunteur>' -> [ :req |			(WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_materiel,id_emprunteur) VALUES (', (req at: #id) , ',' ,(req at: #id_materiel),',',(req at: #id_emprunteur),')']; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 20:23' prior: 35903345!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				GET: '/emprunt/<id>/<id_materiel>/<id_emprunteur>/<etatEmprunt>' -> [ :req |			(WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_materiel,id_emprunteur) VALUES (', (req at: #id) , ',' ,(req at: #id_materiel),',',(req at: #id_emprunteur),(req at: #etatEmprunt),')']; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 20:23' prior: 35904395!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				GET: '/emprunt/<id>/<id_materiel>/<id_emprunteur>/<etatEmprunt>' -> [ :req |			(WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_materiel,id_emprunteur,etatEmprunt) VALUES (', (req at: #id) , ',' ,(req at: #id_materiel),',',(req at: #id_emprunteur),(req at: #etatEmprunt),')']; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 20:25' prior: 35905482!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				GET: '/emprunt/<id>/<id_materiel>/<id_emprunteur>/<etatEmprunt>' -> [ :req |			(WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_materiel,id_emprunteur,etatEmprunt) VALUES (', (req at: #id) , ',' ,(req at: #id_materiel),',',(req at: #id_emprunteur),',''',(req at: #etatEmprunt),''')']; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 20:27' prior: 35906581!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				GET: '/emprunt/<id>/<id_materiel>/<id_emprunteur>/<etatEmprunt>' -> [ :req |			(WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_materiel,id_emprunteur,etatEmprunt) VALUES (', (req at: #id) , ',' ,(req at: #id_materiel),',',(req at: #id_emprunteur),')']; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 20:27' prior: 35907688!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				GET: '/emprunt/<id>/<id_materiel>/<id_emprunteur>/<etatEmprunt>' -> [ :req |			(WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_materiel,etatEmprunt,id_emprunteur) VALUES (', (req at: #id) , ',' ,(req at: #id_materiel),',',(req at: #etatEmprunt),(req at: #id_emprunteur),')']; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 20:28' prior: 35908764!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				GET: '/emprunt/<id>/<id_materiel>/<id_emprunteur>/<etatEmprunt>' -> [ :req |			(WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_materiel,etatEmprunt,id_emprunteur) VALUES (', (req at: #id) , ',' ,(req at: #id_materiel),',''',(req at: #etatEmprunt),''',',(req at: #id_emprunteur),')']; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 20:31' prior: 35909863!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				GET: '/emprunt/<id>/<id_materiel>/<id_emprunteur>/<etatEmprunt>' -> [ :req |			(WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_materiel,etatEmprunt,id_emprunteur) VALUES (', (req at: #id) , ',' ,(req at: #id_materiel),',',(req at: #etatEmprunt),',',(req at: #id_emprunteur),')']; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 20:35' prior: 35910970!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				GET: '/emprunt/<id>/<id_materiel>/<id_emprunteur>/<etatEmprunt>' -> [ :req |			(WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_materiel,etatEmprunt,id_emprunteur) VALUES (', (req at: #id) , ',' ,(req at: #id_materiel),',''',(req at: #etatEmprunt),''',',(req at: #id_emprunteur),')']; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 20:39' prior: 35912073!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				GET: '/emprunt/<id>/<id_materiel>/<id_emprunteur>/<etatEmprunt>' -> [ :req |			(WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_materiel,etatEmprunt,id_emprunteur) VALUES (', (req at: #id) , ',' ,(req at: #id_materiel),',','''',(req at: #etatEmprunt),'''',',',(req at: #id_emprunteur),')']; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 20:48' prior: 35913180!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				GET: '/emprunt/<id>/<id_materiel>/<id_emprunteur>/<etatEmprunt>' -> [ :req |			(WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_materiel,etatEmprunt,id_emprunteur) VALUES (', (req at: #id) , ',' ,(req at: #id_materiel),',',(req at: #etatEmprunt),',',(req at: #id_emprunteur),')']; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 20:59' prior: 35914293!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				GET: '/emprunt/<id>/<id_materiel>/<id_emprunteur>/<etatEmprunt>' -> [ :req |			(WebService new) sqlQuery: 'INSERT INTO Emprunt (id,id_materiel,etatEmprunt,id_emprunteur) VALUES (', (req at: #id) , ',' ,(req at: #id_materiel),',',(req at: #etatEmprunt),',',(req at: #id_emprunteur),')']; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 21:01' prior: 35915396!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				GET: '/emprunt/<id>/<id_materiel>/<id_emprunteur>/<etatEmprunt>' -> [ :req |			(WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_materiel,etatEmprunt,id_emprunteur) VALUES (', (req at: #id) , ',' ,(req at: #id_materiel),',',(req at: #etatEmprunt),',',(req at: #id_emprunteur),')']; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 21:02' prior: 35916497!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				GET: '/emprunt/<id>/<id_materiel>/<id_emprunteur>/<etatEmprunt>' -> [ :req |			(WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_materiel,"etatEmprunt",id_emprunteur) VALUES (', (req at: #id) , ',' ,(req at: #id_materiel),',',(req at: #etatEmprunt),',',(req at: #id_emprunteur),')']; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 21:07' prior: 35917600!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				GET: '/emprunt/<id>/<id_materiel>/<id_emprunteur>/<etatEmprunt>' -> [ :req |			(WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_materiel,"etatEmprunt",id_emprunteur) VALUES (', (req at: #id) , ',' ,(req at: #id_materiel),',''',(req at: #etatEmprunt),''',',(req at: #id_emprunteur),')']; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 21:09' prior: 35918705!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				GET: '/emprunt/<id>/<id_materiel>/<id_emprunteur>/<etatEmprunt>' -> [ :req |			(WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_materiel,"etatEmprunt",id_emprunteur) VALUES (', (req at: #id) , ',' ,(req at: #id_materiel),',''',(req at: #etatEmprunt),''',',(req at: #id_emprunteur),')']; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/3/2017 21:12' prior: 35919814!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				GET: '/emprunt/<id>/<id_materiel>/<id_emprunteur>/<etatEmprunt>' -> [ :req |			(WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_materiel,etatEmprunt,id_emprunteur) VALUES (', (req at: #id) , ',' ,(req at: #id_materiel),',''',(req at: #etatEmprunt),''',',(req at: #id_emprunteur),')']; start.! !----SNAPSHOT----2017-05-03T21:20:18.733924+02:00 Pharo5.0.image priorSource: 2337412!----QUIT----2017-05-03T21:20:23.978133+02:00 Pharo5.0.image priorSource: 2367504!!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/4/2017 00:43' prior: 35920923!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				GET: '/emprunt/<id>/<id_materiel>/<id_emprunteur>/<etatEmprunt>' -> [ :req |			(WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_materiel,''etatEmprunt'',id_emprunteur) VALUES (', (req at: #id) , ',' ,(req at: #id_materiel),',''',(req at: #etatEmprunt),''',',(req at: #id_emprunteur),')']; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/4/2017 00:44' prior: 35922200!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				GET: '/emprunt/<id>/<id_materiel>/<id_emprunteur>/<etatEmprunt>' -> [ :req |			(WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_materiel,etatEmprunt,id_emprunteur) VALUES (', (req at: #id) , ',' ,(req at: #id_materiel),',''',(req at: #etatEmprunt),''',',(req at: #id_emprunteur),')']; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/4/2017 00:57' prior: 35923311!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				GET: '/emprunt/<id>/<id_materiel>/<id_emprunteur>/<etatEmprunt>' -> [ :req |			(WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_materiel,etatEmprunt,id_emprunteur) VALUES (', (req at: #id) , ',''' ,(req at: #id_materiel),''',',(req at: #etatEmprunt),''',',(req at: #id_emprunteur),')']; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/4/2017 01:01' prior: 35924418!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				GET: '/emprunt/<id>/<id_materiel>/<etatEmprunt>/<id_emprunteur>' -> [ :req |			(WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_materiel,etatEmprunt,id_emprunteur) VALUES (', (req at: #id) , ',' ,(req at: #id_materiel),',''',(req at: #etatEmprunt),''',',(req at: #id_emprunteur),')']; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/4/2017 01:04' prior: 35925527!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				GET: '/emprunt/<id>/<id_materiel>/<etatEmprunt>/<id_emprunteur>' -> [ :req |			(WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_materiel,id_emprunteur,etatEmprunt) VALUES (', (req at: #id) , ',' ,(req at: #id_materiel),',''',(req at: #etatEmprunt),''',',(req at: #id_emprunteur),')']; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/4/2017 01:06' prior: 35926634!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				GET: '/emprunt/<id>/<id_materiel>/<etatEmprunt>/<id_emprunteur>' -> [ :req |			(WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_materiel,id_emprunteur,etatEmprunt) VALUES (', (req at: #id) , ',' ,(req at: #id_materiel),',' ,(req at: #id_emprunteur),',''',(req at: #etatEmprunt),''')']; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/4/2017 01:10' prior: 35927741!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				GET: '/emprunt/<id>/<id_materiel>/<etat_emprunt>/<id_emprunteur>' -> [ :req |			(WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_materiel,id_emprunteur,etat_emprunt) VALUES (', (req at: #id) , ',' ,(req at: #id_materiel),',' ,(req at: #id_emprunteur),',''',(req at: #etatEmprunt),''')']; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/4/2017 01:10' prior: 35928849!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				GET: '/emprunt/<id>/<id_materiel>/<etat_emprunt>/<id_emprunteur>' -> [ :req |			(WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_materiel,id_emprunteur,etat_emprunt) VALUES (', (req at: #id) , ',' ,(req at: #id_materiel),',' ,(req at: #id_emprunteur),',''',(req at: #etat_emprunt),''')']; start.! !!WebService methodsFor: 'connection' stamp: 'AymaneBOUZIANE 5/5/2017 01:02' prior: 35929959!restRoute	"route the method"|emprunts teapot| 	emprunts := Dictionary new.		teapot := Teapot configure: {   #defaultOutput -> #json. #port -> 8080. #debugMode -> true }.	teapot 		GET: '/materiels' -> ((WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id');				GET: '/materiel/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT m.nom, reference, photo, etat, description, p.nom AS plateforme FROM "Materiel" m LEFT JOIN "Plateforme" p ON m.id_plateforme = p.id WHERE m.id=', (req at: #id)]; 		GET: '/emprunts' -> ((WebService new) sqlQuery: 'SELECT * from "Emprunt"');				GET: '/emprunt/<id>/<id_materiel>/<etat_emprunt>/<id_emprunteur>' -> [ :req |			(WebService new) sqlQuery: 'INSERT INTO "Emprunt" (id,id_materiel,id_emprunteur,etat_emprunt) VALUES (', (req at: #id) , ',' ,(req at: #id_materiel),',' ,(req at: #id_emprunteur),',''',(req at: #etat_emprunt),''')']; 				GET: '/emprunt/<id>' -> [ :req |      (WebService new) sqlQuery: 'SELECT id,id_materiel,id_emprunteur,etat_emprunt FROM "Emprunt" WHERE id=', (req at: #id)];		start.! !----SNAPSHOT----2017-05-05T01:42:15.725991+02:00 Pharo5.0.image priorSource: 2367591!----QUIT----2017-05-05T01:42:22.782444+02:00 Pharo5.0.image priorSource: 2377822!----SNAPSHOT----2017-05-05T02:37:45.051938+02:00 Pharo5.1.image priorSource: 2377909!----SNAPSHOT----2017-05-05T02:38:48.167411+02:00 Flexin.image priorSource: 2377992!